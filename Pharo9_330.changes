----QUIT----2020-06-03T14:20:47.255354+02:00 Pharo9.0-SNAPSHOT-64bit-1570116.image priorSource: 0!----QUIT----2020-06-03T14:21:13.344032+02:00 Pharo9.0-SNAPSHOT-64bit-1570116.image priorSource: 0!!BaselineOfSmallSuiteGenerator methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				baseline: 'SpyLite'				with: [ spec repository: 'github://andreina-covi/SpyLite:master/src' ].				spec    			baseline: 'RoelTyper'    			with: [ spec repository: 'github://RMODINRIA/RoelTyper:v1.x.x/src' ].        spec baseline: 'Roassal3'				with: [ spec repository: 'github://ObjectProfile/Roassal3' ].			spec				baseline: 'MuTalk'				with: [ spec repository: 'github://pavel-krivanek/mutalk/src' ].			spec				baseline: 'NeoCSV'				with: [ spec repository: 'github://svenvc/NeoCSV/repository' ].			spec				baseline: 'TinyLogger'				with: [ spec repository: 'github://jecisc/TinyLogger:v1.x.x/src' ].			spec				package: 'SmallSuiteGenerator'					with: [ spec requires: #('RoelTyper' 'SpyLite' 'MuTalk' 'NeoCSV' 'TinyLogger') ];				package: 'SmallSuiteGenerator-Scenario';				package: 'SmallSuiteGenerator-Scenario2';				package: 'SmallSuiteGenerator-Visualization' with: [ spec requires: #('Roassal3') ];				package: 'SmallSuiteGenerator-Tests'					with: [ spec						requires:							#('SmallSuiteGenerator' 'SmallSuiteGenerator-Scenario' 'SmallSuiteGenerator-Scenario2') ].			spec 				group: 'default' with: #('SmallSuiteGenerator-Tests');				group: 'All' with: #('SmallSuiteGenerator-Tests' 'SmallSuiteGenerator-Visualization') ]					! !"BaselineOfSmallSuiteGenerator"!!BaselineOfMuTalk methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [		spec for: #'pharo6.x' do: [			spec group: 'testCoverage' with: #().].		spec for: #'pharo7.x' do: [			spec package: 'TestCoverage'.			spec group: 'testCoverage' with: #('TestCoverage').].		spec for: #'pharo8.x' do: [			spec package: 'TestCoverage'.			spec group: 'testCoverage' with: #('TestCoverage').].		spec for: #'pharo9.x' do: [			spec package: 'TestCoverage'.			spec group: 'testCoverage' with: #('TestCoverage').].		spec 			package: 'MuTalk-Model' with: [				spec requires: #('testCoverage')];			package: 'MuTalk-TestResources' with: [				spec requires: #('MuTalk-Model')];			package: 'MuTalk-Tests' with: [				spec requires: #('MuTalk-Model' 'MuTalk-TestResources')].			"package: 'MuTalk-UI'."					spec group: 'default' with: #('MuTalk-Model' 'MuTalk-TestResources' 'MuTalk-Tests').	].		! !"BaselineOfMuTalk"!!BaselineOfRoassal3 commentStamp: '' prior: 0!Baseline for https://github.com/ObjectProfile/Roassal3!!BaselineOfRoassal3 methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ | core examples tests |			"our dependencies"			"https://github.com/ObjectProfile/Roassal3"			spec baseline: 'AthensSVG' with: [				spec repository: 'github://pharo-contributions/Athens-SVG' ].			spec package: 'Athens-SVG-PathConverter' with: [				spec repository: 'github://pharo-contributions/Athens-SVG' ].			spec package: 'Geometry' with: [ 				spec repository: 'github://pharo-contributions/Geometry' ].			spec baseline: 'NumericScales'with: [ 				spec repository: 'github://ObjectProfile/NumericScales' ].			spec 				baseline: 'OSSubprocess'				with: [ spec repository: 'github://pharo-contributions/OSSubprocess/repository' ].							"The packages to use, but not load"						self				roassalCorePackagesIn: spec;				roassalExamplesIn: spec;				roassalTestsIn: spec;				roassalSVGIn: spec.			spec package: #'Roassal3-GraphViz' with: [ spec requires: #('OSSubprocess') ].						"packages to load"			core := self corePackagesNames.			examples := self examplePackagesNames.			tests := self testPackagesNames.							Smalltalk globals at: #SpPresenter ifPresent: [				core add: 'Roassal3-Spec'.				examples add: 'Roassal3-Spec-Examples'.				tests add: 'Roassal3-Spec-Tests'.			] ifAbsent: [ "pharo7"				core add: 'Roassal3-Pharo7' ].			spec 				group: 'Core' with: core asArray;				group: 'Examples'  with: examples asArray;				group: 'Tests' with: tests asArray;				group: 'SVG' with: #('Core' 'Roassal3-SVG');				group: 'SVGTests' with: #('SVG' 'Tests' 'Roassal3-SVG-Tests');				group: 'SVGExamples' with: #('SVG' 'Examples' 'Roassal3-SVG-Examples');				group: 'SVGImporter' with: #('SVG' 'SVGExamples' 'SVGTests' 'Roassal3-SVG-Importer');				group: 'GraphViz' with: #(Core 'Roassal3-GraphViz');				group: 'default' with: #('Core' 'Tests' 'Examples' 'SVG' 'SVGTests' 'SVGExamples') ].			! !!BaselineOfRoassal3 methodsFor: 'API-packages'!corePackagesNames	^ #(	'Roassal3'	'Roassal3-Builders'	'Roassal3-Shapes'	'Roassal3-Interaction'	'Roassal3-Layouts'	'Roassal3-Colors'	'Roassal3-Legend'	'Roassal3-Animation'	'Roassal3-UML'	'Roassal3-Sunburst'	'Roassal3-Pie'	'Roassal3-Inspector'	'Roassal3-Chart'	'Roassal3-Menu') asOrderedCollection! !!BaselineOfRoassal3 methodsFor: 'API-packages'!examplePackagesNames	^ #(	'Core' 	'Roassal3-Examples'	'Roassal3-Legend-Examples'	'Roassal3-Chart-Examples'	'Roassal3-Pie-Examples'	'Roassal3-Sunburst-Examples'	'Roassal3-UML-Examples') asOrderedCollection! !!BaselineOfRoassal3 methodsFor: 'package management'!roassalCorePackagesIn: spec	spec		package: #'Roassal3' with: [ spec requires: #('Geometry' 'NumericScales') ];		package: #'Roassal3-Pharo7';		package: #'Roassal3-Builders';		package: #'Roassal3-Shapes';		package: #'Roassal3-Animation';		package: #'Roassal3-Chart';		package: #'Roassal3-Interaction';		package: #'Roassal3-Legend';		package: #'Roassal3-Pie';		package: #'Roassal3-UML';		package: #'Roassal3-Layouts';		package: #'Roassal3-Colors';		package: #'Roassal3-Spec';		package: #'Roassal3-Sunburst';		package: #'Roassal3-Inspector';		package: #'Roassal3-Menu'! !!BaselineOfRoassal3 methodsFor: 'package management'!roassalExamplesIn: spec	spec		package: #'Roassal3-Examples';		package: #'Roassal3-Legend-Examples';		package: #'Roassal3-Chart-Examples';		package: #'Roassal3-Pie-Examples';		package: #'Roassal3-Spec-Examples';		package: #'Roassal3-Sunburst-Examples';		package: #'Roassal3-UML-Examples'.! !!BaselineOfRoassal3 methodsFor: 'package management'!roassalSVGIn: spec	spec				package: 'Roassal3-SVG' with: [ spec requires: #('Athens-SVG-PathConverter') ];		package: 'Roassal3-SVG-Tests';		package: 'Roassal3-SVG-Examples';		package: 'Roassal3-SVG-Importer' with: [ spec requires: #('AthensSVG') ].! !!BaselineOfRoassal3 methodsFor: 'package management'!roassalTestsIn: spec.		spec		package: #'Roassal3-Global-Tests';		package: #'Roassal3-Animation-Tests';		package: 'Roassal3-Shapes-Tests';		package: 'Roassal3-Interaction-Tests';		package: 'Roassal3-Layouts-Tests';		package: 'Roassal3-Chart-Tests';		package: 'Roassal3-Spec-Tests';		package: 'Roassal3-UML-Tests'.! !!BaselineOfRoassal3 methodsFor: 'API-packages'!testPackagesNames	^ #(	'Core' 	'Roassal3-Global-Tests' 	'Roassal3-Animation-Tests'	'Roassal3-Shapes-Tests'	'Roassal3-Interaction-Tests'	'Roassal3-Layouts-Tests'	'Roassal3-Chart-Tests'	'Roassal3-UML-Tests') asOrderedCollection! !"BaselineOfRoassal3"!!BaselineOfRoelTyper commentStamp: '' prior: 0!Baseline of the RoelTyper project!!BaselineOfRoelTyper methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [			"Packages"			spec				package: 'RoelTyper';				package: 'RoelTyper-Tests' with: [ spec requires: #('RoelTyper') ].			"Groups"			spec				group: 'Core' with: #('RoelTyper');				group: 'Tests' with: #('RoelTyper-Tests') ]! !!BaselineOfRoelTyper methodsFor: 'accessing'!projectClass	^ MetacelloCypressBaselineProject! !"BaselineOfRoelTyper"!!BaselineOfTinyLogger commentStamp: '' prior: 0!Description--------------------I am a baseline to configure the Tiny logger project.https://github.com/jecisc/TinyLogger!!ManifestBaselineOfTinyLogger commentStamp: '' prior: 0!I contains the implementation of a simple and tiny logger.I implement different kind of loggers such as:- Transcript- Stdout - File Check the class comment of `TinyLogger` or the documentation present on https://github.com/jecisc/TinyLogger repository for more informations.!!BaselineOfTinyLogger methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [			"Dependencies"			self mocketry: spec.						"Packages"			spec				package: 'TinyLogger';				package: 'TinyLogger-Tests' with: [ spec requires: #('TinyLogger' 'Mocketry') ].						"Groups"			spec				group: 'Core' with: #('TinyLogger');				group: 'Tests' with: #('TinyLogger-Tests') ]! !!BaselineOfTinyLogger methodsFor: 'dependencies'!mocketry: spec	spec		baseline: 'Mocketry'		with: [ spec				loads: #('Core');				repository: 'github://dionisiydk/Mocketry:v6.0.x' ]! !"BaselineOfTinyLogger"!!BaselineOfNeoCSV commentStamp: '' prior: 0!I am BaselineOfNeoCSV, a way to load the code of the NeoCSV project.I am a BaselineOf.!!BaselineOfNeoCSV methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				package: 'Neo-CSV-Core';				package: 'Neo-CSV-Tests' with: [ spec requires: #('Neo-CSV-Core') ];				group: 'default' with: #('core' 'tests');				group: 'core' with: #('Neo-CSV-Core');				group: 'tests' with: #('Neo-CSV-Tests') ]! !"BaselineOfNeoCSV"!!BaselineOfSpyLite methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				package: 'SpyLite';				package: 'SpyLite-Scenario';				package: 'SpyLite-Tests' ]! !"BaselineOfSpyLite"!!BaselineOfNumericScales commentStamp: '' prior: 0!I am a baseline to load the object profile basic scales!!BaselineOfNumericScales methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [		spec 			package: #'NumericInterpolator';			package: #'NumericNoise';			package: #'NumericInterpolator-Tests'.				spec 			group: 'Core' with: #(				'NumericInterpolator'				NumericNoise);			group: 'Tests' with: #('Core' 'NumericInterpolator-Tests');			group: 'default' with: #('Core' 'Tests') ].			! !"BaselineOfNumericScales"!!BaselineOfMocketry methodsFor: 'baselines'!baseline: spec	<baseline>		spec for: #common do: [		spec 			baseline: 'StateSpecs' with: [spec repository: 'github://dionisiydk/StateSpecs:v4.0.x'];			project: 'StateSpecsCore' copyFrom: 'StateSpecs' with: [		 	    spec	loads: #('Core' 'GhostSupport')];			project: 'StateSpecsTests' copyFrom: 'StateSpecs' with: [		 	    spec	loads: #('Tests' 'GhostSupportTests' )];								baseline: 'Ghost' with: [		 	    spec repository: 'github://pharo-ide/Ghost:v5.0.x'];			project: 'GhostCore' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhost' 'GTSupport' 'ObjectMutation')];			project: 'GhostTests' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhostTests' 'ClassGhostTests' 'ObjectMutationTests')];			package: 'Mocketry-Specs' with: [ spec requires: #('StateSpecsCore')];			package: 'Mocketry-Domain' with: [ spec requires: #('Mocketry-Specs' 'GhostCore')];			package: 'Mocketry-Help' with: [ spec requires: #('Mocketry-Domain')];			package: 'Mocketry-Specs-Tests' with: [ 				spec requires: #('Mocketry-Specs' 'StateSpecsTests') ];			package: 'Mocketry-Domain-Tests' with: [ spec requires: #('Mocketry-Specs' 'GhostTests') ].		spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('Mocketry-Specs' 'Mocketry-Domain');			group: 'Tests' with: #('Mocketry-Specs-Tests' 'Mocketry-Domain-Tests' 'Mocketry-Help')].! !!BaselineOfMocketry methodsFor: 'accessing'!projectClass	^ [ self class environment at: #MetacelloCypressBaselineProject ]		on: NotFound		do: [ super projectClass ]! !"BaselineOfMocketry"!!BaselineOfStateSpecs methodsFor: 'baselines'!baseline: spec	<baseline>		spec for: #common do: [		spec 			package: 'StateSpecs-Specs';			package: 'StateSpecs-DSL-ShouldExpressions' with: [ spec requires: #('StateSpecs-Specs') ];			package: 'StateSpecs-DSL-ClassWords' with: [ spec requires: #('StateSpecs-Specs') ];			package: 'StateSpecs-Help' with: [				spec requires: #('StateSpecs-DSL-ShouldExpressions' 'StateSpecs-DSL-ClassWords')];						package: 'StateSpecs-Specs-Tests' with: [ spec requires: 'StateSpecs-Specs' ];			package: 'StateSpecs-GTTools' with: [ spec requires: 'StateSpecs-Specs' ];			package: 'StateSpecs-DSL-ShouldExpressions-Tests' with: [ 				spec requires: 'StateSpecs-DSL-ShouldExpressions' ];			package: 'StateSpecs-DSL-ClassWords-Tests' with: [ 				spec requires: 'StateSpecs-DSL-ClassWords' ].					spec 			baseline: 'Ghost' with: [		 	    spec repository: 'github://pharo-ide/Ghost:v5.0.x'];			project: 'GhostCore' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhost')];			project: 'GhostTests' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhostTests' )];			package: 'StateSpecs-GhostSupport' with: [ 				spec requires: #('GhostCore' 'StateSpecs-Specs' 'StateSpecs-DSL-ShouldExpressions') ];			package: 'StateSpecs-GhostSupport-Tests' with: [ 				spec requires: #('GhostTests' 'StateSpecs-GhostSupport') ].					spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('StateSpecs-Specs' 'StateSpecs-DSL-ShouldExpressions' 'StateSpecs-DSL-ClassWords');			group: 'Tests' with: #('StateSpecs-Specs-Tests' 'StateSpecs-DSL-ShouldExpressions-Tests' 'StateSpecs-DSL-ClassWords-Tests' 'StateSpecs-Help' 'StateSpecs-GTTools');			group: 'GhostSupport' with: #('StateSpecs-GhostSupport');			group: 'GhostSupportTests' with: #('GhostSupport' 'StateSpecs-GhostSupport-Tests')	]! !!BaselineOfStateSpecs methodsFor: 'accessing'!projectClass	^ [ self class environment at: #MetacelloCypressBaselineProject ]		on: NotFound		do: [ super projectClass ]! !"BaselineOfStateSpecs"!!BaselineOfGhost methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [		spec 			package: 'Ghost-ObjectGhost';			package: 'Ghost-ClassGhost' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-ObjectMutation' with: [ spec requires: #('Ghost-ClassGhost') ];			package: 'Ghost-ObjectGhost-Tests' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-ClassGhost-Tests' with: [ spec requires: #('Ghost-ClassGhost') ];			package: 'Ghost-ObjectMutation-Tests' with: [ spec requires: #('Ghost-ObjectMutation') ];			package: 'Ghost-GTSupport' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-Learning' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-Learning-Tests' with: [ spec requires: #('Ghost-Learning')];			package: 'Ghost-ObjectCallHalt' with: [ spec requires: #('Ghost-ObjectMutation') ];			package: 'Ghost-ObjectCallHalt-Tests' with: [ spec requires: #('Ghost-ObjectCallHalt')].					spec 			group: 'default' with: #( 'ObjectGhostTests' 'ClassGhostTests' 'ObjectMutationTests' 'GTSupport' 'LearningTests' );			group: 'ObjectGhost' with: #('Ghost-ObjectGhost' );			group: 'ObjectGhostTests' with: #('Ghost-ObjectGhost-Tests' );			group: 'ClassGhost' with: #('Ghost-ClassGhost' );			group: 'ClassGhostTests' with: #('Ghost-ClassGhost-Tests' );			group: 'ObjectMutation' with: #('Ghost-ObjectMutation' );			group: 'ObjectMutationTests' with: #('Ghost-ObjectMutation-Tests' );			group: 'GTSupport' with: #('Ghost-GTSupport' );			group: 'Learning' with: #('Ghost-Learning' );			group: 'LearningTests' with: #('Ghost-Learning-Tests' );			group: 'ObjectCallHalt' with: #('Ghost-ObjectCallHalt-Tests' 'ObjectGhostTests' 'ClassGhostTests' 'ObjectMutationTests' 'GTSupport')		] ! !!BaselineOfGhost methodsFor: 'accessing'!projectClass	^ [ self class environment at: #MetacelloCypressBaselineProject ]		on: NotFound		do: [ super projectClass ]! !"BaselineOfGhost"!!SLCollectorLiteral commentStamp: '' prior: 0!Visit any RBProgramNode in the sintax tree and evaluate literal values    Instance Variables	literals:		<Dictionary>!!SpyLite commentStamp: '' prior: 0!I am a superclass to Profiler, PackageSpy, ClassSpy and MethodSpy.!!SLClass commentStamp: '' prior: 0!I represent the profiling data for a class.My attributes are:the classes name, a metaclass spy, and a set of method spies.For each method in the corresponding class, I create a MethodSpy.!!SSTypeCollectorClass commentStamp: '' prior: 0!SSTypeCollectorClass is a subclass of profiler Class that collects class types.!!SLMethod commentStamp: '' prior: 0!I wrap a plain Pharo method and accumulate information during the program execution.I have a selector name and belong to a ClassSpy.I containt the hooks used to collect the actual runtime information. Three methods are provided for that purpose:#beforeRun:with:in: and #afterRun:with:in: are executed before and after the corresponding Smalltalk method.These methods are by default empty; they should be overridden in subclasses of MethodSpy to collect relevant dynamic information. The #run:with:in method simply calls #beforeRun:with:in:, followed by the execution of the represented Smalltalk method, and ultimately calls #afterRun:with:in:.The parameters passed to these methods are: the method name (as a symbol), the list of arguments, and the object that receives the intercepted message.!!SSTypeCollectorMethod commentStamp: '' prior: 0!SSTypeCollectorMethod is a subclass of profiler method that collects method types.Instance Variables	argTypes:			<Collection>	executed:			<False>	receiverType:	<SMultiTypeInfo>	returnType:		<SMultiTypeInfo>!!SLPackage commentStamp: '' prior: 0!I represent the profiling data for a package.Each instance has a name and contains a set of class spies, that is, for each class in the corresponding package, an instance of ClassSpy is created.!!SSTypeCollectorPackage commentStamp: '' prior: 0!SSTypeCollectorPackage is a subclass of Package that collects packages types!!SLProfiler commentStamp: '' prior: 0!I obtain runtime information by profiling the execution of a block of Smalltalk code.I offer a number of public class methods to interface with the profiling.profile: aBlock inPackagesNamed: packageNames accepts as first parameter a block and as second parameter a collection of package names.The effect of calling this method is to(i) instrument the specified packages;(ii) execute the provided block;(iii) uninstrument the targeted packages; and(iv) return the collected data in the form of an instance of the Profiler class which contains instances of PackageSpy, ClassSpy and MethodSpy, essentially mirroring the structure of the program.!!SSTypeCollector commentStamp: '' prior: 0!SSTypeCollector is a subclass of Profiler that collects project typesInstance Variables	scalars:		<Dictionary>!!Behavior methodsFor: '*SpyLite'!classSpy 	| spys |	spys := self spys.	spys ifEmpty: [ self error: 'no spy installed'. ^ self].	^ self spys first classSpy! !!Behavior methodsFor: '*SpyLite'!hasSpy	^ self methodDict values anySatisfy: [ :spy | spy isTemplateMethod ]! !!Behavior methodsFor: '*SpyLite'!profiler	^ self classSpy profiler! !!Behavior methodsFor: '*SpyLite'!removeSpys	(self == SLProfiler class) ifTrue: [ ^ self ].	self isMeta ifFalse: [ self class removeSpys ].	self methodDict associationsDo:[:assoc|		 assoc value isSpy ifTrue:[				self methodDict at: assoc key put: assoc value originalMethod.			].		].! !!Behavior methodsFor: '*SpyLite'!spyFor: aSelector	| v |	v := self methodDict at: aSelector.	self assert: [ v isSpy ].	^ v! !!Behavior methodsFor: '*SpyLite'!spys	^ (self methodDict values select: [ :spy | spy isTemplateMethod ]) collect: #methodSpy! !!SLCollectorLiteral methodsFor: 'initialization'!initialize 	literals := Dictionary new! !!SLCollectorLiteral methodsFor: 'accessing'!literals	^ literals! !!SLCollectorLiteral methodsFor: 'tests'!nameOf: aClass 	^ aClass name! !!SLCollectorLiteral methodsFor: 'visiting'!visitLiteralNode: aLiteralNode  | literalValue aValue |  literalValue := aLiteralNode value.  aValue := literals at: (self nameOf: literalValue class) ifAbsentPut: [ Set new ].  aValue add: literalValue.	literalValue isCollection ifTrue: [ [ aValue add: literalValue class new ] on: Error do: [  ] ]! !!SLInstrumentor methodsFor: 'visiting'!addBlock: aBlockNode	blocks add: (self buildSBBlock: aBlockNode)! !!SLInstrumentor methodsFor: 'accessing'!blocks 		^ blocks! !!SLInstrumentor methodsFor: 'visiting'!buildGhostNode: anInteger	^ RBParser parseExpression: '#metaObject count: ' , anInteger asString , '.nil.'.! !!SLInstrumentor methodsFor: 'visiting'!buildSBBlock: aBlockNode	^ SLBlock new		id: (self nextId);		numberOfStatements: aBlockNode body statements size;		code: aBlockNode sourceCode;		yourself! !!SLInstrumentor methodsFor: 'initialization'!initialize	super initialize.	blocks := OrderedCollection new.! !!SLInstrumentor methodsFor: 'visiting'!instrumentBlock: aBlockNode	self addBlock: aBlockNode.	aBlockNode body addNodeFirst: (self buildGhostNode: currentId)! !!SLInstrumentor methodsFor: 'visiting'!nextId	currentId := blocks size + 1.	^ currentId.! !!SLInstrumentor methodsFor: 'visiting'!visitBlockNode: aBlockNode	self instrumentBlock: aBlockNode.	super visitBlockNode: aBlockNode! !!SLInstrumentor methodsFor: 'visiting'!visitMethodNode: aMethodNode	self instrumentBlock: aMethodNode.	super visitMethodNode: aMethodNode! !!CompiledMethod methodsFor: '*SpyLite'!copyFor: aBehavior	| copy numberOfLiterals superRef |	numberOfLiterals := self numLiterals.	copy := self copy.	superRef := (self literalAt: numberOfLiterals) copy.	superRef value: aBehavior.	copy literalAt: numberOfLiterals put: superRef.	^ copy! !!CompiledMethod methodsFor: '*SpyLite-testing'!hasMethodSpyAsLiteral	"True if one of my literals has a method spy"	^ self literals anySatisfy: [ :l | (l isKindOf: SLMethod) ]! !!CompiledMethod methodsFor: '*SpyLite-testing'!isSpy	^ (self objectAt: 2) isSpyMethod! !!CompiledMethod methodsFor: '*SpyLite-testing'!isTemplateMethod	^ SLProfiler templateMethods anySatisfy: [ :cm | (self size = cm size) 													and: [ (self initialPC to: self endPC) allSatisfy: [ :i | 															(self at: i) = (cm at: i) ] ] ]! !!CompiledMethod methodsFor: '*SpyLite'!methodSpy	self assert: [ self isSpy ].	^ self objectAt: 2! !!CompiledMethod methodsFor: '*SpyLite-testing'!numberOfLinesOfCode	(self propertyValueAt: #numberOfLinesOfCode)			ifNil: [ self propertyValueAt: #numberOfLinesOfCode put: self sourceCode lineCount ].	^ self propertyValueAt: #numberOfLinesOfCode ! !!CompiledMethod methodsFor: '*SpyLite'!originalMethod	^ self methodSpy originalMethod! !!CompiledMethod methodsFor: '*SpyLite'!replaceLiteral: anObject by: anotherObject	1 to: self numLiterals do: [ :i | 		((self literalAt: i) = anObject)			ifTrue: [ self literalAt: i put: anotherObject ]	]! !!CompiledMethod methodsFor: '*SpyLite'!replaceLiterals: associations	associations do: [:assoc | self replaceLiteral: assoc key by: assoc value ]! !!Object methodsFor: '*SpyLite'!aSLProfilerCoverage	^ SLProfilerCoverage! !!Object methodsFor: '*SpyLite'!aSTypeCollectorClass	^ SSTypeCollector! !!Object methodsFor: '*SpyLite'!isSpy	^ false! !!Object methodsFor: '*SpyLite'!isSpyMethod	^ false! !!SLBlock class methodsFor: 'instance creation'!new 		^ super new initialize! !!SLBlock methodsFor: 'accessing'!code	^ code! !!SLBlock methodsFor: 'accessing'!code: anObject	code := anObject! !!SLBlock methodsFor: 'accessing'!executed	executed := true.! !!SLBlock methodsFor: 'accessing'!id	^ id! !!SLBlock methodsFor: 'accessing'!id: anObject	id := anObject! !!SLBlock methodsFor: 'initialization'!initialize	super initialize.	executed := false.	numberOfStatements := 0.	code := ''! !!SLBlock methodsFor: 'updating'!noExecuted	executed := false.	! !!SLBlock methodsFor: 'accessing'!numberOfStatements	^ numberOfStatements! !!SLBlock methodsFor: 'accessing'!numberOfStatements: anObject	numberOfStatements := anObject! !!SLBlock methodsFor: 'accessing'!start	^ start! !!SLBlock methodsFor: 'accessing'!start: anObject	start := anObject! !!SLBlock methodsFor: 'accessing'!stop	^ stop! !!SLBlock methodsFor: 'accessing'!stop: anObject	stop := anObject! !!SLBlock methodsFor: 'accessing'!wasExecuted	^ executed.! !!SLSummaryExecutionMethod class methodsFor: 'instance creation'!on: slMethod	^ self new 		executorClass: slMethod classSpy className;		selector: slMethod selector;		code: ([slMethod blocks first code] on: SubscriptOutOfBounds do: ['']);		executed: ([slMethod blocks first wasExecuted] on: SubscriptOutOfBounds do: [ false ]);		isClassSide: slMethod isClassSide;		summaryStatements: (slMethod blocks allButFirst collect: [:block | 			SLSummaryStatement with: block code and: block wasExecuted 			])! !!SLSummaryExecutionMethod methodsFor: 'comparing'!= another 	^ (self class = another class) 		and: [ (selector = another selector) 			and: [ (executed = another executed ) 				and: [ (executorClass = another executorClass ) 					and: [ (summaryStatements = another summaryStatements) ] ] ] ]! !!SLSummaryExecutionMethod methodsFor: 'testing kind'!allBlocksExecuted	^ executed and: [ summaryStatements allSatisfy: #executed ]! !!SLSummaryExecutionMethod methodsFor: 'accessing'!argsTypes	^ argsTypes! !!SLSummaryExecutionMethod methodsFor: 'accessing'!argsTypes: anObject	argsTypes := anObject! !!SLSummaryExecutionMethod methodsFor: 'accessing'!code	^ code! !!SLSummaryExecutionMethod methodsFor: 'accessing'!code: anObject	code := anObject! !!SLSummaryExecutionMethod methodsFor: 'accessing'!executed	^ executed! !!SLSummaryExecutionMethod methodsFor: 'accessing'!executed: anObject	executed := anObject! !!SLSummaryExecutionMethod methodsFor: 'testing kind'!executedBlocks	^ summaryStatements select: #executed! !!SLSummaryExecutionMethod methodsFor: 'accessing'!executorClass	^ executorClass! !!SLSummaryExecutionMethod methodsFor: 'accessing'!executorClass: anObject	executorClass := anObject! !!SLSummaryExecutionMethod methodsFor: 'accessing'!hasProfiler	^ hasProfiler! !!SLSummaryExecutionMethod methodsFor: 'accessing'!hasProfiler: anObject	hasProfiler := anObject! !!SLSummaryExecutionMethod methodsFor: 'comparing'!hash	^ summaryStatements hash! !!SLSummaryExecutionMethod methodsFor: 'initialization'!initialize 		code := ''.	executed := false.	summaryStatements := OrderedCollection new! !!SLSummaryExecutionMethod methodsFor: 'accessing'!isClassSide	^ isClassSide! !!SLSummaryExecutionMethod methodsFor: 'accessing'!isClassSide: anObject	isClassSide := anObject! !!SLSummaryExecutionMethod methodsFor: 'testing kind'!notAllBlocksExecuted	^ self allBlocksExecuted not! !!SLSummaryExecutionMethod methodsFor: 'accessing'!returnType	^ returnType! !!SLSummaryExecutionMethod methodsFor: 'accessing'!returnType: anObject	returnType := anObject! !!SLSummaryExecutionMethod methodsFor: 'accessing'!selector	^ selector! !!SLSummaryExecutionMethod methodsFor: 'accessing'!selector: anObject	selector := anObject! !!SLSummaryExecutionMethod methodsFor: 'export'!summaryAsColl	^ OrderedCollection new 			add: executorClass;			add: selector;			add: isClassSide;			add: executed;			add: hasProfiler;			add: code;			add:			(argsTypes				ifNil: [ #() ]				ifNotNil: [ (argsTypes collect: [ :argType | argType types asArray ]) asArray ]);			add: returnType types asArray;			add: (self executedBlocks collect: #code) asArray;			add: (self unexecutedBlocks collect: #code) asArray;			yourself ! !!SLSummaryExecutionMethod methodsFor: 'accessing'!summaryStatements	^ summaryStatements! !!SLSummaryExecutionMethod methodsFor: 'accessing'!summaryStatements: anObject	summaryStatements := anObject! !!SLSummaryExecutionMethod methodsFor: 'accessing'!unexecuted	^ self executed not! !!SLSummaryExecutionMethod methodsFor: 'testing kind'!unexecutedBlocks	^ summaryStatements select: [ :slBlock | slBlock executed not ]! !!SLSummaryExecutionMethod methodsFor: 'updating'!updateTypeInfoWith: aMethodTypeInfo	hasProfiler := aMethodTypeInfo hasProfiler.	returnType := aMethodTypeInfo returnType.	argsTypes := aMethodTypeInfo argTypes! !!SLSummaryExecutionMethod methodsFor: 'export'!writeDataCSV: neoCSVWriter withIndex: anInteger	neoCSVWriter nextPut: (Array with: anInteger 		withAll: ( self summaryAsColl ))! !!SLSummaryStatement class methodsFor: 'as yet unclassified'!with: string and: boolean 	^ self new 		code: string;		executed: boolean! !!SLSummaryStatement methodsFor: 'comparing'!= another 	^ (self class = another class) 		and: [ self executed = another executed ]! !!SLSummaryStatement methodsFor: 'accessing'!code	^ code! !!SLSummaryStatement methodsFor: 'accessing'!code: anObject	code := anObject! !!SLSummaryStatement methodsFor: 'accessing'!executed	^ executed! !!SLSummaryStatement methodsFor: 'accessing'!executed: anObject	executed := anObject! !!SLSummaryStatement methodsFor: 'comparing'!hash 	^ executed hash! !!SLSummaryStatement methodsFor: 'initialization'!initialize 	code := ''.	executed := false! !!SLClass class methodsFor: 'hooks'!spyClassForMethod	^ SLMethod ! !!SLClass methodsFor: 'accessing-computed'!>> aSymbol	^ self localMethodAt: aSymbol! !!SLClass methodsFor: 'hooks'!afterEachExecution: messageName On: aReceiver with: arguments! !!SLClass methodsFor: 'accessing-computed'!allMethods	^ self methods , self metaclassSpy methods! !!SLClass methodsFor: 'accessing-computed'!allSubclasses	|result|	allSubclassesCache ifNotNil: [ ^ allSubclassesCache ].		result := OrderedCollection new.	self subclasses do: [:cls | result add: cls. result addAll: cls allSubclasses ].	^ result! !!SLClass methodsFor: 'hooks'!beforeEachExecution: messageName On: aReceiver with: arguments! !!SLClass methodsFor: 'hooks'!beforeEachExecution: messageName on: aReceiver with: arguments! !!SLClass methodsFor: 'contract'!checkInvariant	self assert: [ className notNil ].	self assert: [ className isKindOf: Symbol ].	self assert: [ self profiler notNil ].	self assert: [ self methods notNil ].	self assert: [ self methods isCollection ].	self assert: [ self methods allSatisfy: [:m| m isKindOf: SLMethod ] ].	self assert: [ self class spyClassForMethod == self profiler class spyClassForMethod ].	self assert: [ self class spyClassForMethod == self profiler class spyClassForMethod ].	self assert: [ self class == self profiler class spyClassForClass ].! !!SLClass methodsFor: 'accessing'!className	^ className! !!SLClass methodsFor: 'accessing'!className: aSymbol	className := aSymbol! !!SLClass methodsFor: 'accessing-computed'!downwardLookupMethodsNamed: aSelector	^ (self allSubclasses select: [:cls | cls hasMethodNamed: aSelector])			collect: [:cls | cls localMethodAt: aSelector ]		! !!SLClass methodsFor: 'testing'!hasMethodNamed: aSelector	^ self localMethods includesKey: aSelector! !!SLClass methodsFor: 'initialize-release'!initialize 	super initialize.	 methods := Dictionary new ! !!SLClass methodsFor: 'testing'!isClassPresent	^ Smalltalk globals includesKey: className ! !!SLClass methodsFor: 'testing'!isMeta  ^ self className includes: $ ! !!SLClass methodsFor: 'testing'!isSubclassOf: aClassSpy	"True of I am a subclass of aClassSpy"		^ self == aClassSpy		ifTrue: [ true ]		ifFalse: [ 			self superclass ifNil: [ ^ false ].			self superclass isSubclassOf: aClassSpy ]! !!SLClass methodsFor: 'testing'!isTestClass	"Return true if the real class is a test case"		^ self theClass inheritsFrom: TestCase.! !!SLClass methodsFor: 'accessing-computed'!localMethodAt: aSelector	^ self localMethods at: aSelector! !!SLClass methodsFor: 'accessing-computed'!localMethodAt: aSelector ifAbsent: aBlock	^ self localMethods at: aSelector ifAbsent: aBlock! !!SLClass methodsFor: 'accessing-computed'!localMethodAt: aSelector put:  value	^ self localMethods at: aSelector put: value! !!SLClass methodsFor: 'accessing'!localMethods	^ methods ! !!SLClass methodsFor: 'accessing-computed'!lookupMethodNamed: aSelector	^ (self hasMethodNamed: aSelector)			ifTrue: [ self localMethodAt: aSelector ]			ifFalse: [ self superclass lookupMethodNamed: aSelector ]! !!SLClass methodsFor: 'accessing'!metaclassSpy	^ metaclassSpy ifNil: 		[ metaclassSpy := self class new className: (self nameOf: self theClass class) ; yourself ]! !!SLClass methodsFor: 'accessing-computed'!methods 	^ methods values! !!SLClass methodsFor: 'accessing-computed'!methods: aDictionary	methods := aDictionary ! !!SLClass methodsFor: 'accessing-computed'!nonMetaClassName	^ (self isMeta		ifTrue: [ self className copyFrom: 1 to: ((self className indexOf: $ ) - 1)] 		ifFalse: [ self className ]) asSymbol! !!SLClass methodsFor: 'accessing-computed'!numberOfAllMethods	^ self allMethods size! !!SLClass methodsFor: 'accessing'!package	^ packageSpy ! !!SLClass methodsFor: 'accessing'!packageSpy	^ packageSpy! !!SLClass methodsFor: 'accessing'!packageSpy: anObject 	packageSpy := anObject.	metaclassSpy ifNotNil: [ metaclassSpy packageSpy: anObject ]! !!SLClass methodsFor: 'printing'!printOn: stream	stream nextPut: $<.	stream nextPutAll: (self className printString).	stream nextPut: $>! !!SLClass methodsFor: 'accessing-computed'!profiler	^ self package profiler! !!SLClass methodsFor: 'removing'!removeMethod: aCompiledMethod     (aCompiledMethod methodClass name endsWith: 'class') ifTrue: [         self metaclassSpy methods removeKey: aCompiledMethod selector ]    ifFalse: [ methods removeKey: aCompiledMethod selector ]! !!SLClass methodsFor: 'accessing-computed'!subclasses	^ self profiler allClassesSuchThat: [:cls | cls superclass == self]! !!SLClass methodsFor: 'accessing'!superclass	^ self profiler classAt: self theClass superclass name ifNone: [nil]! !!SLClass methodsFor: 'accessing'!theClass	^ self isMeta		ifTrue: [ (Smalltalk at: self nonMetaClassName) class ]		ifFalse: [ Smalltalk at: self className ]! !!SLClass methodsFor: 'accessing-computed'!theNonMetaClass 	"Return the non metaclass spy for the receiver"		self isMeta ifFalse: [ ^ self ].	^ self packageSpy >> self nonMetaClassName! !!SLClass methodsFor: 'testing'!understandMethodNamed: aSelector	(self hasMethodNamed: aSelector)		ifTrue: [ ^ true ].		self superclass ifNil: [ ^ false ].		^ self superclass understandMethodNamed: aSelector! !!SLClass methodsFor: 'accessing-computed'!withAllSubclasses	^ {self}, self allSubclasses! !!SLClassCoverage class methodsFor: 'hooks'!spyClassForMethod	^ SLMethodCoverage! !!SSTypeCollectorClass class methodsFor: 'hooks'!spyClassForMethod	 ^ SSTypeCollectorMethod! !!SSTypeCollectorClass methodsFor: 'defaults'!typeName 	^ self className! !!SLMethod class methodsFor: 'public'!isInMeta	^ inMeta ! !!SLMethod class methodsFor: 'public'!notIdentifiedMethod	^ self! !!SLMethod class methodsFor: 'public'!setInMeta	inMeta := true! !!SLMethod class methodsFor: 'public'!setInNonMeta	inMeta := false! !!SLMethod class methodsFor: 'hooks'!spyClassForMethod	^ self! !!SLMethod methodsFor: 'delegation'!= v	| vp |	(v isKindOf: SLMethod)		ifTrue: [ vp := v originalMethod ]		ifFalse: [ vp := v ].		^ self originalMethod == vp! !!SLMethod methodsFor: 'hooks'!afterRun: methodName with: listOfArguments in: receiver! !!SLMethod methodsFor: 'delegation'!at: v	^ originalMethod at: v! !!SLMethod methodsFor: 'hooks'!beforeRun: methodName with: listOfArguments in: receiver! !!SLMethod methodsFor: 'contract'!checkInvariant	self assert: [ selector notNil ].	self assert: [ selector isKindOf: Symbol ].	self assert: [ originalMethod isKindOf: CompiledMethod ].	self assert: [ self profiler notNil ].	self assert: [ self classSpy notNil ].	self assert: [ self classSpy profiler == self profiler ].	self assert: [ self classSpy profiler notNil ].		self assert: [ self classSpy profiler isKindOf: SLProfiler ].	! !!SLMethod methodsFor: 'accessing'!classSpy	^ classSpy! !!SLMethod methodsFor: 'accessing'!classSpy: anObject	classSpy := anObject! !!SLMethod methodsFor: 'accessing'!compiledMethod	^ self originalMethod! !!SLMethod methodsFor: 'delegation'!endPC	^ originalMethod endPC! !!SLMethod methodsFor: 'hooks'!flushCache	"Tell the interpreter to remove all references to this method from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of two selective flush methods needs to be used.	Squeak 2.2 and earlier uses 119 (See Symbol flushCache).	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache).""	<primitive: 116>"! !!SLMethod methodsFor: 'delegation'!getSourceFor: sel in: class	^ originalMethod getSourceFor: sel in: class! !!SLMethod methodsFor: 'accessing-computed'!getSpyOf: callingMethod	"Take as argument a compiled method"	"Return nil if none"	| clsSpy |		"We are looking for an instance side method"	callingMethod methodClass isMeta ifFalse: [ 		clsSpy := self profiler classAt: callingMethod methodClass name ifNone: [ ^ nil ].		^ clsSpy >> callingMethod selector ].		"We are looking for a class side method"	" callingMethod methodClass isMeta => true"	clsSpy := self profiler classAt: callingMethod methodClass soleInstance name ifNone: [ ^ nil ].	^ clsSpy metaclassSpy >> callingMethod selector ! !!SLMethod methodsFor: 'testing'!hasClassSpy 	^ self classSpy notNil! !!SLMethod methodsFor: 'testing'!hasLiteral: v	^ self originalMethod hasLiteral: v! !!SLMethod methodsFor: 'delegation'!hasLiteralSuchThat: v	^ originalMethod hasLiteralSuchThat: v! !!SLMethod methodsFor: 'delegation'!hash	^ self originalMethod hash bitXor: super hash! !!SLMethod methodsFor: 'delegation'!initialPC	^ originalMethod initialPC! !!SLMethod methodsFor: 'initialize-release'!initialize	super initialize.! !!SLMethod methodsFor: 'installing'!install	"We do nothing if the method has been supressed"	(self theClass methodDict includesKey: self selector) ifFalse: [ ^ self ].	self assert: [ (self theClass methodDict at: self selector) isSpy not ].	self assert: [ self originalMethod notNil ].	self assert: [ self instrumentedMethod notNil ].	self flushCache.		"We update the original method, it may have changed since the uninstall"	originalMethod := self theClass methodDict at: self selector.	self theClass methodDict at: self selector put: self instrumentedMethod.	! !!SLMethod methodsFor: 'accessing'!instrumentedMethod	^ instrumentedMethod! !!SLMethod methodsFor: 'accessing'!instrumentedMethod: aTemplateMethod	instrumentedMethod := aTemplateMethod! !!SLMethod methodsFor: 'testing'!isAbstract	"True if the original method is abstract"	^ self originalMethod isAbstract! !!SLMethod methodsFor: 'testing'!isClassSide		^ (self classSpy className endsWith: 'class')! !!SLMethod methodsFor: 'delegation'!isConflict	^ originalMethod isConflict! !!SLMethod methodsFor: 'testing'!isMethodExisting	^ self theClass methodDict includesKey: self selector! !!SLMethod methodsFor: 'testing'!isMethodNotExisting	^ self isMethodExisting not! !!SLMethod methodsFor: 'testing'!isNotAMethodExtension	"True if I am a class extension"	^ self originalMethod category first = $*! !!SLMethod methodsFor: 'testing'!isNotMethodExtension	"True if I am a class extension"	^ self originalMethod category first ~= $*! !!SLMethod methodsFor: 'testing'!isNotQuick	^ originalMethod isQuick not! !!SLMethod methodsFor: 'testing'!isQuick	^ originalMethod isQuick! !!SLMethod methodsFor: 'testing'!isRequired	^ self originalMethod isRequired! !!SLMethod methodsFor: 'testing'!isRequired: marker	^ self originalMethod isRequired: marker! !!SLMethod methodsFor: 'testing'!isSpyMethod	^ true! !!SLMethod methodsFor: 'testing'!isTest		^ (self asString findString: 'test' startingAt: 0 caseSensitive: true) > 0 and: [(self classSpy isTestClass )]! !!SLMethod methodsFor: 'testing'!isUnary	^ self selector isUnary! !!SLMethod methodsFor: 'delegation'!last	^ originalMethod last! !!SLMethod methodsFor: 'delegation'!literalAt: v	^ originalMethod literalAt: v! !!SLMethod methodsFor: 'delegation'!literals	^ originalMethod literals! !!SLMethod methodsFor: 'delegation'!methodClass	^ originalMethod methodClass! !!SLMethod methodsFor: 'accessing-computed'!numberOfCalls	^ originalMethod messages size! !!SLMethod methodsFor: 'accessing-computed'!numberOfLinesOfCode	^ originalMethod  numberOfLinesOfCode! !!SLMethod methodsFor: 'delegation'!objectForDataStream: v	^ originalMethod objectForDataStream: v! !!SLMethod methodsFor: 'accessing'!originalMethod	originalMethod isSpy ifTrue: [ ^ originalMethod originalMethod ].	^ originalMethod! !!SLMethod methodsFor: 'accessing'!originalMethod: aCompiledMethod	self assert: [ aCompiledMethod isSpy not ].	originalMethod := aCompiledMethod ! !!SLMethod methodsFor: 'accessing-computed'!package	^ self classSpy packageSpy! !!SLMethod methodsFor: 'delegation'!pragmas	^ originalMethod pragmas! !!SLMethod methodsFor: 'printing'!printOn: stream	stream nextPut: $<.	self classSpy ifNotNil:[ stream nextPutAll: (self theClass name asString).].	stream nextPutAll: ('>>').	self selector ifNotNil:[stream nextPutAll: (self selector asString).].	stream nextPut: $>! !!SLMethod methodsFor: 'accessing-computed'!profiler	self package ifNil: [ ^ nil ].	^ self package profiler! !!SLMethod methodsFor: 'delegation'!readDataFrom: v1 size: v2	^ originalMethod readDataFrom: v1 size: v2! !!SLMethod methodsFor: 'delegation'!refersToLiteral: v	^ originalMethod refersToLiteral: v! !!SLMethod methodsFor: 'hooks'!returnValue: value! !!SLMethod methodsFor: 'hooks'!run: methodName with: listOfArguments in: receiver	| v |	self beforeRun: methodName with: listOfArguments in: receiver.	self classSpy ifNotNil: [		classSpy beforeEachExecution: methodName On: receiver with: listOfArguments ].		v := originalMethod valueWithReceiver: receiver arguments: listOfArguments.	self afterRun: methodName with: listOfArguments in: receiver.	self classSpy ifNotNil: [ 		classSpy afterEachExecution: methodName On: receiver with: listOfArguments ].	self returnValue: v.	^ v! !!SLMethod methodsFor: 'accessing'!selector	^ selector! !!SLMethod methodsFor: 'hooks'!selector: sel	selector := sel! !!SLMethod methodsFor: 'accessing-computed'!sourceCode	^ originalMethod getSourceFromFile ! !!SLMethod methodsFor: 'delegation'!sourcePointer	^ originalMethod sourcePointer! !!SLMethod methodsFor: 'delegation'!storeDataOn: v	^ originalMethod storeDataOn: v! !!SLMethod methodsFor: 'delegation'!storeOn: s	^ originalMethod storeOn: s! !!SLMethod methodsFor: 'delegation'!theClass	^ originalMethod methodClass! !!SLMethod methodsFor: 'installing'!uninstall	self theClass methodDict at: self selector put: self originalMethod.	self flushCache! !!SLMethod methodsFor: 'delegation'!veryDeepCopyWith: v	^ originalMethod veryDeepCopyWith: v! !!SLMethodCoverage methodsFor: 'accessing'!blocks	^ blocks! !!SLMethodCoverage methodsFor: 'enumerating'!count: aNumber	blocks detect:[:block| block id = aNumber] ifFound:[ :block | 		self updateStateFirstBlock.		block executed]! !!SLMethodCoverage methodsFor: 'initialize-release'!initialize 		super initialize.	blocks := OrderedCollection new.! !!SLMethodCoverage methodsFor: 'installing'!installGhosts	| rbMethodNode newMethod aClass |	"self selector = #pic ifTrue: [ self halt ]."	self originalMethod sourceCode size > 20000 	ifTrue: [ self uninstall ]	ifFalse: [[ 	rbMethodNode := RBParser		parseMethod: self originalMethod sourceCode.	blocks := SLInstrumentor new		visitNode: rbMethodNode;		blocks.	aClass := self originalMethod methodClass.	newMethod := aClass compile: rbMethodNode printString notifying: nil.	aClass >> newMethod replaceLiterals: (Array with: (#metaObject -> self)) ]		on: Error		do: [ :e | self uninstall ]]! !!SLMethodCoverage methodsFor: 'public - metrics'!numberOfAllStatements	^ self blocks inject: 0 into:[:sum :block| sum + block numberOfStatements]! !!SLMethodCoverage methodsFor: 'public - metrics'!numberOfExecutedStatements	^ (self blocks select: #wasExecuted)		inject: 0		into: [ :sum :block | sum + block numberOfStatements ]! !!SLMethodCoverage methodsFor: 'updating'!updateStateFirstBlock	blocks ifNotEmpty: [ blocks first executed ]! !!SSTypeCollectorMethod methodsFor: 'accessing'!argTypes	^ argTypes! !!SSTypeCollectorMethod methodsFor: 'hooks'!beforeRun: methodName with: listOfArguments in: aReceiver	self saveArguments: listOfArguments.	self saveReceiver: aReceiver.	self selectLiteralsOf: self originalMethod sourceCode.	listOfArguments do: [ :arg | self checkIfArgIsScalar: arg ].	executed := true.	numberOfExecutions := numberOfExecutions + 1! !!SSTypeCollectorMethod methodsFor: 'hooks'!checkIfArgIsScalar: arg	(self profiler isScalar: arg)		ifTrue: [ self profiler addScalar: arg ]! !!SSTypeCollectorMethod methodsFor: 'accessing'!dictLiterals	^ literals	! !!SSTypeCollectorMethod methodsFor: 'hooks'!initialize	super initialize.	returnType := Set new.	receiverType := Set new.	argTypes := OrderedCollection new.	executed := false.	numberOfExecutions := 0.	literals := Dictionary new! !!SSTypeCollectorMethod methodsFor: 'testing'!isDeprecated 	^ originalMethod isDeprecated ! !!SSTypeCollectorMethod methodsFor: 'testing'!isValidReturnTypeWithReceiver	^ self receiverType = self returnType! !!SSTypeCollectorMethod methodsFor: 'hooks'!numberOfExecutions	^ numberOfExecutions! !!SSTypeCollectorMethod methodsFor: 'hooks'!numberOfExecutions: aNumber	numberOfExecutions := aNumber ! !!SSTypeCollectorMethod methodsFor: 'accessing'!receiverType		^ receiverType! !!SSTypeCollectorMethod methodsFor: 'accessing'!returnType	^ returnType! !!SSTypeCollectorMethod methodsFor: 'hooks'!returnValue: value	returnType add: (self nameOf: value class).	self checkIfArgIsScalar: value! !!SSTypeCollectorMethod methodsFor: 'hooks'!saveArguments: args	args		doWithIndex: [ :anObject :index | 			[ argTypes at: index ]				on: SubscriptOutOfBounds				do: [ argTypes add: Set new ].			(argTypes at: index) add: (self nameOf: anObject class) ]! !!SSTypeCollectorMethod methodsFor: 'hooks'!saveReceiver: anObject	receiverType		add:			(self nameOf: anObject )! !!SSTypeCollectorMethod methodsFor: 'hooks'!selectLiteralsOf: string	| node visitor |	node := RBParser parseMethod: string.	visitor := SLCollectorLiteral new.	node acceptVisitor: visitor.	literals := visitor literals! !!SSTypeCollectorMethod methodsFor: 'hooks'!wasExecuted	^ executed.! !!SLPackage class methodsFor: 'hooks'!spyClassForClass	^ SLClass! !!SLPackage methodsFor: 'accessing'!>> aSymbol	"we are accessing a method defined in a metaclass"	(aSymbol includes: $ ) ifTrue: [ ^ (self >> aSymbol substrings first asSymbol) metaclassSpy ].		^ self classAt: aSymbol! !!SLPackage methodsFor: 'enumerating'!allClassesSuchThat: aBlock	^ self classes select: aBlock! !!SLPackage methodsFor: 'accessing-computed'!allMethods	| coll |	coll := OrderedCollection new.	self classes do: [:cls | coll addAll: cls allMethods ].	^ coll! !!SLPackage methodsFor: 'enumerating'!allMethodsSuchThat: aBlock	^ self allMethods select: aBlock! !!SLPackage methodsFor: 'contract'!checkInvariant	self assert: [ packageName notNil ].	self assert: [ packageName isKindOf: ByteString ].	self assert: [ self profiler notNil ].	self assert: [ self classes notNil ].	self assert: [ self classes allSatisfy: [ :c | c isKindOf: self class spyClassForClass ] ].	self assert: [ self classes allSatisfy: [ :c | c package == self ] ].	self assert: [ self classes allSatisfy: [ :c | c profiler == self profiler ]].		self classes do: #checkInvariant! !!SLPackage methodsFor: 'accessing'!classAt: aSymbol	^ classes at: aSymbol ifAbsent: [ self error: 'Class ', aSymbol, ' not found']! !!SLPackage methodsFor: 'accessing'!classAt: aSymbol ifNone: aBlock	^ classes at: aSymbol ifAbsent: aBlock	! !!SLPackage methodsFor: 'accessing'!classAt: aSymbol put: aClassType	self assert: [aSymbol isSymbol].		aClassType className: aSymbol.	"self class globalTypesAt: aClassType className put: aClassType."	^ classes at: aSymbol put: aClassType! !!SLPackage methodsFor: 'accessing'!classes 	^ classes! !!SLPackage methodsFor: 'enumerating'!classesDo: aBlockOrSymbol	^ self classes do: aBlockOrSymbol! !!SLPackage methodsFor: 'testing'!hasClassNamed: className	^ self classes includesKey: className asSymbol! !!SLPackage methodsFor: 'initialize-release'!initialize 	super initialize.	classes := Dictionary new ! !!SLPackage methodsFor: 'accessing'!packageName	^ packageName! !!SLPackage methodsFor: 'accessing'!packageName: nameAsString	packageName  := nameAsString asString! !!SLPackage methodsFor: 'printing'!printOn: stream	stream nextPutAll: '<<'.	self packageName ifNotNil:[ stream nextPutAll: (self packageName asString).].	stream nextPutAll: '>>'.! !!SLPackage methodsFor: 'accessing'!profiler	^ profiler! !!SLPackage methodsFor: 'accessing'!profiler: anObject	profiler := anObject! !!SLPackageCoverage class methodsFor: 'hooks'!spyClassForClass	^ SLClassCoverage! !!SSTypeCollectorPackage class methodsFor: 'hooks'!spyClassForClass	 ^ SSTypeCollectorClass! !!SLProfiler class methodsFor: 'gathering'!allSpysForPackagesMatching: regexpAsString	"	self allSpysForPackagesMatching: 'Mondrian*'.	"	| classes answer |	classes := self classesForPackagesMatching: regexpAsString.	answer := OrderedCollection new.	classes do: [:cls | answer addAll: (cls methods select: #isSpy)].	^ answer! !!SLProfiler class methodsFor: 'gathering'!classesAndMetaClassesFor: aPackage 	^ OrderedCollection new		addAll: aPackage definedClasses;		addAll: (aPackage definedClasses collect: [ :each | each classSide ]);		yourself! !!SLProfiler class methodsFor: 'gathering'!classesForPackagesMatching: regexpAsString	"Return the list of classes defines in the packages matching one of the regular expressions"	"Traits are excluded"	| packages classes |	packages := (RPackageOrganizer default packages select: [:p | regexpAsString match: p name asString ]).	classes := packages inject: #() 						into: [:sum :el | sum, (el classes reject: #isTrait) asOrderedCollection ].	^ classes! !!SLProfiler class methodsFor: 'util'!currentTestCase 	^ currentTestCase! !!SLProfiler class methodsFor: 'util'!currentTestCase: aTestCase	^ currentTestCase := aTestCase! !!SLProfiler class methodsFor: 'util'!currentTestMethod 	^ currentTestMethod! !!SLProfiler class methodsFor: 'util'!currentTestMethod: aSelector 	^ currentTestMethod := aSelector! !!SLProfiler class methodsFor: 'util'!currentTestMethodSpy: aSelector 	^ currentTestMethodSpy := aSelector! !!SLProfiler class methodsFor: 'hooks'!defaultRun	"Tell on what the profiler has to be run per default"	^ #package ! !!SLProfiler class methodsFor: 'public - profiling'!evaluateBlock: aBlock	aBlock value.! !!SLProfiler class methodsFor: 'public - installing removing'!forClass: aClass	| profiler classSpy packageSpy |	self installOnClass: aClass.	profiler := self new.	classSpy := profiler spyForClass: aClass.	packageSpy := self spyClassForPackage new.	packageSpy classAt: aClass name put: classSpy.	classSpy packageSpy:  packageSpy.	packageSpy packageName: 'Smalltalk'.	profiler addPackage: packageSpy.		^ profiler! !!SLProfiler class methodsFor: 'gathering'!gather	^ self new gather! !!SLProfiler class methodsFor: 'gathering'!gatherForClassCategory: nameAsString	"Return a profiler"	^ self new gatherForClassCategory: nameAsString ! !!SLProfiler class methodsFor: 'gathering'!gatherForPackageNamed: nameAsString	"Return a profiler"		^ self new gatherForPackageNamed: nameAsString ! !!SLProfiler class methodsFor: 'gathering'!gatherForPackagesMatching: regexpAsString	"Return a profiler"		^ self new gatherForPackagesMatching: regexpAsString! !!SLProfiler class methodsFor: 'gathering'!gatherForSeveralPackagesMatching: collectionOfRegExp	"Return a profiler"		^ self new gatherForSeveralPackagesMatching: collectionOfRegExp! !!SLProfiler class methodsFor: 'private - method template'!generateTemplates	"	self generateTemplates	"	| argString parameterString |	self class compileSilently: 'with0Arg ', String cr, (self templateCode expandMacrosWith: '#()') classified: 'private - method template'.	1 to: 15 do: [ :i |		parameterString := ''.		argString := '{'.		1 to: i do: [ :ii | 			parameterString := parameterString, 'arg: ', 'v', ii printString, ' '.			argString := argString, 'v', ii printString, '.'].				argString := argString allButLast, '}'.		self class 				compile: 'with', i printString, parameterString, String cr, (self templateCode expandMacrosWith: argString)				classified: 'private - method template'.	]! !!SLProfiler class methodsFor: 'private - installing'!install	" Install on all classes"	self installOnClasses: Smalltalk allClasses! !!SLProfiler class methodsFor: 'private - installing'!installOnBehavior: aBehavior	| dict cm templateMethod metaObject |	aBehavior flushCache.		"We do nothing for traits"	aBehavior isTrait ifTrue: [ ^ self ].	dict := aBehavior methodDict.	dict keys do:		[:k|			k flushCache.			cm := dict at: k.			cm isSpy ifFalse: [				"Using template method"				templateMethod := self templateMethodForNumberOfArguments: cm 	numArgs.				templateMethod := templateMethod copyFor: aBehavior.				metaObject := self spyClassForMethod new 										originalMethod: cm; 										selector: k; 										instrumentedMethod: templateMethod;										yourself.				templateMethod replaceLiterals: 					{templateMethod selector -> k . 					 #metaObject -> metaObject . 					 #selector -> k}.				dict at: k put: templateMethod.]						"Using method wrapper""			(cm isCompiledMethod and: [ self shouldInstallOnCompiledMethod: cm])			 	ifTrue: [dict at: k put: (self spyClassForMethod new originalMethod: cm; selector: k; yourself)]"		]			! !!SLProfiler class methodsFor: 'private - installing'!installOnClass: aClass	"Transcript show: 'instrumenting ', aClass name printString ;cr."	(self isDangerous: aClass instanceSide)		ifTrue: [ ^ self ].	self		installOnBehavior: aClass instanceSide;		installOnBehavior: aClass classSide.	^ self new spyForClass: aClass! !!SLProfiler class methodsFor: 'private - installing'!installOnClassCategory: nameAsString	| classNames classesAndTraits classes |	classNames := SystemOrganization listAtCategoryNamed: nameAsString.	classesAndTraits := classNames collect: [:clsName | Smalltalk at: clsName].	classes := classesAndTraits reject: #isTrait.	self installOnClasses: classes! !!SLProfiler class methodsFor: 'private - installing'!installOnClassCategoryMatching: regexpAsString	(SystemOrganization categoriesMatching: regexpAsString)		do: [:cat | self installOnClassCategory: cat]! !!SLProfiler class methodsFor: 'private - installing'!installOnClasses: classes	classes do: [:cls | self installOnClass: cls ].! !!SLProfiler class methodsFor: 'private - installing'!installOnPackagesMatching: regexpAsString	| classes |	classes := self classesForPackagesMatching: regexpAsString.	classes do: [:cls | 		(regexpAsString, '*' match: cls category asString) ifTrue: [ self installOnClass: cls ] 	]! !!SLProfiler class methodsFor: 'util'!isDangerous: aClass	self		assert: [ aClass instanceSide == aClass ]		description: 'Can only be called on non meta class'.	"	(aClass inheritsFrom: Spy) ifTrue: [ ^ true ].	true ifTrue: [ ^ false ].	"	"Cannot instrument a configuration"	(aClass name beginsWith: 'ConfigurationOf')		ifTrue: [ ^ true ].	"Can instrument the scenario example, even it belongs to Spy"	(aClass category beginsWith: 'Spy-ScenarioExample')		ifTrue: [ ^ false ].	"	({ByteSymbol . String . Symbol . MethodReference . MorphicToolBuilder} includes: aClass)		ifTrue: [ ^ true ]."	(#('Spy-Core' 'Announcements' 'Balloon' 'Collections' 'CollectionsTests' 'Compiler' 'CompilerTests' 'Compression' 'DeprecatedPreferences' 'Exceptions' 'Files' 'FixUnderscores' 'FreeType' 'FreeTypeSubPixelAntiAliasing' 'FreeTypeTests' 'Gofer' 'Graphics' 'GraphicsTests' 'HostMenus' 'Kernel' 'KernelTests' 'MCDirtyPackage' 'MenuRegistration' 'Monticello' 'MonticelloConfigurations' 'MonticelloGUI' 'MonticelloMocks' 'Morphic' 'MorphicTests' 'Multilingual' 'MultilingualTests' 'ObjectMetaTools' 'PackageInfo' 'PinesoftEnhancementsForFreetype' 'Polymorph' 'PreferenceBrowser' 'ST80' 'SUnit' 'SUnitGUI' 'ScriptLoader' 'ScriptLoader11' 'Settings' 'System' 'Tests' 'ToolBuilder' 'Tools' 'ToolsTest' 'Traits' 'TrueType' 'VB')		anySatisfy: [ :cat | aClass category beginsWith: cat ])		ifTrue: [ ^ true ].	"'Network' 'NetworkTests' "	^ false	"	^ aClass isCollection		or: [ ((Smalltalk specialObjectsArray select: #isBehavior) includes: aClass) ]"! !!SLProfiler class methodsFor: 'util'!isNotDangerous: aClass	^ (self isDangerous: aClass) not! !!SLProfiler class methodsFor: 'util'!log: aString	Transcript show: 'Running: ', aString asString; cr.! !!SLProfiler class methodsFor: 'util'!nonDangerousClasses	^ Smalltalk allClasses select: [:cls | SLProfiler isNotDangerous: cls ]! !!SLProfiler class methodsFor: 'util'!packageInfosMatching: regexpAsString	"Return the list of package info for which their names match the argument		Profiler packageInfosMatching: 'Kernel*'	"		^ MCWorkingCopy allManagers  select: [:p | regexpAsString match: p package name]! !!SLProfiler class methodsFor: 'util'!packageNamesMatching: regexpAsString	"Return the list of package names for which their names match the argument		Profiler packageNamesMatching: 'Kern*'	"		^ (self packageInfosMatching: regexpAsString) collect: #packageName! !!SLProfiler class methodsFor: 'public - profiling'!profile: aBlock	| profiler messageTally tally |	self 		assert: [ self new getTimeAndCallGraph ] 		description: 'profile: can be invoked only if getTimeAndCallGraph return true'.		profiler := self new.	'Profiling' displayProgressAt: Display center from:1 to: 5 during: [:bar |		bar value: 1.		tally := (profiler tallyOn: aBlock).		Smalltalk garbageCollect.		[  bar value: 2.			"self installOnClasses: tally allInvolvedClasses."			self installOnPackagesNamed: tally allInvolvedPackageNames.			profiler beforeProfiling.			bar value: 3.			aBlock value.			bar value: 4.			profiler gatherForPackagesNamed: tally allInvolvedPackageNames.			profiler afterProfiling ]		ensure: [ self removeFromPackagesNamed:  tally allInvolvedPackageNames ].		bar value: 5.		profiler setTimeInfoFromTally: tally.		tally close ].	^ profiler! !!SLProfiler class methodsFor: 'public - profiling'!profile: aBlock forClassNamed: className	|profiler packageSpy cls classSpy |	cls := Smalltalk at: className.	profiler := self new.	Transcript show: 'profiling...'; cr.	[		self installOnClass: cls.		profiler beforeProfiling.				classSpy := profiler spyForClass: cls.		packageSpy := self spyClassForPackage new.		packageSpy classAt: className put: classSpy.		profiler addPackage: packageSpy.		classSpy packageSpy: packageSpy.		aBlock value.		profiler afterProfiling. ]	ensure: [ self removeFromClass: cls ].	Transcript show: 'ended...'; cr.	^ profiler! !!SLProfiler class methodsFor: 'public - profiling'!profile: aBlock inClassCategory: classCategory	| profiler |		Transcript show: 'profiling...'; cr.	profiler := self new.	[		self installOnClassCategory: classCategory.		profiler beforeProfiling.		profiler := self gatherForClassCategory: classCategory.		self evaluateBlock: aBlock.		profiler afterProfiling ]	ensure: [ self removeFromClassCategory: classCategory ].	Transcript show: 'ended...'; cr.	profiler setIfNecessaryTimeAndCallGraphFrom: aBlock.	profiler checkInvariant.	^ profiler! !!SLProfiler class methodsFor: 'public - profiling'!profile: aBlock inPackage: packageName	|profiler |	Transcript show: 'profiling...'; cr.	[		self installOnPackageNamed: packageName.		profiler := self gatherForPackageNamed: packageName.		profiler beforeProfiling.		aBlock value.		profiler afterProfiling. ]	ensure: [ self removeFromPackageNamed: packageName ].	Transcript show: 'ended...'; cr.	profiler setIfNecessaryTimeAndCallGraphFrom: aBlock.	profiler checkInvariant.		^ profiler! !!SLProfiler class methodsFor: 'public - profiling'!profile: aBlock inPackagesMatching: regexp	| profiler |		Transcript show: 'profiling...'; cr.	[		profiler := self profilerForPackagesMatching: regexp.		profiler beforeProfiling.		aBlock value.		profiler afterProfiling  ]	ensure: [ self removeFromPackagesMatching: regexp ].	Transcript show: 'ended...'; cr.	profiler checkInvariant.	^ profiler! !!SLProfiler class methodsFor: 'gathering'!profile: aBlock inPackagesMatching: regexp  withAfterBlockProfiling: afterBlock 	| profiler |		Transcript show: 'profiling...'; cr.	[		profiler := self profilerForPackagesMatching: regexp.		profiler afterBlock: afterBlock.		profiler beforeProfiling.		aBlock value.		profiler afterProfiling  ]	ensure: [ self removeFromPackagesMatching: regexp ].	Transcript show: 'ended...'; cr.	profiler checkInvariant.	^ profiler! !!SLProfiler class methodsFor: 'public - profiling'!profile: aBlock inSeveralPackagesMatching: collectionOfRegExp	| profiler |		Transcript show: 'profiling...'; cr.	[		collectionOfRegExp do: [ :regexp |			self installOnPackagesMatching: regexp ].				"A bit awkward. Hopefully with Spy2 this will be removed"		profiler := self gatherForSeveralPackagesMatching: collectionOfRegExp.		profiler beforeProfiling.		aBlock value.				profiler afterProfiling  ]	ensure: [ collectionOfRegExp do: [ :regexp | self removeFromPackagesMatching: regexp ] ].	Transcript show: 'ended...'; cr.	profiler setIfNecessaryTimeAndCallGraphFrom: aBlock.	profiler checkInvariant.	^ profiler! !!SLProfiler class methodsFor: 'public - profiling'!profilerForClass: className	|profiler packageSpy cls classSpy |	cls := Smalltalk at: className.	profiler := self new.	self installOnClass: cls.			classSpy := profiler spyForClass: cls.	packageSpy := self spyClassForPackage new.	packageSpy classAt: className put: classSpy.	profiler addPackage: packageSpy.	classSpy packageSpy: packageSpy.			^ profiler! !!SLProfiler class methodsFor: 'public - profiling'!profilerForPackagesMatching: regexp	self installOnPackagesMatching: regexp.	^ self gatherForPackagesMatching: regexp! !!SLProfiler class methodsFor: 'private - installing'!remove	" Install on all classes"	self removeFromClasses: Smalltalk allClasses! !!SLProfiler class methodsFor: 'private - installing'!removeFrom: class	class flushCache.	class selectors do: [:k | k flushCache ].	class removeSpys! !!SLProfiler class methodsFor: 'private - installing'!removeFromClass: class	SLProfiler class == class ifTrue: [ ^ self ].	^ self removeFrom: class! !!SLProfiler class methodsFor: 'private - installing'!removeFromClassCategory: nameAsString	| classNames classesAndTraits classes |	classNames := SystemOrganization listAtCategoryNamed: nameAsString.	classesAndTraits := classNames collect: [:clsName | Smalltalk at: clsName].	classes := classesAndTraits reject: #isTrait.	self removeFromClasses: ((classes collect: #theNonMetaClass), (classes collect: #theMetaClass))! !!SLProfiler class methodsFor: 'private - installing'!removeFromClassCategoryMatching: regexpAsString	(SystemOrganization categoriesMatching: regexpAsString)		do: [:cat | self removeFromClassCategory: cat]! !!SLProfiler class methodsFor: 'private - installing'!removeFromClasses: classes	^ classes do: [:cls | self 							removeFromClass: cls theNonMetaClass;							removeFromClass: cls theMetaClass ].! !!SLProfiler class methodsFor: 'private - installing'!removeFromPackagesMatching: regexpAsString	| classes |	classes := self classesForPackagesMatching: regexpAsString.	classes do: [:cls | cls removeSpys ]	! !!SLProfiler class methodsFor: 'private - installing'!removeFromPackagesNamed: strings	self assert: [ strings isString not ] description: 'A collection of String must be passed to #removeFromPackagesNamed:'.	self assert: [ (strings allSatisfy: #isString) ] description: 'A collection of must should be passed to #removeFromPackagesNamed:'.	strings do: [ :packageName | self removeFromPackageNamed: packageName ]	! !!SLProfiler class methodsFor: 'util'!shouldInstallOnClass: aClass	self assert: [ aClass theNonMetaClass == aClass ] description: 'Can only be called on non meta class'.		^ (self isNotDangerous: aClass)! !!SLProfiler class methodsFor: 'util'!shouldInstallOnCompiledMethod: compiledMethod	^ (compiledMethod pragmaAt: #nospy) isNil! !!SLProfiler class methodsFor: 'hooks'!spyClassForClass	^ self spyClassForPackage spyClassForClass! !!SLProfiler class methodsFor: 'hooks'!spyClassForMethod	^ self spyClassForPackage spyClassForClass spyClassForMethod! !!SLProfiler class methodsFor: 'hooks'!spyClassForPackage	^ SLPackage! !!SLProfiler class methodsFor: 'private - method template'!templateCode	^ '^ #metaObject run: #selector with: <1s> in: self  '		"	^ '^ MethodSpy isInMeta		ifTrue: [ #metaObject originalMethod valueWithReceiver: self arguments: <1s> ]		ifFalse: [ #metaObject run: #selector with: <1s> in: self ] '"! !!SLProfiler class methodsFor: 'private - method template'!templateMethodForNumberOfArguments: numberOfArguments	^ SLProfiler class>> (#(			#with0Arg			#with1arg:			#with2arg:arg:			#with3arg:arg:arg:			#with4arg:arg:arg:arg:			#with5arg:arg:arg:arg:arg:			#with6arg:arg:arg:arg:arg:arg:			#with7arg:arg:arg:arg:arg:arg:arg:			#with8arg:arg:arg:arg:arg:arg:arg:arg:			#with9arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with10arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with11arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with12arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with13arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with14arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with15arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			) at: (numberOfArguments + 1))! !!SLProfiler class methodsFor: 'private - method template'!templateMethods	^ #(			#with0Arg			#with1arg:			#with2arg:arg:			#with3arg:arg:arg:			#with4arg:arg:arg:arg:			#with5arg:arg:arg:arg:arg:			#with6arg:arg:arg:arg:arg:arg:			#with7arg:arg:arg:arg:arg:arg:arg:			#with8arg:arg:arg:arg:arg:arg:arg:arg:			#with9arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with10arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with11arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with12arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with13arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with14arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			#with15arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:arg:			) collect: [:k | self class >> k ]! !!SLProfiler class methodsFor: 'hooks'!testMethodsToIgnore	"This is intended to be temporary. There are some strange bugs that are hard to track down"	^ #(testNestingOfFormBuilder testNestedCycle)! !!SLProfiler class methodsFor: 'public - profiling'!viewProfiling: aBlock	(self profile: aBlock) visualize ! !!SLProfiler class methodsFor: 'public - profiling'!viewProfiling: aBlock inPackage: packageName	(self profile: aBlock inPackage: packageName) visualize! !!SLProfiler class methodsFor: 'public - profiling'!viewProfiling: aBlock inPackagesMatching: regexp	(self profile: aBlock inPackagesMatching: regexp) visualize! !!SLProfiler class methodsFor: 'private - method template'!with0Arg	^ #metaObject		run: #selector		with: #()		in: self! !!SLProfiler class methodsFor: 'private - method template'!with10arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 arg: v9 arg: v10 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8.v9.v10} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with11arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 arg: v9 arg: v10 arg: v11 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8.v9.v10.v11} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with12arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 arg: v9 arg: v10 arg: v11 arg: v12 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8.v9.v10.v11.v12} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with13arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 arg: v9 arg: v10 arg: v11 arg: v12 arg: v13 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8.v9.v10.v11.v12.v13} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with14arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 arg: v9 arg: v10 arg: v11 arg: v12 arg: v13 arg: v14 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8.v9.v10.v11.v12.v13.v14} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with15arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 arg: v9 arg: v10 arg: v11 arg: v12 arg: v13 arg: v14 arg: v15 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8.v9.v10.v11.v12.v13.v14.v15} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with1arg: v1 ^ #metaObject run: #selector with: {v1} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with2arg: v1 arg: v2 ^ #metaObject run: #selector with: {v1.v2} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with3arg: v1 arg: v2 arg: v3 ^ #metaObject run: #selector with: {v1.v2.v3} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with4arg: v1 arg: v2 arg: v3 arg: v4 ^ #metaObject run: #selector with: {v1.v2.v3.v4} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with5arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with6arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with7arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with8arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8} in: self  ! !!SLProfiler class methodsFor: 'private - method template'!with9arg: v1 arg: v2 arg: v3 arg: v4 arg: v5 arg: v6 arg: v7 arg: v8 arg: v9 ^ #metaObject run: #selector with: {v1.v2.v3.v4.v5.v6.v7.v8.v9} in: self  ! !!SLProfiler methodsFor: 'accessing - read only'!>> aSymbol	"Fetching a class"		"we are accessing a method defined in a metaclass"	(aSymbol includes: $ ) ifTrue: [ ^ (self >> aSymbol substrings first asSymbol) metaclassSpy ].		^ self classAt: aSymbol! !!SLProfiler methodsFor: 'accessing - read only'!>>> aPackageName	^ self packages detect: [:pak | pak packageName asString = aPackageName asString ]! !!SLProfiler methodsFor: 'adding'!addPackage: aPackageSpy	self assert: [ aPackageSpy class == self class spyClassForPackage ].		self packages add: aPackageSpy.	aPackageSpy profiler: self.! !!SLProfiler methodsFor: 'accessing'!afterBlock: aBlock	afterBlock := aBlock! !!SLProfiler methodsFor: 'hooks'!afterProfiling 	afterBlock value! !!SLProfiler methodsFor: 'accessing - read only'!allClasses	| answer |	answer := OrderedCollection new.	self packages do: [:p | 		answer addAll: p classes ].	^ answer! !!SLProfiler methodsFor: 'accessing - read only'!allClassesAsDictionary  | answer |  allClassesAsDictionaryCache ifNotNil: [ ^allClassesAsDictionaryCache ].  answer := Dictionary new.  self packages do: [:p |  p classes do: [:c |  answer at: c className put: c ] ].  ^allClassesAsDictionaryCache := answer! !!SLProfiler methodsFor: 'accessing - read only'!allClassesSuchThat: aBlock	^ self allClasses select: aBlock! !!SLProfiler methodsFor: 'accessing - read only'!allMethods	"Return the list of all the methods"		allMethodsCache ifNotNil: [ ^ allMethodsCache ].		allMethodsCache := OrderedCollection new.	self packages do: [:p | 		allMethodsCache addAll: p allMethods ].	^ allMethodsCache ! !!SLProfiler methodsFor: 'accessing - read only'!allNonAbstractMethods	"Return the list of non abstract methods"		allNonAbstractMethodsCache ifNotNil: [ ^ allNonAbstractMethodsCache ].	^ allNonAbstractMethodsCache := self allMethods reject: #isAbstract! !!SLProfiler methodsFor: 'accessing - read only'!allNonMetaClasses	^ self allClasses reject: #isMeta! !!SLProfiler methodsFor: 'hooks'!beforeProfiling 	SLMethod setInNonMeta! !!SLProfiler methodsFor: 'contract'!checkInvariant	self assert: [ self packages notNil ].	self assert: [ self packages allSatisfy: [ :p | p isKindOf: self class spyClassForPackage ] ].	self assert: [ self packages allSatisfy: [ :p | p profiler notNil ]].	self assert: [ self packages allSatisfy: [ :p | p profiler == self ]].	self packages do: #checkInvariant.! !!SLProfiler methodsFor: 'accessing - read only'!classAt: aSymbol	^ self allClassesAsDictionary at: aSymbol ifAbsent: [ self error: 'Class ', aSymbol, ' not found']! !!SLProfiler methodsFor: 'accessing - read only'!classAt: aSymbol ifNone: aBlock	^ self allClassesAsDictionary at: aSymbol ifAbsent: aBlock	! !!SLProfiler methodsFor: 'gathering'!classesAndMetaClassesFor: aPackage 	^ self class classesAndMetaClassesFor: aPackage.! !!SLProfiler methodsFor: 'accessing - read only'!deleteCache	allClassesAsDictionaryCache := nil.	allMethodsCache := nil.! !!SLProfiler methodsFor: 'gathering'!fillClassType: classType with: methodDictionary	| compiledMethod methodSpy |	classType theClass == SLProfiler class		ifTrue: [ ^ self ].		methodDictionary associationsDo: 		[:assoc | 			compiledMethod := (classType theClass >> assoc key).			compiledMethod isSpy				ifTrue: [ methodSpy := compiledMethod methodSpy.							methodSpy classSpy: classType.							classType localMethodAt: assoc key put: methodSpy ] ].! !!SLProfiler methodsFor: 'gathering'!gather	^ self gatherForClasses: self class nonDangerousClasses.! !!SLProfiler methodsFor: 'gathering'!gatherForClassCategory: nameAsString	"Return a profiler"	| package|	package := self packageForClassCategory: nameAsString.	package packageName: nameAsString.	self addPackage: package.	^ self! !!SLProfiler methodsFor: 'gathering'!gatherForClasses: classes	| package classType |	package := self class spyClassForPackage new.	package packageName: 'Global profiling'.	classes do: [:cls |		classType := self spyForClass: cls.		classType packageSpy: package.		package classAt: cls name put: classType].		self addPackage: package.	^ package! !!SLProfiler methodsFor: 'gathering'!gatherForPackagesMatching: regexpAsString	"Return a profiler"		| tpackages |	tpackages := (RPackageOrganizer default packages select: [:p | regexpAsString match: p name asString ]).	tpackages do: [ :pak | 		| class package |		package := self class spyClassForPackage new.		package packageName: pak packageName.		self addPackage: package.		(pak definedClasses reject: #isTrait) do: [:cls|			class := self spyForClass: cls.			class packageSpy: package.			package classAt: cls name asSymbol put: class ] ].	^ self! !!SLProfiler methodsFor: 'gathering'!gatherForSeveralPackagesMatching: collectionOfRegExp	"Return a profiler"		| tpackages |	collectionOfRegExp do: [ :regexpAsString | 		tpackages := (RPackageOrganizer default packages select: [:p | regexpAsString match: p name asString ]).		tpackages do: [ :pak | 			| class package |			package := self class spyClassForPackage new.			package packageName: pak packageName.			self addPackage: package.			((self classesAndMetaClassesFor: pak) reject: #isTrait) do: [:cls|				class := self spyForClass: cls.				class packageSpy: package.				package classAt: cls name asSymbol put: class ] ] ].	^ self! !!SLProfiler methodsFor: 'contract'!getSpyClass: class	^ self classAt: class name ifNone: [ nil ]! !!SLProfiler methodsFor: 'testing'!hasUnitTestResult	^ unitTestResult notNil! !!SLProfiler methodsFor: 'initialize-release'!initialize 	super initialize.	packages := nil.	afterBlock := [  ]	! !!SLProfiler methodsFor: 'installing'!install	self allMethods asSet do: #install! !!SLProfiler methodsFor: 'accessing - read only'!noncoveredMethods 	"Return the list of noncovered methods"	^ self allMethods reject: #isCovered! !!SLProfiler methodsFor: 'accessing - read only'!numberOfClasses	^ self allClasses size! !!SLProfiler methodsFor: 'accessing - read only'!numberOfMethods	^ self allMethods size! !!SLProfiler methodsFor: 'accessing - read only'!numberOfNonAbstractMethods	"Return the number of non abstract methods, including the one of the metaclass "	^ self allNonAbstractMethods size! !!SLProfiler methodsFor: 'gathering'!packageForClassCategory: nameAsString	| package classNames classType |	package := self class spyClassForPackage new.	classNames := SystemOrganization listAtCategoryNamed: nameAsString.		classNames do: [:clsName |		| cls |		cls := Smalltalk at: clsName.		cls isTrait ifFalse: 			[classType := self spyForClass: cls.			classType packageSpy: package.			package classAt: clsName put: classType]].		^ package! !!SLProfiler methodsFor: 'accessing'!packages	^ packages ifNil: [ packages := OrderedCollection new ]! !!SLProfiler methodsFor: 'accessing'!packagesToTest: aCollectionOfStrings	packagesToTest := aCollectionOfStrings! !!SLProfiler methodsFor: 'contract'!profiler 	^ self! !!SLProfiler methodsFor: 'actions'!remove	^ self class remove! !!SLProfiler methodsFor: 'actions'!removeFromRegistry	self class registry removeKey: (self class registry keyAtValue: self )! !!SLProfiler methodsFor: 'gathering'!spyForClass: aClass  | classType |  classType := self class spyClassForClass new.  classType className: (self nameOf: aClass).  self fillClassType: classType with: aClass methodDict.  self fillClassType: classType metaclassSpy with: aClass class methodDict.  ^ classType! !!SLProfiler methodsFor: 'installing'!uninstall	self allMethods do: #uninstall! !!SLProfiler methodsFor: 'installing'!uninstallClass: aSymbol 	| class |	class := (self allClassesSuchThat: [ :aClass | aClass className = aSymbol]) first.	class ifNotNil: [ 		class methods do: #uninstall.		class metaclassSpy methods do: #uninstall 	].	^ class! !!SLProfiler methodsFor: 'accessing'!unitTestResult	^ unitTestResult! !!SLProfiler methodsFor: 'accessing'!unitTestResult: testResult	unitTestResult := testResult! !!SLProfilerCoverage class methodsFor: 'hooks'!spyClassForPackage	^ SLPackageCoverage! !!SLProfilerCoverage methodsFor: 'hooks'!beforeProfiling	self allMethods select: #isNotMethodExtension thenDo: #installGhosts.! !!SLProfilerCoverage methodsFor: 'calculations'!calculateExecutedMethodsByClass	^ (self allClassesAsDictionary keys		collect: [ :aClassName | aClassName -> (self calculateExecutedMethodsOf: aClassName) ])		asDictionary! !!SLProfilerCoverage methodsFor: 'calculations'!calculateExecutedMethodsOf: aSymbol	| methods |	methods := (self classAt: aSymbol) allMethods.	^ Array with: methods size with: (self selectExecutedMethods: methods) size! !!SLProfilerCoverage methodsFor: 'calculations'!calculateExecutedStatementsByClass	^ (self allClassesAsDictionary keys		collect:			[ :aClassName | aClassName -> (self calculateExecutedStatementsOf: aClassName) ] thenSelect: [:assoc | assoc value second > 0])		asDictionary! !!SLProfilerCoverage methodsFor: 'calculations'!calculateExecutedStatementsOf: aSymbol	| methods numStmts |	methods := (self classAt: aSymbol) allMethods.	numStmts := methods ifEmpty: [ 0 ] ifNotEmpty: [ (methods collect: #numberOfAllStatements ) sum ].	^ Array with: numStmts with: 	   (methods		inject: 0		into: [ :sum :method | sum + method numberOfExecutedStatements ])! !!SLProfilerCoverage methodsFor: 'cleaning'!cleanBlocksOfMethods	self allMethods do: [ :aMethod | 		aMethod blocks do: [ :aBlock | aBlock noExecuted ]		]! !!SLProfilerCoverage methodsFor: 'calculations'!methodCoverage	| methods |	methods := self allMethods.	methods isEmpty		ifTrue: [ ^ 0 ].	^ ((100 * self numberOfExecutedMethods / methods size) asFloat) round: 3! !!SLProfilerCoverage methodsFor: 'calculations'!methodCoverage1	^ (self calculateExecutedMethodsByClass associations		collect: [ :assoc | 			| aClassName dataExecMethods |			aClassName := assoc key.			dataExecMethods := assoc value.  "it contains: number of methods, number of executed methods"			dataExecMethods first > 0 ifTrue: [ 			aClassName				-> (((100 * dataExecMethods second / dataExecMethods first ) asFloat) round: 3) ] ifFalse: [ aClassName -> 0 ]])		asDictionary! !!SLProfilerCoverage methodsFor: 'accessing'!numberOfAllStatements	^ self allMethods		inject: 0		into: [ :sum :method | sum + method numberOfAllStatements ].! !!SLProfilerCoverage methodsFor: 'accessing'!numberOfExecutedMethods	"| methodsWithBlocks |	methodsWithBlocks := self allMethods select: [ :aMethod | aMethod blocks isNotEmpty ].	^ (methodsWithBlocks 		collect: [ :aMethod | aMethod blocks first ]		thenSelect: [ :aBlock | aBlock wasExecuted ])"	^ (self selectExecutedMethods: self allMethods) size ! !!SLProfilerCoverage methodsFor: 'accessing'!numberOfExecutedStatements	^ self allMethods		inject: 0		into: [ :sum :method | sum + method numberOfExecutedStatements ]! !!SLProfilerCoverage methodsFor: 'filtering'!selectExecutedMethods: aList	^ (aList select: [ :aMethod | aMethod blocks isNotEmpty ])		select: [ :aMethod | aMethod blocks first wasExecuted ]! !!SLProfilerCoverage methodsFor: 'calculations'!statementCoverage	self numberOfAllStatements == 0		ifTrue: [ ^ 0 ].	^ ((100 * self numberOfExecutedStatements / self numberOfAllStatements)		asFloat) round: 3! !!SLProfilerCoverage methodsFor: 'calculations'!statementCoverage1	^ (self calculateExecutedStatementsByClass associations		collect: [ :assoc | 			| dataExecStmts |			dataExecStmts := assoc value. "it contains: number of statements of class methods, number of executed statements"			dataExecStmts first > 0 ifFalse: [ assoc key -> 0 ] ifTrue: [ 			assoc key				->					(((100 * dataExecStmts second / dataExecStmts first)						asFloat) round: 3) ]]) asDictionary! !!SLProfilerCoverage methodsFor: 'calculations'!statementCoverageFor: aTargetClass	[| executedStatements |	executedStatements := self calculateExecutedStatementsOf: aTargetClass.	^ ((executedStatements second / executedStatements first) * 100 asFloat) round: 3] on: Errordo: [ ^ 0 ]! !!SLProfilerCoverage methodsFor: 'summaries'!summaryExecutionMethods	^ (self selectExecutedMethods: self allMethods) collect: [ :method | 		SLSummaryExecutionMethod on: method ]! !!SLProfilerCoverage methodsFor: 'summaries'!summaryMethodsOf: aTargetClass	| aSTypeClassInfo |	aSTypeClassInfo := (typeInfo classAt: aTargetClass).	^ (self classAt: aTargetClass) allMethods collect: [ :method | | summary methodTypeInfo |		summary := SLSummaryExecutionMethod on: method.		methodTypeInfo := (method isClassSide ifTrue: [ aSTypeClassInfo classMethodTypes ]		ifFalse: [ aSTypeClassInfo methodTypes ]) at: method selector ifAbsent: [nil].		methodTypeInfo ifNotNil: [ summary updateTypeInfoWith: methodTypeInfo ] ]! !!SLProfilerCoverage methodsFor: 'accessing'!typeInfo	^ typeInfo! !!SLProfilerCoverage methodsFor: 'accessing'!typeInfo: anObject	typeInfo := anObject! !!SLProfilerCoverage methodsFor: 'updating'!updateClass: aClassCoverage	self packages do: [ :pack | 		pack classes 			at: aClassCoverage className			ifPresent: [ :val | aClassCoverage localMethods do: [ :meth | meth classSpy: val ] .				aClassCoverage metaclassSpy localMethods do: [ :meth | meth classSpy: val metaclassSpy ] .				val methods: aClassCoverage localMethods.				val metaclassSpy methods: aClassCoverage metaclassSpy localMethods.				pack classes at: aClassCoverage className put: val ]		]! !!SSTypeCollector class methodsFor: 'hooks'!profile: aBlock onPackagesMatching: regex	^ (self profile: aBlock inPackagesMatching: regex) "asTypeInfo".! !!SSTypeCollector class methodsFor: 'hooks'!spyClassForPackage	 ^ SSTypeCollectorPackage! !!SSTypeCollector class methodsFor: 'hooks'!typeNameOf: anObject	^ anObject name! !!SSTypeCollector methodsFor: 'initialization'!addScalar: anObject  | value |  value := scalars at: (self nameOf: anObject class) ifAbsentPut: [ Set new ].  value add: anObject.	anObject isCollection ifTrue: [ [ value add: anObject class new ] on: Error do: [  ] ]! !!SSTypeCollector methodsFor: 'initialization'!initialize	super initialize.	scalars := Dictionary new! !!SSTypeCollector methodsFor: 'initialization'!isScalar: anObject  ((self nameOf: anObject class) includesAll: 'BlockClosure') ifTrue: [ ^true ].  self allClassesAsDictionary at: (self nameOf: anObject class) asSymbol ifAbsent: [ ^true ].  ^false! !!SSTypeCollector methodsFor: 'initialization'!scalars	^ scalars.! !!SpyLite methodsFor: 'tests'!nameOf: anObject 		^ (anObject isClass				ifTrue: [ anObject name ]				ifFalse: [ anObject class name ])! !"SpyLite"!!SLCounter methodsFor: 'as yet unclassified'!anAssignment	| a |	a := 3.	^ a! !!SLCounter methodsFor: 'accessing'!main	^ self one! !!SLCounter methodsFor: 'as yet unclassified'!methMix	| aBoolean number |	aBoolean := 2 == 3.	aBoolean		ifTrue: [ number := 3 ]		ifFalse: [ number := 5 ].	number := number + 1.	^ number! !!SLCounter methodsFor: 'as yet unclassified'!methWithArguments: aList	| selectedNumbers |	selectedNumbers := OrderedCollection new.	aList detect: [ :aNum | aNum odd ]	ifFound: [ :aNum | 		aNum > 10 ifTrue: [ 			selectedNumbers add: aNum		] ifFalse: [ 			selectedNumbers add: aNum * 3		]	] ifNone: [  ].	^ selectedNumbers ! !!SLCounter methodsFor: 'as yet unclassified'!methWithComposeBlocks	| list selectedNumbers |	selectedNumbers := OrderedCollection new.	list := { 1. 4. 6. 7. 8. 15. 17. 16 }.	list select: [ :aNum | aNum odd ]	thenDo: [ :aNum | 		aNum > 10 ifTrue: [ 			selectedNumbers add: aNum		] ].	^ selectedNumbers ! !!SLCounter methodsFor: 'as yet unclassified'!methWithCondition	^ 2 = 1		ifTrue: [ 3 ]		ifFalse: [ 4 ]! !!SLCounter methodsFor: 'accessing structure variables'!one	^ 1.! !"SpyLite-Scenario"!!SLProfilerCoverageTest methodsFor: 'as yet unclassified'!asserMethodCoverage: profiler toNoExecutedMethods: aNumber	self assert: profiler methodCoverage closeTo: ((100 * aNumber / profiler allMethods size) asFloat round: 2)! !!SLProfilerCoverageTest methodsFor: 'asserting'!assert: aObject class: aClass	self assert: aObject class name equals: aClass name ! !!SLProfilerCoverageTest methodsFor: 'as yet unclassified'!assertMethodCoverageOf: profiler on: symbol equals: number	| dictMethodCoverage |	dictMethodCoverage := profiler methodCoverage1.	self		assert: (dictMethodCoverage at: symbol)		closeTo: number! !!SLProfilerCoverageTest methodsFor: 'asserting'!assertNoExecutedMethods: profiler equals: aNumber	self assert: profiler numberOfExecutedMethods equals: aNumber! !!SLProfilerCoverageTest methodsFor: 'asserting'!assertNumExecutedMethodsOf: profiler on: symbol equals: number	| dict |	dict := profiler calculateExecutedMethodsByClass.	self assert: (dict at: symbol) equals: number! !!SLProfilerCoverageTest methodsFor: 'asserting'!assertNumExecutedStatementsOf: profiler on: symbol equals: number	| dict |	dict := profiler calculateExecutedStatementsByClass.	self assert: (dict at: symbol) equals: number! !!SLProfilerCoverageTest methodsFor: 'as yet unclassified'!assertStatementCoverageOf: profiler on: symbol equals: number	| dictMethodCoverage |	dictMethodCoverage := profiler statementCoverage1.	self		assert: (dictMethodCoverage at: symbol)		equals: number! !!SLProfilerCoverageTest methodsFor: 'api'!clean: aProfiler	aProfiler uninstall.	"SLProfilerCoverage resetInstance."! !!SLProfilerCoverageTest methodsFor: 'tests'!nameOf: aClass 		^ aClass name! !!SLProfilerCoverageTest methodsFor: 'running'!tearDown"	S2Lock value: false.	S2Context value: nil.	S2Profiler remove."	super tearDown! !!SLProfilerCoverageTest methodsFor: 'tests'!testMethodCoverage  | profiler aClassName |  profiler := self aSLProfilerCoverage profile: [ SLCounter new ] inPackagesMatching: 'SpyLite-Scen*'.	aClassName := self nameOf: SLCounter.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 0.  self assertMethodCoverageOf: profiler on: aClassName equals: 0.  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new one ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 1.  self assertMethodCoverageOf: profiler on: aClassName equals: ((1 / 7) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new anAssignment ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 1.  self assertMethodCoverageOf: profiler on: aClassName equals: ((1 / 7) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new main ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 2.  self assertMethodCoverageOf: profiler on: aClassName equals: ((2 / 7) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithCondition ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 1.  self assertMethodCoverageOf: profiler on: aClassName equals: ((1 / 7) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methMix ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 1.  self assertMethodCoverageOf: profiler on: aClassName equals: ((1 / 7) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithComposeBlocks ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 1.  self assertMethodCoverageOf: profiler on: aClassName equals: ((1 / 7) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithArguments: #(2 6 8 13 5 9 11 13) ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedMethodsOf: profiler on: aClassName equals: 1.  self assertMethodCoverageOf: profiler on: aClassName equals: ((1 / 7) asFloat * 100 round: 3).  self clean: profiler! !!SLProfilerCoverageTest methodsFor: 'tests'!testProfileOnPackagesMatching  | profiler |  profiler := self aSLProfilerCoverage profile: [ SLCounter new ] inPackagesMatching: 'SpyLite-Scen*'.  self assert: profiler class: self aSLProfilerCoverage.  self assertMethodCoverageOf: profiler on: (self nameOf: SLCounter) equals: 0.  self assert: profiler statementCoverage1 isEmpty.  self clean: profiler! !!SLProfilerCoverageTest methodsFor: 'tests'!testStatementCoverage  | profiler aClassName |  profiler := self aSLProfilerCoverage profile: [ SLCounter new ] inPackagesMatching: 'SpyLite-Scen*'.	aClassName := self nameOf: SLCounter.  self assert: profiler numberOfAllStatements equals: 27.  self assert: profiler statementCoverage1 isEmpty.  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new one ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 1.  self assertStatementCoverageOf: profiler on: aClassName equals: ((1 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new anAssignment ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 2.  self assertStatementCoverageOf: profiler on: aClassName equals: ((2 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new main ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 2.  self assertStatementCoverageOf: profiler on: aClassName equals: ((2 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithCondition ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 2.  self assertStatementCoverageOf: profiler on: aClassName equals: ((2 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methMix ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 5.  self assertStatementCoverageOf: profiler on: aClassName equals: ((5 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithComposeBlocks ] inPackagesMatching: 'SpyLite-Scen*'.  self assert: profiler numberOfExecutedStatements equals: 7.  self assertStatementCoverageOf: profiler on: aClassName equals: ((7 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithArguments: #(2 6 8 13 5 9 11 13) ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 6.  self assertStatementCoverageOf: profiler on: aClassName equals: ((6 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithArguments: #(1 4 6 7) ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 6.  self assertStatementCoverageOf: profiler on: aClassName equals: ((6 / 27) asFloat * 100 round: 3).  self clean: profiler.  profiler := self aSLProfilerCoverage profile: [ SLCounter new methWithArguments: #(4 6 12) ] inPackagesMatching: 'SpyLite-Scen*'.  self assertNumExecutedStatementsOf: profiler on: aClassName equals: 4.  self assertStatementCoverageOf: profiler on: aClassName equals: ((4 / 27) asFloat * 100 round: 3).  self clean: profiler! !!SSTypeCollectorMethodTest methodsFor: 'tests'!nameOf: aClass 	^ aClass name! !!SSTypeCollectorMethodTest methodsFor: 'running'!setUp 	typeCollectorMethod := SSTypeCollectorMethod new! !!SSTypeCollectorMethodTest methodsFor: 'tests'!testSelectLiteralsOf  | source dictLiterals |  source := 'test1 	^ 1	'.  typeCollectorMethod selectLiteralsOf: source.  dictLiterals := typeCollectorMethod dictLiterals.  self assertCollection: dictLiterals keys hasSameElements: (Array with: (self nameOf: SmallInteger)).  self assertCollection: (dictLiterals values flatCollect: [:s |  s ]) hasSameElements: #(1).  source := 'test2		|number string|		number := 2.		string := ''hello''.		number = 5 ifTrue: [string := ''world''].'.  typeCollectorMethod selectLiteralsOf: source.  dictLiterals := typeCollectorMethod dictLiterals.  self assertCollection: dictLiterals keys hasSameElements: (Array with: (self nameOf: SmallInteger) with: (self nameOf: ByteString)).  self assertCollection: (dictLiterals values flatCollect: [:val |  val ]) hasSameElements: #(2 5 'hello' 'world')! !!SSTypeCollectorMethodTest methodsFor: 'tests'!testSelectLiteralsOfMethodsWithoutLiterals	| source  |	source := 'test1 	^ name	'.	typeCollectorMethod selectLiteralsOf: source.	self		assert: typeCollectorMethod dictLiterals associations isEmpty.	source := 'test2		name = nickname ifTrue: [id := age].'.	typeCollectorMethod selectLiteralsOf: source.	self		assert: typeCollectorMethod dictLiterals associations isEmpty! !"SpyLite-Tests"!!TypeCollector commentStamp: '' prior: 0!I collect and assemble the types sent to instance variables for a certain class (I use the InterfaceExtractor for that), and use them to create and return TypingResults.Instance Variables:	assignments	<Object>	description of assignments	instVarOffset	<Object>	description of instVarOffset	instVars	<(Palette of: (ExceptionSet | GenericException | SequenceableCollection | Signal)) | (SequenceableCollection of: (ExceptionSet | GenericException | SequenceableCollection | Signal))>	description of instVars	sends	<Object>	description of sends	theClass	<ClassDescription>	description of theClass			Our type-reconstruction algorithm can be decomposed into three phases:	1. interface type extraction. This phase reconstructs the types according to the messages that are being sent to the variable in the class where it is defined. This is done in two steps: first of all the set of messages sent to the variable is collected. Secondly we look through the system and find all types that understand this set of selectors. The output of this phase are the interface types.	2. assignment type extraction. This phase reconstructs the types by looking at assignments made to the variable in the class where it is defined. It collects all right-hand sides of assign- ment expressions involving the variable, and applies a series of heuristics to find the type results of these expressions. These are then collected in the assignment types.	3. merging. This phase takes the interface types and the assignment types as input, and merges them into the final type results for the variable.!!PharoTypeCollector commentStamp: '' prior: 0!(TypeCollector typeTmpsIn: (ASampleClass>>#return) ofClass: ASampleClass)!!TypeMerger commentStamp: '' prior: 0!1. assignment type subtype of interface type: In this scenario, an interface type is reconstructed, an abstract type for which several concrete (sub)types are plausible at runtime. The assign- ment type is found to be one of these types: it is a subtype of the interface type. In the left column of Figure 3 we see that the interface type will be Number, while the assignment type is SmallInteger, a subclass of Number. Note that this scenario is the most frequently occurring.		2. interface type subtype of assignment type: It can occur that the assignment type does not lie within the hierarchy defined by the interface type, but is a supertype of that hierarchy. In that case the concrete assignment type is more general than the abstract interface type. This is illustrated in the middle pane of Figure 3: the extracted type (which would be Date, since it implements a method weekday) is subtype of the assignment type (Magnitude).	3. assignment and interface type unrelated: Another possibil- ity is related to the previous one, but here the assignment type and the interface type are completely unrelated. This is a tech- nique sometimes used in dynamic languages. For example, one can hold a collection of objects and, when there is only one object in the collection, decide to directly hold that object in- stead of a collection with only one element. When doing type reconstruction this can easily lead to two different types being extracted: one a collection type, and a second, completely dif- ferent type. The right side of Figure 3 shows how an assignment type could be SmallInteger, while the interface type would be Collection, two completely separated types.	4. assignment type same as the interface type: Both can be the same, in which case there is no need to merge.When merging the sets of interface and assignment types, these cases need to be taken into account. Number of different merging approaches:• 	with the AbstractMerger the result of the first case in the exam- ple will be the interface type, since it is the most abstract.•	the ConcreteMerger will favor the assignment type for the first case in the example. The motivation for this choice is that it is very likely that the concrete type will indeed be the one as- signed, given that it corresponds to the active type. However, this is a heuristic, and some valid types might be omitted be- cause of it.	• the AssignmentsFirstMerger is a refinement of the ConcreteMerger and therefore also favors the assignment types over the interface types. However when there are assignment types and all interface types are subtypes of the assignment types, the result will be the assignment types (and the found interface types are not used). It only considers the interface types when there is no assignment information, or when there are interface type that are not related to the assignment types.!!TypingResultKeeper commentStamp: '' prior: 0!The scientific documentation of RoelTyper can be found in the article 	Fast Type Reconstruction for Dynamically Typed Programming LanguagesI'm keeping the type information. I collaborate with a TypeCollector.TypingResultKeeper forImage forClasses: { Array . Point }TypingResultKeeper calculateTypesForClass: PointTypingResultKeeper forImageExpanded!!InstvarInterfaceExtractor commentStamp: '' prior: 0!I am responsible for extracting the messages sent to an instance variable and the assignments done to an instance variable. I am supposed to work together with a TypeCollector.Instance Variables:	collector	<TypeCollector>	description of collector	copied	<Array>	description of copied	initialStack	<Collection | KeyBindingsList | MethodFilterAnd | MethodFilterOr>	description of initialStack	input	<InstructionStream>	description of input	method	<CompiledInitializer | CompiledMethod>	description of method	saveStacks	<Dictionary>	description of saveStacks	stack	<(OrderedCollection of: Object)>	description of stack!!Collection methodsFor: '*RoelTyper-testing'!sameElements: aCollection	^(self allSatisfy: [:each | aCollection includes: each])		and: [aCollection allSatisfy: [:each | self includes: each]]! !!AbstractType class methodsFor: 'instance creation'!forInstvar: iv inClass: aClass	^ self new		ivarName: iv;		ivarClass: aClass;		yourself! !!AbstractType methodsFor: 'private'!conflictingAssignmentsWith: anExtractedType	| conflictingAssignments |	conflictingAssignments := anExtractedType assignments		reject: [ :assignment | self types includes: assignment ].	^ conflictingAssignments! !!AbstractType methodsFor: 'private'!conflictingSelectorsWith: anExtractedType	| conflictingSelectors |	conflictingSelectors := Dictionary new.	anExtractedType interface		do:			[:selector | 			self types				do:					[:aType | 					(aType canUnderstand: selector)						ifFalse:							[(conflictingSelectors								at: selector								ifAbsentPut: [OrderedCollection new]) add: aType]]].	^conflictingSelectors! !!AbstractType methodsFor: 'initialization'!initialize	"Do nothing, but give subclasses the chance to override."	! !!AbstractType methodsFor: 'testing'!is: aClass	^self isSingularType and: [self types first = aClass]! !!AbstractType methodsFor: 'testing'!isExtractedResult	^self subclassResponsibility! !!AbstractType methodsFor: 'testing'!isObjectType	^self isSingularType and: [self types includes: Object]! !!AbstractType methodsFor: 'testing'!isSingularType	^self types size = 1! !!AbstractType methodsFor: 'accessing'!ivarClass	^ivarClass! !!AbstractType methodsFor: 'accessing'!ivarClass: aClass	ivarClass := aClass.	! !!AbstractType methodsFor: 'accessing'!ivarName	^ivarName! !!AbstractType methodsFor: 'accessing'!ivarName: aSymbol	ivarName := aSymbol! !!AbstractType methodsFor: 'private'!liveExtractType	^self! !!AbstractType methodsFor: 'printing'!printOn: aStream	self printTypesOn: aStream! !!AbstractType methodsFor: 'printing'!printTypesOn: aStream	self types		do: [ :each | aStream print: each ]		separatedBy: [ aStream nextPutAll: ' , ' ]! !!AbstractType methodsFor: 'accessing'!types	^self subclassResponsibility! !!ExtractedType class methodsFor: 'instance creation'!forInstvar: iv inClass: aClass interface: selectorCollection assignments: classCollection	^(self		forInstvar: iv		inClass: aClass)		interface: selectorCollection		assignments: classCollection! !!ExtractedType class methodsFor: 'private'!mergerClass	"Still experimenting with different mergers. So for the moment I uncomment things to experiment with."		"^ConcreteMerger"		"^AbstractMerger"	^AssignmentsFirstMerger! !!ExtractedType methodsFor: 'private-accessing'!addAssignment: anObject	(self assignments includes: anObject)		ifFalse: [self assignments add: anObject]! !!ExtractedType methodsFor: 'private-accessing'!addLinkedExtractedType: anExtractedType	 links add: anExtractedType liveExtractType! !!ExtractedType methodsFor: 'private-accessing'!addReverseLinkedExtractedType: anExtractedType	links add: anExtractedType liveExtractType.	anExtractedType liveExtractType  addLinkedExtractedType: self! !!ExtractedType methodsFor: 'private-accessing'!addSend: anObject	self interface add: anObject! !!ExtractedType methodsFor: 'private-accessing'!assignments	^assignments! !!ExtractedType methodsFor: 'private-accessing'!basicExtractedTypes	^extractedTypes! !!ExtractedType methodsFor: 'private'!cleanedAssignments	| assigns |	assigns := self assignments copy.	((assigns includes: True) or: [assigns includes: False])		ifTrue:			[assigns				remove: True ifAbsent: [];				remove: False ifAbsent: [];				add: Boolean].	^assigns! !!ExtractedType methodsFor: 'accessing'!contents	^self types! !!ExtractedType methodsFor: 'private'!flattenLinks	[links isEmpty] 		whileFalse: [|link|			link :=  links anyOne.			links remove: link.			link flattenLinks.			link interface				do: [ :sel | self addSend: sel ].			link assignments				do: [ :assign | self addAssignment: assign ]].	! !!ExtractedType methodsFor: 'private'!foldInterfaceTypes: interfaceClasses withAssignmentTypes: assignmentClasses	| tmp | 	assignmentClasses remove: UndefinedObject ifAbsent: [].	tmp:=interfaceClasses.	(assignmentClasses isEmpty and: [		((interface includes: #value) 		or: [interface includes: #value:]) and: [interfaceClasses includes: BlockClosure]]) 			ifTrue: [ tmp:=OrderedCollection with: BlockClosure]			ifFalse: [ tmp:=interfaceClasses].	^self class mergerClass		interfaceTypes: tmp		assignmentTypes: assignmentClasses! !!ExtractedType methodsFor: 'testing'!hasEmptyAssignments	^self assignments isEmpty! !!ExtractedType methodsFor: 'testing'!hasEmptyInterface	^self interface isEmpty! !!ExtractedType methodsFor: 'initialization'!initialize	super initialize.	links := Set new.	self		interface: IdentitySet new		assignments: OrderedCollection new.! !!ExtractedType methodsFor: 'private-accessing'!interface	^interface! !!ExtractedType methodsFor: 'private-accessing'!interface: selectorCollection assignments: classCollection	interface := selectorCollection.	assignments := classCollection! !!ExtractedType methodsFor: 'testing'!isEmpty	^self hasEmptyAssignments and: [self hasEmptyInterface]! !!ExtractedType methodsFor: 'testing'!isExtractedResult	^true! !!ExtractedType methodsFor: 'private-accessing'!links	^links! !!ExtractedType methodsFor: 'private'!mergeTypes	self flattenLinks.	^self		foldInterfaceTypes: (self rootsUnderstanding: self interface)		withAssignmentTypes: self cleanedAssignments! !!ExtractedType methodsFor: 'printing'!printInterfaceAndAssigments	| s |	s := WriteStream on: String new.	self printInterfaceAndAssigmentsOn: s.	^ s contents! !!ExtractedType methodsFor: 'printing'!printInterfaceAndAssigmentsOn: aStream	aStream nextPutAll: 'Sends: {'.	self interface		do: [ :symbol | aStream print: symbol ]		separatedBy: [ aStream space ].	aStream		nextPutAll: '}';		cr;		nextPutAll: 'Assignments: {'.	self assignments		do: [ :symbol | aStream print: symbol ]		separatedBy: [ aStream space ].	aStream		nextPutAll: '}';		cr! !!ExtractedType methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'ExtractedType: '.	self basicExtractedTypes		ifNil: [self printInterfaceAndAssigmentsOn: aStream]		ifNotNil: [self printTypesOn: aStream]! !!ExtractedType methodsFor: 'private'!rootsUnderstanding: selectors	"When the set of selectors is not empty, answer a set of the highest possible classes in the system that implement all the selectors. When the set of selectors is empty, return the empty set."	| initialClasses nextClasses traverseStack next |	selectors isEmpty		ifTrue: [ ^ OrderedCollection new ].	nextClasses := OrderedCollection with: Object.	traverseStack := OrderedCollection new: 10000.	selectors		do: [ :selector | 			initialClasses := nextClasses.			nextClasses := OrderedCollection new.			initialClasses				do: [ :initialClass | 					"inline canUnderstand: for performance"					| cl |					cl := initialClass.					[ cl == nil or: [ cl methodDict pointsTo: selector ] ]						whileFalse: [ cl := cl superclass ].					cl isNil						ifFalse: [ nextClasses addLast: initialClass ]						ifTrue: [ | size |							traverseStack reset.							traverseStack addLast: initialClass.							size := 1.							"(traverseStack isEmpty) removed for performance"							[ size = 0 ]								whileFalse: [ "(traverseStack removeFirst) removed for performance"									next := traverseStack unsafeRemoveFirst.									size := size - 1.									next										subclassesDo: [ :subcl | 											"(subcl includesSelector: selector) removed for performance"											(subcl methodDict pointsTo: selector)												ifTrue: [ nextClasses addLast: subcl ]												ifFalse: [ traverseStack addLast: subcl.													size := size + 1 ] ] ] ] ] ].	^ nextClasses! !!ExtractedType methodsFor: 'accessing'!types	^extractedTypes		ifNil: [extractedTypes := self mergeTypes]		ifNotNil: [extractedTypes]! !!ExtractedTypeForTmp class methodsFor: 'instance creation'!forTmpOffset: offset ofCompiledMethod: aCompiledMethod inClass: aClass	^ self new 		tempOffset: offset;		ivarClass: aClass;		compiledMethod: aCompiledMethod;		yourself! !!ExtractedTypeForTmp methodsFor: 'accessing'!asBlockArgInTypeCollector: aTypeCollector	aTypeCollector transformAsBlockArg: self ! !!ExtractedTypeForTmp methodsFor: 'accessing'!compiledMethod	^ compiledMethod! !!ExtractedTypeForTmp methodsFor: 'accessing'!compiledMethod: anObject	compiledMethod := anObject! !!ExtractedTypeForTmp methodsFor: 'accessing'!tempOffset	^ivarName 	! !!ExtractedTypeForTmp methodsFor: 'accessing'!tempOffset: anOffset	ivarName := anOffset! !!ExtractedTypeForBlockArg class methodsFor: 'instance creation'!forOffset: offset ofCompiledMethod: aCompiledMethod inClass: aClass	^self new		tempOffset: offset;		ivarClass: aClass;		compiledMethod: aCompiledMethod;		yourself! !!ExtractedTypeForBlockArg methodsFor: 'accessing'!asBlockArgInTypeCollector: aTypeCollector	self newLive! !!ExtractedTypeForBlockArg methodsFor: 'accessing'!compiledMethod: aCompiledMethod	compiledMethod := aCompiledMethod! !!ExtractedTypeForBlockArg methodsFor: 'system primitives'!doesNotUnderstand: aMessage	^aMessage sendTo: self liveExtractType ! !!ExtractedTypeForBlockArg methodsFor: 'initialization'!initialize	super initialize.	lives := OrderedCollection with: (ExtractedTypeForTmp new)! !!ExtractedTypeForBlockArg methodsFor: 'private-accessing'!interface	^(lives inject: Set new into: [:ord :et | ord addAll: (et interface); yourself ]) asOrderedCollection! !!ExtractedTypeForBlockArg methodsFor: 'private'!liveExtractType	^lives last! !!ExtractedTypeForBlockArg methodsFor: 'instance creation'!newLive	^lives addLast: (ExtractedTypeForTmp new)! !!ExtractedTypeForBlockArg methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: 'Block arg';		cr;		cr.	lives		doWithIndex: [ :et :index | 			aStream				nextPutAll: 'Activation ';				print: index;				nextPutAll: ': '.			et printOn: aStream.			aStream cr ]! !!ExtractedTypeForBlockArg methodsFor: 'accessing'!tempOffset: anOffset	ivarName := anOffset! !!ExtractedTypeForBlockArg methodsFor: 'accessing'!types	|types|	types := IdentitySet new.	lives do: [:et | types addAll: (et mergeTypes)].	^types asOrderedCollection! !!PharoTypeCollector methodsFor: 'heuristics'!assignmentTypeOf: val	val isBehavior ifTrue: [^val].	val isVariableBinding		ifTrue:			[val key == #instcreation				ifTrue: [^val value]				ifFalse: [^val value class]].	^nil! !!PharoTypeCollector methodsFor: 'heuristics'!languageSpecificPushSendOf: selector to: rec args: args	(#(#// #quo: #rem: #\\ #ceiling #floor #rounded #roundTo: #truncated #truncateTo: #/ #+ #- #* #abs #negated #reciprocal)		includes: selector)		ifTrue:			[^self				tryUsing: rec				for: selector				ifNotUse: Number].	(selector = #yourself) ifTrue: [^rec].	(rec = #self and: [(theClass methodDict includesKey: selector)]) ifTrue: [^#return->selector].	^#computed! !!PharoTypeCollector methodsFor: 'private'!newExtractor	^PharoInstvarInterfaceExtractor new! !!TypeCollector class methodsFor: 'instance creation'!collectorAfterTypeInstvarsOfClass: aClass	"self typeInstvarsOfClass: Point"	^self new typeInstvarsOfClass: aClass; yourself! !!TypeCollector class methodsFor: 'instance creation'!new	"Override new to return either a VWTypeCollector or a SqueakTypeCollector"	^self newForPlatform! !!TypeCollector class methodsFor: 'instance creation'!newForPlatform	"Return either a VWTypeCollector or a SqueakTypeCollector, depending on the platform used."	^PharoTypeCollector basicNew! !!TypeCollector class methodsFor: 'instance creation'!onClass: aClass	^self new onClass: aClass! !!TypeCollector class methodsFor: 'instance creation'!typeInstvar: var ofClass: aClass	"self typeInstvar: #x ofClass: Point "	^(self new typeInstvarsOfClass: aClass) at: var! !!TypeCollector class methodsFor: 'instance creation'!typeInstvar: var ofClassWithLookup: aClass 	"self typeInstvar: #origin ofClassWithLookup: Quadrangle"	| theClass |	theClass := aClass.	[theClass isNil not		and: [theClass instVarNames includes: var]]		whileFalse: [theClass := theClass superclass].	theClass isNil		ifTrue: [^ ExtractedType new].	^ self typeInstvar: var ofClass: theClass! !!TypeCollector class methodsFor: 'instance creation'!typeInstvarsOfClass: aClass	"self typeInstvarsOfClass: Point"	^self new typeInstvarsOfClass: aClass! !!TypeCollector class methodsFor: 'instance creation'!typeTmpsIn: aCompiledMethod ofClass: aClass	"self typeInstvarsOfClass: Point"	^self new typeTmpsIn: aCompiledMethod ofClass: aClass! !!TypeCollector class methodsFor: 'instance creation'!versionString	"Take the removal of the standard version method on Smalltalk into account for Squeak :-( "	^(Smalltalk		at: #SystemVersion		ifAbsent: [^Smalltalk version]) current version! !!TypeCollector methodsFor: 'accessing'!absoluteIndexForVar: iVar	"Note: works for Squeak and VisualWorks. If it would be only for VW, you could just use instVarIndexFor: instead."	^instVars indexOf: iVar! !!TypeCollector methodsFor: 'adding'!addAssignment: value to: index	self		withTranslatedIndex: index		do: [ :i | (self typingResults at: i) addAssignment: value ]! !!TypeCollector methodsFor: 'adding'!addAssignment: val toReturnOf: aSelector  	| eT |	eT := self extractedTypeForReturnInMethod: (theClass >> aSelector).	eT addAssignment: val.! !!TypeCollector methodsFor: 'adding'!addAssignment: value toTmp: index 	((localTypingResults at: currentExtractedMethod) at: index + 1) addAssignment: value! !!TypeCollector methodsFor: 'adding'!addAssignment: value toTmp: index in: aCompiledMethod	((localTypingResults at: aCompiledMethod) at: index + 1) addAssignment: value! !!TypeCollector methodsFor: 'adding'!addAssignmentForReturn: val 	| eT |	eT := self extractedTypeForReturnInMethod: currentExtractedMethod.	val isInteger 		ifTrue: 			[ self 				withTranslatedIndex: val				do: [ :idx | eT addReverseLinkedExtractedType: (typingResults at: idx) ] ]		ifFalse: 			[ (val isVariableBinding and: [ val key = #temp ]) 				ifTrue: 					[ eT addReverseLinkedExtractedType: ((localTypingResults at: currentExtractedMethod) at: val value + 1) ]				ifFalse: 					[ (val isVariableBinding and: [ val key = #return ]) 						ifTrue: 							[ eT addReverseLinkedExtractedType: (self extractedTypeForReturnInMethod: theClass >> val value) ]						ifFalse: 							[  (val isVariableBinding and: [ val key = #blockArg ])							ifTrue: [							]						ifFalse: [(self assignmentTypeOf: val) ifNotNil: [ :result | eT addAssignment: result ] ] ] ]]! !!TypeCollector methodsFor: 'adding'!addAssignmentForReturnSelf	(self extractedTypeForReturnInMethod: currentExtractedMethod) addAssignment: theClass! !!TypeCollector methodsFor: 'adding'!addSend: selector onReturnOfSelfMethod: aSelfSelector	"Add a range check to filter out sends to instvars defined in superclasses, etc."	(self extractedTypeForReturnInMethod: theClass >> aSelfSelector) addSend: selector! !!TypeCollector methodsFor: 'adding'!addSend: selector to: index	"Add a range check to filter out sends to instvars defined in superclasses, etc."	self		withTranslatedIndex: index		do: [:i | (self typingResults at: i) addSend: selector]! !!TypeCollector methodsFor: 'adding'!addSend: selector toTmp: index 	"Add a range check to filter out sends to instvars defined in superclasses, etc."	((localTypingResults at: currentExtractedMethod ) at: index + 1) addSend: selector! !!TypeCollector methodsFor: 'accessing'!allInstVarTypes	self typingResults do: [ :each | each types ]	! !!TypeCollector methodsFor: 'accessing'!allTmpTypes	localTypingResults valuesDo: [ :array | array do: [ :et | et types]]! !!TypeCollector methodsFor: 'accessing'!allTypes	self typingResults do: [ :each | each types ].	localTypingResults valuesDo: [ :array | array do: [ :et | et types ]]! !!TypeCollector methodsFor: 'heuristics'!assignmentTypeOf: val	^self subclassResponsibility! !!TypeCollector methodsFor: 'accessing'!assignmentsTo: instVarName	^ (self typingResultsFor: instVarName) flattenLinks; assignments! !!TypeCollector methodsFor: 'accessing'!currentExtractedMethod	^ currentExtractedMethod! !!TypeCollector methodsFor: 'accessing'!currentExtractedMethod: anObject	currentExtractedMethod := anObject.	localTypingResults at: anObject put: ((1 to: anObject numTemps + 1) collect: [:each | ExtractedTypeForTmp 					forTmpOffset: each ofCompiledMethod:  anObject inClass: anObject methodClass  ]) asArray ! !!TypeCollector methodsFor: 'adding'!extractedTypeForReturnInMethod: aCompiledMethod	^(localTypingResults at: aCompiledMethod) last! !!TypeCollector methodsFor: 'heuristics'!handleAssignment: val for: index 	val isInteger 		ifTrue: 			[ self 				withTranslatedIndex: val				do: 					[ :idx | 					(typingResults at: index + 1) addReverseLinkedExtractedType: (typingResults at: idx) ] ]		ifFalse: 			[ (val isVariableBinding and: [ val key = #temp ]) 				ifTrue: 					[ (typingResults at: index + 1) addReverseLinkedExtractedType: ((localTypingResults at: currentExtractedMethod) at: val value + 1) ]				ifFalse: 					[ (val isVariableBinding and: [ val key = #return ]) 						ifTrue: 							[ (typingResults at: index + 1) addReverseLinkedExtractedType: (self extractedTypeForReturnInMethod: theClass >> val value) ]						ifFalse: 							[ (val isVariableBinding and: [ val key = #blockArg ]) 							ifFalse: [(self assignmentTypeOf: val) ifNotNil: 								[ :result | 								self 									addAssignment: result									to: index ] ] ] ]]! !!TypeCollector methodsFor: 'heuristics'!handleAssignment: val forTmp: index 	"Cannot use ifNotNil: with argument in Squeak, so use a temporary instead."		(localTypingResults at: currentExtractedMethod) at: index + 1 ifAbsent: [		self flag: 'bug here. For now just do nothing. uncomment the halt to run the example'.		"this case seems to be broken for now. "		"Try for example: 			TypeCollector typeInstvar:  #lastStepMessage ofClassWithLookup:  WorldState "		"self halt."		^ self.		].		val isInteger 		ifTrue: 			[ self 				withTranslatedIndex: val				do: 					[ :idx | 					((localTypingResults at: currentExtractedMethod) at: index + 1) addReverseLinkedExtractedType: (typingResults at: idx) ] ]		ifFalse: 			[ (val isVariableBinding and: [ val key = #temp ]) 				ifTrue: 					[ ((localTypingResults at: currentExtractedMethod ) at: index + 1) addReverseLinkedExtractedType: ((localTypingResults at: currentExtractedMethod) at: val value + 1) ]				ifFalse: 					[ (val isVariableBinding and: [ val key = #return ]) 						ifTrue: 							[ ((localTypingResults at: currentExtractedMethod ) at: index + 1) addReverseLinkedExtractedType: (self extractedTypeForReturnInMethod: theClass >> val value) ]						ifFalse: [							 (val isVariableBinding and: [ val key = #blockArg ]) 							ifFalse: [(self assignmentTypeOf: val) ifNotNil: 						[ :result | 						self 							addAssignment: result							toTmp: index ] ] ]]]! !!TypeCollector methodsFor: 'heuristics'!handleAssignment: val forTmp: index in: aCompiledMethod	"Cannot use ifNotNil: with argument in Squeak, so use a temporary instead."	val isInteger 		ifTrue: 			[ self 				withTranslatedIndex: val				do: 					[ :idx | 					((localTypingResults at: aCompiledMethod) at: index + 1) addReverseLinkedExtractedType: (typingResults at: idx).					 ] ]		ifFalse: 			[ (val isVariableBinding and: [ val key = #temp ]) 				ifTrue: 					[ ((localTypingResults at: aCompiledMethod ) at: index + 1) addReverseLinkedExtractedType: ((localTypingResults at: currentExtractedMethod) at: val value + 1).					 ]				ifFalse: 					[ (val isVariableBinding and: [ val key = #return ]) 						ifTrue: 							[ ((localTypingResults at: aCompiledMethod ) at: index + 1) addReverseLinkedExtractedType: (self extractedTypeForReturnInMethod: theClass >> val value) ]						ifFalse: [							 (val isVariableBinding and: [ val key = #blockArg ]) 							ifFalse: [(self assignmentTypeOf: val) ifNotNil: 						[ :result | 						self 							addAssignment: result							toTmp: index							in: aCompiledMethod ] ] ]]]! !!TypeCollector methodsFor: 'heuristics'!languageSpecificPushSendOf: selector to: rec args: args	^#computed! !!TypeCollector methodsFor: 'private'!lastAssignmentForIndex: anIndex	| assignments |	assignments := (self typingResults at: anIndex) assignments.	^assignments isEmpty		ifTrue: [nil]		ifFalse: [assignments last]! !!TypeCollector methodsFor: 'private'!lastAssignmentForTmpIndex: anIndex 	| assignments |	assignments := ((localTypingResults at: currentExtractedMethod) at: anIndex) assignments.	^ assignments isEmpty 		ifTrue: [ nil ]		ifFalse: [ assignments last ]! !!TypeCollector methodsFor: 'private'!newExtractor	"Return a new extractor class. This is typically Smalltalk dialect dependent, so subclasses have to override to choose the one they want."	^self subclassResponsibility! !!TypeCollector methodsFor: 'initialize-release'!onClass: aClass 	theClass := aClass.	instVars := aClass allInstVarNames collect: [ :e | e asSymbol].	typingResults := (instVars collect: 		[ :ivar | 		ExtractedType 			forInstvar: ivar			inClass: aClass ]) asArray.	localTypingResults := IdentityDictionary new.	theClass selectorsAndMethodsDo: [:sel :cm | 	localTypingResults 			at: cm			put: ((1 to: cm numTemps + 1) collect:  "the last one is for the method returned object"				[ :i | 				ExtractedTypeForTmp 					forTmpOffset: i ofCompiledMethod:  cm inClass: theClass ]) asArray]! !!TypeCollector methodsFor: 'accessing'!packagedResults	| results |	results := IdentityDictionary new.	instVars size - theClass instVarNames size + 1		to: instVars size		do:			[ :index | 			results				at: (instVars at: index)				put: (self typingResults at: index)].	localTypingResults keysAndValuesDo: [:cm :arr | | prefix prefixTmp|		prefix := '_',cm selector,'>>'.		prefixTmp := prefix, 'tmp'.		1 to: arr size - 1 do: [:i | results at: ( prefixTmp, i printString) put: (arr at: i)].		results at: (prefix, 'return') put: (arr last).		 ].	 	^results! !!TypeCollector methodsFor: 'accessing'!packagedResultsForCompiledMethod: aCompiledMethod	| results arr tmpNames numberOfTemporaryVariables |	results := IdentityDictionary new.	arr := (localTypingResults at: aCompiledMethod).	tmpNames := [aCompiledMethod methodNode tempNames] on: Error do: [aCompiledMethod tempNames].		"Note we are here voluntary excluding temporary variables that may be contained in a block contained in the compiled method. This has to be fixed somehow"	numberOfTemporaryVariables := (arr size - 1) min: tmpNames size.	1 to: numberOfTemporaryVariables do: [:i | results at: (tmpNames at: i) put: (arr at: i)].	results at: ('^') put: arr last.	 	^results! !!TypeCollector methodsFor: 'heuristics'!pushSendOf: selector to: rec args: args	"Needs to be optimized"	| index recValue |	rec == #self		ifTrue:			[			(index := instVars indexOf: selector) > 0 ifTrue: [^index - 1].			(selector last == $:				and:					[(index := instVars						indexOf:							(selector								copyFrom: 1								to: selector size - 1)) > 0])				ifTrue:					[self 						handleAssignment: args first						for: index - 1.					^#result->selector].			].	(#(#= #== #< #> #<= #>= #~= #notNil #xor:) includes: selector) ifTrue: [^Boolean].	"('is*' match: selector ) replaced for performance"	((selector at: 1 ifAbsent: [$j] ) = $i and: [(selector at: 2 ifAbsent: [$j] ) = $s and: [(selector at: 3 ifAbsent: [$n]) isLowercase not]]) ifTrue: [^Boolean].	(rec isVariableBinding		and:			[(recValue := rec value) isBehavior				and:					[(recValue class categoryForSelector: selector) == #'instance creation']])		ifTrue:			[^Association				key: #instcreation				value: recValue].	^self		languageSpecificPushSendOf: selector		to: rec		args: args! !!TypeCollector methodsFor: 'accessing'!sendsTo: instVarName	^ (self typingResultsFor: instVarName) interface! !!TypeCollector methodsFor: 'initialize-release'!theClass	^theClass! !!TypeCollector methodsFor: 'adding'!transformAsBlockArg: anExtractedTypeForTmp 	(localTypingResults at: anExtractedTypeForTmp compiledMethod) 		at: anExtractedTypeForTmp tempOffset		put: (ExtractedTypeForBlockArg 				forOffset: anExtractedTypeForTmp tempOffset				ofCompiledMethod: anExtractedTypeForTmp compiledMethod				inClass: anExtractedTypeForTmp ivarClass)! !!TypeCollector methodsFor: 'adding'!transformAsBlockArgTheTmpOffset: offset 	((localTypingResults at: currentExtractedMethod ) at: (offset + 1)) asBlockArgInTypeCollector: self! !!TypeCollector methodsFor: 'adding'!transformAsBlockArgTheTmpOffset: offset in: aCompiledMethod 	((localTypingResults at: aCompiledMethod ) at: (offset + 1)) asBlockArgInTypeCollector: self! !!TypeCollector methodsFor: 'private'!tryUsing: receiver for: selector ifNotUse: aClass	"If receiver has a type, and the selector is understood by that type, pass that type. If not, use aClass as type."	| cl |	cl := self assignmentTypeOf: receiver.	^(cl notNil and: [cl methodDict includesKey: selector])		ifTrue: [ cl ]		ifFalse: [ aClass ]! !!TypeCollector methodsFor: 'public-typing'!typeInstvarsOfClass: aClass	| extractor|	self onClass: aClass.	extractor := self newExtractor.		aClass selectorsAndMethodsDo:			[:sel :method |			currentExtractedMethod := method. 			extractor				extractInterfacesFrom: method				addTo: self].	^self packagedResults! !!TypeCollector methodsFor: 'public-typing'!typeTmpsIn: aCompiledMethod ofClass: aClass	| extractor|	self onClass: aClass.	extractor := self newExtractor.		aClass selectorsAndMethodsDo:			[:sel :method |			currentExtractedMethod := method. 			extractor				extractInterfacesFrom: method				addTo: self].	^self packagedResultsForCompiledMethod: aCompiledMethod! !!TypeCollector methodsFor: 'accessing'!typingResults	^ typingResults! !!TypeCollector methodsFor: 'private'!typingResultsFor: instVarName	^self typingResults at: (self absoluteIndexForVar: instVarName)! !!TypeCollector methodsFor: 'private'!withTranslatedIndex: index do: aBlock	aBlock value: index + 1! !!AbstractMerger methodsFor: 'public'!mergeInterfaceTypes: interfaceTypeCollection assignmentTypes: assignmentTypesCollection	"interfaceTypes is a set of trees of types reconstructed by looking at the interfaces.	assignmentTypes is a set of trees of types reconstructed by looking at the assignments.	The receiver takes these sets as input and needs to return one set of trees of types that combines both."	"This class does this by preferring abstract types over concrete types."	| assignmentsToKeep chain |	(interfaceTypeCollection isEmpty and: [assignmentTypesCollection notEmpty])		ifTrue: [^assignmentTypesCollection].	assignmentsToKeep := assignmentTypesCollection		select:			[:assignmentType | 			chain := assignmentType withAllSuperclasses.			(interfaceTypeCollection				anySatisfy: [:superType | chain includes: superType]) not].	assignmentsToKeep addAll: interfaceTypeCollection.	^assignmentsToKeep isEmpty		ifTrue: [OrderedCollection with: Object]		ifFalse: [assignmentsToKeep]! !!AssignmentsFirstMerger methodsFor: 'public'!mergeInterfaceTypes: interfaceTypeCollection assignmentTypes: assignmentTypesCollection	"interfaceTypes is a set of trees of types reconstructed by looking at the interfaces.	assignmentTypes is a set of trees of types reconstructed by looking at the assignments.	The receiver takes these sets as input and needs to return one set of trees of types that combines both."	"This merger favors the assignment types over the interface types. It only considers the interface types when there is no assignment information, or when there is only one interface type that is not related to the assignment types."	| interfaceType assignments |	(assignmentTypesCollection size = 1 and: [assignmentTypesCollection first = UndefinedObject]) ifTrue: [assignmentTypesCollection removeFirst].	assignmentTypesCollection isEmpty		ifTrue:			[interfaceTypeCollection isEmpty				ifTrue: [^OrderedCollection with: Object]				ifFalse:					[^self cleanBooleansIn: interfaceTypeCollection asOrderedCollection]].	assignments := assignmentTypesCollection asOrderedCollection.	interfaceTypeCollection size == 1		ifFalse: [^self cleanBooleansIn: assignments].	interfaceType := interfaceTypeCollection asOrderedCollection first.	^((assignments anySatisfy: [:cl | cl includesBehavior: interfaceType])		or:			[assignments				anySatisfy:					[:assignmentType | interfaceType includesBehavior: assignmentType]])		ifTrue: [self cleanBooleansIn: assignments]		ifFalse:			[self				cleanBooleansIn:					(assignments						add: interfaceType;						yourself)]! !!ConcreteMerger methodsFor: 'public'!mergeInterfaceTypes: interfaceTypeCollection assignmentTypes: assignmentTypesCollection	"interfaceTypes is a set of trees of types reconstructed by looking at the interfaces.	assignmentTypes is a set of trees of types reconstructed by looking at the assignments.	The receiver takes these sets as input and needs to return one set of trees of types that combines both."	"This class does this by preferring concrete types over abstract types."	| toKeep chain |	toKeep := interfaceTypeCollection copy.	assignmentTypesCollection		do:			[:assignmentType | 			chain := assignmentType withAllSuperclasses.			(interfaceTypeCollection select: [:type | chain includes: type])				do:					[:each | 					toKeep						remove: each						ifAbsent: []]].	toKeep addAll: assignmentTypesCollection.	^toKeep isEmpty		ifTrue: [OrderedCollection with: Object]		ifFalse: [toKeep asOrderedCollection]! !!TypeMerger class methodsFor: 'instance creation'!interfaceTypes: interfaceTypeCollection assignmentTypes: assignmentTypesCollection	^self new		mergeInterfaceTypes: interfaceTypeCollection		assignmentTypes: assignmentTypesCollection! !!TypeMerger methodsFor: 'private'!cleanBooleansIn: collection	"Remove all occurences of True, False and Boolean in the given collection. If any element was removed, add Boolean"	"Note: removeAllSuchThat: in VisualWorks returns the elements removed, while in Squeak it returns the new set. Therefore I adopted a check on the sizes to see if any Boolean class was removed or not, instead of checking the result of removeAllSuchThat: "	| oldSize |	oldSize := collection size.	collection		removeAllSuchThat:			[ :type | type == True | (type == False) | (type == Boolean)].	^oldSize == collection size		ifFalse:			[collection				add: Boolean;				yourself]		ifTrue: [collection]! !!TypeMerger methodsFor: 'public'!mergeInterfaceTypes: interfaceTypeCollection assignmentTypes: assignmentTypesCollection	"interfaceTypes is a set of trees of types reconstructed by looking at the interfaces.	assignmentTypes is a set of trees of types reconstructed by looking at the assignments.	The receiver takes these sets as input and needs to return one set of trees of types that combines both."	^self subclassResponsibility! !!TypingResultKeeper class methodsFor: 'instance creation'!benchmarkImage	"self benchmarkImage"	| keeper |	^Time		millisecondsToRun:			[keeper := self forImage.			keeper withAllInstvarResultsDo: [:cl :iv :result | result types]]! !!TypingResultKeeper class methodsFor: 'instance creation'!forImage	^self new forImage! !!TypingResultKeeper class methodsFor: 'instance creation'!forImageExpanded	| keeper |	keeper := self forImage.	keeper withAllInstvarResultsDo: [:cl :iv :result | result types].	^keeper! !!TypingResultKeeper methodsFor: 'private'!addCollectorResult: collectorResult	collectorResult isEmpty ifTrue: [^self].	typeResults		at: collectorResult values first ivarClass		put: collectorResult! !!TypingResultKeeper methodsFor: 'private'!addTypingResult: aTypeResult	| typeResultsForClass |	typeResultsForClass := self typeResults		at: aTypeResult ivarClass		ifAbsentPut: [Dictionary new].	typeResultsForClass		at: aTypeResult ivarName		put: aTypeResult! !!TypingResultKeeper methodsFor: 'accessing'!calculateTypesForClass: aClass	^TypeCollector typeInstvarsOfClass: aClass! !!TypingResultKeeper methodsFor: 'public'!forClasses: aClassList	| collector |	collector := TypeCollector new.	timeTaken := Time		millisecondsToRun:			[aClassList				do:					[:cl | 					cl isMeta						ifFalse:							[self addCollectorResult: (collector typeInstvarsOfClass: cl)]]]! !!TypingResultKeeper methodsFor: 'public'!forImage	self forClasses: Object allSubclasses! !!TypingResultKeeper methodsFor: 'initialize-release'!initialize	typeResults := IdentityDictionary new! !!TypingResultKeeper methodsFor: 'accessing'!nrObjectTypes	| nr |	nr := 0.	self		withAllInstvarResultsDo:			[:cl :ivar :typeResult | (typeResult is: Object) ifTrue: [nr := nr + 1]].	^nr! !!TypingResultKeeper methodsFor: 'accessing'!nrUniqueTypes	| nr |	nr := 0.	self		withAllInstvarResultsDo:			[:cl :ivar :typeResult | typeResult isSingularType ifTrue: [nr := nr + 1]].	^nr! !!TypingResultKeeper methodsFor: 'accessing'!resetTypesForClass: aClass	^typeResults		removeKey: aClass		ifAbsent: []! !!TypingResultKeeper methodsFor: 'private'!resultsForClass: aClass instvar: instvar ifAbsent: absentBlock	| ivars |	ivars := typeResults		at: aClass		ifAbsent: absentBlock.	^ivars		at: instvar		ifAbsent: absentBlock! !!TypingResultKeeper methodsFor: 'statistics'!sameTypesAs: otherKeeper	| result correspondingResult |	result := OrderedCollection new.	self		withAllInstvarResultsDo:			[:cl :iv :res | 			correspondingResult := otherKeeper				typesForClass: cl				instvar: iv.			(res types sameElements: correspondingResult types)				ifTrue: [result add: cl -> iv]].	^result! !!TypingResultKeeper methodsFor: 'accessing'!timeTaken	^timeTaken! !!TypingResultKeeper methodsFor: 'accessing'!typeResults	^typeResults! !!TypingResultKeeper methodsFor: 'accessing'!typesForClass: aClass	^typeResults		at: aClass		ifAbsentPut: [self calculateTypesForClass: aClass]! !!TypingResultKeeper methodsFor: 'accessing'!typesForClass: aClass instvar: instvar	^(self typesForClass: aClass)		at: instvar		ifAbsent:			[ExtractedType				forInstvar: instvar				inClass: aClass]! !!TypingResultKeeper methodsFor: 'enumerating'!withAllInstvarResultsDo: aBlock	self typeResults		keysAndValuesDo:			[:cl :instvarDict | 			instvarDict				keysAndValuesDo:					[:ivar :typeResult | 					aBlock						value: cl						value: ivar						value: typeResult]]! !!Class methodsFor: '*RoelTyper-enumerating'!nonMetaSubclassesDo: aBlock	"Evaluate the argument, aBlock, for each of the receiver's immediate non-meta subclasses."	"This one is here for the sake of Squeak (where it is Class and not Behavior that keeps the subclasses instance variable)."	"This method is supposed to be local in Class because of a good reason.   We use this pragma to test if Class does not contain some accidental    local selectors."	<localClassMethod>	subclasses isNil		ifFalse: [ subclasses do: aBlock ]! !!Metaclass methodsFor: '*RoelTyper-enumerating'!nonMetaSubclassesDo: aBlock	"Evaluate the argument, aBlock, for each of the receiver's immediate non-meta subclasses."	self subclasses do: aBlock! !!OrderedCollection methodsFor: '*RoelTyper'!unsafeRemoveFirst	"Remove the first element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| firstObject |	firstObject := array at: firstIndex.	array at: firstIndex put: nil.	firstIndex := firstIndex + 1.	^ firstObject! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!blockReturnTop	"Return Top Of Stack bytecode."	^self pop! !!InstvarInterfaceExtractor methodsFor: 'private'!copied: list	copied := list! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!doDup	"Duplicate Top Of Stack bytecode."	self dupFirst! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!doPop	"Remove Top Of Stack bytecode."	^self pop! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement'!dupFirst	stack add: stack last! !!InstvarInterfaceExtractor methodsFor: 'extracting'!extractInterfacesFrom: m addTo: aTypeCollector	method := m.	saveStacks := Dictionary new.	stack := OrderedCollection new.	"0 to: method numTemps - 1 do: [:i | stack add: #temp -> i ]."	initialStack := stack copy.	collector := aTypeCollector.	input := InstructionStream on: method.	blockTraversal := false.	blockArgs := 0.	[input atEnd]		whileFalse:			[self reloadStack.			input interpretNextInstructionFor: self]! !!InstvarInterfaceExtractor methodsFor: 'private'!initialize	super initialize.	blockTraversal := false.	blockArgs := 0.! !!InstvarInterfaceExtractor methodsFor: 'private'!input	^input! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!jump: delta	| currentPC |	currentPC := self input pc.	delta < 1 ifTrue: [^self].	self saveStacks		at: currentPC + delta		put: stack copy.	stack := OrderedCollection new.	! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!jump: delta if: condition	|top|	(top := stack last)	 isInteger ifTrue: [		collector addAssignment: Boolean to: top.		]	ifFalse: [		(top isVariableBinding and: [top key = #temp]) ifTrue: [collector addAssignment: Boolean toTmp: top value]		ifFalse: [			(top isVariableBinding and: [top key = #return]) ifTrue: [collector addAssignment: Boolean toReturnOf: top value]			]		].	self pop.	"receiver of ifTrue or ifFalse, according to condition"	delta < 1 ifTrue: [^self].	self saveStacks		at: self input pc + delta		put:			(stack copy)! !!InstvarInterfaceExtractor methodsFor: 'private'!method: aMethod	method := aMethod.	copied := #()! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!methodReturnConstant: value	"Return Constant bytecode."	collector addAssignmentForReturn: value class.  	^self		pushConstant: value;		sqReturnTop! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!methodReturnReceiver	"Return Self bytecode."	collector addAssignmentForReturnSelf.  	^self		pushReceiver;		sqReturnTop! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!methodReturnTop	"Return Top Of Stack bytecode."	collector addAssignmentForReturn: stack last.	^self sqReturnTop! !!InstvarInterfaceExtractor methodsFor: 'opcodes-control'!nativeSend: selector numArgs: na 	| receiver args |	args := stack removeLast: na.	receiver := stack removeLast.	receiver isInteger 		ifTrue: 			[ collector 				addSend: selector				to: receiver ]		ifFalse: 			[ receiver isVariableBinding ifTrue: 				[ receiver key = #temp 					ifTrue: 						[ collector 							addSend: selector							toTmp: receiver value ]					ifFalse: 						[ receiver key = #return ifTrue: 							[ collector 								addSend: selector								onReturnOfSelfMethod: receiver value ] ] ] ].	(receiver = #self and: [ collector theClass methodDict includesKey: selector ]) ifTrue: 		[ args doWithIndex: 			[ :arg :index | 			collector 				handleAssignment: arg				forTmp: index - 1				in: collector theClass >> selector ] ].	stack add: (collector 			pushSendOf: selector			to: receiver			args: args)! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement'!pop	stack removeLast! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!popIntoLiteralVariable: anAssociation	"Remove Top Of Stack And Store Into Literal Variable bytecode."	^self pop! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!popIntoReceiverVariable: offset	"Remove Top Of Stack And Store Into Instance Variable bytecode."	collector		handleAssignment: stack removeLast		for: offset! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!popIntoTemporaryVariable: offset	"Remove Top Of Stack And Store Into Temporary Variable bytecode."	"An empty stack => we are in a block"		blockTraversal ifTrue: [blockArgs > 0 ifTrue: [stack addLast: #temp -> offset. collector transformAsBlockArgTheTmpOffset: offset]. blockArgs := blockArgs - 1. blockTraversal := (blockArgs > 0) ].  	collector		handleAssignment: stack removeLast		forTmp: offset! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushActiveContext	"Push Active Context On Top Of Its Own Stack bytecode."	self pushContext! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement'!pushConstant: value	value class == BlockClosure		ifTrue:			[self				readBlock: value method				copied: 0]		ifFalse: [			blockArgs := value.			stack addLast: value class]! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement'!pushContext	stack add: #context! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement'!pushInst: index	stack add: index! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushLiteralVariable: anAssociation	"Push Contents Of anAssociation On Top Of Stack bytecode."	self pushStatic: anAssociation! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement'!pushReceiver	stack addLast: #self! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushReceiverVariable: offset	"Push Contents Of the Receiver's Instance Variable Whose Index 	is the argument, offset, On Top Of Stack bytecode."	self pushInst: offset! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement'!pushStatic: assoc	"assoc can be an association OR a variable binding. I just push the complete association, since it does not interest me for the moment."	stack addLast: assoc! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushTemporaryVariable: offset	"Push Contents Of Temporary Variable Whose Index Is the 	argument, offset, On Top Of Stack bytecode."	stack add: (#temp -> offset)! !!InstvarInterfaceExtractor methodsFor: 'private'!readBlock: block copied: count	| newCopied |	newCopied := stack removeLast: count.	stack add: #block.	^(self class new)		copied: newCopied;		extractInterfacesFrom: block			addTo: collector! !!InstvarInterfaceExtractor methodsFor: 'private'!reloadStack	stack isNil		ifTrue:			[stack := self saveStacks				at: self input pc				ifAbsent: [initialStack copy].			^self].	stack := self saveStacks		at: self input pc		ifAbsent: [stack]! !!InstvarInterfaceExtractor methodsFor: 'private'!saveStacks	saveStacks ifNil: [saveStacks := Dictionary new].	^saveStacks! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!send: selector numArgs: na		self nativeSend: selector numArgs: na.	(stack last = #block and: [blockArgs > 0])ifTrue: [blockTraversal := true]! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!send: selector super: supered numArgs: numberArguments	"Send Message With Selector, selector, bytecode. The argument, 	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found in 	the top numArguments locations on the stack and the receiver just 	below them."	^supered		ifTrue:			[self				sendSuper: selector				numArgs: numberArguments]		ifFalse:			[self				send: selector				numArgs: numberArguments]! !!InstvarInterfaceExtractor methodsFor: 'opcodes-control'!sendSuper: selector numArgs: na	stack removeLast: na + 1.	stack add: #computed! !!InstvarInterfaceExtractor methodsFor: 'private'!sqReturnTop	"In VW, method returnTop is inherited from instructionClient and does nothing."	! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!storeIntoLiteralVariable: anAssociation	"Store Top Of Stack Into Literal Variable Of Method bytecode."	"Nothing to do, since I do not do anything with literal variables. Just keep the right-hand side on the stack for further processing"	! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!storeIntoReceiverVariable: offset	"Store Top Of Stack Into Instance Variable Of Method bytecode."	| rvalue |	collector		handleAssignment: (rvalue := stack removeLast)		for: offset.	stack add: rvalue! !!InstvarInterfaceExtractor methodsFor: 'instruction decoding'!storeIntoTemporaryVariable: offset	"Store Top Of Stack Into Temporary Variable Of Method bytecode."	"Nothing to do,since I do not treat temporary variables for the moment."		| rvalue |	blockTraversal ifTrue: [blockArgs > 0 ifTrue: [stack addLast: #temp -> offset. collector transformAsBlockArgTheTmpOffset: offset]. blockArgs := blockArgs - 1. blockTraversal := (blockArgs > 0) ].  	collector		handleAssignment: (rvalue := stack removeLast)		forTmp: offset.	stack add: rvalue! !!PharoInstvarInterfaceExtractor methodsFor: 'block'!blockMapping	^ blockTempsMapping last! !!PharoInstvarInterfaceExtractor methodsFor: 'block'!blocksArgsBySize	^ blocksLimits ifNil: [ blocksLimits := OrderedCollection new ]! !!PharoInstvarInterfaceExtractor methodsFor: 'block'!blocksDecrement		blocksLimits := blocksLimits select: [:e | (e = input pc) ifTrue: [self removeBlockMapping.  false] ifFalse: [true] ]	! !!PharoInstvarInterfaceExtractor methodsFor: 'extracting'!extractInterfacesFrom: m addTo: aTypeCollector	method := m.	saveStacks := Dictionary new.	stack := OrderedCollection new.	"0 to: method numTemps - 1 do: [:i | stack add: #temp -> i ]."	initialStack := stack copy.	collector := aTypeCollector.	input := InstructionStream on: method.	blockTraversal := false.	blocksLimits := OrderedCollection new.	blockTempsMapping := OrderedCollection new.	blockArgs := 0.	[input atEnd]		whileFalse:			[self reloadStack.			input interpretNextInstructionFor: self.			self blocksDecrement.			]! !!PharoInstvarInterfaceExtractor methodsFor: 'block'!inABlock	^ blockTempsMapping isNotEmpty! !!PharoInstvarInterfaceExtractor methodsFor: 'initialization'!initialize	super initialize.	blockTempsMapping := OrderedCollection new.! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!methodReturnTop	^self pop! !!PharoInstvarInterfaceExtractor methodsFor: 'block'!newBlockMapping	blockTempsMapping add: OrderedCollection new.	! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Remove Top Of Stack And Store Into Offset of Temp Vector bytecode."	stack removeLast	! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!popIntoTemporaryVariable: offset	"Remove Top Of Stack And Store Into Temporary Variable bytecode."	"An empty stack => we are in a block"	self inABlock ifFalse: [	collector		handleAssignment: stack removeLast		forTmp: offset] ifTrue: [					]! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	self newBlockMapping.	self blocksArgsBySize add: blockSize + input pc - 1.	1 to: numArgs do: [:index | self blockMapping add: #blockArg->index.].	numCopied timesRepeat: [ self blockMapping add: stack removeLast afterIndex: numArgs]. 	stack addLast: #block.	blockArgs := numArgs.	! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushConsArrayWithElements: anArray	stack add: #instcreation->Array! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushNewArrayOfSize: numElements 	"Push New Array of size numElements bytecode."	stack addLast: #computed ! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	stack addLast: #computed! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!pushTemporaryVariable: offset 	"Push Contents Of Temporary Variable Whose Index Is the 	argument, offset, On Top Of Stack bytecode."	self inABlock		ifTrue: [stack				add: (self blockMapping						at: offset + 1						ifAbsent: [#blockTemp -> (offset - self blockMapping size)])]		ifFalse: [stack add: #temp -> offset]! !!PharoInstvarInterfaceExtractor methodsFor: 'removing'!removeBlockMapping	blockTempsMapping removeLast! !!PharoInstvarInterfaceExtractor methodsFor: 'opcodes-control'!send: selector numArgs: na	"selector = #shapeBoundsAt:ifPresent: ifTrue: [self halt]".	^self nativeSend: selector numArgs: na ! !!PharoInstvarInterfaceExtractor methodsFor: 'instruction decoding'!storeIntoTemporaryVariable: offset	"Store Top Of Stack Into Temporary Variable Of Method bytecode."	"Nothing to do,since I do not treat temporary variables for the moment."		| rvalue |  	stack isEmpty ifTrue: [		self flag: 'bug here. For now just do nothing. uncomment the halt to run the example. 		It seems that there is a general problem with this method, see also TypeCollector >> handleAssignment:forTmp: '.		"Try for example: 			TypeCollector typeInstvar:  #superclass ofClassWithLookup:   Behavior "		"self halt."		^ self.		].	collector		handleAssignment: (rvalue := stack removeLast)		forTmp: offset.	stack add: rvalue! !!ClassDescription methodsFor: '*RoelTyper-organization'!categoryForSelector: aSelector	"Starting from the receiver, find the category for the given selector (if any). "	| cat s |	^(cat := self whichCategoryIncludesSelector: aSelector)		ifNil:			[(s := self superclass)				ifNil: [nil]				ifNotNil: [s categoryForSelector: aSelector]]		ifNotNil: [cat]! !"RoelTyper"!!ManifestRoelTyperTests commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ExtractedTypeTest methodsFor: 'tests'!testFlattenLinks	|et1 et2|	et1 := ExtractedType new.	et2 := ExtractedType new.	et1 addReverseLinkedExtractedType: et2.	et1 flattenLinks.	et2 flattenLinks.! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary'!assertAssignments: description in: collector	| emptyIndexes ivarName ivarInterface extractedInterface ivarIndex anArray |	anArray := collector typingResults.	emptyIndexes := (1 to: self class allInstVarNames size) asOrderedCollection.	description		do:			[:desc | 			ivarName := desc first.			ivarInterface := desc at: 2.			ivarIndex := collector absoluteIndexForVar: ivarName.			extractedInterface := collector assignmentsTo: ivarName.			self assert: extractedInterface size equals: ivarInterface size.			self				assert:					(extractedInterface allSatisfy: [:each | ivarInterface includes: each name]).			emptyIndexes remove: ivarIndex].	self		emptyAssigment: anArray		atIndexes: emptyIndexes! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary'!assertSends: description in: collector	| emptyIndexes ivarName ivarInterface extractedInterface ivarIndex anArray |	anArray := collector typingResults.	emptyIndexes := (1 to: self class allInstVarNames size) asOrderedCollection.	description		do:			[:desc | 			ivarName := desc first.			ivarInterface := desc at: 2.			ivarIndex := collector absoluteIndexForVar: ivarName.			extractedInterface := collector sendsTo: ivarName.			self assert: extractedInterface size equals: ivarInterface size.			self				assert:					(extractedInterface allSatisfy: [:each | ivarInterface includes: each]).			emptyIndexes remove: ivarIndex].	self		emptyInterface: anArray		atIndexes: emptyIndexes! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary'!denyAssignments: description in: collector	| emptyIndexes ivarName ivarInterface extractedInterface ivarIndex anArray |	anArray := collector typingResults.	emptyIndexes := (1 to: self class allInstVarNames size) asOrderedCollection.	description		do:			[:desc | 			ivarName := desc first.			ivarInterface := desc at: 2.			ivarIndex := collector absoluteIndexForVar: ivarName.			extractedInterface := collector assignmentsTo: ivarName.			ivarInterface				do: [:each | self deny: (extractedInterface includes: each)].			emptyIndexes remove: ivarIndex].	self		emptyAssigment: anArray		atIndexes: emptyIndexes! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary'!empty: anArray atIndexes: indexCollection	indexCollection do: [:index | self assert: (anArray at: index) isEmpty]! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary'!emptyAssigment: anArray atIndexes: indexCollection	indexCollection		do: [:index | self assert: (anArray at: index) hasEmptyAssignments]! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary'!emptyInterface: anArray atIndexes: indexCollection	indexCollection		do: [:index | self assert: (anArray at: index) hasEmptyInterface]! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary'!processMethod: aCompiledMethod	"Fail by default. Needs to be overridden by subclasses to trigger the base testing backbone."	| collector |	collector := TypeCollector onClass: self class.	collector currentExtractedMethod: aCompiledMethod.	TypeCollector new newExtractor		extractInterfacesFrom: aCompiledMethod		addTo: collector.	^collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testArithmetic	"self run: #testArithmetic"	| collector |	collector := self		doForSource:			'u := v \\ 3. a := b floor. b := c truncateTo: (x := 4 roundTo: 5)'.	self		assertSends: #(#(#v #(#\\)) #(#b #(#floor)) #(#c #(#truncateTo:)))		in: collector.	self		assertAssignments:			#(#(#u #(#Number)) #(#a #(#Number)) #(#b #(#Number)) #(#x #(#Number)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'combined tests'!testArithmeticValueSpecialisation	| collector |	collector := self		doForSource:			'		b := (Point x: 2 y: 4) - (1@1) '.	self		assertSends: #()		in: collector.	self		assertAssignments: #(#(#b #(#Point)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testArrayAssignment	| collector |	collector := self doForSource: 'v := #(one two three)'.	self		assertAssignments: #(#(#v #(#Array)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testCascaded1	| collector |	collector := self doForSource: 'x printString; size'.	self		assertSends: #(#(#x #(#printString #size)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testCascaded2	| collector |	collector := self doForSource: 'x printString; size; yourself'.	self		assertSends: #(#(#x #(#printString #size #yourself)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testComplicated1	| collector |	collector := self		doForSource:			'		b := Set new: 3 * (c collect: [:s | s])'.	self		assertSends: #(#(#c #(#collect:)))		in: collector.	self		assertAssignments: #(#(#b #(#Set)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'non supported'!testComplicated2	| collector |	collector := self		doForSource:			'		| temp1 temp2 |		temp1 := b := temp2 := 3.'.	self		denyAssignments: #(#(#b #(#SmallInteger)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'non supported'!testComplicated3	"self run: #testComplicated3"	"selfdebug: #testComplicated3"	| collector |	collector := self		doForSource:			'		| temp1 temp2 temp3 |		temp2 := b := temp1 := 3.'.	self		denyAssignments: #(#(#b #(#SmallInteger)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testEquality	| collector |	collector := self doForSource: 'u := v = 3'.	self		assertSends: #(#(#v #(#=)))		in: collector.	self		assertAssignments: #(#(#u #(#Boolean)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testIdentity	| collector |	collector := self doForSource: 'u := v == 3'.	self		assertSends: #(#(#v #(#==)))		in: collector.	self		assertAssignments: #(#(#u #(#Boolean)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testIftrue	| vSends collector |	collector := self doForSource: 'u := v isNil ifTrue: [1] ifFalse: [2]'.	vSends := collector sendsTo: #v.	self assert: vSends size equals: 1.	self assert: (vSends includes: #isNil)! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testIndirectAssignments		(TypeCollector typeInstvar: #c ofClass: ASampleClass) types! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testInstanceAssignment	| collector |	collector := self doForSource: 'w := TypeCollector new'.	self		assertAssignments: #(#(#w #(#TypeCollector)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testInstanceAssignmentIndirect	| collector |	collector := self doForSource: 'self w: TypeCollector new'.	self		assertAssignments: #(#(#w #(#TypeCollector)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testInstvarAssignment1	| collector |	collector := self		doForSource:			'		| temp1 temp2 temp3 |		a := 3.		b := a'.	self		assertAssignments: #(#(#b #(#SmallInteger)) #(#a #(#SmallInteger)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testInstvarAssignment2	| collector |	collector := self		doForSource:			'		| temp1 temp2 temp3 |		c := b := 3.'.	self		assertAssignments: #(#(#b #(#SmallInteger)) #(#c #(#SmallInteger)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests'!testMetaClassAssignment	| collector wAssignments wIndex wIndexRelative |	collector := self doForSource: 'w := TypeCollector'.	wIndex := collector absoluteIndexForVar: #w.	"Absolute"	wIndexRelative := wIndex		- (self class allInstVarNames size - self class instVarNames size).	wAssignments := collector assignmentsTo: #w.	self assert: wAssignments size equals: 1.	self assert: (wAssignments includes: TypeCollector class).	self		emptyAssigment: collector typingResults		atIndexes:			(((1 to: self class instVarNames size) asOrderedCollection)				remove: wIndexRelative;				yourself)! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testSuperivarAssignment	| collector |	collector := self doForSource: '^testSelector := testSelector'.	self		assertSends: #()		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testSuperivarSend	| collector |	collector := self doForSource: '^testSelector printString'.	self		assertSends: #(#(#testSelector #(#printString)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testblockindirectxy	| collector |	collector := self		doForSource: '^self testu ifTrue: [self x] ifFalse: [self y asString]'.	self		assertSends: #(#(#y #(#asString)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testblockuwx	| collector |	collector := self		doForSource: '^[u + w] on: Error do: [:exc | x printString]'.	self		assertSends: #(#(#u #(#+)) #(#x #(#printString)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testblockwithargs	| collector |	collector := self		doForSource: '^[:s | s + 1] value: 1'.	self		assertSends: #()		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testblockxy	| collector |	collector := self doForSource: '^self xyw ifTrue: [x] ifFalse: [y]'.	self		assertSends: #()		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testblockyab	" #'ifTrue:ifFalse: is sent to a, but is not Captured by the extractor"	| collector |	collector := self doForSource: '^self a ifTrue: [b] ifFalse: [y]'.	self		assertSends: #()		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testindirectx	| collector |	collector := self doForSource: '^self x printString'.	self		assertSends: #(#(#x #(#printString)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testu	| collector |	collector := self doForSource: '^u'.	self		assertSends: #()		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testuxyw	| collector |	collector := self		doForSource: '	u := (x asString ~= y printString). ^u = w'.	self		assertSends: #(#(#y #(#printString)) #(#x #(#asString)) #(#u #(#=)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testxyw	| collector |	collector := self		doForSource:			'		| t |		t := (x = y).		^t = w'.	self		assertSends: #(#(#x #(#=)))		in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests'!testzuv	| collector |	collector := self doForSource: '^u ~= z or: [u = v]'.	self		assertSends: #(#(#u #(#= #~=)))		in: collector! !!RoelTypingTestRoot methodsFor: 'auxiliary'!doForSource: src	| m |	m := (Smalltalk compiler		source: 'gen ' , src;		class: self class;		requestor: nil;		failBlock: [ self error: 'Error during compilation of generated method.' ];		parse) generate.	^ self processMethod: m! !!RoelTypingTestRoot methodsFor: 'auxiliary'!processMethod: aCompiledMethod	"Fail by default. Needs to be overridden by subclasses to trigger the base testing backbone."	self assert: false! !!AbstractMergerTest methodsFor: 'auxiliary'!mergeClass	^AbstractMerger! !!AbstractMergerTest methodsFor: 'folding tests'!test1	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Collection! !!AbstractMergerTest methodsFor: 'folding tests'!test10	"Dictionary and Array are in unrelated hierarchies -> keep both."	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Array				with: Collection).	self assert: mergeResult size equals: 3.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!AbstractMergerTest methodsFor: 'folding tests'!test11	"Dictionary and Array are in unrelated hierarchies -> keep both."	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Collection				with: Array).	self assert: mergeResult size equals: 3.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!AbstractMergerTest methodsFor: 'folding tests'!test12	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes:			(OrderedCollection				with: Dictionary				with: Array).	self assert: mergeResult size equals: 1.	self assert: (mergeResult includes: Collection)! !!AbstractMergerTest methodsFor: 'folding tests'!test13	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes:			(OrderedCollection				with: Array				with: Dictionary).	self assert: mergeResult size equals: 1.	self assert: (mergeResult includes: Collection)! !!AbstractMergerTest methodsFor: 'folding tests'!test14	self		mergeInterfaceTypes:			(OrderedCollection				with: SequenceableCollection				with: Bag)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: SequenceableCollection).	self assert: (mergeResult includes: Bag)! !!AbstractMergerTest methodsFor: 'folding tests'!test2	self		mergeInterfaceTypes: (OrderedCollection with: Array)		assignmentTypes: (OrderedCollection with: Collection).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!AbstractMergerTest methodsFor: 'folding tests'!test3	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: OrderedCollection new.	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!AbstractMergerTest methodsFor: 'folding tests'!test4	self		mergeInterfaceTypes: (OrderedCollection with: Object)		assignmentTypes: OrderedCollection new.	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!AbstractMergerTest methodsFor: 'folding tests'!test5	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: (OrderedCollection with: Object).	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!AbstractMergerTest methodsFor: 'folding tests'!test6	"Dictionary and Array are in unrelated hierarchies -> keep both"	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array)! !!AbstractMergerTest methodsFor: 'folding tests'!test7	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 1.	self assert: (mergeResult includes: Array)! !!AbstractMergerTest methodsFor: 'folding tests'!test8	"Dictionary and Array are in unrelated hierarchies -> keep both"	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Array				with: Object).	self assert: mergeResult size equals: 3.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Object)! !!AssignmentsFirstMergerTest methodsFor: 'auxiliary'!mergeClass	^AssignmentsFirstMerger! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test1	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Array! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test10	"Dictionary and Array are in unrelated hierarchies -> keep both."	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Array				with: Collection).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test11	"Dictionary and Array are in unrelated hierarchies -> keep both."	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Collection				with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test12	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes:			(OrderedCollection				with: Dictionary				with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test13	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes:			(OrderedCollection				with: Array				with: Dictionary).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Dictionary)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test14	self		mergeInterfaceTypes:			(OrderedCollection				with: SequenceableCollection				with: Bag)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 1.	self assert: (mergeResult includes: Array)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test2	self		mergeInterfaceTypes: (OrderedCollection with: Array)		assignmentTypes: (OrderedCollection with: Collection).	self assert: mergeResult size equals: 1.	self assert: (mergeResult includes: Collection)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test3	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: OrderedCollection new.	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test4	self		mergeInterfaceTypes: (OrderedCollection with: Object)		assignmentTypes: OrderedCollection new.	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test5	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: (OrderedCollection with: Object).	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test6	"Dictionary and Array are in unrelated hierarchies -> keep both"	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test7	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 1.	self assert: (mergeResult includes: Array)! !!AssignmentsFirstMergerTest methodsFor: 'folding tests'!test8	"Dictionary and Array are in unrelated hierarchies -> keep both"	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Array				with: Object).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Object)! !!ConcreteMergerTest methodsFor: 'auxiliary'!mergeClass	^ConcreteMerger! !!ConcreteMergerTest methodsFor: 'folding tests'!test1	"assignment type Array is subtype of interface type Collection		-> folding keeps Array and loses Collection"	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Array! !!ConcreteMergerTest methodsFor: 'folding tests'!test10	"Dictionary and Array are in unrelated hierarchies -> keep both."	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Array				with: Collection).	self assert: mergeResult size equals: 3.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!ConcreteMergerTest methodsFor: 'folding tests'!test11	"Dictionary and Array are in unrelated hierarchies -> keep both."	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Collection				with: Array).	self assert: mergeResult size equals: 3.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!ConcreteMergerTest methodsFor: 'folding tests'!test12	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes:			(OrderedCollection				with: Dictionary				with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array)! !!ConcreteMergerTest methodsFor: 'folding tests'!test13	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."	self		mergeInterfaceTypes: (OrderedCollection with: Collection)		assignmentTypes:			(OrderedCollection				with: Array				with: Dictionary).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array)! !!ConcreteMergerTest methodsFor: 'folding tests'!test14	self		mergeInterfaceTypes:			(OrderedCollection				with: SequenceableCollection				with: Bag)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Bag)! !!ConcreteMergerTest methodsFor: 'folding tests'!test2	"interface type Array is subclass of assignment type Collection		-> folding keeps Array and loses Collection"	self		mergeInterfaceTypes: (OrderedCollection with: Array)		assignmentTypes: (OrderedCollection with: Collection).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Collection)! !!ConcreteMergerTest methodsFor: 'folding tests'!test3	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: OrderedCollection new.	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!ConcreteMergerTest methodsFor: 'folding tests'!test4	self		mergeInterfaceTypes: (OrderedCollection with: Object)		assignmentTypes: OrderedCollection new.	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!ConcreteMergerTest methodsFor: 'folding tests'!test5	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: (OrderedCollection with: Object).	self assert: mergeResult size equals: 1.	self assert: mergeResult first equals: Object! !!ConcreteMergerTest methodsFor: 'folding tests'!test6	"Dictionary and Array are in unrelated hierarchies -> keep both"	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 2.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array)! !!ConcreteMergerTest methodsFor: 'folding tests'!test7	self		mergeInterfaceTypes: OrderedCollection new		assignmentTypes: (OrderedCollection with: Array).	self assert: mergeResult size equals: 1.	self assert: (mergeResult includes: Array)! !!ConcreteMergerTest methodsFor: 'folding tests'!test8	"Dictionary and Array are in unrelated hierarchies -> keep both"	self		mergeInterfaceTypes: (OrderedCollection with: Dictionary)		assignmentTypes:			(OrderedCollection				with: Array				with: Object).	self assert: mergeResult size equals: 3.	self assert: (mergeResult includes: Dictionary).	self assert: (mergeResult includes: Array).	self assert: (mergeResult includes: Object)! !!TypeMergerTestsRoot methodsFor: 'auxiliary'!mergeClass	^self subclassResponsibility! !!TypeMergerTestsRoot methodsFor: 'auxiliary'!mergeInterfaceTypes: interfaceTypes assignmentTypes: assignmentTypes	mergeResult := self mergeClass		interfaceTypes: interfaceTypes		assignmentTypes: assignmentTypes! !!TypeCollectorTest methodsFor: 'typing tests'!methodWithTmpInBlock: anObject	|some fancy variables|	some := 1.	fancy := 'hola'.	variables := #sexSymbol.	[ |l| l := true. l ] whileFalse: [ ].	^ self! !!TypeCollectorTest methodsFor: 'typing tests'!testOnBehavior	self shouldnt: (TypeCollector typeInstvar:  #'superclass' ofClassWithLookup: Behavior) raise: Error! !!TypeCollectorTest methodsFor: 'typing tests'!testOnTmpVarContainedInBlock	self shouldnt: (TypeCollector typeTmpsIn: (self class >> #methodWithTmpInBlock:)		ofClass: self class) raise: Error! !!TypeCollectorTest methodsFor: 'typing tests'!testPoint	| types xTypes yTypes |	types := TypeCollector typeInstvarsOfClass: Point.	xTypes := types at: #x.	self assert: ((xTypes is: Number) or: [xTypes is: Integer]).	yTypes := types at: #y.	self assert: ((yTypes is: Number) or: [yTypes is: Integer])! !!ASampleClass methodsFor: 'assignments links'!a	a := 5! !!ASampleClass methodsFor: 'assignments links'!b	b := a! !!ASampleClass methodsFor: 'blocks typing'!blockReturn: arg	"(TypeCollector typeTmpsIn: (self>>#blockReturn:) ofClass: self) "		self byParam: [:bu | ^bu].	g := arg.	! !!ASampleClass methodsFor: 'blocks typing'!blockTyping	"(TypeCollector typeTmpsIn: (self>>#blockTyping) ofClass: self) "	|t3 t t2|	[:s | t2 + 1. t - 1.1] value: 5. ! !!ASampleClass methodsFor: 'parameters links'!byParam	e := 6.	self byParam: e! !!ASampleClass methodsFor: 'parameters links'!byParam: aTmp 	d := aTmp! !!ASampleClass methodsFor: 'assignments links'!c	c := b! !!ASampleClass methodsFor: 'return links'!return	"(TypeCollector typeTmpsIn: (self>>#return) ofClass: self)"	^5! !!ASampleClass methodsFor: 'temporaries typing'!tmpTyping	"(TypeCollector typeTmpsIn: (self>>#tmpTyping) ofClass: self) "	|tmp1 tmp2|	tmp1 := 1.	tmp2 :=  tmp1.! !!ASampleClass methodsFor: 'return links'!useReturn	"(TypeCollector typeInstvar: #f ofClass: self) types"	^f := self return.! !!ManifestRoelTyperTests class methodsFor: 'code-critics'!ruleGRTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#TypeCollectorTest #methodWithTmpInBlock: #false)) #'2018-11-15T18:15:36.392243+01:00') )! !"RoelTyper-Tests"!!ASConverter commentStamp: '' prior: 0!A converter is a kind of parser.!!ASPathConverter commentStamp: '' prior: 0!The syntax of path data is concise in order to allow for minimal file size and efficient downloads, since many SVG files will be dominated by their path data. Some of the ways that SVG attempts to minimize the size of path data are as follows:● All instructions are expressed as one character (e.g., a moveto is expressed as an M).● Superfluous white space and separators such as commas can be eliminated (e.g., "M 100 100 L 200 200"contains unnecessary spaces and could be expressed more compactly as "M100 100L200 200").● The command letter can be eliminated on subsequent commands if the same command is used multiple timesin a row (e.g., you can drop the second "L" in "M 100 200 L 200 100 L -100 -200" and use "M 100 200 L 200100 -100 -200" instead).● Relative versions of all commands are available (uppercase means absolute coordinates, lowercase meansrelative coordinates).● Alternate forms of lineto are available to optimize the special cases of horizontal and vertical lines (absolute andrelative).● Alternate forms of curve are available to optimize the special cases where some of the control points on thecurrent segment can be determined automatically from the control points on the previous segment.!!ASConverter methodsFor: 'parsing-public'!nextNumber	"read the number from stream.	or answer nil if not successfull"	"<number> (real number value): The specification of real number values is different for property values than for XML attribute values.❍ CSS2 [CSS2] states that a property value which is a <number> is specified in decimal notation (i.e., a <decimal-number>), which consists of either an <integer>, or an optional sign character followed byzero or more digits followed by a dot (.) followed by one or more digits. Thus, for conformance withCSS2, any property in SVG which accepts <number> values is specified in decimal notation only.❍ For SVG's XML attributes, to provide as much scalability in numeric values as possible, real numbervalues can be provided either in decimal notation or in scientific notation (i.e., a <scientific-number>), which consists of a <decimal-number> immediately followed by the letter ''e'' or ''E'' immediately followed by an <integer>.Unless stated otherwise for a particular attribute or property, a <number> has the capacity for at least a single- precision floating point number (see [ICC32]) and has a range (at a minimum) of -3.4e+38F to +3.4e+38F.It is recommended that higher precision floating point storage and computation be performed on operations such as coordinate system transformations to provide the best possible precision and to prevent round-off errors.Conforming High-Quality SVG Viewers are required to use at least double-precision floating point (see [ICC32]) for intermediate calculations on certain numerical operations.Within the SVG DOM, a <number> is represented as a float or an SVGAnimatedNumber."		| result char sign esign pos int frac exponent |		esign := sign := 1.	pos := stream position.		stream peek = $- ifTrue: [ sign := -1.  stream next ].	int := self readInteger.		stream peek = $. ifTrue: [		stream next.		frac := self readFraction.	].		(stream peek = $e or: [ stream peek = $E ]) ifTrue: [		stream next.		stream peek = $- ifTrue: [ esign := -1.  stream next ].		exponent := self readInteger * esign ].		"failed"	(int isNil and: [ frac isNil ]) ifTrue: [ stream position: pos.  ^ nil ].		int ifNil: [ int := 0 ].	frac ifNil: [ frac := 0 ].	exponent ifNil: [ exponent := 0 ].		result :=  (int + frac * (10 raisedTo: exponent) * sign).		result isFraction ifTrue: [  ^ result asFloat ] ifFalse: [ ^ result ]! !!ASConverter methodsFor: 'accessing'!noFill	^ ASNoFill soleInstance ! !!ASConverter methodsFor: 'parsing'!parseColor: aString	^ Color fromString: aString! !!ASConverter methodsFor: 'operations'!readFraction"read fraction, what is after the decimal point:.12345"	| result mul |	(stream atEnd or: [ stream peek isDigit not ]) ifTrue: [ ^ nil ].		mul := 1/10. 	result := 0.	[ stream peek notNil and: [ stream peek isDigit ] ] whileTrue: [		result := result + ( (stream next digitValue) * mul ).		mul := mul / 10	].	^ result! !!ASConverter methodsFor: 'write and read'!readInteger	| result |	(stream atEnd or: [ stream peek isDigit not ]) ifTrue: [ ^ nil ].		result := 0.	[ stream peek notNil and: [ stream peek isDigit ] ] whileTrue: [		result := result * 10 + (stream next digitValue)	].	^ result! !!ASConverter methodsFor: 'operations'!skipBlanks	[ stream atEnd not and: [ stream peek isSeparator ] ] whileTrue: [ stream next ].! !!ASConverter methodsFor: 'operations'!skipBlanksAndComma	[ stream atEnd not and: [ stream peek isSeparator or: [stream peek =$,]] ] whileTrue: [ stream next ].! !!ASConverter methodsFor: 'accessing'!stream	^ stream! !!ASConverter methodsFor: 'accessing'!stream: aStream	stream := aStream! !!ASPathConverter methodsFor: 'path commands'!A	self absolute; ellipticalArc! !!ASPathConverter methodsFor: 'path commands'!C	^ self absolute; cubicBezier ! !!ASPathConverter methodsFor: 'path commands'!H	self absolute; hLineTo ! !!ASPathConverter methodsFor: 'path commands'!L	self absolute; lineTo.! !!ASPathConverter methodsFor: 'path commands'!M	"move-to absolute"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	self absolute; moveTo.! !!ASPathConverter methodsFor: 'path commands'!Q	self absolute; quadraticBezier! !!ASPathConverter methodsFor: 'path commands'!S	self absolute; reflectedCubicBezier! !!ASPathConverter methodsFor: 'path commands'!T	self absolute; smoothQuadraticBezier! !!ASPathConverter methodsFor: 'path commands'!V	self absolute; vLineTo ! !!ASPathConverter methodsFor: 'path commands'!Z	self close! !!ASPathConverter methodsFor: 'path commands'!a	self relative; ellipticalArc! !!ASPathConverter methodsFor: 'builder commands'!absolute	absolute := true.	self addSegment ! !!ASPathConverter methodsFor: 'adding'!addSegment	| sel args |	sel := 	thisContext sender selector.	args := thisContext sender arguments.	"update min/max for calculatin bounding box"		path add: { sel. args }! !!ASPathConverter methodsFor: 'converting'!assertValidCommand: aCharacter 	( #( $M $m $Z $z $L $l $H $h $V $v $C $c $S $s $Q $q $T $t $A $a ) includes: aCharacter ) ifFalse: [		self error: 'invalid path segment command' ]! !!ASPathConverter methodsFor: 'accessing'!bbox	^ 100@100! !!ASPathConverter methodsFor: 'path commands'!c	^ self relative; cubicBezier ! !!ASPathConverter methodsFor: 'builder commands'!close	self addSegment ! !!ASPathConverter methodsFor: 'operations'!convertPathData	path := OrderedCollection new.		[ self skipBlanks. stream atEnd ] whileFalse: [		| cmd |		cmd := stream next.		self assertValidCommand: cmd.		self perform: cmd asString asSymbol.	].	^ path	! !!ASPathConverter methodsFor: 'operations'!cubicBezier"C/c (x1 y1 x2 y2 x y)+Draws a cubic Bézier curve from the current point to (x,y) using (x1,y1) as the control point at the beginning of the curve and (x2,y2) as the control point at the end of the curve. C (uppercase) indicates that absolute coordinates will follow; c (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybézier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybézier."	| p1 p2 p3 |		p1 := self readPoint.	p2 := self readPoint.	p3 := self readPoint.		p3 ifNil: [ self error: 'Invalid path data: 3 points expected for cubic bezier '].	self curveVia: p1 and:  p2 to: p3. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p3 := self readPoint.		p3 ifNil: [ self error: 'Invalid path data: 3 points expected for cubic bezier '].		self curveVia: p1 and:  p2 to: p3. 	] repeat.! !!ASPathConverter methodsFor: 'builder commands'!curveVia: aPoint and: aPoint2 to: aPoint3 	self addSegment ! !!ASPathConverter methodsFor: 'builder commands'!curveVia: aPoint to: aPoint2 	self addSegment ! !!ASPathConverter methodsFor: 'operations'!ellipticalArc "A (absolute) a (relative)elliptical arc(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+Draws an elliptical arc from the current point to (x, y). The size and orientation of the ellipse are defined by two radii (rx, ry) and an x-axis-rotation, which indicates how the ellipse as a whole is rotated relative to the current coordinate system. The center (cx, cy) of the ellipse is calculated automatically to satisfy the constraints imposed by the other parameters. large-arc-flag and sweep- flag contribute to the automatic calculations and help determine how the arc is drawn."	| r xrot large sweep pt |		[	r := self readPoint.	r ifNil: [ ^ self ].		self skipBlanksAndComma.		xrot := self nextNumber.	self skipBlanksAndComma.		large := self nextNumber.	self skipBlanksAndComma.	sweep := self nextNumber.		pt := self readPoint.		pt ifNil: [ self error: 'Invalid path data for elliptical arc segment'].	self ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt relative: absolute not.	] repeat.! !!ASPathConverter methodsFor: 'operations'!ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt	self addSegment! !!ASPathConverter methodsFor: 'operations'!ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt relative: isRelative	self addSegment! !!ASPathConverter methodsFor: 'path commands'!h	self relative; hLineTo ! !!ASPathConverter methodsFor: 'operations'!hLineTo"H (absolute) h (relative)x +Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H (uppercase) indicates that absolute coordinates will follow; h (lowercase) indicates that relative coordinates will follow. Multiple x values can be provided (although usually this doesn't make sense). At the end of the command, the new current point becomes (x, cpy) for the final value of x."	| x |		self skipBlanks.	x := self nextNumber ifNil: [ ^ self error: 'number expected for horizontal line segment'   ].		self hLineTo: x.		[ self skipBlanks. x := self nextNumber. x notNil ] whileTrue: [		self hLineTo: x	].! !!ASPathConverter methodsFor: 'builder commands'!hLineTo: aNumber	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!l	self relative; lineTo.! !!ASPathConverter methodsFor: 'operations'!lastBezierPoint	path reverseDo: [ :arr | arr first caseOf: { 		[ #relative ] -> [ "ignore" ] } ]! !!ASPathConverter methodsFor: 'operations'!lineTo" L (absolute) l (relative)lineto(x y)+Draw a line from the current point to the given (x,y) coordinate which becomes the new current point. L (uppercase) indicates that absolute coordinates will follow; l (lowercase) indicates that relative coordinates will follow. A number of coordinates pairs may be specified to draw a polyline. At the end of the command, the new current point is set to the final set of coordinates provided."	| pt |	pt := self readPoint.		pt ifNil: [ self error: 'point expected for line segment' ].		self lineTo: pt.		[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'builder commands'!lineTo: aPoint 	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!m	"move-to relative"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	| pt reset |	pt := self readPoint.	pt ifNil: [ self error: 'a point expected following after M/m command'].	path isEmpty ifTrue: [ 			self absolute; moveTo: pt; relative ] 		ifFalse: [ self relative; moveTo: pt ].	[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'operations'!moveTo	"move-to"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	| pt |	pt := self readPoint.	pt ifNil: [ self error: 'a point expected following after M/m command'].		self moveTo: pt.		[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'builder commands'!moveTo: aPoint 	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!q	self relative; quadraticBezier! !!ASPathConverter methodsFor: 'operations'!quadraticBezier "Q/q (x1 y1 x y)+Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1) as the control point. Q (uppercase) indicates that absolute coordinates will follow; q (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybézier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybézier."	| p1 p2 |		p1 := self readPoint.	p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for quadratic bezier '].		self curveVia: p1 to: p2. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for quadratic bezier '].		self curveVia: p1 to: p2. 	] repeat.! !!ASPathConverter methodsFor: 'operations'!readPoint	" A path data permits specifying points without comma separator "	| x y pos |	self skipBlanksAndComma.	pos := stream position.	x := self nextNumber ifNil: [ ^ nil ].		self skipBlanksAndComma.		y := self nextNumber ifNil: [ stream position: pos. ^ nil ].		^ x @ y! !!ASPathConverter methodsFor: 'operations'!reflectedCubicBezier"S/s (x2 y2 x y)+cubic Bézier curve from the current point to (x,y). The first control point is assumed to be the reflection of the second control point on the previous command relative to the current point. (If there is no previous command or if the previous command was not an C, c, S or s, assume the first control point is coincident with the current point.) (x2,y2) is the second control point (i.e., the control point at the end of the curve). S (uppercase) indicates that absolute coordinates will follow; s (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybézier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybézier."	| p1 p2 |		p1 := self readPoint.	p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for reflected cubic bezier '].	self reflectedCurveVia: p1 to: p2. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for reflected cubic bezier '].		self reflectedCurveVia: p1 to: p2. 	] repeat.! !!ASPathConverter methodsFor: 'builder commands'!reflectedCurveVia: aPoint to: aPoint2 	self addSegment ! !!ASPathConverter methodsFor: 'builder commands'!relative	absolute := false.	self addSegment ! !!ASPathConverter methodsFor: 'path commands'!s	self relative; reflectedCubicBezier! !!ASPathConverter methodsFor: 'operations'!smoothQuadraticBezier	self notYetImplemented ! !!ASPathConverter methodsFor: 'path commands'!t	self relative; smoothQuadraticBezier! !!ASPathConverter methodsFor: 'path commands'!v	self relative; vLineTo ! !!ASPathConverter methodsFor: 'operations'!vLineTo"V (absolute) v (relative)Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V (uppercase) indicates that absolute coordinates will follow; v (lowercase) indicates that relative coordinates will follow. Multiple y values can be provided (although usually this doesn't make sense). At the end of the command, the new current point becomes (cpx, y) for the final value of y."	| y |		self skipBlanks.	y := self nextNumber ifNil: [ ^ self error: 'number expected for horizontal line segment'   ].		self vLineTo: y.		[ self skipBlanks. y := self nextNumber. y notNil ] whileTrue: [		self vLineTo: y	].! !!ASPathConverter methodsFor: 'builder commands'!vLineTo: aNumber		self addSegment ! !!ASPathConverter methodsFor: 'path commands'!z	self close! !!ASNoFill class methodsFor: 'as yet unclassified'!soleInstance	^ soleInstance ifNil: [ soleInstance  := self new ]	! !!ASNoFill methodsFor: 'as yet unclassified'!fill: aShape on: aCanvas	"do nothing"! !!ASNoFill methodsFor: 'as yet unclassified'!resolveIds: aDictionary 	^ self! !!ASNoFill methodsFor: 'as yet unclassified'!stroke: aShape on: aCanvas	"do nothing" ! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!arcDegreeStart: aStartAngle sweep: aSweepAngle centerX: anX y: aY radius: aRadius 	^self 		arcRadianStart: aStartAngle degreesToRadians		sweep: aSweepAngle degreesToRadians		centerX: anX		y: aY		radius: aRadius! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!arcRadianStart: aStartAngle sweep: aSweepAngle centerX: anX y: aY radius: aRadius 	| endAngle |		endAngle := aStartAngle + aSweepAngle.	aSweepAngle positive 		ifTrue: 			[ self arcCenterX: anX centerY: aY radius: aRadius startAngle: aStartAngle endAngle: endAngle ]		ifFalse: 			[ self arcNegativeCenterX: anX centerY: aY radius: aRadius startAngle: aStartAngle endAngle: endAngle ].! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!ellipticalArc3: radii xrot: xAxisRotation large: largeArcFlag sweep: sweepFlag to: theEndPoint"	 self cwArcTo: pt angle: 45 degreesToRadians  "		| rx ry x1 y1 x2 y2 dx2 dy2 phi cosAngle sinAngle arx ary coeff cx1 cy1 ux uy vx vy sign xPrime1 yPrime1 r  radical  startAngle  sweepAngle cx cy aPoint |			aPoint := lastControlPoint.		rx := radii x.	ry := radii y.		(rx - ry) abs < 1e-7 ifTrue: [		^self "self computeCircleArcAt: aPoint"].		x1 := aPoint x.	y1 := aPoint y.	x2 := theEndPoint x.	y2 := theEndPoint y.	dx2 := (x1 - x2) / 2.	dy2 := (y1 - y2) / 2.	phi := (xAxisRotation \\ 360) degreesToRadians.	cosAngle := phi cos.	sinAngle := phi sin.	xPrime1 := cosAngle * dx2 + (sinAngle * dy2).	yPrime1 := cosAngle * dy2 - (sinAngle * dx2).	"Ensure radii are positive"	arx := rx abs.	ary := ry abs.	"Ensure radii are large enough"	"lambda := (x1 squared / arx squared) + (y1 squared / ary squared).	lambda > 1 ifTrue: [		arx := arx * lambda sqrt.		ary := ary * lambda sqrt]."	"Step 2: Compute (cx1, cy1) "	radical := (arx squared * ary squared - (arx squared * yPrime1 squared)				- (ary squared * xPrime1 squared))					/ (arx squared * yPrime1 squared + (ary squared * xPrime1 squared)).	radical abs <= 1e-4 ifTrue: [radical := 0.0].	coeff := radical sqrt.	sweepFlag == largeArcFlag ifTrue: [coeff := coeff negated].	cx1 := coeff * arx * yPrime1 / ary.	cy1 := (coeff * ary * xPrime1 / arx) negated.	"Step 3: Compute (cx, cy)"	cx := cosAngle * cx1 - (sinAngle * cy1) + ((x1 + x2) / 2).	cy := sinAngle * cx1 + (cosAngle * cy1) + ((y1 + y2) / 2).	"Step 4: Compute startAngle and sweepAngle"	ux := (xPrime1 - cx1) / arx.	uy := (yPrime1 - cy1) / ary.	vx := (xPrime1 negated - cx1) / arx.	vy := (yPrime1 negated - cy1) / ary.	sign := ux * vy - (uy * vx) < 0 ifTrue: [-1] ifFalse: [1].	startAngle := ((ux / (ux squared + uy squared) sqrt) arcCos * uy sign)				radiansToDegrees \\ 360.	sweepAngle := (((ux * vx + (uy * vy))				/ ((ux squared + uy squared) * (vx squared + vy squared)) abs sqrt) asFloat				arcCos * sign)				radiansToDegrees \\ 360.	(sweepAngle abs < 180 and: [largeArcFlag])		ifTrue: 			[sweepAngle < 0				ifTrue: [sweepAngle := 360 + sweepAngle]				ifFalse: [sweepAngle := sweepAngle - 360]].	sweepFlag		ifTrue: [sweepAngle < 0 ifTrue: [sweepAngle := sweepAngle + 360]]		ifFalse: [sweepAngle > 0 ifTrue: [sweepAngle := sweepAngle - 360]].			! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!ellipticalArc: radii xrot: xAxisRotation large: largeArcFlag sweep: sweepFlag to: theEndPoint"	 self cwArcTo: pt angle: 45 degreesToRadians  "		| rx ry x1 y1 x2 y2 dx2 dy2 phi cosAngle sinAngle arx ary coeff cx1 cy1 ux uy vx vy sign xPrime1 yPrime1 r  radical  startAngle  sweepAngle cx cy aPoint lFlag swFlag isRelative aCenter |			aPoint := 0@0.		lFlag := false.	swFlag := false.		rx := radii x.	ry := radii y.			x1 := aPoint x.	y1 := aPoint y.	x2 := theEndPoint x.	y2 := theEndPoint y.	dx2 := (x1 - x2) / 2.	dy2 := (y1 - y2) / 2.	phi := (xAxisRotation \\ 360) degreesToRadians.	cosAngle := phi cos.	sinAngle := phi sin.	xPrime1 := cosAngle * dx2 + (sinAngle * dy2).	yPrime1 := cosAngle * dy2 - (sinAngle * dx2).	"Ensure radii are positive"	arx := rx abs.	ary := ry abs.	"Ensure radii are large enough"	"lambda := (x1 squared / arx squared) + (y1 squared / ary squared).	lambda > 1 ifTrue: [		arx := arx * lambda sqrt.		ary := ary * lambda sqrt]."	"Step 2: Compute (cx1, cy1) "	radical := (arx squared * ary squared - (arx squared * yPrime1 squared)				- (ary squared * xPrime1 squared))					/ (arx squared * yPrime1 squared + (ary squared * xPrime1 squared)).	radical "abs" <= 1e-4 ifTrue: [radical := 0.0].	coeff := radical sqrt.	swFlag == lFlag ifTrue: [coeff := coeff negated].	cx1 := coeff * arx * yPrime1 / ary.	cy1 := (coeff * ary * xPrime1 / arx) negated.	"Step 3: Compute (cx, cy)"	cx := cosAngle * cx1 - (sinAngle * cy1) + ((x1 + x2) / 2).	cy := sinAngle * cx1 + (cosAngle * cy1) + ((y1 + y2) / 2).	"Step 4: Compute startAngle and sweepAngle"	ux := (xPrime1 - cx1) / arx.	uy := (yPrime1 - cy1) / ary.	vx := (xPrime1 negated - cx1) / arx.	vy := (yPrime1 negated - cy1) / ary.	sign := ux * vy - (uy * vx) < 0 ifTrue: [-1] ifFalse: [1].	startAngle := ((ux / (ux squared + uy squared) sqrt) arcCos * uy sign)				radiansToDegrees \\ 360.	sweepAngle := (((ux * vx + (uy * vy))				/ ((ux squared + uy squared) * (vx squared + vy squared)) abs sqrt) asFloat				arcCos * sign)				radiansToDegrees \\ 360.	(sweepAngle abs < 180 and: [lFlag])		ifTrue: 			[sweepAngle < 0				ifTrue: [sweepAngle := 360 + sweepAngle]				ifFalse: [sweepAngle := sweepAngle - 360]].	swFlag		ifTrue: [sweepAngle < 0 ifTrue: [sweepAngle := sweepAngle + 360]]		ifFalse: [sweepAngle > 0 ifTrue: [sweepAngle := sweepAngle - 360]].			isRelative := false.	aCenter := isRelative ifTrue: [ endPoint + (cx@cy)] ifFalse: [cx@cy].		self arcDegreeStart: startAngle sweep: sweepAngle centerX: aCenter x y: aCenter y radius: rx abs.	endPoint := self toAbsolute: theEndPoint."self arcDegreeStart: startAngle sweep: sweepAngle centerX: cx y: cy radius: 1.0 "		"	self arcCenterX: xc centerY: yc radius: radius startAngle: angle1 endAngle: angle2  "! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG-PathConverter'!ellipticalArc: radii xrot: xAxisRotation large: largeArcFlag sweep: sweepFlag to: theEndPoint relative: isRelative"	 self cwArcTo: pt angle: 45 degreesToRadians  "		| rx ry x1 y1 x2 y2 dx2 dy2 phi cosAngle sinAngle arx ary coeff cx1 cy1 ux uy vx vy sign xPrime1 yPrime1 r  radical  startAngle  sweepAngle cx cy aPoint lFlag swFlag aCenter uySign |			aPoint := isRelative				ifTrue: [0.0 @ 0.0]				ifFalse: [endPoint].		lFlag := false.	swFlag := sweepFlag = 1.0.		rx := radii x.	ry := radii y.			x1 := aPoint x.	y1 := aPoint y.	x2 := theEndPoint x.	y2 := theEndPoint y.	dx2 := (x1 - x2) / 2.	dy2 := (y1 - y2) / 2."	phi := (xAxisRotation \\ 360) degreesToRadians.	cosAngle := phi cos.	sinAngle := phi sin.	xPrime1 := cosAngle * dx2 + (sinAngle * dy2).	yPrime1 := cosAngle * dy2 - (sinAngle * dx2)."		xPrime1 := dx2.	yPrime1 := dy2.	"Ensure radii are positive"	arx := rx abs.	ary := ry abs.	"Ensure radii are large enough"	"lambda := (x1 squared / arx squared) + (y1 squared / ary squared).	lambda > 1 ifTrue: [		arx := arx * lambda sqrt.		ary := ary * lambda sqrt]."	"Step 2: Compute (cx1, cy1) "	radical := (arx squared * ary squared - (arx squared * yPrime1 squared)				- (ary squared * xPrime1 squared))					/ (arx squared * yPrime1 squared + (ary squared * xPrime1 squared)).	radical abs <= 1e-4 ifTrue: [radical := 0.0].	coeff := radical abs sqrt.	sweepFlag == largeArcFlag ifTrue: [coeff := coeff negated].	cx1 := coeff * yPrime1.	cy1 := (coeff * xPrime1) negated.	"Step 3: Compute (cx, cy)"	cx := cx1 + ((x1 + x2) / 2).	cy := cy1 + ((y1 + y2) / 2).	"Step 4: Compute startAngle and sweepAngle"	ux := (xPrime1 - cx1) / arx.	uy := (yPrime1 - cy1) / ary.	vx := (xPrime1 negated - cx1) / arx.	vy := (yPrime1 negated - cy1) / ary.	sign := ux * vy - (uy * vx) <= 0 ifTrue: [-1] ifFalse: [1].	uySign := uy = 0 ifTrue: [1] ifFalse: [uy sign].	startAngle := ((ux / (ux squared + uy squared) sqrt) arcCos * uySign)				radiansToDegrees \\ 360.	sweepAngle := (((ux * vx + (uy * vy))				/ ((ux squared + uy squared) * (vx squared + vy squared)) abs sqrt) asFloat				arcCos * sign)				radiansToDegrees \\ 360.	(sweepAngle abs < 180 and: [lFlag])		ifTrue: 			[sweepAngle < 0				ifTrue: [sweepAngle := 360 + sweepAngle]				ifFalse: [sweepAngle := sweepAngle - 360]].	swFlag		ifTrue: [sweepAngle < 0 ifTrue: [sweepAngle := sweepAngle + 360]]		ifFalse: [sweepAngle > 0 ifTrue: [sweepAngle := sweepAngle - 360]].					aCenter := isRelative ifTrue: [ endPoint + (cx@cy)] ifFalse: [cx@cy].		self arcDegreeStart: startAngle sweep: sweepAngle centerX: aCenter x y: aCenter y radius: rx abs.	endPoint := self toAbsolute: theEndPoint."self arcDegreeStart: startAngle sweep: sweepAngle centerX: cx y: cy radius: 1.0 "		"	self arcCenterX: xc centerY: yc radius: radius startAngle: angle1 endAngle: angle2  "! !"Athens-SVG-PathConverter"!!GeometryObject commentStamp: '' prior: 0!Description--------------------I am a common superclass for all Geometry object. Concrete (points, segments, polygons...) and abstract objects (coordinates, vectors, ...).!!GAngle commentStamp: '' prior: 0!Description--------------------I represent a geometric angle. For now I can manage angle in radians or degrees.If the angle is not in [0;2π[ , I'll take care to convert it in order to store the angle as a radian value in [0;2π[.Examples--------------------	90 degrees. "90.0°"	(0.5 * Float pi)  radians. "90.0°"		0.5π radians. "90.0°"			450 degrees. "90.0°"		0.5π radians + 0.5π radians. "180.0°"		0.5π radians - 0.25π radians. "45.0°"		0.5π radians * 6. "180.0°"		6 * 0.5π radians. "180.0°"		90 degrees < 100 degrees. "true"		90 degrees < -270 degrees. "false"		90 degrees < 460 degrees. "false"		0 radians isZero. "true"		90 degrees explementary. "270.0°" Internal Representation and Key Implementation Points.--------------------    Instance Variables	radians:		<aNumber>		The angle in radians in bounds [0;2π[!!GCoordinates commentStamp: '' prior: 0!Description--------------------I represent a set of coordinates that will be used by other geometric elements.My subclass will represent sets of a certain amount of coordinates. In the long terme we would like to remove all the subclasses and that everything manage myself as a n-dimensions coordinates set, but for now we prefer to begin with simple sets like 2D or 3D.I implement basic arithmetic that can be done with coordinates.Examples--------------------		"Instance creation"	GCoordinates withCollection: #(1 3). 	"(1,3)"		#(1 3) asGCoordinates.	"(1,3)"		"Arithmetic"			(GCoordinates withCollection: #(1 3)) + (GCoordinates withCollection: #(5 1)). 	"(6,4)"			(GCoordinates withCollection: #(1 3)) - (GCoordinates withCollection: #(5 1)). 	"(-4,2)"			(GCoordinates withCollection: #(1 3)) * 2. 	"(2,6)"			(GCoordinates withCollection: #(1 3)) / 2. 	"((1/2),(3/2))" Internal Representation and Key Implementation Points.--------------------    Instance Variables	coordinates:		<aCollection> 	A collection of all the coordinates I contains.!!G2DCoordinates commentStamp: '' prior: 0!Description--------------------I am a coordinates set for plans. (2D space).Examples--------------------	GCoordinates withCollection: #(1 3).	G2DCoordinates coordinates: #(1 3).		G2DCoordinates x: 1 y: 2!!G3DCoordinates commentStamp: '' prior: 0!Description--------------------I am a coordinates set for 3D spaces.Examples--------------------	GCoordinates withCollection: #(1 3 2).	G3DCoordinates coordinates: #(1 3 2).		G2DCoordinates x: 1 y: 2 z: 3!!GElement commentStamp: '' prior: 0!Description--------------------I am a common super class for all geometric elements. I define the common API all elements should be able to answer to.Public API and Key Messages--------------------- #includes: 	This methods takes a point as parameter and answer true of the element includes the point. (Boundaries included) Note: In the future I should be able to take more elements than the point as parameter using double dispatch as #intersectionsWith:.- #contains: 	This methods takes a point as parameter and answer true of the element includes the point. (Boundaries excluded) Note: In the future I should be able to take more elements than the point as parameter using double dispatch as #intersectionsWith:.- #boundaryContains: 		This methods takes a point as parameter and answer true of the boundaries of the element includes the point.- #intersectionsWith: 	Takes as parameter any GElement and returns a collection of intersections points with this element.- #translateBy: 			Takes a vector as parameter and translate the element by this vector.!!G1DElement commentStamp: '' prior: 0!Description--------------------I am the common superclass to all 1D elements. A 1D elements covers elements such as points, lines, segments, rays...!!GArc commentStamp: '' prior: 0!Description--------------------In Euclidean geometry, an arc is a closed segment of a differentiable curve.It is defined by 3 parameters- The center of the arc- The origin of the arc- The oriented angle of the arcExamples--------------------	GArc center: 3 , 3 origin: 5 , 6 angle: 0.5π radians.		GArc center: 3 , 3 origin: 5 , 6 angle: 90 degrees.		GArc center: 6 , 6 origin: 8 , 4 direction: 10 , 10.		(GArc center: 6 , 6 origin: 8 , 4 direction: 10 , 10) endPoint.		(GArc center: 1 , 0 origin: 4 , 0 direction: -1 , 2) includes: 1 , 3.		(GArc center: -1 , 0 origin: 4 , 0 direction: 1 , 4) intersectionsWith: (GLine through: 0 , 0 and: 1 , 1).		(GArc center: 6 , 6 origin: 8 , 4 direction: 10 , 10) length.		(GArc center: 6 , 6 origin: 8 , 4 direction: 10 , 10) radius.		(GArc center: 6 , 6 origin: 8 , 4 direction: 10 , 10) translateBy: #(1 -2) asGVector. Internal Representation and Key Implementation Points.--------------------    Instance Variables	center:			<aGPoint>		Center of the circle whose bounds contains the arc.	direction:		<aGPoint>		Origin point of the arc.	angle:				<aGAngle>		Angle betweent the vector center-origin and the vector center-endpoint of the arc.!!GLine commentStamp: '' prior: 0!Description--------------------A GLine goes through two points and can be represented by an equation of the form ax + by + c = 0.Examples--------------------	GLine a: 1 b: 1 c: -13.		GLine through: 1 , 3 and: 3 , 0.		(GLine a: 2 b: -3 c: 0.5) intersectionsWith: (GLine a: -2 b: -2 c: 4).		(GLine a: 1 b: 2 c: 0.5) isParallelTo: (GLine a: 2 b: 4 c: 4).		(GLine through: -1 , -4 and: 1 , -2) translateBy: #(1 -2) asGVector. Internal Representation and Key Implementation Points.--------------------    Instance Variables	v1:						<aGPoint>				One points on the line.	v2:						<aGPoint>				Another point on the line.	equationCache:		<aDictionary>		Dictionary caching the values of the equation ax + by + c = 0.!!GPoint commentStamp: '' prior: 0!Description--------------------I represent a geometric point. In the contrary of default Pharo point, I implement only the point logic and cannot be used as a vector. Vectors can be used with GVector.I am based on a set of coordinates and my API should be independent from the number of dimensions of the current space. The computations will rely on coordinates.Examples--------------------	"Instance creation"		GPoint withCollection: #(1 2).	 "a GPoint(1,2)"		GPoint withCollection: #(1 4 2). "a GPoint(1,4,2)"		GPoint coordinates: (GCoordinates withCollection: #(1 3)). 	"a GPoint(1,3)"		(GCoordinates withCollection: #(1 3)) asGPoint.	"a GPoint(1,3)"		#(1 2) asGPoint.	"a GPoint(1,2)"			1 , 2.		"a GPoint(1,2)"					"Arithmetic"	(1 , 2) + (2 , 3). "a GPoint(3,5) <= This will be a new instance."		(1, 2) translateBy: (2 , 3).	"a GPoint(3,5) <= This will be the same instance than the receiver" 			(4, 2) - (1, 1).	"a GVector(3,1)"			(3, 5) middlePointTo: (9, 15).	"a GPoint(6,10)"		(3, 5) distanceTo: (9, 15).	"11.661903789690601"	 Internal Representation and Key Implementation Points.--------------------    Instance Variables	coordinates:		<aGCoordinates> 	I represent the coordinates of the point.!!GRay commentStamp: '' prior: 0!Description--------------------A ray starts out at a point and continues off to infinityA ray is a geometry figure defined by an initial point, the origin, and another point to define a direction.Examples--------------------	GRay origin: 0 , -1 direction: 1 , 4.		(GRay origin: 100 , 100 direction: 80 , 110) flipped.		(GRay origin: 100 , 100 direction: 80 , 110) includes: 120 , 90.		(GRay origin: 0 , 0 direction: 1 , 1) intersectionsWith: GRay origin: 2 , 3 direction: 2 , 0.		(GRay origin: -1 , -4 direction: 1 , -2) translateBy: #(1 -2). Internal Representation and Key Implementation Points.--------------------    Instance Variables	directionPoint:		<aGPoint>		A point that can be anywhere on the ray and defining the direction of the ray.	initialPoint:		<aGPoint>		A GPoint defining the end point of the ray.!!GSegment commentStamp: '' prior: 0!Description--------------------I am a geometric segment. I am defined by two points which are my limits.As a goemetric segment, I have no direction, so the order of the two points during the creation has no importance.Examples--------------------	GSegment with: 1 , 2 with: 3 , 4.		(GSegment with: 1 , 3 with: 3 , 0) includes: 1 , 3.		(GSegment with: -1 , -1 with: 1 , 1) intersectionsWith: (GSegment with: -3 , 3 with: -1 , 1).		(GSegment with: 0 , 0 with: 3 , 4) length.		(GSegment with: -1 , 2 with: 2 , 1) midPoint.		(GSegment with: -1 , -4 with: 1 , -2) translateBy: #(1 -2) asGVector. Internal Representation and Key Implementation Points.--------------------    Instance Variables	v1:		<aGPoint>		One of the two limit of the segment.	v2:		<aGPoint>		Second limit of the segment. !!GShape commentStamp: '' prior: 0!Description--------------------I am a common superclass for all shapes elements.I define the minimal API each elements should be able to answer to.!!GCircle commentStamp: '' prior: 0!I am a circle. I have a center in (cx, cy) and radius. My equation is: (x-cx)^2  + (y-cy)^2 = radius^2 or a * (x^2) + a * (y^2) + d * x + e * y + f = 0 !!GPolygon commentStamp: '' prior: 0!I'm polygon builded on my vertices.!!GRectangle commentStamp: '' prior: 0!I am a rectangle. See my parent for API!!GTriangle commentStamp: '' prior: 0!I am a triangle!!GMatrix commentStamp: '' prior: 0!Description--------------------I am a simple implementation of matrix for operations needing matrix in geometry computations.I will not implement all matrix operations, only the one needed for the features of geometry elements.	 Internal Representation and Key Implementation Points.--------------------    Instance Variables	rows:		<aCollection> 	A collection of collection containing the rows of the matrix.!!GVector commentStamp: '' prior: 0!Description--------------------I represent a geometric vector. I have a state close to the state of a GPoint but a vector only represent a direction and a length.My direction will go from the origin of the plan ( (0, 0) in a 2D plan) to my coordinates. My length will be defined by my coordinates.Examples--------------------	"Instance creation"	GVector withCollection: #(1 2).	 "a GVector(1,2)"		GVector coordinates: (GCoordinates withCollection: #(1 3)). 	"a GVector(1,3)"		(GCoordinates withCollection: #(1 3)) asGVector.	"a GVector(1,3)"		#(1 2) asGVector.	"a GVector(1,2)"					"Arithmetic"		#(3 5) asGVector length.	"5.830951894845301" Internal Representation and Key Implementation Points.--------------------    Instance Variables	coordinates:		<GCoordinates> 	Coordinates defining my direction and length.!!GZeroVector commentStamp: '' prior: 0!Description--------------------	I represent the zero vector that is a vector of length 0 and the only vector without direction.!!ManifestGeometry commentStamp: '' prior: 0!I am a project of Euclidean geometry.!!GeometryError commentStamp: '' prior: 0!Description--------------------I am a common exception for the Geometry project!!TGWithCoordinates methodsFor: 'accessing'!coordinates	^ self explicitRequirement! !!TGWithCoordinates methodsFor: 'accessing'!coordinates: gCoordinates	^ self explicitRequirement! !!TGWithCoordinates methodsFor: 'enumerating'!coordinatesWith: aCollection collect: aBlock	^ self coordinates coordinatesWith: aCollection coordinates collect: aBlock! !!TGWithCoordinates methodsFor: 'enumerating'!coordinatesWith: aCollection do: aBlock	self coordinates coordinatesWith: aCollection coordinates do: aBlock! !!TGWithCoordinates methodsFor: 'copying'!postCopy	super postCopy.	self coordinates: self coordinates copy! !!TGWithCoordinates methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self coordinates printCoordinatesOn: aStream! !!TGWithCoordinates methodsFor: 'accessing'!x	^ self coordinates x! !!TGWithCoordinates methodsFor: 'accessing'!x: aNumber 	self coordinates x: aNumber! !!TGWithCoordinates methodsFor: 'accessing'!y	^ self coordinates y! !!TGWithCoordinates methodsFor: 'accessing'!y: aNumber 	self coordinates y: aNumber! !!GAngle class methodsFor: 'instance creation'!degrees: anInteger 	^ self radians: anInteger degreesToRadians! !!GAngle class methodsFor: 'class initialization'!initialize	TwoPi := 2π.	ZeroAngle := 0 radians.	RightAngle := 0.5π radians.	StraightAngle := 1π radians! !!GAngle class methodsFor: 'instance creation'!radians: aNumber	^ self new		initializeWith: aNumber;		yourself! !!GAngle methodsFor: 'arithmetic'!* anInteger 	^ anInteger multiplyWithAngle: self! !!GAngle methodsFor: 'arithmetic'!+ aGAngle 	^ aGAngle addWithAngle: self! !!GAngle methodsFor: 'arithmetic'!- aGAngle 	^ aGAngle substractWithAngle: self! !!GAngle methodsFor: 'arithmetic'!/ anInteger 	^ anInteger divideWithAngle: self! !!GAngle methodsFor: 'comparison'!< aGAngle 	^ self radians < aGAngle radians! !!GAngle methodsFor: 'comparison'!<= aGAngle 	^ (self > aGAngle) not! !!GAngle methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ (radians - anObject radians) =~ 0 or: [ (radians - anObject radians) =~ TwoPi ]! !!GAngle methodsFor: 'comparison'!> aGAngle 	^ aGAngle < self! !!GAngle methodsFor: 'comparison'!>= aGAngle 	^ aGAngle <= self! !!GAngle methodsFor: 'arithmetic'!adaptToNumber: anInteger andSend: aString 	(#(#/ #+) anySatisfy: [ :forgivenSelector | aString = forgivenSelector ]) ifTrue: [ self error: 'Cannot execute ' , aString , ' on an Integer with an angle' ]. "I think we can do better than an if here but no time."	^ self perform: aString with: anInteger! !!GAngle methodsFor: 'arithmetic'!addWithAngle: aGAngle 	^ (self radians + aGAngle radians) radians! !!GAngle methodsFor: 'arithmetic'!cos	^ self radians cos! !!GAngle methodsFor: 'converting'!degreeNumber	^ self radians radiansToDegrees! !!GAngle methodsFor: 'accessing'!explementary	^ (0 - self radians) radians! !!GAngle methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ radians hash! !!GAngle methodsFor: 'initialization'!initializeWith: aNumber 	radians := aNumber.	radians := radians \\ TwoPi.	radians negative ifTrue: [ radians := radians + TwoPi ]! !!GAngle methodsFor: 'testing'!isAcute	^ self > 0 radians and: [ self < RightAngle ]! !!GAngle methodsFor: 'testing'!isObtuse	^ self > RightAngle and: [ self < StraightAngle ]! !!GAngle methodsFor: 'testing'!isReflex	^ self > StraightAngle and: [ self radians < TwoPi ]! !!GAngle methodsFor: 'testing'!isRight	^ self = RightAngle! !!GAngle methodsFor: 'testing'!isStraight	^ self = StraightAngle! !!GAngle methodsFor: 'testing'!isZero	^ self = ZeroAngle! !!GAngle methodsFor: 'arithmetic'!multiplyWithAngle: aGAngle 	self error: 'Not possible to multiply an angle by another angle'! !!GAngle methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: (self degreeNumber asString truncateTo: 10);		nextPutAll: '°'! !!GAngle methodsFor: 'converting'!radianNumber	^ self radians! !!GAngle methodsFor: 'accessing'!radians	^ radians! !!GAngle methodsFor: 'arithmetic'!sin	^ self radians sin! !!GAngle methodsFor: 'arithmetic'!substractWithAngle: aGAngle 	^ (aGAngle radians - self radians) radians! !!GAngle methodsFor: 'arithmetic'!tan	^ self radians tan! !!G2DCoordinates class methodsFor: 'accessing'!numberOfDimensions	^ 2! !!G2DCoordinates class methodsFor: 'instance creation'!x: aNumber y: anotherNumber	^ self new		x: aNumber;		y: anotherNumber;		yourself! !!G3DCoordinates class methodsFor: 'accessing'!numberOfDimensions	^ 3! !!G3DCoordinates class methodsFor: 'instance creation'!x: aNumber y: anotherNumber z: thirdNumber	^ self new		x: aNumber;		y: anotherNumber;		z: thirdNumber;		yourself! !!G3DCoordinates methodsFor: 'accessing'!z	^ coordinates at: 3! !!G3DCoordinates methodsFor: 'accessing'!z: aNumber	^ coordinates at: 3 put: aNumber! !!GCoordinates class methodsFor: 'instance creation'!newWithCoordinates: aCollection	^ self basicNew		initializeWith: aCollection;		yourself! !!GCoordinates class methodsFor: 'accessing'!numberOfDimensions	^ self subclassResponsibility! !!GCoordinates class methodsFor: 'instance creation'!withCollection: aCollection	^ self allSubclasses		detect: [ :e | e numberOfDimensions = aCollection size ]		ifFound: [ :class | 			class basicNew				initializeWith: aCollection asArray;				yourself ]		ifNone: [ self error: 'This amount of coordinated is not yet managed.' ]! !!GCoordinates methodsFor: 'arithmetic'!* aNumber	"Answer a Point that is the multiplication of the receiver and arg."	aNumber isNumber ifFalse: [ self error: 'Coordinates can only be multiplicated by a number.' ].	^ self class newWithCoordinates: (self coordinatesCollect: [ :number | number * aNumber ])! !!GCoordinates methodsFor: 'arithmetic'!+ otherCoordinates 	"Answer a Point that is the sum of the receiver and arg."	self numberOfDimensions = otherCoordinates numberOfDimensions ifFalse: [ self error: 'For now we accept only addition of coordinates from the same dimension. We will see later if we should do more.' ].	^ self class newWithCoordinates: (otherCoordinates coordinatesWith: coordinates collect: [ :number1 :number2 | number1 + number2 ])! !!GCoordinates methodsFor: 'arithmetic'!- otherCoordinates 	"Answer a Point that is the substraction of the receiver and arg."	self numberOfDimensions = otherCoordinates numberOfDimensions ifFalse: [ self error: 'For now we accept only substraction of coordinates from the same dimension. We will see later if we should do more.' ].	^ self class newWithCoordinates: (otherCoordinates coordinatesWith: coordinates collect: [ :number2 :number1 | number1 - number2 ])! !!GCoordinates methodsFor: 'arithmetic'!/ aNumber	"Answer a Point that is the division of the receiver and arg."	aNumber isNumber ifFalse: [ self error: 'Coordinates can only be divided by a number.' ].	^ self class newWithCoordinates: (self coordinatesCollect: [ :number | number / aNumber ])! !!GCoordinates methodsFor: 'comparing'!= otherCoordinates	"Answer whether the receiver and anObject represent the same object."	self == otherCoordinates ifTrue: [ ^ true ].	self class = otherCoordinates class ifFalse: [ ^ false ].	otherCoordinates coordinatesWith: coordinates do: [ :number2 :number1 | number1 = number2 ifFalse: [ ^ false ] ].	^ true! !!GCoordinates methodsFor: 'converting'!asGPoint	^ GPoint coordinates: self! !!GCoordinates methodsFor: 'converting'!asGVector	^ GVector coordinates: self! !!GCoordinates methodsFor: 'accessing'!at: anInteger	^ self coordinates at: anInteger! !!GCoordinates methodsFor: 'accessing'!coordinates	^ coordinates! !!GCoordinates methodsFor: 'enumerating'!coordinatesCollect: aBlock	^ coordinates collect: aBlock! !!GCoordinates methodsFor: 'enumerating'!coordinatesWith: aCollection collect: aBlock	^ coordinates with: aCollection collect: aBlock! !!GCoordinates methodsFor: 'enumerating'!coordinatesWith: aCollection do: aBlock	coordinates with: aCollection do: aBlock! !!GCoordinates methodsFor: 'enumerating'!fold: aBlock	^ self coordinates fold: aBlock! !!GCoordinates methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."		^ coordinates hash negated "We negate to not have a collision with Array"! !!GCoordinates methodsFor: 'initialization'!initialize	super initialize.	coordinates := Array new: self numberOfDimensions! !!GCoordinates methodsFor: 'private'!initializeWith: anArray	anArray size = self numberOfDimensions ifFalse: [ self error: 'The provided array must have the same size than my number of dimensions which is ' , self numberOfDimensions size asString ].	coordinates := anArray! !!GCoordinates methodsFor: 'enumerating'!inject: aSeed into: aBlock	^ self coordinates inject: aSeed into: aBlock! !!GCoordinates methodsFor: 'accessing'!lowerLimitsWith: otherCoordinates	^ self class newWithCoordinates: (self coordinatesWith: otherCoordinates coordinates collect: [ :number1 :number2 | number1 min: number2 ])! !!GCoordinates methodsFor: 'accessing'!numberOfDimensions	^ self class numberOfDimensions! !!GCoordinates methodsFor: 'copying'!postCopy	super postCopy.	coordinates := coordinates copy! !!GCoordinates methodsFor: 'printing'!printCoordinatesOn: aStream	aStream << $(.	coordinates do: [ :number | aStream << number asString ] separatedBy: [ aStream << $, ].	aStream << $)! !!GCoordinates methodsFor: 'printing'!printOn: aStream	self printCoordinatesOn: aStream! !!GCoordinates methodsFor: 'accessing'!upperLimitsWith: otherCoordinates	^ self class newWithCoordinates: (self coordinatesWith: otherCoordinates coordinates collect: [ :number1 :number2 | number1 max: number2 ])! !!GCoordinates methodsFor: 'accessing'!x	^ coordinates at: 1! !!GCoordinates methodsFor: 'accessing'!x: aNumber	coordinates at: 1 put: aNumber! !!GCoordinates methodsFor: 'accessing'!y	"Might return an error for 1D coordinates, but do they make sense?"	^ coordinates at: 2! !!GCoordinates methodsFor: 'accessing'!y: aNumber	"Might return an error for 1D coordinates, but do they make sense?"	coordinates at: 2 put: aNumber! !!G1DElement class methodsFor: 'testing'!isAbstract	^ self = G1DElement! !!G1DElement methodsFor: 'testing'!boundaryContains: aPoint	^ self includes: aPoint! !!G1DElement methodsFor: 'accessing'!length	"Return the length of the element."	^ self subclassResponsibility! !!GArc class methodsFor: 'instance creation'!center: aGPoint origin: anotherGPoint angle: aGAngle	"Take three parameters to create a new arc:	- A point representing the center of the arc (center of the circle whose bond contains the arc circle)	- A point defining the origin of the arc	- An angle representing the angle between the vector center-origin and the vector center-endpoint of the arc."	^ self new		center: aGPoint;		origin: anotherGPoint;		angle: aGAngle;		yourself! !!GArc class methodsFor: 'instance creation'!center: aGPoint origin: anotherGPoint direction: yetAnotherGPoint	"Take three parameters to create a new arc:	- A point representing the center of the arc (center of the circle whose bond contains the arc circle)	- A point defining the origin of the arc	- A point denining the direction of the arc in the trigonometric direction"		"The conventional representation of an arc it a center, an origin and an angle. To determine the angle we compute the oriented angle between the vector center-origin and the vector center-direction."	^ self center: aGPoint origin: anotherGPoint angle: (aGPoint - anotherGPoint angleWith: aGPoint - yetAnotherGPoint)! !!GArc methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].		^ origin = anObject origin and: [ center = anObject center and: [ angle = anObject angle ] ]! !!GArc methodsFor: 'accessing'!angle	^ angle! !!GArc methodsFor: 'accessing'!angle: anObject	angle := anObject! !!GArc methodsFor: 'accessing'!center	^ center! !!GArc methodsFor: 'accessing'!center: anObject	center := anObject! !!GArc methodsFor: 'accessing'!centralAngle	"Alias of angle to cover the geometric names"	^ self angle! !!GArc methodsFor: 'accessing'!endPoint	"The end point is the point at the end of the arc (opposed to the origin)."	^ self origin rotatedBy: self angle about: self center! !!GArc methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ origin hash bitXor: (center hash bitXor: angle hash)! !!GArc methodsFor: 'testing'!includes: aGPoint	"An arc includes a point in the angle between the vector defined by the origin and center and the vector defined by the point and the center is between 0 and the arc angle and if the distance of the point from the center is equals to the radius."	^ ((self origin - self center angleWith: aGPoint - self center) < self angle)		and: [ (aGPoint distanceTo: self center) =~ self radius ]! !!GArc methodsFor: 'intersections'!intersectionsWith: anElement	^ anElement intersectionsWithArc: self! !!GArc methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse	^ aGEllipse intersectionsWithArc: self! !!GArc methodsFor: 'intersections'!intersectionsWithLine: aGLine 	^ aGLine intersectionsWithArc: self! !!GArc methodsFor: 'accessing'!length	^ self angle radians * self radius! !!GArc methodsFor: 'accessing'!origin	^ origin! !!GArc methodsFor: 'accessing'!origin: anObject	origin := anObject! !!GArc methodsFor: 'comparing'!printOn: aStream	super printOn: aStream.	aStream		<< $(;		<< 'center: ';		print: center coordinates;		<< ' | origin: ';		print: origin coordinates;		<< ' | angle: ';		print: self angle;		<< $)! !!GArc methodsFor: 'accessing'!radius	^ (self origin - self center) length! !!GArc methodsFor: 'comparing'!translateBy: aGVector 	self center: self center + aGVector.	self origin: self origin + aGVector! !!GLine class methodsFor: 'instance creation'!a: a b: b c: c	"ax + by + c = 0	ax + c = -by	-((ax + c) / b) = y		ax + by + c = 0	by + c = -ax	-((by + c) / a) = x	"	^ b = 0 ifFalse: [ self through: 1 , ((a * 1 + c) / b) negated and: 2 , ((a * 2 + c) / b) negated ] ifTrue: [ self through: ((b * 1 + c) / a) negated , 1 and: ((b * 2 + c) / a) negated , 2 ]! !!GLine class methodsFor: 'instance creation'!through: aPoint1 and: aPoint2	^ self new		v1: aPoint1;		v2: aPoint2;		yourself! !!GLine methodsFor: 'comparing'!= line	self == line ifTrue: [ ^ true ].	self class = line class ifFalse: [ ^ false ].	(self isParallelTo: line) ifFalse: [ ^ false ].	^ [ (self yFor: 1) =~ (line yFor: 1) ]		on: GeometryError		do: [ "This can happen if b = 0" (self xFor: 1) =~ (line xFor: 1) ]! !!GLine methodsFor: 'accessing'!a	^ self linearEquation at: #a! !!GLine methodsFor: 'arithmetic'!angleWith: aLine	^ self v1 - self v2 angleWith: aLine v1 - aLine v2! !!GLine methodsFor: 'converting'!asGLine	^ self ! !!GLine methodsFor: 'accessing'!b	^ self linearEquation at: #b! !!GLine methodsFor: 'accessing'!c	^ self linearEquation at: #c! !!GLine methodsFor: 'accessing'!determinantWith: aLine	"I return the determinant between two line.		First line: ax + by + c = 0	Second line: px + qy + c = 0		Determinant: a*q - p*b	"	^ (GMatrix rows: {{self a . self b} . {aLine a . aLine b}}) determinant! !!GLine methodsFor: 'distance functions'!distanceTo: aGPoint	^ (self a * aGPoint x + (self b * aGPoint y) + self c) abs / (self a squared + self b squared) sqrt! !!GLine methodsFor: 'comparing'!hash	^ ([ self yFor: 1 ]		on: GeometryError		do: [ "This can happen if b = 0" self xFor: 1 ]) hash! !!GLine methodsFor: 'testing'!includes: aPoint	^ self a * aPoint x + (self b * aPoint y) + self c =~ 0! !!GLine methodsFor: 'intersections'!intersectionsWith: anElement	^ anElement intersectionsWithLine: self! !!GLine methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse 	^ aGEllipse intersectionsWithLine: self! !!GLine methodsFor: 'intersections'!intersectionsWithLine: aGLine	| p q r x y determinant |	determinant := self determinantWith: aGLine.	determinant =~ 0 ifTrue: [ ^ { } "Line are parallel if determinant = 0" ].	p := aGLine a.	q := aGLine b.	r := aGLine c.		x := (self c negated * q - (r negated * self b)) / determinant.	y := (self a * r negated - (p * self c negated)) / determinant.	^ { (x , y) }! !!GLine methodsFor: 'properties'!isParallelTo: aLine	"If the determinant it 0 then the lines are parallel"	^ (self determinantWith: aLine) =~ 0! !!GLine methodsFor: 'accessing'!length	^ Float infinity! !!GLine methodsFor: 'accessing'!linearEquation	"Return a dictionary with value for a, b and c representing the line with an equation of the form: ax + by + c = 0"	^ equationCache ifNil: [ equationCache := self privateLinearEquationComputation ]! !!GLine methodsFor: 'printing'!printOn: aStream	self a ~~ 0		ifTrue: [ self a ~~ 1 ifTrue: [ self a printOn: aStream ].			aStream nextPutAll: 'x '.			self b sign >= 0 ifTrue: [ aStream nextPutAll: '+ ' ] ].	self b ~~ 0		ifTrue: [ self b ~~ 1 ifTrue: [ self b printOn: aStream ].			aStream nextPutAll: 'y' ].	self c ~~ 0		ifTrue: [ aStream space.			self c sign >= 0 ifTrue: [ aStream nextPutAll: '+ ' ].			self c printOn: aStream ].	aStream nextPutAll: ' = 0'! !!GLine methodsFor: 'private'!privateLinearEquationComputation	v1 y = v2 y ifTrue: [ ^ Dictionary with: #a -> 0 with: #b -> 1 with: #c -> v1 y negated ].	v1 x = v2 x ifTrue: [ ^ Dictionary with: #a -> 1 with: #b -> 0 with: #c -> v1 x negated ].	^ Dictionary with: #a -> (v1 y - v2 y) with: #b -> (v2 x - v1 x) with: #c -> ((v1 x - v2 x) * v1 y + ((v2 y - v1 y) * v1 x))! !!GLine methodsFor: 'initialization'!resetEquationCache	equationCache := nil! !!GLine methodsFor: 'transforming'!translateBy: aGVector	self v1: self v1 + aGVector.	self v2: self v2 + aGVector! !!GLine methodsFor: 'accessing'!v1	^ v1! !!GLine methodsFor: 'accessing'!v1: aPoint	v1 := aPoint.	self resetEquationCache! !!GLine methodsFor: 'accessing'!v2	^ v2! !!GLine methodsFor: 'accessing'!v2: aPoint	v2 := aPoint.	self resetEquationCache! !!GLine methodsFor: 'properties'!xFor: anY	self a = 0 ifTrue: [ self error: 'Cannot answer a x if a = 0' ].	^ ((anY * self b + self c) / self a) negated! !!GLine methodsFor: 'properties'!yFor: anX	self b = 0 ifTrue: [ self error: 'Cannot answer an y if b = 0' ].	^ ((anX * self a + self c) / self b) negated! !!GPoint class methodsFor: 'instance creation'!coordinates: aCoordinates	^ self new		coordinates: aCoordinates;		yourself! !!GPoint class methodsFor: 'instance creation'!withCollection: aCollection	^ self coordinates: (GCoordinates withCollection: aCollection)! !!GPoint class methodsFor: 'instance creation'!x: aNumber y: anotherNumber	^ self new		coordinates: (G2DCoordinates x: aNumber y: anotherNumber);		yourself! !!GPoint methodsFor: 'arithmetic'!+ aGVector	"I return a new point translated by a vector"	^ self copy		translateBy: aGVector;		yourself! !!GPoint methodsFor: 'arithmetic'!- aPoint	"I return a vector represented by the substraction of two points"	^ (self coordinates - aPoint coordinates) asGVector! !!GPoint methodsFor: 'comparing'!= anotherPoint	"Answer whether the receiver and anObject represent the same object."	self == anotherPoint ifTrue: [ ^ true ].	self class = anotherPoint class ifFalse: [ ^ false ].	^ coordinates = anotherPoint coordinates! !!GPoint methodsFor: 'comparing'!=~ aPoint	^ (self distanceTo: aPoint) =~ 0! !!GPoint methodsFor: 'arithmetic'!additionWithVector: aGVector	^ self + aGVector! !!GPoint methodsFor: 'converting'!asGPoint	^ self! !!GPoint methodsFor: 'accessing'!coordinates	^ coordinates! !!GPoint methodsFor: 'accessing'!coordinates: anObject	coordinates := anObject! !!GPoint methodsFor: 'comparing'!distanceTo: aGPoint 	"Answer the distance between aPoint and the receiver.		The distance between two points is the length of the vector transposing v1 into v2"		^ (self - aGPoint) length! !!GPoint methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ coordinates hash squared "Try to avoid collisions with GAbstractCoordinates"! !!GPoint methodsFor: 'testing'!includes: aGPoint	^ aGPoint =~ self! !!GPoint methodsFor: 'intersections'!intersectionsWith: anElement	^ anElement intersectionsWithPoint: self! !!GPoint methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse 	^ aGEllipse intersectionsWithPoint: self! !!GPoint methodsFor: 'intersections'!intersectionsWithLine: aGLine 	^ aGLine intersectionsWithPoint: self! !!GPoint methodsFor: 'accessing'!length	"https://math.stackexchange.com/questions/1936865/what-is-the-length-of-a-point-on-the-real-number-line"	^ 0! !!GPoint methodsFor: 'transformations'!rotateBy: aGAngle	"Rotate the point around the origin (0,0) of the plan.		This will change the receiver. To get a new point use #rotatedBy:.		This is only valid for 2D points."	self rotateBy: aGAngle about: 0 , 0! !!GPoint methodsFor: 'transformations'!rotateBy: aGAngle about: aGPoint	"Rotate the point around the another point of the plan.		This will change the receiver. To get a new point use #rotatedBy:about:.		This is only valid for 2D points."	| cos sin diffX diffY |	cos := aGAngle cos.	sin := aGAngle sin.	diffX := self x - aGPoint x.	diffY := self y - aGPoint y.	self x: cos * diffX - (sin * diffY) + aGPoint x.	self y: sin * diffX + (cos * diffY) + aGPoint y! !!GPoint methodsFor: 'transformations'!rotatedBy: aGAngle	"Rotate the point around the origin (0,0) of the plan.		This will return a new point. To change the receiver use #rotateBy:.		This is only valid for 2D points."	^ self rotatedBy: aGAngle about: 0 , 0! !!GPoint methodsFor: 'transformations'!rotatedBy: aGAngle about: aGPoint	"Rotate the point around another point of the plan.		This will return a new point. To change the receiver use #rotateBy:about:.		This is only valid for 2D points."	| cos sin diffX diffY |	cos := aGAngle cos.	sin := aGAngle sin.	diffX := self x - aGPoint x.	diffY := self y - aGPoint y.	^ cos * diffX - (sin * diffY) + aGPoint x , (sin * diffX + (cos * diffY) + aGPoint y)! !!GPoint methodsFor: 'accessing'!segment: aPoint 	^ GSegment with: self with: aPoint ! !!GPoint methodsFor: 'transforming'!translateBy: aVector 	"Answer a Point translated by a vector."	coordinates := coordinates + aVector coordinates! !!GRay class methodsFor: 'instance creation'!origin: aGPoint direction: anotherPoint	^ self new		initialPoint: aGPoint;		directionPoint: anotherPoint;		yourself! !!GRay methodsFor: 'comparing'!= aRay	self == aRay ifTrue: [ ^ true ].	self class = aRay class ifFalse: [ ^ false ].	^ self initialPoint =~ aRay initialPoint and: [ (self angleWith: aRay) isZero ]! !!GRay methodsFor: 'arithmetic'!angleWith: aGRay 	^ (self directionPoint - self initialPoint) angleWith: (aGRay directionPoint - aGRay initialPoint)! !!GRay methodsFor: 'converting'!asGLine	^ GLine through: self initialPoint and: self directionPoint! !!GRay methodsFor: 'accessing'!directionPoint	^ directionPoint ! !!GRay methodsFor: 'accessing'!directionPoint: aGPoint	directionPoint := aGPoint asGPoint! !!GRay methodsFor: 'properties'!flipped	^ self class origin: self initialPoint direction: initialPoint + (initialPoint - directionPoint)! !!GRay methodsFor: 'comparing'!hash	"We define the hash by its origin and the angle the ray has with the x axis."	^ self initialPoint hash bitXor: (self directionPoint - self initialPoint angleWith: {1 . 1} asGVector) hash! !!GRay methodsFor: 'testing'!includes: aPoint	^ ((self directionPoint - self initialPoint) angleWith: (aPoint - self initialPoint)) isZero! !!GRay methodsFor: 'accessing'!initialPoint 	^ initialPoint! !!GRay methodsFor: 'accessing'!initialPoint: aGPoint	initialPoint := aGPoint asGPoint! !!GRay methodsFor: 'intersections'!intersectionsWith: anElement	^ anElement intersectionsWithRay: self! !!GRay methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse		^ aGEllipse intersectionsWithRay: self! !!GRay methodsFor: 'intersections'!intersectionsWithLine: aGLine	^ aGLine intersectionsWithRay: self! !!GRay methodsFor: 'accessing'!length	"A ray is not finite."	^ Float infinity! !!GRay methodsFor: 'transforming'!translateBy: aGVector 	initialPoint := initialPoint + aGVector.	directionPoint := directionPoint + aGVector! !!GSegment class methodsFor: 'instance creation'!with: aPoint1 with: aPoint2	^ self new		v1: aPoint1;		v2: aPoint2;		yourself! !!GSegment methodsFor: 'comparing'!= aSegment	self == aSegment ifTrue: [ ^ true ].	self class = aSegment class ifFalse: [ ^ false ].		^ (v1 =~ aSegment v1 and: [ v2 =~ aSegment v2 ])		or: [ v1 =~ aSegment v2 and: [ v2 =~ aSegment v1 ] ]! !!GSegment methodsFor: 'arithmetic'!angleWith: aSegment	^ self v1 - self v2 angleWith: aSegment v1 - aSegment v2! !!GSegment methodsFor: 'properties'!asGLine	^ GLine through: v1 and: v2! !!GSegment methodsFor: 'properties'!distanceTo: aGPoint	self flag: #todo.	"«The distance between segments and rays may not be the same as the distance between their extended lines. » http://geomalgorithms.com/a07-_distance.html		So apparently this implementation is wrong."	^ self asGLine distanceTo: aGPoint! !!GSegment methodsFor: 'initialization'!hash	^ v1 hash bitXor: v2 hash! !!GSegment methodsFor: 'properties'!includes: aGPoint	"The point is on the segment if the sum of the distance from v1 to aGPoint and the distance of a GPoint to v2 is my length"	^ (v2 distanceTo: aGPoint) + (aGPoint distanceTo: v1) =~ self length! !!GSegment methodsFor: 'intersections'!intersectionsWith: anElement	^ anElement intersectionsWithSegment: self! !!GSegment methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse 	^ aGEllipse intersectionsWithSegment: self! !!GSegment methodsFor: 'intersections'!intersectionsWithLine: aLine	^ aLine intersectionsWithSegment: self! !!GSegment methodsFor: 'properties'!length	"The distance between two points is the length of the vector transposing v1 into v2"	^ (v2 - v1) length! !!GSegment methodsFor: 'properties'!midPoint	^ ((v1 coordinates + v2 coordinates) / 2) asGPoint! !!GSegment methodsFor: 'properties'!perpendicularBisector	self flag: #todo.	"This is only for 2D. We should rely on GPoints to be able to do it for n-dimensions."	^ GLine a: v2 x - v1 x b: v2 y - v1 y c: (v1 x * v1 x - (v2 x * v2 x) + (v1 y * v1 y) - (v2 y * v2 y)) / 2! !!GSegment methodsFor: 'printing'!printOn: aStream	v1 coordinates printOn: aStream.	aStream nextPutAll: '>-<'.	v2 coordinates printOn: aStream! !!GSegment methodsFor: 'transforming'!translateBy: aGVector 	v1 := v1 + aGVector.	v2 := v2 + aGVector! !!GSegment methodsFor: 'accessing'!v1	^ v1! !!GSegment methodsFor: 'accessing'!v1: aGPoint	v1 := aGPoint asGPoint! !!GSegment methodsFor: 'accessing'!v2	^ v2! !!GSegment methodsFor: 'accessing'!v2: aGPoint	v2 := aGPoint asGPoint! !!GSegment methodsFor: 'initialization'!vertices	^ { v1 . v2 }! !!GElement class methodsFor: 'testing'!isAbstract	^ self = GElement! !!GElement methodsFor: 'testing'!boundaryContains: aPoint	"Should return true if the boundaries of the element contains the point. Else it should return false.		For 1D elements it is equivalent to #includes:"	^ self subclassResponsibility! !!GElement methodsFor: 'testing'!boundaryContainsAny: points	^ points anySatisfy: [ :point | self boundaryContains: point ]! !!GElement methodsFor: 'testing'!boundaryContainsWhichOf: points	^ points select: [ :point | self boundaryContains: point ]! !!GElement methodsFor: 'testing'!contains: aPoint	"Return true if the element includes the argument but not in its boundaries.		Will always be false for 1D elements."	self flag: #todo. "Maybe later we could use double dispatch to be able to do something like `aPolygon contains: aCricle` like with intersections"	^ (self includes: aPoint) and: [ (self boundaryContains: aPoint) not ]! !!GElement methodsFor: 'testing'!includes: aPoint	"I should return true if the points is contained in the element including the boundaries. Else I will answer false."	self flag: #todo. "Maybe later we could use double dispatch to be able to do something like `aPolygon includes: aCricle` like with intersections"	^ self subclassResponsibility! !!GElement methodsFor: 'intersections'!intersectionsWith: anElement	"We should use double dispatch to find intersection points"	^ self subclassResponsibility! !!GElement methodsFor: 'intersections'!intersectionsWithArc: anArc	^ (self intersectionsWithEllipse: (GCircle center: anArc center radius: anArc radius)) select: [ :point | anArc includes: point ]! !!GElement methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse	"I should return the intersection points between me and an ellipse"		^ self subclassResponsibility! !!GElement methodsFor: 'intersections'!intersectionsWithLine: aGLine	"I should return the intersection points between me and a line"		^ self subclassResponsibility! !!GElement methodsFor: 'intersections'!intersectionsWithPoint: aPoint	^ (self boundaryContains: aPoint) ifTrue: [ {aPoint} ] ifFalse: [ {} ]! !!GElement methodsFor: 'intersections'!intersectionsWithPolygon: aGPolygon	^ (aGPolygon edges flatCollect: [ :segment | segment intersectionsWith: self ]) asSet! !!GElement methodsFor: 'intersections'!intersectionsWithRay: aGRay	^ (aGRay asGLine intersectionsWith: self) select: [ :point | aGRay includes: point ]! !!GElement methodsFor: 'intersections'!intersectionsWithSegment: aGSegment	^ (aGSegment asGLine intersectionsWith: self) select: [ :point | aGSegment includes: point ]! !!GElement methodsFor: 'transforming'!translateBy: aPoint	"Translate the shape by a delta defined by a point."		self subclassResponsibility! !!GCircle class methodsFor: 'instance creation'!center: aPoint1 radius: aNumber	^ self center: aPoint1 vertex: aPoint1 x , (aPoint1 y + aNumber) coVertex: aPoint1 x + aNumber , aPoint1 y! !!GCircle methodsFor: 'comparing'!boundaryContains: aPoint	^ self radius =~ (self center distanceTo: aPoint)! !!GCircle methodsFor: 'accessing'!perimeter	^ 2π * self radius! !!GCircle methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: ('x² + y² = {1}²' format: {self radius})! !!GCircle methodsFor: 'accessing'!radius	^ self semiMajorAxisLength! !!GCircle methodsFor: 'public interface'!upperPoint	^ center x , ( center y + self radius )! !!GEllipse class methodsFor: 'instance creation'!center: aGPoint vertex: aGPoint2 coVertex: aGPoint3	^ self new		center: aGPoint;		vertex: aGPoint2;		coVertex: aGPoint3;		yourself! !!GEllipse methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].		^ vertex =~ anObject vertex and: [ center =~ anObject center and: [ coVertex =~ anObject coVertex ] ]! !!GEllipse methodsFor: 'accessing'!area	"pi * a * b"	^ (self semiMajorAxisLength * self semiMinorAxisLength)π! !!GEllipse methodsFor: 'testing'!boundaryContains: aPoint	"Solution from: https://math.stackexchange.com/questions/76457/check-if-a-point-is-within-an-ellipse"	^ (aPoint x - center x) squared / self semiMajorAxisLength squared + ((aPoint y - center y) squared / self semiMinorAxisLength squared) = 1! !!GEllipse methodsFor: 'accessing'!center	^ center! !!GEllipse methodsFor: 'accessing'!center: anObject	center := anObject! !!GEllipse methodsFor: 'accessing'!coVertex	^ coVertex! !!GEllipse methodsFor: 'accessing'!coVertex: anObject	coVertex := anObject! !!GEllipse methodsFor: 'accessing'!encompassingRectangle	| radiuxPoints |	radiuxPoints := { vertex . (center + (center - vertex)). coVertex . (center + (center - coVertex)) } collect: #coordinates.	^ GRectangle origin: (radiuxPoints fold: [ :pt1 :pt2 | pt1 upperLimitsWith: pt2 ]) asGPoint corner: (radiuxPoints fold: [ :pt1 :pt2 | pt1 lowerLimitsWith: pt2 ]) asGPoint! !!GEllipse methodsFor: 'transforming'!fitInExtent: extent	| scales |	scales := extent coordinatesWith: self encompassingRectangle extent coordinates collect: [ :number1 :number2 | number1 / number2 ].	vertex := ((vertex - center) coordinates coordinatesWith: scales collect: [ :a :b | a * b ]) asGVector + center.	coVertex := ((coVertex - center) coordinates coordinatesWith: scales collect: [ :a :b | a * b ]) asGVector + center! !!GEllipse methodsFor: 'accessing'!foci	^ self majorAxis asGLine intersectionsWith: (GCircle center: center radius: self fociLocation)! !!GEllipse methodsFor: 'accessing'!fociLocation	"c² = a² - b²"	^ (self semiMajorAxisLength squared - self semiMinorAxisLength squared) sqrt! !!GEllipse methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ vertex hash bitXor: (center hash bitXor: coVertex hash)! !!GEllipse methodsFor: 'testing'!includes: aPoint	"Solution from: https://math.stackexchange.com/questions/76457/check-if-a-point-is-within-an-ellipse"	^ (aPoint x - center x) squared / self semiMajorAxisLength squared + ((aPoint y - center y) squared / self semiMinorAxisLength squared) <= 1! !!GEllipse methodsFor: 'intersections'!intersectionsWith: anElement	^ anElement intersectionsWithEllipse: self! !!GEllipse methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse	"And also tested"	self shouldBeImplemented! !!GEllipse methodsFor: 'intersections'!intersectionsWithLine: aGLine	"	http://www.ambrsoft.com/TrigoCalc/Circles2/Ellipse/EllipseLine.htm		Ellipse: ((x-h)²/a²) + ((y - k)²/b²) = 1	Line: y = mx + c	"	| h k a b m c e t a2m2 ab a2 b2 m2 k2 t2 tk sqrt abm x1 x2 y1 y2 sqrtContent |		"If b = 0 this is a vertical line"	aGLine b = 0 ifTrue: [ ^ self intersectionsWithVerticalLine: aGLine ].		h := center x.	k := center y.	a := self semiMajorAxisLength.	b := self semiMinorAxisLength.	m := aGLine a / aGLine b negated.	c := aGLine c / aGLine b negated.	e := c - k.	t := c + (m * h).	ab := a * b.	abm := ab * m.	a2 := a squared.	b2 := b squared.	m2 := m squared.	k2 := k squared.	t2 := t squared.	a2m2 := a2 * m2.	tk := t * k.	sqrtContent := (a2m2 + b2 - t2 - k2 + (2 * tk)).	sqrtContent >= 0 ifFalse: [ ^ {  } ]. "No intersections"	sqrt := (a2m2 + b2 - t2 - k2 + (2 * tk)) sqrt.	x1 := (h * b2 - (m * a2 * e) + (ab * sqrt)) / (a2m2 + b2).	x2 := (h * b2 - (m * a2 * e) - (ab * sqrt)) / (a2m2 + b2).	y1 := (b2 * t + (k * a2m2) + (abm * sqrt)) / (a2m2 + b2).	y2 := (b2 * t + (k * a2m2) - (abm * sqrt)) / (a2m2 + b2).	^ {(x1 , y1) . (x2 , y2)} asSet! !!GEllipse methodsFor: 'intersections'!intersectionsWithVerticalLine: aGLine	"	Ellipse: ((x-h)²/a²) + ((y - k)²/b²) = 1	Line: x = -c/a 	"	| h k a2 b2 x sqrt y1 y2 tmp tmp2 |	h := center x.	k := center y.	a2 := self semiMajorAxisLength squared.	b2 := self semiMinorAxisLength squared.	x := aGLine c negated / aGLine a.	tmp := (x - h) squared / a2.	tmp2 := (b2 * (1 - tmp)).		"I am not sure this is correct but I have the impression that if this is negative, there is no intersection."	tmp2 < 0 ifTrue: [ ^ {  } ].		sqrt := tmp2 sqrt.	y1 := k + sqrt.	y2 := k - sqrt.	^ {(x , y1) . (x , y2)} asSet! !!GEllipse methodsFor: 'accessing'!majorAxis	^ GSegment with: center + (center - vertex) with: center + (vertex - center)! !!GEllipse methodsFor: 'accessing'!majorAxisLength	^ self majorAxis length! !!GEllipse methodsFor: 'accessing'!minorAxis	^ GSegment with: center + (center - coVertex) with: center + (coVertex - center)! !!GEllipse methodsFor: 'accessing'!minorAxisLength	^ self minorAxis length! !!GEllipse methodsFor: 'accessing'!perimeter	"The perimeter of an ellipse cannot be calculated easily. This method will give an approximation with Ramanujan II"	| h semiMajorAndMinorLength |	semiMajorAndMinorLength := self semiMajorAxisLength + self semiMinorAxisLength.	h := (self semiMajorAxisLength - self semiMinorAxisLength) squared / semiMajorAndMinorLength squared.	^ (semiMajorAndMinorLength * (1 + (3 * h / (10 + (4 - (3 * h)) squared))))π! !!GEllipse methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: ('((x - {1})²/{2}) + ((y - {3})²/{4}) = 1' format: {center x . self semiMajorAxisLength squared . center y . self semiMinorAxisLength squared})! !!GEllipse methodsFor: 'accessing'!semiMajorAxisLength	^ self majorAxis length / 2! !!GEllipse methodsFor: 'accessing'!semiMinorAxisLength	^ self minorAxis length / 2! !!GEllipse methodsFor: 'transforming'!translateBy: aGVector 	center translateBy: aGVector.	vertex translateBy: aGVector.	coVertex translateBy: aGVector! !!GEllipse methodsFor: 'accessing'!vertex	^ vertex! !!GEllipse methodsFor: 'accessing'!vertex: anObject	vertex := anObject! !!GPolygon class methodsFor: 'as yet unclassified'!convexHullOn: aCollection	| lastPoint nextPoint convexHull |	"self halt."	convexHull := OrderedCollection new.	nextPoint := aCollection detectMin: #x.	[ lastPoint := nextPoint.	convexHull add: lastPoint.	nextPoint := aCollection detect: [ :point | point ~= lastPoint ].	(aCollection copyWithout: nextPoint)		do: [ :point | 			| turn |			turn := (nextPoint x - lastPoint x) * (point y - lastPoint y)				- ((point x - lastPoint x) * (nextPoint y - lastPoint y)).			(turn < 0				or: [ turn = 0						and: [ (lastPoint distanceTo: point) > (lastPoint distanceTo: nextPoint) ] ])				ifTrue: [ nextPoint := point ] ] ]		doWhileTrue: [ convexHull first ~= nextPoint ].	^ self vertices: convexHull! !!GPolygon class methodsFor: 'instance creation'!newRegularPolygonWithEdgeNumber: aNumber	"I return the polygon vertices for a regular polygon with a number of segment given as parameter.		If Y give 8 as parameter I get an octogon."	| angle encompassingCircleRadius |	angle := 2π / aNumber.	encompassingCircleRadius := 0.5.	^ self newVertices: ((1 to: aNumber) collect: [ :index | ((encompassingCircleRadius + index) * angle) sin , ((encompassingCircleRadius + index) * angle) cos negated ])! !!GPolygon class methodsFor: 'instance creation'!newVertices: aCollection	self deprecated: 'Use #vertices: instead' transformWith: '`@receiver newVertices: `@statements' -> '`@receiver vertices: `@statements'.	^ self vertices: aCollection! !!GPolygon class methodsFor: 'instance creation'!vertices: aCollection	^ self new		vertices: aCollection;		yourself! !!GPolygon methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ vertices = anObject vertices! !!GPolygon methodsFor: 'testing'!boundaryContains: aGPoint 	^ self edges anySatisfy: [ :segment | segment includes: aGPoint ]! !!GPolygon methodsFor: 'accessing'!edges	| edges |	edges := (self vertices overlappingPairsCollect: [ :point1 :point2 | (GSegment with: point1 with: point2) ]) asOrderedCollection.	edges add: (GSegment with: self vertices last with: self vertices first).	^ edges! !!GPolygon methodsFor: 'accessing'!encompassingRectangle	| origin corner |	origin := ((self vertices collect: #coordinates) fold: [ :coor1 :coor2 | coor1 lowerLimitsWith: coor2 ]) asGPoint.	corner := ((self vertices collect: #coordinates) fold: [ :coor1 :coor2 | coor1 upperLimitsWith: coor2 ]) asGPoint.	^ GRectangle origin: origin corner: corner! !!GPolygon methodsFor: 'rectangle functions'!expandBy: anInteger	self fitInExtent: self extent + (2 * {anInteger . anInteger} asGVector)! !!GPolygon methodsFor: 'transforming'!fitInExtent: extent	"I take as parameter a point and will fit the polygon in a rectangle whose dimensions is defined by the extent."	| scales |	scales := extent coordinatesWith: self encompassingRectangle extent coordinates collect: [ :number1 :number2 | number1 / number2 ].	vertices := self vertices collect: [ :vertice | ((vertice - self center) coordinates coordinatesWith: scales collect: [ :a :b | a * b ]) asGVector + self center ]! !!GPolygon methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ vertices hash bitXor: self class hash! !!GPolygon methodsFor: 'testing'!includes: aPoint	" Thanks to Google and Randolph Franklin i don't have to reinvent this very simple algorithm. See [ 1 ] for details, copyrights etc.	https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html"	| inside testX testY j |	inside := false.	j := self vertices size.	testX := aPoint x.	testY := aPoint y.	self vertices doWithIndex: [ :pi :i | 		| pj |		pj := self vertices at: j.		(pi y > testY ~= (pj y > testY) and: [ testX < ((pj x - pi x) * (testY - pi y) / (pj y - pi y) + pi x) ]) ifTrue: [ inside := inside not ].		j := i ].	^ inside! !!GPolygon methodsFor: 'intersections'!intersectionsWith: anElement	^ anElement intersectionsWithPolygon: self! !!GPolygon methodsFor: 'intersections'!intersectionsWithEllipse: aGEllipse	^ aGEllipse intersectionsWithPolygon: self! !!GPolygon methodsFor: 'intersections'!intersectionsWithLine: aGLine	^ aGLine intersectionsWithPolygon: self! !!GPolygon methodsFor: 'accessing'!perimeter	^ self edges sum: #length! !!GPolygon methodsFor: 'transforming'!scaleBy: anInteger	anInteger <= 0 ifTrue: [ self error: 'Scale must be over zeo' ].	vertices := self vertices collect: [ :vertice | (vertice - self center) * anInteger + self center ]! !!GPolygon methodsFor: 'transforming'!translateBy: aPoint	"Move a polygon by a delta defined by aPoint"	vertices := self vertices collect: [ :point | point + aPoint ]! !!GPolygon methodsFor: 'accessing'!vertices		^ vertices! !!GPolygon methodsFor: 'accessing'!vertices: aCollection	vertices := aCollection collect: #asGPoint! !!GRectangle class methodsFor: 'instance creation'!left: left right: right top: top bottom: bottom	"Answer an instance of me whose left, right, top, and bottom coordinates 	are determined by the arguments."	| origin corner |	origin := (left min: right) @ (top min: bottom).	corner := (left max: right) @ (top max: bottom).	^ self origin: origin corner: corner! !!GRectangle class methodsFor: 'instance creation'!origin: point1 corner: point2	"Answer an instance of me whose corners (top left and bottom right) are 	determined by the arguments."	| or cor |	or := (point1 x min: point2 x) , (point1 y min: point2 y).	cor := (point1 x max: point2 x) , (point1 y max: point2 y).		or = cor ifTrue: [ self error: 'This is not a rectangle but a point.' ].		^ self vertices: { or . (cor x , or y). cor. (or x , cor y) }! !!GRectangle class methodsFor: 'instance creation'!vertices: aCollection	| rectangle edges |		aCollection size = 4 ifFalse: [ self error: 'A Rectangle should have 4 vertices.' ].		rectangle := super vertices: aCollection.		edges := rectangle edges.		(((edges at: 1) length = (edges at: 3) length) and: [ ((edges at: 2) length = (edges at: 4) length) ]) ifFalse: [ self error: 'This is not a rectangle but a parallelogram' ].		^ rectangle! !!GRectangle methodsFor: 'accessing'!area	"Answer the receiver's area, the product of width and height."	^ self width * self height max: 0! !!GRectangle methodsFor: 'accessing'!center	"Answer the point at the center of the receiver."	^ self diagonals anyOne midPoint! !!GRectangle methodsFor: 'accessing'!diagonals	^ {((self vertices at: 1) segment: (self vertices at: 3)).	((self vertices at: 2) segment: (self vertices at: 4))}! !!GRectangle methodsFor: 'accessing'!extent	"Answer a vector representing the extent of my encompassing rectangle."	| verticesCoordinates encompassingRectangleOrigin encompassingRectangleCorner |	verticesCoordinates := self vertices collect: #coordinates.	encompassingRectangleOrigin := verticesCoordinates fold: [:coor1 :coor2 | coor1 upperLimitsWith: coor2].	encompassingRectangleCorner := verticesCoordinates fold: [:coor1 :coor2 | coor1 lowerLimitsWith: coor2].	^ (encompassingRectangleOrigin - encompassingRectangleCorner) asGVector! !!GRectangle methodsFor: 'accessing'!height	"Answer the height of the receiver."	^ (self vertices at: 2) distanceTo: (self vertices at: 3)! !!GRectangle methodsFor: 'accessing'!width	"Answer the width of the receiver."	^ (self vertices at: 2) distanceTo: (self vertices at: 1)! !!GTriangle class methodsFor: 'instance creation'!vertices: aCollection		aCollection size = 3 ifFalse: [ self error: 'A triangle should have 3 vertices.' ].	^ super vertices: aCollection! !!GTriangle class methodsFor: 'instance creation'!with: aPoint1 with: aPoint2 with: aPoint3	^ self vertices: { aPoint1. aPoint2. aPoint3 }! !!GTriangle methodsFor: 'properties'!area	| semiperimeter|	semiperimeter := self semiperimeter.	^ (self edges 		inject: semiperimeter		into: [ :subProduct :edge |			(semiperimeter - edge length) * subProduct ]) sqrt! !!GTriangle methodsFor: 'figures'!circumscribedCircle	^ (self edges first perpendicularBisector intersectionsWith: self edges last perpendicularBisector)		ifNotEmpty: [ :points | GCircle center: points anyOne radius: (self v1 distanceTo: self v2) * (self v2 distanceTo: self v3) * (self v3 distanceTo: self v1) / (4 * self area) ]! !!GTriangle methodsFor: 'figures'!isDegenerate	^ (self v1 = self v2 or: [ self v1 = self v3 or: [ self v2 = self v3 ] ])		ifTrue: [ true ]		ifFalse: [ self edges first length + self edges second length = self edges third length				or: [ self edges second length + self edges third length = self edges first length or: [ self edges third length + self edges first length = self edges second length ] ] ]! !!GTriangle methodsFor: 'accessing'!v1	^ vertices at: 1! !!GTriangle methodsFor: 'accessing'!v2	^ vertices at: 2! !!GTriangle methodsFor: 'accessing'!v3	^ vertices at: 3! !!GShape class methodsFor: 'testing'!isAbstract	^ self = GShape! !!GShape methodsFor: 'accessing'!area	"Return the area of the shape"		^ self subclassResponsibility! !!GShape methodsFor: 'accessing'!center	^ self encompassingRectangle center! !!GShape methodsFor: 'accessing'!encompassingRectangle	"I should return a rectangle on the minimum size that contains the shape"		^ self subclassResponsibility! !!GShape methodsFor: 'accessing'!extent	"I return a vector representing the extent of the encompassing rectangle of the shape. I should be able to translate the corner of the encompassing rectangle to its origin."		^ self encompassingRectangle extent! !!GShape methodsFor: 'transforming'!fitInExtent: anExtent	"I should transform my shape to fit in a rectangle of size 0@0 to the extent as parameter, keeping my center.	Note that I should keep proportions. We could maybe implement another method to not keep proportions."		self subclassResponsibility! !!GShape methodsFor: 'accessing'!perimeter	"Return the perimeter of the shape"		^ self subclassResponsibility! !!GShape methodsFor: 'transforming'!scaleBy: aPoint	"Scale the shape by a delta defined by a point."		self subclassResponsibility! !!GShape methodsFor: 'properties'!semiperimeter	^ self perimeter / 2! !!GMatrix class methodsFor: 'instance creation'!rows: aCollection	^ self new		rows: aCollection;		yourself! !!GMatrix methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ rows = anObject rows! !!GMatrix methodsFor: 'accessing'!at: anInteger	^ self rows at: anInteger! !!GMatrix methodsFor: 'accessing'!at: anInteger at: anInteger2 	^ (self at: anInteger) at: anInteger2! !!GMatrix methodsFor: 'arithmetic'!determinant	self flag: #todo.	"For now this implementation is only for 2D squared matrix. We should later manage n-dimensions matrix"	^ (self at: 1 at: 1) * (self at: 2 at: 2) - ((self at: 1 at: 2) * (self at: 2 at: 1))! !!GMatrix methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ rows hash negated! !!GMatrix methodsFor: 'accessing'!rows	^ rows! !!GMatrix methodsFor: 'accessing'!rows: anObject	rows := anObject! !!GVector class methodsFor: 'instance creation'!coordinates: aCoordinates	(aCoordinates coordinates allSatisfy: [ :e | e = 0]) ifTrue: [ ^ GZeroVector coordinates: aCoordinates ].	^ self new		coordinates: aCoordinates;		yourself! !!GVector class methodsFor: 'instance creation'!withCollection: aCollection	^ self coordinates: (GCoordinates withCollection: aCollection)! !!GVector class methodsFor: 'instance creation'!x: aNumber y: anotherNumber	^ self coordinates: (G2DCoordinates x: aNumber y: anotherNumber)! !!GVector methodsFor: 'arithmetic'!* anOperand	^ anOperand multiplyWithVector: self! !!GVector methodsFor: 'arithmetic'!+ anOperand	^ anOperand additionWithVector: self! !!GVector methodsFor: 'arithmetic'!/ aGVector 	self shouldBeImplemented.! !!GVector methodsFor: 'comparing'!= anotherPoint	"Answer whether the receiver and anObject represent the same object."	self == anotherPoint ifTrue: [ ^ true ].	self class = anotherPoint class ifFalse: [ ^ false ].	^ coordinates = anotherPoint coordinates! !!GVector methodsFor: 'arithmetic'!adaptToNumber: anInteger andSend: aString 	^ self perform: aString with: anInteger! !!GVector methodsFor: 'arithmetic'!additionWithVector: aGVector	^ (self coordinates + aGVector coordinates) asGVector! !!GVector methodsFor: 'arithmetic'!angleWith: aGVector	| angle |	self flag: #todo.	"This implementation is only for 2D vectors. Later we should support it for n-dimension vectors."	self coordinates numberOfDimensions ~= 2 ifTrue: [ self error: 'For now oriented angle is only implemented for 2D vectors. Feel free to contribute.' ]. 		angle := self nonOrientedAngleWith: aGVector.	^ (GMatrix rows: {self coordinates . aGVector coordinates}) determinant > 0 ifTrue: [ angle ] ifFalse: [ angle explementary ]! !!GVector methodsFor: 'accessing'!coordinates	^ coordinates! !!GVector methodsFor: 'accessing'!coordinates: anObject	coordinates := anObject! !!GVector methodsFor: 'arithmetic'!dotProduct: aGVector	^ (self coordinatesWith: aGVector coordinates collect: [ :point1 :point2 | point1 * point2 ]) sum! !!GVector methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	| coordHash |	coordHash := coordinates hash.	^ coordHash squared + coordHash "Try to avoid collisions with GAbstractCoordinates and GPoint"! !!GVector methodsFor: 'testing'!isZeroVector	^ false! !!GVector methodsFor: 'accessing'!length	"https://onlinemschool.com/math/library/vector/length/"	^ (self coordinates inject: 0 into: [ :res :number | res + number squared ]) sqrt! !!GVector methodsFor: 'arithmetic'!multiplyWithVector: aGVector	"We should implement vector product later."		self shouldBeImplemented! !!GVector methodsFor: 'arithmetic'!nonOrientedAngleWith: aGVector	"angle = cos^-1 a . b / (|a| * |b|)"	"If we have a zero vector, delegate it the computation to avoid a zero divide."	aGVector isZeroVector ifTrue: [ ^ aGVector angleWith: self ].	^ ([ ((self dotProduct: aGVector) / (self length * aGVector length)) arcCos ]		on: DomainError		do:			[ "Sometimes we can get a Domain Error because of some missprecision of floats... In that case we will reduce the precision to get a result" ((self dotProduct: aGVector) / (self length * aGVector length) roundTo: 0.00000000000001) arcCos ]) radians! !!GZeroVector class methodsFor: 'instance creation'!coordinates: aCoordinates	^ self new		coordinates: aCoordinates;		yourself! !!GZeroVector methodsFor: 'arithmetic'!angleWith: aGVector	^ 0 radians! !!GZeroVector methodsFor: 'testing'!isZeroVector	^ true! !!GeometryObject class methodsFor: 'error handling'!error	GeometryError signal! !!GeometryObject class methodsFor: 'error handling'!error: aString	GeometryError signal: aString! !!GeometryObject methodsFor: 'error handling'!error	^ self class error! !!GeometryObject methodsFor: 'error handling'!error: aString	^ self class error: aString! !!Point methodsFor: '*Geometry'!asGPoint	^ x , y! !!Point methodsFor: '*Geometry'!asGVector	^ GVector coordinates: (G2DCoordinates x: x y: y)! !!Number class methodsFor: '*geometry'!epsilon	^ 0.00001! !!Number methodsFor: '*Geometry'!, aNumber	^ GPoint x: self y: aNumber! !!Number methodsFor: '*Geometry'!=~ aNumber 	^((self - aNumber) abs) < Number epsilon.! !!Number methodsFor: '*Geometry'!degrees	^ GAngle degrees: self! !!Number methodsFor: '*Geometry'!divideWithAngle: aGAngle 	^ (aGAngle radians / self) radians! !!Number methodsFor: '*Geometry'!multiplyWithAngle: aGAngle 	^ (aGAngle radians * self) radians! !!Number methodsFor: '*Geometry'!multiplyWithVector: aGVector 	^ (aGVector coordinates * self) asGVector! !!Number methodsFor: '*Geometry'!radians	^ GAngle radians: self! !!Number methodsFor: '*Geometry'!π	^ self * Float pi! !!Collection methodsFor: '*Geometry'!asGCoordinates	^ GCoordinates withCollection: self! !!Collection methodsFor: '*Geometry'!asGPoint	^ GPoint withCollection: self! !!Collection methodsFor: '*Geometry'!asGVector	^ GVector withCollection: self! !"Geometry"!!NSInterpolator commentStamp: '' prior: 0!I determine the correct interpolator for a kind of datamy subclasses NSColorInterpolatorNSNumberInterpolatorThe basic interpolation is between 2 values 0 and 1, usually the value between these values is called 't'!!NSAbstractInterpolator commentStamp: '' prior: 0!I have two ranges the start an the stop!!NSColorRGBAInterpolator commentStamp: '' prior: 0!I am the interpolator  for colors!!NSColorHSLAInterpolator commentStamp: '' prior: 0!reate a color with the given hue, saturation, lightness, and alpha.!!NSColorHSVAInterpolator commentStamp: '' prior: 0!Same as NSColorRGBAInterpolation but for hsva  !!NSNumberInterpolator commentStamp: '' prior: 0!I am the basic interpolator for numbers!!NSRoundInterpolator commentStamp: '' prior: 0!I am a interpolator to round numbers!!NSPowPowScale commentStamp: '' prior: 0!I am a utility clas for NSScalePow!!NSScale commentStamp: '' prior: 0!<keyClass>`NSScale` is a common scale interpolator. It transformes numerical or ordinal values using a range and a domain. `NSScale` offers several scales as class side methods. The code of the scales are inspired from https://github.com/d3/d3-scale*Responsibility*: act as a scale interpolator for numerical and ordinal values.*Collaborators*: `NSScale` depends on a number of Pharo packages, including `Colors`, `Random-Core`. The scales are intensively used by Roassal*Variables*:- `range`: contains an array of two elements. The range variable defines the range of the scaled value.- `VARIABLE2`:*Example*:```Smalltalks := NSScale linear.s range: { 5 . 10 }.s scale: 0. "=> 5"s scale: 0.5. "=> 7.5"s scale: 1. "=> 10"``````Smalltalks := NSScale linear.s domain: { -1 . 1 }.s range: { 5 . 10 }.s scale: 0.5``````Smalltalks := NSScale linear.s range: { Color white . Color black }.s scale: 0.5  "=> Color gray"```!!NSBilinearScale commentStamp: '' prior: 0!I represent a bilinear range for 2 limits, start and end!!NSLinearScale commentStamp: '' prior: 0!I follow the linear function!!NSLnScale commentStamp: '' prior: 0!I use natural logarithms to compute scales.!!NSLogScale commentStamp: '' prior: 0!for scale log, for positive domains or negative domains!!NSPowScale commentStamp: '' prior: 0!I scale using pow function!!NSSymLogScale commentStamp: '' prior: 0!I order to have a generic log scale for positive and negative log scales Inspired from https://github.com/d3/d3-scale/blob/master/src/symlog.js!!NSOrdinalScale commentStamp: '' prior: 0!I am a scale for ordinal ranges!!NSPolylinearScale commentStamp: '' prior: 0!I can handle a several kind of values!!NSUninterpolate commentStamp: '' prior: 0!I am the basic uninterpolator, my subclasses areNSUninterpolateClampNSUninterpolateNumber!!NSUninterpolateClamp commentStamp: '' prior: 0!I am a private class useful to uninterpolate a value in the range { 0. 1 }.Scales with `clamp:` should limit their ranges and domains.Example```Smalltalkx := NSScale linear	clamp: true;	domain: { -100. 100 };	range: { 500. 1000 }.x scale: 200."1000"x invert: 1250."100"``` !!NSUninterpolateNumber commentStamp: '' prior: 0!I uninterpolate a value of x acording to 2 limits, a and b without limitation!!Color methodsFor: '*NumericInterpolator'!interpolateTo: anObject at: t	| start stop |	anObject isColor ifFalse: [ ^ anObject interpolateTo: self at: 1 - t  ].	start := self.	stop := anObject.	^ self class		r: start red + ((stop red - start red) * t)		g: start green + ((stop green - start green)  * t)		b: start blue + ((stop blue - start blue) * t)		alpha: start alpha + ((stop alpha - start alpha) * t)! !!Random methodsFor: '*NumericInterpolator'!rsNext: limit	^ self rsNext: 0 and: limit.! !!Random methodsFor: '*NumericInterpolator'!rsNext: u and: v	^ NSScale linear range: {u. v}; scale: self next.! !!GradientPaint methodsFor: '*NumericInterpolator'!interpolateTo: anObject at: t	| otherRamp ramp newRamp | 	otherRamp := anObject isColor 		ifTrue: [ colorRamp collect: [ :a | anObject ] ]		ifFalse: [ anObject colorRamp ].	ramp := self colorRamp.	ramp size = otherRamp size ifFalse: [ self error: 'invalid sizes for color ramp' ].		newRamp := self colorRamp collectWithIndex: [ :a :i | | a2 |		a2 := otherRamp at: i.		a key -> (a value interpolateTo: a2 value at: t) ].	^ self copy		colorRamp: newRamp! !!NSAbstractInterpolator methodsFor: 'accessing'!start: anObject	start := anObject! !!NSAbstractInterpolator methodsFor: 'accessing'!stop: anObject	stop := anObject! !!NSColorHSLAInterpolator methodsFor: 'interpolation'!interpolate: t	^ Color		h: start hue + ((stop hue - start hue) * t)		s: start hslSaturation + ((stop hslSaturation - start hslSaturation)  * t)		l: start luminance + ((stop luminance - start luminance) * t)		alpha: start alpha + ((stop alpha - start alpha) * t)! !!NSColorHSVAInterpolator methodsFor: 'interpolation'!interpolate: t	^ Color		h: start hue + ((stop hue - start hue) * t)		s: start hsvSaturation + ((stop hsvSaturation - start hsvSaturation)  * t)		l: start luminance + ((stop luminance - start luminance) * t)		alpha: start alpha + ((stop alpha - start alpha) * t)! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!category10	^ self colorHex: #(2062260 16744206 2924588 14034728 9725885 9197131 14907330 8355711 12369186 1556175)	! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!category20	^ self colorHex: #(2062260 11454440 16744206 16759672 2924588 10018698 14034728 16750742 9725885 12955861 9197131 12885140 14907330 16234194 8355711 13092807 12369186 14408589 1556175 10410725)	! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!category20b	^ self colorHex: #(3750777 5395619 7040719 10264286 6519097 9216594 11915115 13556636 9202993 12426809 15186514 15190932 8666169 11356490 14049643 15177372 8077683 10834324 13528509 14589654)	! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!category20c	^ self colorHex: #(3244733 7057110 10406625 13032431 15095053 16616764 16625259 16634018 3253076 7652470 10607003 13101504 7695281 10394312 12369372 14342891 6513507 9868950 12434877 14277081)	! !!NSColorRGBAInterpolator class methodsFor: 'helpers'!colorHex: arr	^ arr collect: [ :value | Color colorFrom: (		(self hex: value >> 16),		(self hex: value >> 8 & 255), 		(self hex: value & 255))		 ].	! !!NSColorRGBAInterpolator class methodsFor: 'interpolation'!colorInterpolator	^ self! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!eva10	^ #('A57DBF' '562A65' 'A1DC5C' '46705C' 'B5A7DD' 'F1C123' 'C9783E' '605EA9' '730D0B' '5B5C65') 		collect: [ :s | Color colorFrom: s ].! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!google20	^ self colorHex: #(3368652 14432530 16750848 1087000 10027161 39366 14500983 6728192 12070446 3236757 10044569 2271897 11184657 6697932 15102720 9111303 6623335 3314274 5600422 3882668)! !!NSColorRGBAInterpolator class methodsFor: 'helpers'!hex: v	^ (v < 16 ifTrue: [ '0' ] ifFalse: [ '' ]), v printStringHex! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!paired12	^ self colorHex: #(10931939 2062516 11722634 3383340 16489113 14883356 16629615 16744192 13284054 6962586 16777113 11622696)! !!NSColorRGBAInterpolator class methodsFor: 'color categories'!sky8	^ self colorHex: #(13623528 12048360 8895960 14347240 12372694 9280950 6714002 15852509)! !!NSColorRGBAInterpolator methodsFor: 'interpolation'!interpolate: t	^ start interpolateTo: stop at: t! !!NSColorRGBAInterpolator methodsFor: 'interpolation'!start: anObject	start := Color colorFrom: anObject! !!NSColorRGBAInterpolator methodsFor: 'interpolation'!stop: anObject	stop := Color colorFrom: anObject! !!NSNumberInterpolator methodsFor: 'interpolation'!interpolate: t	^ (start * (1 - t)) + (stop * t).! !!NSRoundInterpolator class methodsFor: 'interpolation'!interpolate: a and: b	^ self new start: a; stop: b.! !!NSRoundInterpolator methodsFor: 'interpolation'!interpolate: t	^  (start + (stop * t)) rounded! !!NSRoundInterpolator methodsFor: 'accessing'!stop: b	stop := b - start! !!NSInterpolator class methodsFor: 'interpolation'!colorInterpolator	^ NSColorRGBAInterpolator! !!NSInterpolator class methodsFor: 'interpolation'!interpolate: a and: b	| clazz |	clazz := self interpolatorFor: b.	^ clazz new start: a; stop: b.! !!NSInterpolator class methodsFor: 'interpolation'!interpolatorFor: b	(b isString or: [ b isColor ]) ifTrue: [ ^ self colorInterpolator ].	b isNumber ifTrue: [ ^ NSNumberInterpolator ].	b isPoint ifTrue: [ ^ NSNumberInterpolator ].	self error: 'Invalid value for interpolator'! !!NSInterpolator methodsFor: 'interpolation'!interpolate: anObject	self subclassResponsibility! !!NSPowPowScale class methodsFor: 'instance creation'!exponent: exponent	^ self new 		exponent: exponent;		yourself! !!NSPowPowScale methodsFor: 'accessing'!exponent: aNumber	exponent := aNumber! !!NSPowPowScale methodsFor: 'transformations'!scale: x	^ x < 0		ifTrue: [ (x negated raisedTo: exponent) negated ]		ifFalse: [ x raisedTo: exponent ]! !!NSBilinearScale methodsFor: 'transformation'!invert: anObject	self shouldNotImplement! !!NSBilinearScale methodsFor: 'hooks'!rescale	u := uninterpolate uninterpolate: domain first and: domain second.	i := interpolate interpolate: range first and: range second.! !!NSBilinearScale methodsFor: 'transformation'!scale: x	^ i interpolate: (u uninterpolate: x)! !!NSLinearScale methodsFor: 'accessing'!clamp	^ clamp! !!NSLinearScale methodsFor: 'accessing'!clamp: aBool	"If clamp is specified, enables or disables clamping accordingly. If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the return value of the scale is always within the scale’s range."	clamp := aBool.	self rescale.! !!NSLinearScale methodsFor: 'accessing'!domain: x	super domain: x.	self rescale.! !!NSLinearScale methodsFor: 'initialization'!initialize	super initialize.	range := domain := #(0 1).	clamp := false.	interpolate := NSInterpolator.	self rescale.! !!NSLinearScale methodsFor: 'accessing'!input	^ input! !!NSLinearScale methodsFor: 'accessing'!interpolate: x	interpolate := x.	self rescale.! !!NSLinearScale methodsFor: 'transformation'!invert: y	^ input scale: y.! !!NSLinearScale methodsFor: 'accessing'!output	^ output! !!NSLinearScale methodsFor: 'accessing'!range: r	super range: r.	self rescale.! !!NSLinearScale methodsFor: 'accessing'!rangeRound: x	"x is a range"	self 		range: x;		interpolate: NSRoundInterpolator.! !!NSLinearScale methodsFor: 'hooks'!rescale	| linear |	linear := (domain size min: range size ) > 2		ifTrue: [ NSPolylinearScale ]		ifFalse: [ NSBilinearScale ].	uninterpolate := clamp		ifTrue: [ NSUninterpolateClamp ]		ifFalse: [ NSUninterpolateNumber ].	output := linear new domain: domain; range: range; 		uninterpolate: uninterpolate; interpolate: interpolate.	output rescale.	input := linear new domain: range; range: domain;		uninterpolate: uninterpolate; interpolate: NSInterpolator.	input rescale.! !!NSLinearScale methodsFor: 'transformation'!scale: x	^ output scale: x! !!NSLnScale methodsFor: 'accessing'!clamp	^ linear clamp! !!NSLnScale methodsFor: 'accessing'!clamp: x	 linear clamp: x! !!NSLnScale methodsFor: 'accessing'!domain: arr	domain := arr collect: [:i | i max: Float epsilon ].	linear domain: (domain collect: [:n | n ln ]).! !!NSLnScale methodsFor: 'accessing'!initialize	super initialize.	linear := self class linear.! !!NSLnScale methodsFor: 'accessing'!interpolate	^ linear interpolate! !!NSLnScale methodsFor: 'accessing'!interpolate: x	linear interpolate: x! !!NSLnScale methodsFor: 'accessing'!invert: x	^ (linear invert: x) exp.! !!NSLnScale methodsFor: 'accessing'!range	^ linear range! !!NSLnScale methodsFor: 'accessing'!range: x	linear range: x! !!NSLnScale methodsFor: 'accessing'!scale: x	^ linear scale: (x max: Float epsilon) ln! !!NSLogScale methodsFor: 'accessing'!base	^ base! !!NSLogScale methodsFor: 'accessing'!base: number	base := number.	linear domain: (domain collect: [:n | self lg: n ]).! !!NSLogScale methodsFor: 'accessing'!clamp	^ linear clamp! !!NSLogScale methodsFor: 'accessing'!clamp: x	 linear clamp: x! !!NSLogScale methodsFor: 'accessing'!domain: arr	positive := arr first >= 0.	domain := arr.	linear domain: (arr collect: [:n | self lg: n]).! !!NSLogScale methodsFor: 'initialization'!initialize	super initialize.	linear := self class linear.	base := 10.	positive := true.	domain := #(1 0).! !!NSLogScale methodsFor: 'accessing'!interpolate	^ linear interpolate! !!NSLogScale methodsFor: 'accessing'!interpolate: x	linear interpolate: x! !!NSLogScale methodsFor: 'transformation'!invert: x	^ self pow: (linear invert: x).! !!NSLogScale methodsFor: 'math functions'!lg: x	"logarithm"	^ (positive 		ifTrue: [ (x max: 0) ln ]		ifFalse: [ (x > 0 			ifTrue: [ 0 ] 			ifFalse: [ 0 - x ] ) ln negated ])		/ (base ln).		! !!NSLogScale methodsFor: 'math functions'!pow: x	^ positive  		ifTrue: [ base raisedTo: x ]		ifFalse: [ (base raisedTo: x negated) negated ].		! !!NSLogScale methodsFor: 'accessing'!range	^ linear range! !!NSLogScale methodsFor: 'accessing'!range: x	linear range: x! !!NSLogScale methodsFor: 'transformation'!scale: x	^ linear scale: (self lg: x)! !!NSLogScale methodsFor: 'accessing'!uninterpolate	^ linear uninterpolate! !!NSLogScale methodsFor: 'accessing'!uninterpolate: anUninterolator	linear uninterpolate: anUninterolator! !!NSPowScale methodsFor: 'accessing'!clamp	^ linear clamp! !!NSPowScale methodsFor: 'accessing'!clamp: x	linear clamp: x! !!NSPowScale methodsFor: 'accessing'!domain: x	linear domain: ((domain := x) collect: [ :i | powp scale: i ]).! !!NSPowScale methodsFor: 'accessing'!exponent	^ exponent! !!NSPowScale methodsFor: 'accessing'!exponent: x	exponent := x.	powp exponent: exponent.	powb exponent: 1/exponent.	linear domain: (domain collect: [ :i | powp scale: i ])! !!NSPowScale methodsFor: 'initialization'!initialize	super initialize.	linear := self class linear.	exponent := 1.	domain := #(0 1).	powp := NSPowPowScale exponent: exponent.	powb := NSPowPowScale exponent: 1 / exponent.! !!NSPowScale methodsFor: 'initialization'!interpolate	^ linear interpolate! !!NSPowScale methodsFor: 'initialization'!interpolate: x	linear interpolate: x! !!NSPowScale methodsFor: 'initialization'!invert: x	^ powb scale: (linear invert: x)! !!NSPowScale methodsFor: 'initialization'!range	^ linear range! !!NSPowScale methodsFor: 'initialization'!range: x	linear range: x! !!NSPowScale methodsFor: 'initialization'!rescale! !!NSPowScale methodsFor: 'initialization'!scale: x	^ linear scale: (powp scale: x)! !!NSSymLogScale methodsFor: 'accessing'!clamp	^ linear clamp! !!NSSymLogScale methodsFor: 'accessing'!clamp: x	 linear clamp: x! !!NSSymLogScale methodsFor: 'accessing'!constant	^ constant! !!NSSymLogScale methodsFor: 'accessing'!constant: aNumber	constant := aNumber.! !!NSSymLogScale methodsFor: 'accessing'!domain: arr	domain := arr.	linear domain: (arr collect: [ :i | self transformSymLog: i ]).! !!NSSymLogScale methodsFor: 'initialization'!initialize	super initialize.	self constant: 1.	linear := self class linear.! !!NSSymLogScale methodsFor: 'accessing'!interpolate	^ linear interpolate! !!NSSymLogScale methodsFor: 'accessing'!interpolate: x	linear interpolate: x! !!NSSymLogScale methodsFor: 'accessing'!invert: x	^ self transformSymExp: (linear invert: x).! !!NSSymLogScale methodsFor: 'accessing'!range	^ linear range! !!NSSymLogScale methodsFor: 'accessing'!range: x	linear range: x.! !!NSSymLogScale methodsFor: 'accessing'!scale: x	^ linear scale: (self transformSymLog: x)! !!NSSymLogScale methodsFor: 'accessing'!transformSymExp: x	^ x sign *  (1.0 + x abs) exp * constant! !!NSSymLogScale methodsFor: 'accessing'!transformSymLog: x	^ x sign * (1.0 + (x / constant) abs) ln! !!NSOrdinalScale methodsFor: 'accessing'!dictionary 	^ dictionary ! !!NSOrdinalScale methodsFor: 'accessing'!domain: arr	domain := OrderedCollection new.	dictionary := Dictionary new.	arr do: [ :xi |		(dictionary includesKey: xi) ifFalse: [ 			domain add: xi.			dictionary at: xi put: domain size ] ].	self perform: ranger withArguments: argument! !!NSOrdinalScale methodsFor: 'initialization'!initialize	super initialize.	ranger := #range:.	argument := #( #() ).	self domain: #().		! !!NSOrdinalScale methodsFor: 'transformation'!invert: anObject	self shouldNotImplement! !!NSOrdinalScale methodsFor: 'accessing'!range: x	range := x.	rangeBand := 0.	ranger := #range:.	argument := Array with: x.! !!NSOrdinalScale methodsFor: 'accessing'!rangeBand	^ rangeBand! !!NSOrdinalScale methodsFor: 'public'!rangeBands: x	self rangeBands: x padding: 0! !!NSOrdinalScale methodsFor: 'public'!rangeBands: x padding: padding	self rangeBands: x padding: padding outerPadding: padding! !!NSOrdinalScale methodsFor: 'public'!rangeBands: x padding: padding outerPadding: outerPadding	| start stop step reverse |	start := x first.	stop := x second.	reverse := false.	start > stop ifTrue: [| t |		t := start. start := stop. stop := t.		reverse := true. ].	step := (stop - start) / (domain size - padding + (2*outerPadding)).		range := self 		steps: start + (step * outerPadding)		and: step.	reverse ifTrue: [ range := range reverse ].	rangeBand := step * (1 - padding).	ranger := #rangeBands:padding:outerPadding:.	argument := Array with: x with: padding with: outerPadding! !!NSOrdinalScale methodsFor: 'accessing'!rangeExtent	^ self scaleExtent: argument first! !!NSOrdinalScale methodsFor: 'accessing'!rangeFrom: array	self range: (array collect: [ :val | Color colorFrom: val ])! !!NSOrdinalScale methodsFor: 'public'!rangePoints: x	self rangePoints: x padding: 0! !!NSOrdinalScale methodsFor: 'public'!rangePoints: x padding: padding	| start stop step |	start := x first.	stop := x second.	step := domain size < 2		ifTrue: [ start := (start  + stop)/2. 0 ]		ifFalse: [ (stop - start)/(domain size - 1 + padding) ].	range := self 		steps: start + (step * padding / 2)		and: step.	rangeBand := 0.		ranger := #rangePoints:padding:.	argument := Array with: x with: padding! !!NSOrdinalScale methodsFor: 'public'!rangeRoundBands: x	self rangeRoundBands: x padding: 0! !!NSOrdinalScale methodsFor: 'public'!rangeRoundBands: x padding: padding	self rangeRoundBands: x padding: padding outerPadding: padding! !!NSOrdinalScale methodsFor: 'public'!rangeRoundBands: x padding: padding outerPadding: outerPadding	| start stop step reverse |	start := x first.	stop := x second.	reverse := false.	start > stop ifTrue: [| t |		t := start. start := stop. stop := t.		reverse := true. ].	step := ((stop - start) / (domain size - padding + (2*outerPadding))) floor.		range := self 		steps: start + ( (stop - start - ((domain size - padding) * step) ) / 2 ) rounded		and: step.	reverse ifTrue: [ range := range reverse ].	rangeBand := (step * (1 - padding)) rounded.	ranger := #rangeRoundBands:padding:outerPadding:.	argument := Array with: x with: padding with: outerPadding! !!NSOrdinalScale methodsFor: 'public'!rangeRoundPoints: x	self rangeRoundPoints: x padding: 0! !!NSOrdinalScale methodsFor: 'public'!rangeRoundPoints: x padding: padding	| start stop step |	start := x first.	stop := x second.	step := domain size < 2		ifTrue: [ start := stop := ((start + stop)/2) rounded. 0 ]		ifFalse: [[ (stop - start)/(domain size -1 + padding)]			on: Error do: [ :ex | 0 ] ].			range := self 		steps: start + ((step * padding / 2) + (stop - start - 			((domain size - 1 + padding)* step) )/ 2) rounded		and: step.	rangeBand := 0.	ranger := #rangeRoundPoints:padding:.	argument := Array with: x with: padding! !!NSOrdinalScale methodsFor: 'transformation'!scale: x	| index |	index := dictionary at: x ifAbsent: [ nil ].	(index isNil and: [ ranger = #range:]) ifTrue: [		domain add: x.		dictionary at: x put: (index := domain size).		].	index ifNil: [ self error: 'invalid input' ].	index := index % range size.	index isZero 		ifTrue: [ index := range size ].	^ range at: index! !!NSOrdinalScale methodsFor: 'helpers'!scaleExtent: d	| start stop |	start := d first.	stop := d last.	^ start < stop		ifTrue: [ Array with: start with: stop ]		ifFalse: [ Array with: stop with: start ]! !!NSOrdinalScale methodsFor: 'helpers'!steps: start and: step	^ (0 to: domain size - 1) collect: [ :i | (start + (step * i)) asFloat ].! !!NSPolylinearScale methodsFor: 'private'!findJ: x	| lo hi mid |	lo := 2.	hi := k.	[ lo < hi ] whileTrue: [ 		mid := ((lo + hi) / 2) asInteger.		(domain at: mid) > x 			ifTrue: [ hi := mid ]			ifFalse: [ lo := mid + 1 ] ].	^ lo - 1 ! !!NSPolylinearScale methodsFor: 'transformation'!invert: anObject	self shouldNotImplement! !!NSPolylinearScale methodsFor: 'hooks'!rescale	| obj |	u := OrderedCollection new.	i := OrderedCollection new.	k := domain size min: range size.	obj := domain at: k.		((obj class canUnderstand: #<) and: [obj < domain first]) ifTrue: [		domain := domain reverse.		range := range reverse ].		2 to: k do: [ :j | 		u add: (uninterpolate uninterpolate: (domain at: j -1 ) and: (domain at: j)).		i add: (interpolate interpolate: (range at: j -1) and: (range at: j) )		 ].		! !!NSPolylinearScale methodsFor: 'transformation'!scale: x	| j |	j := self findJ: x.	^ (i at: j) interpolate: ((u at: j) uninterpolate: x)	! !!NSScale class methodsFor: 'colors'!category10	^ self fromColorCategory: #category10! !!NSScale class methodsFor: 'colors'!category20	^ self fromColorCategory: #category20! !!NSScale class methodsFor: 'colors'!category20b	^ self fromColorCategory: #category20b! !!NSScale class methodsFor: 'colors'!category20c	^ self fromColorCategory: #category20c! !!NSScale class methodsFor: 'colors'!eva10	^ self fromColorCategory: #eva10! !!NSScale class methodsFor: 'colors'!fromColorCategory: symbol	^ self ordinal 		range: (NSColorRGBAInterpolator perform: symbol);		yourself! !!NSScale class methodsFor: 'colors'!google20	^ self fromColorCategory: #google20! !!NSScale class methodsFor: 'instance creation'!linear	^ NSLinearScale new. ! !!NSScale class methodsFor: 'instance creation'!ln	^ NSLnScale new! !!NSScale class methodsFor: 'instance creation'!log	^ NSLogScale new! !!NSScale class methodsFor: 'instance creation'!ordinal"Define an ordinal scale.Example:```Smalltalkc := RSCanvas new.colors := NSScale ordinal range: { Color red translucent . Color yellow translucent . Color blue translucent }.r := Random seed: 42.100 timesRepeat: [ 	txt := { 'hello' . 'bonjour' . 'Guten Morgen' } atRandom: r.	g := RSGroup new.	g add: (RSBox new width: 130; height: 20; model: txt; color: (colors scale: txt)).	g add: (RSLabel new text: txt).	c add: g asShape.	 ].RSGridLayout new lineItemsCount: 5; on: c shapes.c @ RSCanvasController.c open```"	^ NSOrdinalScale new ! !!NSScale class methodsFor: 'colors'!paired12	^ self fromColorCategory: #paired12! !!NSScale class methodsFor: 'instance creation'!pow	^ NSPowScale new! !!NSScale class methodsFor: 'colors'!sky8	^ self fromColorCategory: #sky8! !!NSScale class methodsFor: 'instance creation'!sqrt	^ self pow		exponent: 0.5; 		yourself! !!NSScale class methodsFor: 'instance creation'!symlog	^ NSSymLogScale new! !!NSScale methodsFor: 'accessing'!domain	^ domain! !!NSScale methodsFor: 'accessing'!domain: aTwoArrayAsNumbers	"Define the domain of the input values. Values provided to scale: should be within the domain	For example	-=-=-=	s := NSScale linear.	s domain: { -1 . 1 }.	s range: { 5 . 10 }.	s scale: 0	-=-=-=	Return 7.5	"	domain := aTwoArrayAsNumbers! !!NSScale methodsFor: 'accessing'!from	^ self range first! !!NSScale methodsFor: 'accessing'!from: value	self range: { value. self range last }.! !!NSScale methodsFor: 'accessing'!interpolate	^ interpolate! !!NSScale methodsFor: 'accessing'!interpolate: anObject	interpolate := anObject.! !!NSScale methodsFor: 'transformation'!invert: anObject	"This is the inverse of scale"	self subclassResponsibility.! !!NSScale methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream << '('.	self domain printOn: stream.	stream << ', '.	self range printOn: stream.	stream << ')'.! !!NSScale methodsFor: 'accessing'!range	^ range! !!NSScale methodsFor: 'accessing'!range: aTwoArrayOfNumbers	"Expect an array of two numbers.	A range defines the range of the scaled value.		For example:	-=-=-=	s := NSScale linear.	s range: { 5 . 10 }.	s scale: 0.5 	-=-=-=	Return 7.5	"		range := aTwoArrayOfNumbers! !!NSScale methodsFor: 'hooks'!rescale	self subclassResponsibility! !!NSScale methodsFor: 'transformation'!rsValue: obj	^ self scale: obj! !!NSScale methodsFor: 'transformation'!scale: anObject	"do you have your domain, and your range? ok so use this method in one of my subclasses"	self subclassResponsibility! !!NSScale methodsFor: 'accessing'!to	^ self range last! !!NSScale methodsFor: 'accessing'!to: value	self range: { self range first. value }.! !!NSScale methodsFor: 'accessing'!uninterpolate	^ uninterpolate! !!NSScale methodsFor: 'accessing'!uninterpolate: anObject	uninterpolate := anObject! !!NSUninterpolate class methodsFor: 'interpolating'!uninterpolate: aNum1 and: aNum2	^ self new uninterpolate: aNum1 and: aNum2.	! !!NSUninterpolate methodsFor: 'accessing'!stopValue: aNum1 stop: aNum2	aNum1 isZero ifFalse: [ ^ aNum1 ].	aNum2 isZero ifTrue: [ ^ Float infinity ].	^ 1 / aNum2! !!NSUninterpolate methodsFor: 'interpolating'!uninterpolate: x	self subclassResponsibility.! !!NSUninterpolate methodsFor: 'accessing'!uninterpolate: aNum1 and: aNum2	a := aNum1.	b := aNum2.	(a isPoint or: [ b isPoint ]) ifTrue: [ 		| b2 |		a := a asPoint.		b2 := b := b asPoint.		b := b - a.		b := (self stopValue: b x stop: b2 x ) @ b y.		b := b x @ (self stopValue: b y stop: b2 y).		^ self  ].	a isNumber 		ifFalse: [ ^ a := b := Float nan. ].	b  := b - a.	b := self stopValue: b stop: aNum2.	! !!NSUninterpolateClamp methodsFor: 'interpolating'!uninterpolate: x	^ 0 max: (1 min: ((x - a ) / b))! !!NSUninterpolateNumber methodsFor: 'interpolating'!uninterpolate: x	^ (x - a )/b! !"NumericInterpolator"!!NSPerlinNoise commentStamp: '' prior: 0!Based on http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf!!NSPerlinNoise2 commentStamp: '' prior: 0!Based on Ken Perlin!!NSPerlinNoise3 commentStamp: '' prior: 0!based on https://mrl.nyu.edu/~perlin/noise/!!NSPerlinNoise methodsFor: 'private'!dot: arr and: x and: y	^ (arr first * x) + (arr second * y)! !!NSPerlinNoise methodsFor: 'accessing'!grad3At: index	^ grad3 at: index + 1! !!NSPerlinNoise methodsFor: 'initialization'!initialize	| p |	super initialize.	grad3 := #( 		#(1 1 0) 		#(-1 1 0) 		#(1 -1 0)		#(-1 -1 0)		#(1 0 1)		#(-1 0 1)		#(1 0 -1)		#(-1 0 -1)		#(0 1 1)		#(0 -1 1)		#(0 1 -1)		#(0 -1 -1)).			p := #(151 160 137 91 90 15 131 13 201 95 96 53 194 233 7 225 140 36 103 30 69 142 8 99 37 240 21 10 23 190 6 148 247 120 234 75 0 26 197 62 94 252 219 203 117 35 11 32 57 177 33 88 237 149 56 87 174 20 125 136 171 168 68 175 74 165 71 134 139 48 27 166 77 146 158 231 83 111 229 122 60 211 133 230 220 105 92 41 55 46 245 40 244 102 143 54 65 25 63 161 1 216 80 73 209 76 132 187 208 89 18 169 200 196 135 130 116 188 159 86 164 100 109 198 173 186 3 64 52 217 226 250 124 123 5 202 38 147 118 126 255 82 85 212 207 206 59 227 47 16 58 17 182 189 28 42 223 183 170 213 119 248 152 2 44 154 163 70 221 153 101 155 167 43 172 9 129 22 39 253 19 98 108 110 79 113 224 232 178 185 112 104 218 246 97 228 251 34 242 193 238 210 144 12 191 179 162 241 81 51 145 235 249 14 239 107 49 192 214 31 181 199 106 157 184 84 204 176 115 121 50 45 127 4 150 254 138 236 205 93 222 114 67 29 24 72 243 141 128 195 78 66 215 61 156 180).	perm := Array new: 512.	1 to: 256 do: [ :i | | v |		v := p at: i.		perm at: i put: v.		perm at: i + 256 put: v ].	! !!NSPerlinNoise methodsFor: 'public'!noise: xin and: yin	"all this proces explained in http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf"	| f2 s i j g2 t xzero yzero x0 y0 i1 j1 x1 y1 x2 y2 ii jj gi0 gi1 gi2 t0 n0 t1 n1 t2 n2 |	f2 := 0.5 * (3 sqrt - 1).	s := (xin + yin) * f2.	i := (xin + s) floor.	j := (yin + s) floor.	g2 := (3 - 3 sqrt) / 6.	t := (i + j) * g2.	xzero := i - t.	yzero := j - t.	x0 := xin - xzero.	y0 := yin - yzero.	x0 > y0 ifTrue: [ 		i1 := 1.		j1 := 0 ]		ifFalse: [ 		i1 := 0.		j1 := 1 ].	x1 := x0 - i1 + g2.	y1 := y0 - j1 + g2.	x2 := x0 - 1 + (2* g2).	y2 := y0 - 1 + (2* g2).		ii := i & 255.	jj := j & 255.		gi0 := (self permAt: ii + (self permAt: jj)) % 12.	gi1 := (self permAt: ii + i1 + (self permAt: jj + j1)) % 12.	gi2 := (self permAt: ii + 1 + (self permAt: jj + 1) ) % 12.		t0 := 0.5 - (x0 * x0) - (y0 * y0).	t0 < 0 ifTrue: [ n0 := 0 ] ifFalse: [ 		t0 := t0 * t0.		n0 := t0 * t0 * (self dot: (self grad3At: gi0) and: x0 and: y0 ) ].	t1 := 0.5 - (x1*x1) - (y1 * y1).	t1 < 0 ifTrue: [ n1 := 0 ] ifFalse: [ 		t1 := t1 * t1.		n1 := t1 * t1 * (self dot: (self grad3At: gi1) and: x1 and: y1 ) ].	t2 := 0.5 - (x2 * x2) - (y2 * y2).	t2 < 0 ifTrue: [ n2 := 0 ] ifFalse: [ 		t2 := t2 * t2.		n2 := t2 * t2 * (self dot: (self grad3At: gi2) and: x2 and: y2) ].	^ 70.0 * (n0 + n1 + n2).	! !!NSPerlinNoise methodsFor: 'accessing'!permAt: index	^ perm at: index + 1! !!NSPerlinNoise2 methodsFor: 'public'!fade: t	^ t * t * t * (t * (t * 6 - 15) + 10 )! !!NSPerlinNoise2 methodsFor: 'public'!grad: hash x: x y: y z: z	| h u v |	h := hash & 15.	u := h < 8		ifTrue: [ x ]		ifFalse: [ y ].	v := h < 4		ifTrue: [ y ]		ifFalse: [ ((h = 12) or: [ h = 14 ])				ifTrue: [ x ]				ifFalse: [ z ] ].	^ (h & 1 = 0		ifTrue: [ u ]		ifFalse: [ u negated ])		+			((h & 2) = 0				ifTrue: [ v ]				ifFalse: [ v negated ])! !!NSPerlinNoise2 methodsFor: 'initialization'!initialize	| permutation |	super initialize.	p := Dictionary new.	permutation :=#(151 160 137 91 90 15 131 13 201 95 96 53 194 233 7 225 140 36 103 30 69 142 8 99 37 240 21 10 23 190 6 148 247 120 234 75 0 26 197 62 94 252 219 203 117 35 11 32 57 177 33 88 237 149 56 87 174 20 125 136 171 168 68 175 74 165 71 134 139 48 27 166 77 146 158 231 83 111 229 122 60 211 133 230 220 105 92 41 55 46 245 40 244 102 143 54 65 25 63 161 1 216 80 73 209 76 132 187 208 89 18 169 200 196 135 130 116 188 159 86 164 100 109 198 173 186 3 64 52 217 226 250 124 123 5 202 38 147 118 126 255 82 85 212 207 206 59 227 47 16 58 17 182 189 28 42 223 183 170 213 119 248 152 2 44 154 163 70 221 153 101 155 167 43 172 9 129 22 39 253 19 98 108 110 79 113 224 232 178 185 112 104 218 246 97 228 251 34 242 193 238 210 144 12 191 179 162 241 81 51 145 235 249 14 239 107 49 192 214 31 181 199 106 157 184 84 204 176 115 121 50 45 127 4 150 254 138 236 205 93 222 114 67 29 24 72 243 141 128 195 78 66 215 61 156 180).	0 to: 255 do: [ :i |		p at: 256 + i put: (p at: i put: (permutation at: i + 1) ) ]! !!NSPerlinNoise2 methodsFor: 'public'!lerp: t a: a b: b	^ t * (b - a) + a! !!NSPerlinNoise2 methodsFor: 'public'!noise: xin	^ self noise: xin y: 0 z: 0! !!NSPerlinNoise2 methodsFor: 'public'!noise: xin and: yin	^ self noise: xin y: yin z: 0! !!NSPerlinNoise2 methodsFor: 'public'!noise: xin y: yin z: zin	"(TSPerlinNoise2 new noise: 3.14 y: 42 z: 7) >>> 0.13691995878400012"	| x0 y0 z0 x y z u v w a aa ab b ba bb |	x0 := xin floor & 255.	y0 := yin floor & 255.	z0 := zin floor & 255.	x := xin - xin floor.	y := yin - yin floor.	z := zin - zin floor.	u := self fade: x.	v := self fade: y.	w := self fade: z.	a := (p at: x0)+y0.	aa := (p at: a)+z0.	ab := (p at: a+1)+z0.	b := (p at: x0+1)+y0.	ba := (p at: b) + z0.	bb := (p at: b+1) + z0.	"result will cover the range [-1,1]"	^ self lerp: w 		a: (self lerp: v			a: (self lerp: u 				a: (self grad: (p at: aa) x: x 	y: y z: z)				b: (self grad: (p at: ba) x: x-1	y: y z: z) )  			b: (self lerp: u				a: (self grad: (p at: ab) x: x 	y: y-1 z: z)				b: (self grad: (p at: bb) x: x-1	y: y-1 z: z) ) )		b: (self lerp: v			a: (self lerp: u 				a: (self grad: (p at: aa+1) x: x 	y: y z: z-1)				b: (self grad: (p at: ba+1) x: x-1	y: y z: z-1) )  			b: (self lerp: u				a: (self grad: (p at: ab+1) x: x 	y: y-1 z: z-1)				b: (self grad: (p at: bb+1) x: x-1	y: y-1 z: z-1) ) )! !!NSPerlinNoise2 methodsFor: 'public'!snoise: xin and: yin	"range #(0 1)"	^((self noise: xin and: yin) + 1)/2! !!NSPerlinNoise3 methodsFor: 'public'!grad2d: i x: x y: y	| v |	v := (i &1) = 0 		ifTrue: [ x ] 		ifFalse: [ y ].	^ (i & 2) = 0 ifTrue: [ v negated ] ifFalse: [ v ]! !!NSPerlinNoise3 methodsFor: 'initialization'!initialize	| r |	super initialize.	self octaves: 1.	r := Random new.	p := Dictionary new.	0 to: 511 do: [ :i | 		p at: i put: (r next * 256) asInteger ].! !!NSPerlinNoise3 methodsFor: 'public'!lerp: t a: a b: b	^ t * (b - a) + a! !!NSPerlinNoise3 methodsFor: 'public'!noise2d: xin and: yin	| x1 y1 x y fx fy p0 p1 |	x1 := xin floor & 255.	y1 := yin floor & 255.	x := xin - xin floor.	y := yin - yin floor.	fx := (3- (2 * x)) * x * x.	fy := (3 -(2 * y)) * y * y.	p0 := (p at: x1) + y1.	p1 := (p at: x1 + 1)+ y1.	^ self lerp: fy 		a: (self lerp: fx			a: (self grad2d: (p at: p0) x: x y: y)			b: (self grad2d: (p at: p1) x: x -1 y: y))		b: (self lerp: fx			a: (self grad2d: (p at: p0+1) x: x y: y-1)			b: (self grad2d: (p at: p1+1) x: x -1 y: y-1)).! !!NSPerlinNoise3 methodsFor: 'public'!noise: xin and: yin	| e k s |	e := 1.	k := 1.	s := 0.	1 to: octaves do: [ :i | 		e := e * 0.5.		s := s + (e * (1 + (self noise2d: k * xin and: k * yin)/2) ).		k := k * 2 ].	^ s! !!NSPerlinNoise3 methodsFor: 'accessing'!octaves: anInteger	octaves := anInteger! !"NumericNoise"!!NSLinearScaleTest commentStamp: '' prior: 0!A NSLinearScaleTest is a test class for testing the behavior of NSLinearScale!!NSLogScaleTest commentStamp: '' prior: 0!A NSLogScaleTest is a test class for testing the behavior of NSLogScale!!NSOrdinalScaleTest commentStamp: '' prior: 0!A NSOrdinalScaleTest is a test class for testing the behavior of NSOrdinalScale!!NSPolylinearScaleTest commentStamp: '' prior: 0!A NSPolylinearScaleTest is a test class for testing the behavior of NSPolylinearScale!!NSPowScaleTest commentStamp: '' prior: 0!A NSPowScaleTest is a test class for testing the behavior of NSPowScale!!NSScaleTest commentStamp: '' prior: 0!A NSScaleTest is a test class for testing the behavior of NSScale!!NSClampTest methodsFor: 'tests'!testBasic01	| x |		x := NSScale linear		domain: { -100. 100 };		range: { 500. 1000 }.	self deny: x clamp.	self assert: x uninterpolate equals: NSUninterpolateNumber.	self assert: (x scale: 0) equals: 750.	self assert: (x scale: 200) equals: 1250.	self assert: (x invert: 1250) equals: 200.		x clamp: true.	self assert: x uninterpolate equals: NSUninterpolateClamp.	self assert: (x scale: 0) equals: 750.	self assert: (x scale: 200) equals: 1000.	self assert: (x invert: 1250) equals: 100.		! !!NSClampTest methodsFor: 'tests'!testBasic02	| x |	x := NSScale sqrt		domain: { -100. 100 };		range: { 500. 1000 }.	self deny: x clamp.	self assert: (x scale: 0) equals: 750.	self assert: (x scale: 200) closeTo: 1103.5533905932737.	self assert: (x invert: 1103.5533905932737) closeTo: 200.		x clamp: true.	self assert: (x scale: 0) closeTo: 750.	self assert: (x scale: 200) closeTo: 1000.	self assert: (x invert: 1250) closeTo: 100.		! !!NSClampTest methodsFor: 'tests'!testBasic03	| x |		x := NSScale log		domain: { 1. 100 };		range: { 500. 1000 }.	self deny: x clamp.	self assert: x uninterpolate equals: NSUninterpolateNumber.	self assert: (x scale: 1) closeTo: 500.	self assert: (x scale: 200) closeTo: 1075.2574989159953.	self assert: (x invert: 1075.2574989159953) closeTo: 200.		x clamp: true.	self assert: x uninterpolate equals: NSUninterpolateClamp.	self assert: (x scale: 0) closeTo: 500.	self assert: (x scale: 200) closeTo: 1000.	self assert: (x invert: 1250) closeTo: 100.		! !!NSLinearScaleTest methodsFor: 'running'!classToTest	^ NSLinearScale! !!NSLinearScaleTest methodsFor: 'test - scales'!testSameRange	| sc |	sc := self classToTest new		domain: #(0 100);		range: #(100 100).	self assert: (sc scale: 0) equals: 100.	self assert: (sc scale: 50) equals: 100.	self assert: (sc scale: 100) equals: 100.	self assert: (sc scale: 123123) equals: 100.	sc := NSScale linear		domain: #(0 100);		range: #(0 0).	self assert: (sc scale: 0) equals: 0.	self assert: (sc scale: 50) equals: 0.	self assert: (sc scale: 100) equals: 0.	self assert: (sc scale: 123123) equals: 0.! !!NSLinearScaleTest methodsFor: 'test - linear'!testScaleLinear	| linear |	linear := self classToTest new.	self 		assert: linear domain equals: #(0 1);		assert: linear range equals: #(0 1).	linear range: #(1 10).	self		assert: (linear scale: 1) equals: 10;		assert: (linear scale: 0.5) equals: 5.5.			self assert: linear interpolate equals: NSInterpolator.	self assert: linear uninterpolate equals: NSUninterpolateNumber.		! !!NSLinearScaleTest methodsFor: 'test - linear'!testScaleLinearClamp	| linear |	linear := self classToTest new		domain: #(0 10);		range: #(0 100).	self assert: (linear scale: 11) equals: 110.	self assert: (linear scale: -5) equals: -50.	linear clamp: true.	self assert: (linear scale: 11) equals: 100.	self assert: (linear scale: -5) equals: 0.! !!NSLinearScaleTest methodsFor: 'test - linear'!testScaleLinearColors	| linear |	linear := self classToTest new		domain: #(0 100);		range: #('white' 'black').	self assert: (linear scale: 50) equals: Color gray.	self assert: (linear scale: 0) equals: Color white.	self assert: (linear scale: 100) equals: Color black.	! !!NSLinearScaleTest methodsFor: 'test - linear'!testScaleLinearInvert	| linear |	linear := self classToTest new		domain: #(-5 5);		range: #(40 50).	self 		assert: (linear scale: 0) equals: 45;		assert: (linear scale: 5) equals: 50;		assert: (linear invert: 50) equals: 5;		assert: (linear invert: 40) equals: -5	! !!NSLinearScaleTest methodsFor: 'test - linear'!testScaleLinearRound	| linear |	linear := self classToTest new		domain: #(-5 5);		rangeRound: #(40 50).	self 		assert: (linear scale: 0.2) equals: 45;		assert: (linear scale: 5.1) equals: 50;		assert: (linear invert: 50) equals: 5;		assert: (linear invert: 40) equals: -5	! !!NSLogScaleTest methodsFor: 'test - scales'!testLogScale	| log |	log := NSLogScale new.	self 		assert: log base equals: 10;		assert: log range equals: #(0 1);		assert: (log scale: 10) equals: 1;		assert: (log scale: 100) equals: 2;		assert: (log scale: 50) equals: 1.6989700043360185.	log := NSLogScale new		base: Float e;		domain: (#(0 9) collect: #exp);		range: #(200 0).	self assert: ((log scale: 50) closeTo: 113.0661554349301).	self assert: ((log scale: 0.01) closeTo: 302.3371152441798).	self assert: ((log scale: 100) closeTo: 97.66288475582019).	self assert: ((log invert: 10) closeTo: 5166.754427175983).		self assert: (log scale: 9000) closeTo: -2.3328856959635047.	log clamp: true.	self		assert: (log scale: 9000) closeTo: 0;		assert: log interpolate equals: NSInterpolator.	log interpolate: NSInterpolator	! !!NSLogScaleTest methodsFor: 'test - scales'!testNA	| log |	log := NSLogScale new.	self assert: (log scale: 10) closeTo: 1.0.	self assert: (log scale: 1) closeTo: 0.	self assert: (log scale: 0.5) closeTo: -0.30102999566398114.	self assert: (log scale: 0.1) closeTo: -0.9999999999999998.	self assert: (log scale: 0.001) closeTo: -2.9999999999999996.	self assert: (log scale: 0) isNaN.	self assert: (log scale: -1) isNaN.	self assert: (log scale: -10) isNaN.! !!NSOrdinalScaleTest methodsFor: 'running'!classToTest	^ NSOrdinalScale! !!NSOrdinalScaleTest methodsFor: 'test - scales'!testOrdinalScale	| ordinal |	ordinal := self classToTest new		domain: #('a' 'b' 'c' 'd' 'e' 'f');		range: #(10 20 30 40 50 60).	self 		assert: (ordinal scale: 'a') equals: 10;		assert: (ordinal scale: 'd') equals: 40;		assert: (ordinal scale: 'f') equals: 60.		! !!NSOrdinalScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangeBands	| ordinal |	ordinal := self classToTest new		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeBands: #(0 960).	self 		assert: ordinal rangeBand equals: 160;		assert: (ordinal scale: 'a') equals: 0;		assert: (ordinal scale: 'd') equals: 480;		assert: (ordinal scale: 'f') equals: 800;				assert: ordinal rangeExtent equals: #(0 960)		! !!NSOrdinalScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangePoints	| ordinal |	ordinal := self classToTest new		domain: #('apple' 'orange' 'banana' 'grape');		rangePoints: #(0 960).	self 		assert: (ordinal scale: 'apple') equals: 0;		assert: (ordinal scale: 'orange') equals: 320;		assert: (ordinal scale: 'grape') equals: 960;				assert: ordinal rangeExtent equals: #(0 960)			! !!NSOrdinalScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangeRoundBands	| ordinal |	ordinal := self classToTest new		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeRoundBands: #(0 960) padding: 0.1.	self 		assert: ordinal rangeBand equals: 141;		assert: (ordinal scale: 'a') equals: 17;		assert: (ordinal scale: 'd') equals: 488;		assert: (ordinal scale: 'f') equals: 802;		assert: ordinal rangeExtent equals: #(0 960).			ordinal := NSScale ordinal		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeRoundBands: #(0 960).	self 		assert: ordinal rangeBand equals: 160;		assert: (ordinal scale: 'a') equals: 0;		assert: (ordinal scale: 'd') equals: 480;		assert: (ordinal scale: 'f') equals: 800;		assert: ordinal rangeExtent equals: #(0 960)! !!NSOrdinalScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangeRoundPoints	| ordinal |	ordinal := self classToTest new		domain: #(1 2 3 4);		rangeRoundPoints: #(0 100).	self 		assert: ordinal rangeBand equals: 0;		assert: (ordinal scale: 1) equals: 0;		assert: (ordinal scale: 2) equals: 33.333333333333333;		assert: (ordinal scale: 4) equals: 100.	! !!NSPolylinearScaleTest methodsFor: 'test - linear'!testScalePolyLinear	| linear |	linear := NSScale linear		domain: #(0 0.5 1);		range: #(10 80 10).	self		assert: linear input class equals: NSPolylinearScale;		assert: linear output class equals: NSPolylinearScale;		assert: (linear scale: 0) equals: 10;		assert: (linear scale: 0.5) equals: 80;		assert: (linear scale: 1) equals: 10;		assert: (linear scale: 1.5) equals: -60.	linear := NSScale linear		domain: #(0 0.5 1);		range: #('white' 'black' 'white').	self 		assert: (linear scale: 0) equals: Color white;		assert: (linear scale: 0.25) equals: Color gray;		assert: (linear scale: 0.75) equals: Color gray.			! !!NSPowScaleTest methodsFor: 'test - scales'!testPowScale	| pow |	pow := NSPowScale new.		self		assert: pow exponent equals: 1;		assert: (pow scale: 5) equals: 5.	pow exponent: 2.	self		assert: (pow scale: 5) equals: 25;		assert: (pow invert: 25) equals: 5;		assert: pow exponent equals: 2.		pow 		domain: #(0 100);		range: #(-10 10);		clamp: true.			self 		assert: (pow scale: 200) equals: 10;		assert: (pow scale: 99.9) closeTo: 9.960020000000004.	pow interpolate: NSRoundInterpolator.	self 		assert: pow interpolate equals: NSRoundInterpolator;		assert: (pow scale: 99.9) equals: 10;		assert: pow range equals: #(-10 10)! !!NSPowScaleTest methodsFor: 'test - scales'!testSqrt	| sqrt |	sqrt := NSScale sqrt.		self		assert: sqrt class equals: NSPowScale;		assert: sqrt exponent equals: 0.5;		assert: ((sqrt scale: 9) closeTo: 3).		sqrt := NSScale sqrt		domain: #(0 36756666);		range: #(0 220).	self assert: (sqrt scale: 4661900) closeTo: 78.34947695663722	! !!NSSLnScaleTest methodsFor: 'tests'!testBasic	| s |	s:= NSLnScale new		domain: {  -100. 50};		range: { 100. 50 }.	self assert: s domain equals: { Float epsilon. 50 }.	self assert: (s scale: -1000) closeTo: 100.	self assert: (s scale: 0) closeTo: 100. 	self assert: (s scale: 50) closeTo: 50. ! !!NSSLnScaleTest methodsFor: 'tests'!testMultiple	| s |	s:= NSLnScale new		domain: {  0. 50. 100 };		range: { 100. 50. 200 }.	self assert: (s scale: 0) closeTo: 100.	self assert: (s scale: 50) closeTo: 50.	self assert: (s scale: 100) closeTo: 200.		self assert: (s scale: -100) closeTo: 100.! !!NSScaleTest methodsFor: 'tests'!testAccessors	self assert: NSScale linear class equals: NSLinearScale.	self assert: NSScale log class equals: NSLogScale.	self assert: NSScale sqrt class equals: NSPowScale.	self assert: NSScale pow class equals: NSPowScale.	self assert: NSScale ordinal class equals: NSOrdinalScale.	! !!NSScaleTest methodsFor: 'tests'!testAccessorsColors	#(category10 category20 category20b category20c eva10 google20 paired12 sky8) 		do: [ :sel| | scale |		scale := NSScale perform: sel.		self assert: scale class equals: NSOrdinalScale.		self assert: scale range class equals: Array.		self assert: scale range first class equals: Color ]! !!NSScaleTest methodsFor: 'test - colors'!testCategories	| color |	color := NSScale category10.	self assert: color range size equals: 10.		1 to: 10 do: [ :i | 		self assert: (color scale: i) class equals: Color ].		1 to: 10 do: [ :i | 		self assert: (color scale: i) equals: (color scale: i + 10) ].		color := NSScale category20.		self assert: color range size equals: 20.	0 to: 19 do: [ :i | 		self assert: (color scale: i) class equals: Color ].	color := NSScale category20b.		self assert: color range size equals: 20.	color := NSScale category20c.	self assert: color range size equals: 20.		color := NSScale paired12.	self assert: color range size equals: 12.! !!NSScaleTest methodsFor: 'test - linear'!testRandom	"Random uses TSScale linear"	| random value |	random := Random new.	value := random rsNext: 10.	self assert: (value between: 0 and: 10).	value := random rsNext: -10 and: -5.	self assert: (value between: -10 and: -5 ).! !!NSScaleTest methodsFor: 'test - colors'!testSetInterpolator	| scale |	scale := NSScale linear		range: { 'white'. 'black' }.	self assert: (scale scale: 0.5) equals: Color gray.	scale interpolate: NSColorHSLAInterpolator.	self assert: (scale scale: 0.5) equals: Color gray.	scale interpolate: NSColorHSVAInterpolator.	self assert: (scale scale: 0.5) equals: Color gray.! !!NSSymLogScaleTest methodsFor: 'tests'!testBasic	| log |	log := NSSymLogScale new		domain: #(0 100);		range: #(50 1150).	self assert: (log scale: 71) closeTo: 1069.330419162588.	self assert: (log scale: 0) closeTo: 50.		self assert: (log invert: 50) closeTo: 0.! !"NumericInterpolator-Tests"!!RSTContainer commentStamp: '' prior: 0!My users can have edges and nodes useful to build graphs with roassal!!RSTPositionable commentStamp: '' prior: 0!I am a trait for BoundingShape and Camera since both of them uses an announcement when the position of both changes!!RSObject commentStamp: '' prior: 0!Root of most of the Trachel classes.!!RSCamera commentStamp: '' prior: 0!<keyClass>All shapes in Roassal are contained in a `RSCanvas`. The canvas has an infinite 2D dimension. The portion of the canvas that is visible within the window is given by a camera. `RSCamera` describes a camera in Roassal. A camera has a scale and a position.*Responsibility*: identify the portion and the zoom level of a canvas that must be visible. Whenever the canvas is scrolled with the mouse or the key, then the camera is responsible for this.*Collaborators*: A `RSCanvas` has a `RSCamera`. *Variables*:`position` is a point representing coordinates of the canvas on which the viewing window frame will be centered. Position can be changes with the method `#translateBy:` and `#translateTo:`. Both methods accept canvas based coordinates`scale` defines a magnitude of zooming applied to the canvas and its elements.*Example*:```Smalltalkc := RSCanvas new.1 to: 100 do: [ :i |	| g |	g := RSGroup new.	g add: (RSEllipse new size: 30; color: Color gray lighter).	g add: (RSLabel new text: i).	c add: g asShape ].RSGridLayout on: c shapes.camera := c canvas camera.camera translateBy: 500 @ 50.camera scale: 0.5.c```!!RSObjectWithProperty commentStamp: '' prior: 0!My subclasses has attributes useful to add extra data to each component!!RSCanvas commentStamp: '' prior: 0!<keyClass>Roassal keeps its shapes (i.e., instance of a subclass of `RSShape`) into a canvas. The class `RSCanvas` implements the Roassal canvas.*Responsibility*: keep the (i) structure of the Roassal shapes (both fixed and non-fixed) and (ii) the animations. `RSCanvas` hides the creation of the `RSAthensMorph`.*Collaborators*: This class is the entry point of Roassal. As soon as one wishes to use Roassal, she has to go through a canvas.*Variables*:`shapes` keeps a collection of shapes (i.e., instance of a subclass of `RSShape`) as an instance of `RSGroup`. Shapes contained in `shapes` are considered as non-fixed, which means that they are subject to the camera.`fixedShapes` is an instance of `RSGroup` that contains "fixed" shapes. A fixed shape is a shape that is not subject to the state of the camera. A fixed shape remains at the same position, independently if the canvas is scrolled.`color` is an instance of the Pharo class `Color` and is used to paint the background.`morph` refers to an instance of the class `RSAthensMorph`, which is the object that intersects Roassal and Morphic.`camera` refers to the camera of the canvas.`clearBackground` is a boolean indicating whether the background must be cleared at each refresh. This is useful sometime to obtain some interesting visual effects.*Example*:```Smalltalkc := RSCanvas new.c add: (RSLabel new text: 'Hello from Roassal').c```!!RSShape commentStamp: '' prior: 0!<keyClass>`RSShape` is the root of all the Roassal shapes. A shape represents a visual element meant to be inserted in a `RSCanvas`. `RSShape` is an abstract class, not meant to be directly instantiated therefore.*Responsibility*: A shape, i.e., subclass of the class `RSShape` is responsible to model a visual element. *Collaborators*: A shape is meaningful when inserted in a canvas*Variables*:- `paint`: the color of the Athens paint object used to render the visual shape- `path`: refers to AthensCairoPath, which is a resource of a foreign object, ie., the cairo on- `border`:- `parent`: the parent shape- `isFixed`: a boolean indicating if the shape is fixed (ie., not subject to the camera position and movement)!!RSRenderer commentStamp: '' prior: 0!A renderer recives a canvas a then it visit each element of the canvas.RSRenderer is like a visitor for the RSCanvas.RSCanvas and RSShapes accept this visitor.RSCanvas can be rendered with the next - RSAthensRenderer renders the canvas in a Athens Surface using an athens libraryFuture renderes: - RSPngRenderer, this can produce an image with different parameters - RSBlocRenderer, this render a canvas with the bloc/sparta commponents- RSPDFRenderer, creates a pdf documents- RSGifRenderer, creates gif files with animation- RSSourceRenderer, creates a method with the content of the canvas.- RSJavascriptRenderer, creates and html file with css and javascript code to render the canvas with basic insteractions.- RSVideoRenderer, creates a mp4 video with the canvas animation and transparency.!!RSAthensRenderer commentStamp: '' prior: 0!<keyClass>Roassal uses Athens (and therefore Cairo) to performs the rendering. The rendering in Roassal is modularized in the class `RSAthensRenderer`. The connection between Roassal and Athens is expressed by the class `RSAthensRenderer`.The class `RSAthensRenderer` is essentially a visitor for a `RSCanvas`. The renderer visits the canvas and ultimately calls the Athens primitives for each visited shapes.If you wish to add a new rendering engine (to produce a PDF file or use an alternative low level graphic engine such as Moz2D), you need to subclass the class `RSRenderer`.`RSAthensRenderer` visits the canvas and its contained shapes to draw it in a AthensSurface.*Responsibility*: invoke the low level primitives offered by Athens to render the visual aspect of shapes.*Collaborators*: `RSAthensMorph` is using the class `RSAthensRenderer` to "draw" a `RSCanvas` instance.!!RSEvent commentStamp: '' prior: 0!<keyClass>`RSEvent` is the root of all the events handled by Roassal. Events are expressed as an instance of a subclass of `RSEvent`. Some events describe the actions made by the users (e.g., `RSMouseDragEnd`), some other event describes some state change of a shape (e.g., `RSShapeAddedEvent`, `RSHighlightEvent`).*Responsibility*: model an event triggered either by a user action or a state change.*Collaborators*: events are emitted by `RSAthensMorph` or by some interaction (e.g., `RSHighlightable`)*Variables*:- `canvas`: the `RSCanvas` - `morph`: the `RSAthensMorph` - `shape`: the shape related to the event  !!RSCanvasEvent commentStamp: '' prior: 0!I am top class for canvas event!!RSScaleChangedEvent commentStamp: '' prior: 0!When canvas changes the scale value of the TSCamera!!RSShapeAddedEvent commentStamp: '' prior: 0!When the canvas add a shape!!RSShapeRemovedEvent commentStamp: '' prior: 0!When a canvas removes a shape!!RSHighlightableEvent commentStamp: '' prior: 0!I am a basic event for class RSHighlightable interaction!!RSHighlightEvent commentStamp: '' prior: 0!I am a basic event when RSHightlightable needs to highlight an element!!RSUnHighlightEvent commentStamp: '' prior: 0!I am a basic event when RSHightlightable needs to unhighlight an element!!RSShapeEvent commentStamp: '' prior: 0!TSShapeEvent represent all events with shapes and the canvas!!RSExtentChangedEvent commentStamp: '' prior: 0!When a bounding shape uses extent:, width: or height: I will trigger !!RSPositionChangedEvent commentStamp: '' prior: 0!When the shape uses translateBy: or translateTo:, position: does not trigger this event!!RSUserInputEvent commentStamp: '' prior: 0!for user input events!!RSAbstractMouseEvent commentStamp: '' prior: 0!Abstract for mouse events!!RSAbstractMouseClick commentStamp: '' prior: 0!abstract for mouse click events!!RSMouseClick commentStamp: '' prior: 0!Common event for mouse clicks!!RSMouseLeftClick commentStamp: '' prior: 0!Common event for mouse left click!!RSMouseRightClick commentStamp: '' prior: 0!Common event for mouse right clicks!!RSMouseDoubleClick commentStamp: '' prior: 0!Events for double clicks!!RSMouseDoubleLeftClick commentStamp: '' prior: 0!Double click for the left button!!RSMouseDoubleRightClick commentStamp: '' prior: 0!Double clicks for right button!!RSMouseUp commentStamp: '' prior: 0!Events for mouseUp!!RSMouseUpLeft commentStamp: '' prior: 0!left buttom!!RSMouseUpRight commentStamp: '' prior: 0!Event for mouse up right!!RSMouseDragEnd commentStamp: '' prior: 0!When: at the end of DragDrop eventTarget: dragged element!!RSMouseDragStart commentStamp: '' prior: 0!When: when a valid draggable element is grabbedTarget: dragged element!!RSMouseLeftDragStart commentStamp: '' prior: 0!left buttom!!RSMouseMiddleDragStart commentStamp: '' prior: 0!middle button!!RSMouseRightDragStart commentStamp: '' prior: 0!right button!!RSMouseDragging commentStamp: '' prior: 0!When: during dragging of the elementTarget: dragged element!!RSMouseEnter commentStamp: '' prior: 0!When: when a mouse cursor entered an elementTarget: entered element!!RSMouseLeave commentStamp: '' prior: 0!When: when a mouse cursor left an elementTarget: entered element!!RSMouseMove commentStamp: '' prior: 0!Performed while mouse is moving over the morph!!RSMouseWheelEvent commentStamp: '' prior: 0!I'm a mouse wheel scrolling event.!!RSKeyboardEvent commentStamp: '' prior: 0!A base class for keyboard events.!!RSKeyDown commentStamp: '' prior: 0!Event representing a key pressing (but not releasing)-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=c := TSCanvas new.e := TSEllipse new.c addShape: e.e when: TRKeyDown do: [ :event |	event keyCombination = $r asKeyCombination ifTrue: [		e color: Color random.		v signalUpdate.	]].c open-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=!!RSKeyUp commentStamp: '' prior: 0!Event representing a key release.[[[c := TSCanvas new.c when: TRKeyDown do: [ :event |	self log: '[DOWN]'; logCr: event keyCombination.].c when: TRKeyUp do: [ :event |	self log: '[UP]'; logCr: event keyCombination.].c open]]]!!RSGroup commentStamp: '' prior: 0!<keyClass>A `RSGroup` represents a collection of Roassal shapes. As soon as one assume a collection contains graphical elements, then it is convenient to be able to perform some operations (e.g., getting the encompassing rectangle of the elements, transforming a collection into a composite shape). `RSGroup` is a subclass of `OrderedCollection`. A `RSGroup` is not designed to contain other things than Roassal shapes. *Responsibility*: handle a collection of graphical shapes in an intuitive and efficient way. A group is also responsible to retrieve shapes from a given model object.*Collaborators*: `RSGroup` is a central class in Roassal. Shapes are held in instance of `RSGroup`.*Variables*:- `shapeFromModelCache`: a group of shapes must remember the model to speed up the retreival of shapes from a given object model.*Example*:```Smalltalkshapes := (1 to: 20) collect: [ :value | 	| g |	g := RSGroup new.	g add: (RSEllipse new size: 30 atRandom).	g add: (RSLabel new text: value).	g asShape ].c := RSCanvas new.c addAll: shapes.RSFlowLayout on: shapes.c @ RSCanvasController.```Layout may be applied on a group```Smalltalkshapes := (1 to: 20) collect: [ :value | 	| g |	g := RSGroup new.	g add: (RSLabel new text: value).	g add: (RSEllipse new size: 30 atRandom).	RSVerticalLineLayout new center; gapSize: 0; on: g.	g asShape ].c := RSCanvas new.c addAll: shapes.RSFlowLayout on: shapes.c @ RSCanvasController.``````Smalltalkg := RSGroup new.g add: (RSBox new model: 'hello').g add: (RSEllipse new model: 'world').g shapeFromModel: 'hello' "=> a RSBox(hello))"```!!RSAthensMorph commentStamp: '' prior: 0!A RSAthensMorph is at the interface between Morphic and Roassal. I am directly referenced by RSCanvas!!RSTContainer methodsFor: 'adding nodes edges'!add: aShape	self		assert: aShape notNil		description: 'Nil cannot be added to a canvas'.	aShape 		addedIn: self;		renderOn: self.	^ aShape! !!RSTContainer methodsFor: 'adding nodes edges'!addAll: aCollection	"Add a collection of shapes to the canvas	aCollection of shapes, a shape can be a line or can be a node"	self assert: [ aCollection isCollection ] description: 'Need to provide a collection as argument'.	self assert: [ aCollection allSatisfy: [ :e | e isKindOf: RSShape ] ] description: 'Need to provide a collection of RSShape'.		"Add each shape"	aCollection do: [ :aShape | self add: aShape ]! !!RSTContainer methodsFor: 'adding nodes edges'!addEdge: aShape	self edges add: aShape.	^ aShape! !!RSTContainer methodsFor: 'adding nodes edges'!addNode: aShape	self nodes add: aShape.	^ aShape! !!RSTContainer methodsFor: 'accessing'!edges	^ self privateEdges		ifNil: [ | res |			self privateEdges: (res := RSGroup new).			res ]! !!RSTContainer methodsFor: 'accessing'!nodes 	^ self privateNodes		ifNil: [ | res |			self privateNodes: (res := RSGroup new).			res ]! !!RSTContainer methodsFor: 'accessing'!numberOfEdges	^ self privateEdges		ifNil: [ 0 ]		ifNotNil: [ :edges | edges size ]! !!RSTContainer methodsFor: 'private'!privateEdges	^ self explicitRequirement! !!RSTContainer methodsFor: 'private'!privateEdges: aTSGroup	self explicitRequirement! !!RSTContainer methodsFor: 'private'!privateNodes	^ self explicitRequirement! !!RSTContainer methodsFor: 'private'!privateNodes: aTSGroup	self explicitRequirement! !!RSTContainer methodsFor: 'private'!privateShapes	^ self explicitRequirement! !!RSTContainer methodsFor: 'private'!privateShapes: aCollection	self explicitRequirement! !!RSTContainer methodsFor: 'removing'!removeEdge: anEdge	self edges remove: anEdge ifAbsent: [  ].! !!RSTContainer methodsFor: 'removing'!removeNode: aNode	self nodes remove: aNode ifAbsent: [  ].! !!RSTContainer methodsFor: 'accessing'!shapeFromModel: anObject	"Retreive a shape from a given model. Return nil if not found"	^ self nodes shapeFromModel: anObject! !!RSTContainer methodsFor: 'accessing'!shapes 	^ self privateShapes		ifNil: [ | res |			self privateShapes: (res := RSGroup new).			res ]! !!RSTPositionable methodsFor: 'actions'!translateBy: deltaAsPoint	"Move an element by a delta value, expressed as a point"	self translateTo: self position + deltaAsPoint	! !!RSTPositionable methodsFor: 'actions'!translateTo: aPoint	"Translate an element to a new position, expressed as a point"	| oldPosition |	oldPosition := self position.	oldPosition = aPoint ifTrue: [ ^ self ].	self position: aPoint.	self announce: [RSPositionChangedEvent new 		shape: self; 		oldPosition: oldPosition;		newPosition: aPoint ].! !!Object methodsFor: '*Roassal3'!rsValue: anArgument 	^ self! !!RSCamera class methodsFor: 'utilities'!maxExtentFor: rectangle	^ rectangle extent max: self minimumExtent! !!RSCamera class methodsFor: 'utilities'!minimumExtent	^ 0.0001 asPoint! !!RSCamera methodsFor: 'announce'!announce: anEvent	canvas announce: anEvent! !!RSCamera methodsFor: 'accessing'!canvas	^ canvas! !!RSCamera methodsFor: 'accessing'!canvas: aCanvas	canvas := aCanvas! !!RSCamera methodsFor: 'convertion'!distanceFromPixelToSpace: aPoint	^ (aPoint / self scale) asFloatPoint! !!RSCamera methodsFor: 'convertion'!fromPixelToSpace: aPoint	^ AthensAffineTransform new		translateBy: self position;		scaleBy: 1 / self scale;		translateBy: (self canvas extent / 2) negated;		transform: aPoint! !!RSCamera methodsFor: 'convertion'!fromSpaceToPixel: aPoint	^ AthensAffineTransform new		translateBy: self canvas extent / 2;		scaleBy: self scale;		translateBy: self position negated;		transform: aPoint	! !!RSCamera methodsFor: 'initialization'!initialize	super initialize.	position := 0@0.	scale := 1.0000001.! !!RSCamera methodsFor: 'accessing'!position	"Return the position of the camera. For example:```Smalltalkc := RSCanvas new.c add: (RSEllipse new size: 30).c camera translateBy: 25 @ 15.c camera  position```returns the value `25 @ 15`"	^ position! !!RSCamera methodsFor: 'accessing'!position: aPoint 	position := aPoint! !!RSCamera methodsFor: 'accessing'!scale	^ scale! !!RSCamera methodsFor: 'accessing'!scale: aNumber	| oldScale |	scale = aNumber ifTrue: [ ^ self ].	oldScale := scale.	scale := aNumber.	self canvas announce: [ RSScaleChangedEvent new		canvas: self canvas;		oldScale: oldScale;		newScale: aNumber ]! !!RSCamera methodsFor: 'actions'!translateTo: aPoint	| oldPosition |	oldPosition := self position.	oldPosition = aPoint ifTrue: [ ^ self ].	self position: aPoint.	self announce: [RSPositionChangedEvent new 		shape: self; 		oldPosition: oldPosition;		newPosition: aPoint ].! !!RSCamera methodsFor: 'zoom'!zoomToFit	self zoomToFit: canvas extent * 0.9! !!RSCamera methodsFor: 'zoom'!zoomToFit: anExtent	self 		zoomToFit: anExtent 		rectangle: canvas encompassingRectangle	! !!RSCamera methodsFor: 'zoom'!zoomToFit: anExtent extent: otherExtent	self 		zoomToFit: anExtent 		rectangle: (Rectangle floatCenter: 0@0 extent: otherExtent)	! !!RSCamera methodsFor: 'zoom'!zoomToFit: anExtent rectangle: rect	| sc |	sc := anExtent / (self class maxExtentFor: rect).	sc := sc x min: sc y.	self 		translateTo: rect floatCenter;		scale: sc.! !!RSCanvas methodsFor: 'visiting'!accept: visitor	visitor visitCanvas: self! !!RSCanvas methodsFor: 'animations'!addAnimation: anAnimation	"Schedule an animation, and run it until its completion"	animations add: anAnimation.	anAnimation canvas: self.	anAnimation start.	self signalUpdate! !!RSCanvas methodsFor: 'adding removing shapes'!addBasicShape: aShape	shapes add: aShape! !!RSCanvas methodsFor: 'adding removing shapes'!addFixedShape: aShape	fixedShapes add: aShape.! !!RSCanvas methodsFor: 'adding removing shapes'!addShape: aShape	aShape addedIn: self! !!RSCanvas methodsFor: 'adding removing shapes'!addShape: aShape before: otherShape	aShape addedIn: self.	shapes remove: aShape.	shapes add: aShape before: otherShape.! !!RSCanvas methodsFor: 'animations'!animations	^ animations! !!RSCanvas methodsFor: 'announcer'!announce: anEventOrAnEventClass	"Send an event"	| theEventToSend |	announcer ifNil: [ ^ self ].	theEventToSend := anEventOrAnEventClass value asAnnouncement.	theEventToSend canvas: self.	announcer announce: theEventToSend.! !!RSCanvas methodsFor: 'accessing'!basicRectangle	^ Rectangle origin: 0@0 extent: self extent! !!RSCanvas methodsFor: 'camera'!camera	"Return the camera used by the canvas:For example:```Smalltalkc := RSCanvas new.(1 to: 10) do: [ :i | c add: (RSEllipse new size: 20) ]. RSGridLayout on: c shapes.c camera translateBy: -30 @ 50.c ```"	^ camera! !!RSCanvas methodsFor: 'camera'!camera: aCamera	"Set a new camera for the canvas."	camera := aCamera! !!RSCanvas methodsFor: 'accessing'!canvas	^ self! !!RSCanvas methodsFor: 'testing'!clearBackground	"Return whether the screen must be cleaned at each screen refresh"	^ clearBackground! !!RSCanvas methodsFor: 'accessing'!clearBackground: aBool	"Determine if the canvas must be cleaned at each screen refresh. Per default it is, which means that if some shapes are translated, a footprint is left. This is useful to realize interesting visual effects.	For example, evaluate the following script:```Smalltalkc := RSCanvas new.c clearBackground: false.(1 to: 10) do: [ :i | c add: (RSEllipse new size: 20) ]. RSGridLayout on: c shapes.c.```And execute the expression `c camera translateBy: 1 @ 1.`"	clearBackground := aBool! !!RSCanvas methodsFor: 'accessing'!color 	^ color! !!RSCanvas methodsFor: 'accessing'!color: aColor	color := aColor.	color isColor ifTrue: [ ^ self ].	color := Color colorFrom: aColor.! !!RSCanvas methodsFor: 'morph creation'!createMorph	"Create a Morph that contains myself."	morph := RSAthensMorph new. 	morph renderer: RSAthensRenderer new.	morph canvas: self.	^ morph! !!RSCanvas methodsFor: 'accessing'!edges	"Return all the lines contained in the canvas."	^ self privateEdges		ifNil: [ | res |			self privateEdges: (res := RSGroup new).			res ]! !!RSCanvas methodsFor: 'accessing - computed'!encompassingRectangle	^ self encompassingRectangleOf: shapes! !!RSCanvas methodsFor: 'accessing - computed'!encompassingRectangleOf: aCollectionOfShapes	| r |	r := aCollectionOfShapes		ifEmpty: [ 0@0 corner: 0@0 ]		ifNotEmpty: [ Rectangle 			merging: (aCollectionOfShapes 				collect: [:each | each encompassingRectangle] ) ].	^ r topLeft extent: (self camera class maxExtentFor: r)! !!RSCanvas methodsFor: 'accessing'!extent	^ extent! !!RSCanvas methodsFor: 'accessing'!extent: aPoint	| evt |	evt := RSExtentChangedEvent new		shape: self;		oldExtent: extent;		newExtent: (extent := aPoint).	self announce: evt! !!RSCanvas methodsFor: 'accessing'!fixedShapes	"Return the list of shapes that are fixed, i.e., not subjet to the camera"	^ fixedShapes ! !!RSCanvas methodsFor: 'accessing'!fixedShapes: aCollection 	fixedShapes := aCollection! !!RSCanvas methodsFor: 'matrix'!globalMatrix	^ AthensAffineTransform new! !!RSCanvas methodsFor: 'animations'!hasAnimation	"True if at least one animation is running"	^ animations notEmpty! !!RSCanvas methodsFor: 'animations'!hasAnimation: anAnimation	"True if anAnimation is running"	^ animations includes: anAnimation! !!RSCanvas methodsFor: 'debug support'!hideEncompassingRectangles	showRectangles := false.! !!RSCanvas methodsFor: 'initialization'!initialize	super initialize.	showRectangles := false.	shapes := RSGroup new.	fixedShapes := RSGroup new.	nodes := RSGroup new.	edges := RSGroup new.	animations := OrderedCollection new.	clearBackground := true.	color := Color white.	extent := 500@500.	camera := RSCamera new		canvas: self;		yourself.! !!RSCanvas methodsFor: 'testing'!isShape	"Useful to lookup the canvas in a hierarchy of nested shapes"	^ false! !!RSCanvas methodsFor: 'accessing'!morph	^ morph! !!RSCanvas methodsFor: 'accessing'!morph: aMorph	morph := aMorph! !!RSCanvas methodsFor: 'accessing'!nodes 	"Return all the shapes except lines contained in the canvas."	^ self privateNodes		ifNil: [ | res |			self privateNodes: (res := RSGroup new).			res ]! !!RSCanvas methodsFor: 'animations'!numberOfAnimations	"Return the number of animations contained in the canvas"	^ animations size! !!RSCanvas methodsFor: 'accessing'!numberOfFixedShapes	"Return the number of fixed shapes"	^ fixedShapes size! !!RSCanvas methodsFor: 'accessing'!numberOfShapes	"Return the number of non-fixed shapes"	^ shapes size! !!RSCanvas methodsFor: 'morph creation'!open	| window |	self createMorph.	window := morph openInWindow.	window extent: 500@500.	morph privateOwner: window.	^ window	! !!RSCanvas methodsFor: 'morph creation'!openOnce	"Open a visualization and record the position. When #openOnce is called a second time,	the new window replace the previous one, at the recorded position. This method is useful when 	demoing and scripting."	| bounds win |	bounds := nil. 	Smalltalk at: #previousWindow ifPresent: [ :w | bounds := w bounds. w close ].	win := self open.	Smalltalk at: #previousWindow put: win.	bounds ifNotNil: [		win bounds: bounds ]! !!RSCanvas methodsFor: 'accessing'!parent	^ self! !!RSCanvas methodsFor: 'animations'!playAnimations	| shouldClean |	shouldClean := false.	animations do: [ :animation | 		animation refresh. 		animation hasCompleted			ifTrue: [ shouldClean := true. ] ].	shouldClean ifTrue: [ 		animations copy do: [ :animation |			animation hasCompleted ifTrue: [ animation remove ] ] ].! !!RSCanvas methodsFor: 'private'!privateEdges	^ edges! !!RSCanvas methodsFor: 'private'!privateEdges: aTSGroup	edges := aTSGroup! !!RSCanvas methodsFor: 'private'!privateNodes	^ nodes! !!RSCanvas methodsFor: 'private'!privateNodes: aTSGroup	nodes := aTSGroup! !!RSCanvas methodsFor: 'shapes controling'!pushBack: aShape	"Shapes are ordered in the same order they are inserted. The order can be changed using #pushFront: and #pushBack.For example:```Smalltalkc := RSCanvas new.shape1 := RSEllipse new size: 50; color: #red.shape2 := RSEllipse new size: 50; color: #blue.shape2 translateBy: -25@0.c add: shape1; add: shape2.c pushFront: shape1.c.```	"	| col |	col := aShape isFixed 		ifTrue: [ fixedShapes ]		ifFalse: [ shapes ].	col 		remove: aShape;		addFirst: aShape.! !!RSCanvas methodsFor: 'shapes controling'!pushFront: aShape	"Shapes are ordered in the same order they are inserted. The order can be changed using #pushFront: and #pushBack.For example:```Smalltalkc := RSCanvas new.shape1 := RSEllipse new size: 50; color: #red.shape2 := RSEllipse new size: 50; color: #blue.shape2 translateBy: -25@0.c add: shape1; add: shape2.c pushFront: shape1.c.```The red circle is in front of the blue one, despite the red one is inserted first."	| col |	col := aShape isFixed 		ifTrue: [ fixedShapes ]		ifFalse: [ shapes ].	col 		remove: aShape ifAbsent: [];		addLast: aShape.! !!RSCanvas methodsFor: 'adding removing shapes'!removeFixedShape: aShape	fixedShapes remove: aShape! !!RSCanvas methodsFor: 'adding removing shapes'!removeShape: shape	| evt index |	index := shapes indexOf: shape.	index = 0 		ifTrue: [ index := fixedShapes indexOf: shape.			index = 0 ifFalse: [ fixedShapes remove: shape ] ]		ifFalse: [ shapes removeAt: index ].		shape parent: nil.	evt := RSShapeRemovedEvent new shape: shape.	self announce: evt.	shape announce: evt.	! !!RSCanvas methodsFor: 'adding removing shapes'!setAsFixed: aShape	self removeShape: aShape.	aShape isFixed: true.	self addShape: aShape.	! !!RSCanvas methodsFor: 'accessing - shapes'!shapeWithAction: eventClass forPositionInPixels: position	"position is in pixel, it corresponds to the physical location in the window.	e.g., 0 @ 0 is top left of the window"	| block |	block := [ :list :pos| 		list reverseDo: [ :s | | shape |			shape := s shapeWithAction: eventClass forPosition: pos.			shape ifNotNil: [ ^ shape ] ] ].	block value: fixedShapes value: position.	block value: shapes value: (self camera fromPixelToSpace: position).	^ self! !!RSCanvas methodsFor: 'accessing - shapes'!shapeWithActionForPositionInPixels: position	"position is in pixel, it corresponds to the physical location in the window.	e.g., 0 @ 0 is top left of the window"	| block |	block := [ :list :pos |		list reverseDo: [ :s | | shape |			shape := s shapeWithActionForPosition: pos.			shape ifNotNil: [^ shape ] ] ].	block value: fixedShapes value: position.	block value: shapes value: (self camera fromPixelToSpace: position).	^ self	! !!RSCanvas methodsFor: 'accessing'!shapes	^ shapes! !!RSCanvas methodsFor: 'accessing'!shapes: aCollection	shapes := aCollection! !!RSCanvas methodsFor: 'accessing - shapes'!shapesFromModels: objects	"Return shapes that corresponds to the objects provided as parameter. If none is found, then return an empty collection"	^ self nodes shapesFromModels: objects! !!RSCanvas methodsFor: 'debug support'!showEncompassingRectangles	showRectangles := true.! !!RSCanvas methodsFor: 'testing'!showRectangles	^ showRectangles! !!RSCanvas methodsFor: 'updating'!signalUpdate	"Signal a platform signal that the canvas should be refreshed. This is important when some shapes are modified (color or position)."	morph changed! !!RSCanvas methodsFor: 'accessing'!topParent	^ self! !!RSCanvas methodsFor: 'accessing - computed'!transform: aPoint	^ aPoint! !!RSCanvas methodsFor: 'accessing - computed'!visibleRectangle	^ Rectangle 		floatCenter: self camera position		extent: self extent / self camera scale.! !!RSCanvas methodsFor: 'camera'!zoomToFit	self camera zoomToFit! !!RSObjectWithProperty methodsFor: 'interactions'!@ anInteractionClassOrInstance	"Add an interaction to the canvas or a shape.Here is an example that illustrate two interactions, one for a shape and another for the canvas:-=-=-=-=-=-=-=-=-=c := RSCanvas new.shape := RSEllipse new size: 30; model: 'hello'.c add: shape.shape @ RSPopup.c @ RSCanvasController-=-=-=-=-=-=-=-=-=	"		self addInteraction: anInteractionClassOrInstance! !!RSObjectWithProperty methodsFor: 'interactions'!addInteraction: anInteractionClassOrInstance 	anInteractionClassOrInstance onShape: self! !!RSObjectWithProperty methodsFor: 'announcer'!announce: anEventOrAnEventClass	"Send an event"	self subclassResponsibility! !!RSObjectWithProperty methodsFor: 'announcer'!announcer 	^ announcer ifNil: [ announcer := Announcer new ]! !!RSObjectWithProperty methodsFor: 'announcer'!announcer: anAnnouncer	announcer := anAnnouncer! !!RSObjectWithProperty methodsFor: 'accessing'!canvas	^ self subclassResponsibility! !!RSObjectWithProperty methodsFor: 'events'!click	"Simulate a click. 	For example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.box := RSBox new size: 40.box when: RSMouseClick do: [ :evt | self inform: 'hello' ].c add: box.box click.c-=-=-=-=-=-=-=-=-="	self announcer announce: (RSMouseClick new).! !!RSObjectWithProperty methodsFor: 'interactions'!getInteractionsForClass: anInteractionClass	"Return the Announcement subscriptions for the interaction"	^ self announcer subscriptions getInteractionsForClass: anInteractionClass! !!RSObjectWithProperty methodsFor: 'interactions'!hasInteraction: anInteractionClass	"Return true or false if the receiver has an interaction. Note that the argument has to be an interaction class. And not an event"	self announcer subscriptions ifNil: [ ^ false ].	^ self announcer subscriptions handleSubscriberClass: anInteractionClass! !!RSObjectWithProperty methodsFor: 'properties'!hasProperties	^ properties notNil and: [ properties notEmpty ]! !!RSObjectWithProperty methodsFor: 'properties'!hasProperty: aKey 	^ properties notNil and: [ properties includesKey: aKey ]! !!RSObjectWithProperty methodsFor: 'announcer'!privateAnnouncer	^ announcer! !!RSObjectWithProperty methodsFor: 'private'!privateAttributes	^ properties! !!RSObjectWithProperty methodsFor: 'properties'!properties	^ properties ifNil: [ properties := Dictionary new ]! !!RSObjectWithProperty methodsFor: 'properties'!propertiesDo: block	self hasProperties ifFalse: [ ^ self ].	block value: self properties.! !!RSObjectWithProperty methodsFor: 'properties'!propertyAt: aKey	^ self properties at: aKey ifAbsent: [ nil ]! !!RSObjectWithProperty methodsFor: 'properties'!propertyAt: aKey ifAbsent: aBlockClosure 	^ self properties at: aKey ifAbsent: aBlockClosure ! !!RSObjectWithProperty methodsFor: 'properties'!propertyAt: aKey ifAbsentPut: aBlockClosure 	^ self properties at: aKey ifAbsentPut: aBlockClosure ! !!RSObjectWithProperty methodsFor: 'properties'!propertyAt: aKey ifPresent: aBlockClosure 	^ self properties at: aKey ifPresent: aBlockClosure ! !!RSObjectWithProperty methodsFor: 'properties'!propertyAt: aKey put: value	^ self properties at: aKey put: value! !!RSObjectWithProperty methodsFor: 'events'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!RSObjectWithProperty methodsFor: 'interactions'!removeInteractionIfPresent: anInteractionClass	"Remove all the callbacks associated to the interaction."	(self hasInteraction: anInteractionClass) ifFalse: [ ^ self ].	(self getInteractionsForClass: anInteractionClass) do: [ :int | self announcer unsubscribe: int ]! !!RSObjectWithProperty methodsFor: 'properties'!removeKey: aKey	| att |	att := self properties.	(att includesKey: aKey) ifFalse: [ ^ self ].	att removeKey: aKey.	! !!RSObjectWithProperty methodsFor: 'properties'!removePropertyAt: aKey	^ self properties removeKey: aKey! !!RSObjectWithProperty methodsFor: 'properties'!removePropertyAt: aKey ifAbsent: anErrorBlock	^ self properties removeKey: aKey ifAbsent: anErrorBlock! !!RSObjectWithProperty methodsFor: 'announcer'!when: event do: aBlock	self announcer when: event do: aBlock! !!RSObjectWithProperty methodsFor: 'announcer'!when: anAnnouncementClass send: aSelector to: anObject	self announcer when: anAnnouncementClass send: aSelector to: anObject! !!RSShape methodsFor: 'adding'!accept: aVisitor	self subclassResponsibility ! !!RSShape methodsFor: 'adding'!addedIn: aCanvas	| evt |	self isFixed		ifTrue: [ aCanvas addFixedShape: self ]		ifFalse: [ aCanvas addBasicShape: self ].	parent ifNotNil: [ self remove ].	parent := aCanvas.		evt := RSShapeAddedEvent new shape: self.	self announce: evt.! !!RSShape methodsFor: 'announcer'!announce: anEventOrAnEventClass	"Send an event"	| theEventToSend |	announcer ifNil: [ ^ self ].	theEventToSend := anEventOrAnEventClass value asAnnouncement.	theEventToSend canvas: self canvas.	theEventToSend shape: self.	announcer announce: theEventToSend.! !!RSShape methodsFor: 'border'!border	^ border! !!RSShape methodsFor: 'border'!border: aBorder	border := aBorder! !!RSShape methodsFor: 'border'!borderColor	^ self border color! !!RSShape methodsFor: 'border'!borderColor: aColor	self border color: aColor! !!RSShape methodsFor: 'accessing - computed'!canvas	"Return the canvas in which I belong to. Can return nil if the shape is not added to a canvas" 	parent ifNil: [ ^ nil ].	^ parent isShape 		ifTrue: [ parent canvas ]		ifFalse: [ parent ]! !!RSShape methodsFor: 'accessing'!children	"only RSComposite can use children"	^ nil! !!RSShape methodsFor: 'accessing'!color	^ paint ! !!RSShape methodsFor: 'accessing'!color: aColor	"Set the color of the shape. ```Smalltalkc := RSCanvas new.c add: (RSBox new size: 50; color: #blue).c```	```Smalltalkc := RSCanvas new.c add: (RSBox new size: 50; color: Color blue).c```	"	paint := aColor.	paint isColor ifTrue: [ ^ self ].	paint := Color colorFrom: aColor.! !!RSShape methodsFor: 'accessing'!computeEncompassingRectangle	self subclassResponsibility! !!RSShape methodsFor: 'copying'!copyWithAnnouncer	"Answer a copy of this shape that shares the same instance of announcer (The default #postCopy cleans it). 	This means that interactions and subscription handlers to any RSEvent will be shared between both instances. 	This is useful for optimizations. Senders should be careful!! 		Example:		base := RSBox new		    size: 100;		    color: Color blue;		    popup;		    draggable.		    		shapes := (1 to: 20) collect:[:i | 		    base copyWithEvents		        model: i;		        yourself.		    ].		c := RSCanvas new.		RSHorizontalLineLayout on: shapes.		c addAll: shapes.		c zoomToFit.	"	^ self copy		announcer: announcer;		yourself! !!RSShape methodsFor: 'accessing - attributes'!depth	^ self propertyAt: #depth! !!RSShape methodsFor: 'accessing - attributes'!depth: anObject	"depth is used by tree builders usefull to relationate hierarchy visualizations"	self propertyAt: #depth put: anObject! !!RSShape methodsFor: 'accessing'!encompassingRectangle	^ encompassingRectangle ifNil: [ 		encompassingRectangle := self computeEncompassingRectangle ].! !!RSShape methodsFor: 'accessing'!encompassingRectangle: aRectangle	encompassingRectangle := aRectangle! !!RSShape methodsFor: 'accessing'!extent	^ self encompassingRectangle extent! !!RSShape methodsFor: 'testing'!hasBorder	^ border notNil and: [ border width > 0 ].! !!RSShape methodsFor: 'testing'!hasChildren	^ false! !!RSShape methodsFor: 'testing'!hasEventCallback	"Return true if at least one event callback has been added to the shape"	^ announcer notNil and: [ announcer numberOfSubscriptions > 0 ]! !!RSShape methodsFor: 'accessing'!height	^ self extent y! !!RSShape methodsFor: 'testing'!includesPoint: aPoint	"Answer whether this shape includes aPoint."	^ false! !!RSShape methodsFor: 'accessing - attributes'!index	^ self propertyAt: #index! !!RSShape methodsFor: 'accessing - attributes'!index: anObject	"the current index of this object in an object collection"	self propertyAt: #index put: anObject! !!RSShape methodsFor: 'initialization'!initialize	super initialize.	paint := Color lightGray.	isFixed := false.! !!RSShape methodsFor: 'testing'!isEdge	^ false! !!RSShape methodsFor: 'testing'!isFixed 	^ isFixed! !!RSShape methodsFor: 'accessing'!isFixed: aBool	isFixed := aBool! !!RSShape methodsFor: 'testing'!isInACanvas	^ parent notNil! !!RSShape methodsFor: 'testing'!isNode	^ false! !!RSShape methodsFor: 'accessing - attributes'!isSLeaf	^ self schildren isEmpty! !!RSShape methodsFor: 'testing'!isShape	"Useful to lookup the canvas in a hierarchy of nested shapes"	^ true! !!RSShape methodsFor: 'actions'!loadShape: aShape	self subclassResponsibility! !!RSShape methodsFor: 'accessing - attributes'!model	^ self propertyAt: #model! !!RSShape methodsFor: 'accessing - attributes'!model: anObject	"model is used to create popups and other interactions"	self propertyAt: #model put: anObject! !!RSShape methodsFor: 'border'!noBorder	border := nil! !!RSShape methodsFor: 'accessing'!noPaint	paint := nil! !!RSShape methodsFor: 'accessing'!paint	^ paint! !!RSShape methodsFor: 'accessing'!paint: aPaint	"Receive a Color or an Athens paint object"	paint := aPaint! !!RSShape methodsFor: 'accessing'!paintOn: visitor	^ visitor paintFor: self form: self paint! !!RSShape methodsFor: 'accessing'!parent	^ parent! !!RSShape methodsFor: 'accessing'!parent: aCanvasOrComposite	parent := aCanvasOrComposite! !!RSShape methodsFor: 'path'!path	^ path! !!RSShape methodsFor: 'path'!path: aPath	"Keep a AthensCairoPath"	path := aPath! !!RSShape methodsFor: 'copying'!postCopy	self 		parent: nil;		announcer: nil;		resetPath;		resetBBox! !!RSShape methodsFor: 'printing'!printOn: stream	| model |	super printOn: stream.	model := self model.	model ifNil: [ ^ self ].	stream << '('; << model asString; << ')'.! !!RSShape methodsFor: 'actions'!pushBack	"Move the element behind. This method can be called only if the shape is in a canvas"	self assert: [ parent notNil ] description: 'Should add the shape in a canvas first'.	parent pushBack: self.! !!RSShape methodsFor: 'actions'!pushFront	parent pushFront: self.! !!RSShape methodsFor: 'actions'!remove	"Do nothing if the line is not already in a canvas"	self isInACanvas ifFalse: [ ^ self ].	parent removeShape: self	! !!RSShape methodsFor: 'adding'!renderOn: aCanvas	self subclassResponsibility! !!RSShape methodsFor: 'actions'!replaceWith: aShape	parent ifNil: [ ^ self ].	aShape loadShape: self.	parent shapes replaceAll: self with: aShape.	parent nodes replaceAll: self with: aShape.	! !!RSShape methodsFor: 'initialization'!resetBBox	encompassingRectangle := nil.! !!RSShape methodsFor: 'path'!resetPath	path := nil! !!RSShape methodsFor: 'accessing - attributes'!schildren	^ self propertyAt: #schildren! !!RSShape methodsFor: 'accessing - attributes'!schildren: anObject	"children is used by tree builders usefull to relationate hierarchy visualizations"	self propertyAt: #schildren put: anObject! !!RSShape methodsFor: 'path'!sessionChanged	"This method releases all the native graphical resources. This method is typically invoked when starting a Pharo image with a visualization that was previously open"	self resetPath! !!RSShape methodsFor: 'actions'!setAsFixed	parent ifNil: [ self error: 'Add first this shape in the canvas' ].	parent setAsFixed: self.	isFixed := true.! !!RSShape methodsFor: 'accessing'!shape	^ self! !!RSShape methodsFor: 'accessing - computed'!shapeWithAction: eventClass forPosition: position	^ (self hasEventCallback and: [ 		(self announcer handleEventClass: eventClass)			and: [ self includesPoint: position ] ]) 			ifTrue: [ self ]			ifFalse: [ nil ]! !!RSShape methodsFor: 'accessing - computed'!shapeWithActionForPosition: position	^ (self hasEventCallback and: [ self includesPoint: position ] ) 			ifTrue: [ self ]			ifFalse: [ ^ nil ]! !!RSShape methodsFor: 'actions'!signalUpdate	"Refresh the canvas"	parent ifNil: [ ^ self ].	parent signalUpdate! !!RSShape methodsFor: 'accessing - attributes'!sparent	^ self propertyAt: #sparent! !!RSShape methodsFor: 'accessing - attributes'!sparent: anObject	"children is used by tree builders usefull to relationate hierarchy visualizations"	self propertyAt: #sparent put: anObject! !!RSShape methodsFor: 'accessing'!topParent	^ parent topParent! !!RSShape methodsFor: 'accessing'!width	^ self extent x! !!RSAthensRenderer methodsFor: 'utilities'!applyRadius: radius on: controlPoints from: start to: end	"based on https://riptutorial.com/html5-canvas/example/18766/render-a-rounded-polygon-"	| cp p1 p2 p3 arc v1 len1 a1 v2 len2 a2 sinA sin90 	angle radDir drawDir halfAngle cRadius lenOut p a b len |	cp := controlPoints.	len := cp size.	p1 := p2 := p3 := nil.	arc := [ 		v1 := p1 - p2.		len1 := ((v1 x * v1 x) + (v1 y * v1 y)) sqrt.		v1 := v1 / len1.		a1 := v1 angle.				v2 := p3 - p2.		len2 := ((v2 x * v2 x) + (v2 y * v2 y)) sqrt.		v2 := v2 / len2.		a2 := v2 angle.					sinA := (v1 x * v2 y) - (v1 y * v2 x).		sin90 := (v1 x * v2 x) - (v1 y * v2 y negated).		angle := sinA arcSin.		radDir := 1.		drawDir := false.				sin90 < 0 ifTrue: [ 			angle < 0 ifTrue: [ 				angle := angle + Float pi ]			ifFalse: [ 				angle := angle - Float pi.				radDir := -1.				drawDir := true ] ]		ifFalse: [ 			angle >= 0 ifTrue: [ 				radDir := -1.				drawDir := true. ] ].		halfAngle := angle / 2.		sinA :=  halfAngle sin.		lenOut := sinA = 0 			ifTrue: [ Float infinity ]			ifFalse: [ (halfAngle cos * radius/ sinA) abs].		cRadius := radius.		lenOut > ((len1 / 2) min: (len2 / 2)) ifTrue: [ 			lenOut := (len1 / 2) min: (len2 / 2).			cRadius := (lenOut * halfAngle tan) abs.			].		p := p2 + (v2 * lenOut) + (v2 y negated@ v2 x * cRadius * radDir).		a := a1 + (Float halfPi * radDir).		b := a2 - (Float halfPi * radDir). 		(a closeTo: b) ifTrue: [ a := b ].		builder 			arcAround: p			radius: cRadius			startAngle: a			endAngle: b			cw: drawDir. ].	start to: end do: [ :i |		p1 := cp at: (i)%len + 1.		p2 := cp at: (i + 1)%len + 1.		p3 := cp at: (i + 2)%len + 1.		(p1 = p2 or: [p2 = p3]) ifFalse: [ arc value ] ].	! !!RSAthensRenderer methodsFor: 'utilities'!arcCornerTangets: p0 p1: p1 r: r1 rc: rc cw: cw	| x01 y01 lo ox oy x1 y1 x2 y2 x3 y3 dx dy d2 r d D cx0 cy0 cx1 cy1 dx0 dy0 dx1 dy1 |	x01 := p0 x - p1 x.	y01 := p0 y - p1 y.	lo := (cw ifTrue:[rc ] ifFalse: [ rc negated ]) / ((x01 * x01) + (y01*y01)) sqrt.	ox := lo * y01.	oy := lo negated * x01.	x1 := p0 x + ox.	y1 := p0 y + oy.	x2 := p1 x + ox.	y2 := p1 y + oy.	x3 := (x1 + x2)/2.	y3 := (y1 + y2)/2.	dx := x2 - x1.	dy := y2 - y1.	d2 := (dx * dx) + (dy * dy).	r := r1 - rc.	D := (x1 * y2) - (x2 * y1).	d := (dy < 0 ifTrue: [ -1 ] ifFalse: [ 1 ]) * (0 max: ((r*r *d2) - (D * D) ) ) sqrt.	cx0 := ((D * dy) - (dx * d)) / d2.	cy0 := ( (D negated * dx) - (dy * d) ) / d2.	cx1 := ((D * dy) + (dx * d)) / d2.	cy1 := ( (D negated * dx) + (dy * d) ) / d2.	dx0 := cx0 - x3.	dy0 := cy0 - y3.	dx1 := cx1 - x3.	dy1 := cy1 - y3.	((dx0 * dx0) + (dy0 * dy0)) > ((dx1 * dx1) + (dy1 * dy1)) ifTrue: [ 		cx0 := cx1.		cy0 := cy1 ].	^  (cx0 - ox)@ (cy0 - oy) negated -> ((cx0 * r1 / r)@(cy0 * r1/r) negated).! !!RSAthensRenderer methodsFor: 'utilities'!arcSweep: p1 and: p2	^ ((p1 x - p2 x)* p1 y) - ((p1 y - p2 y) * p1 x) > 0		ifTrue: [ 1 ] 		ifFalse: [ 0 ]! !!RSAthensRenderer methodsFor: 'utilities'!asin: x	^ x >= 1	ifTrue: [ 1.5707963267948966 ]	ifFalse: [ x <= -1		ifTrue: [ -1.5707963267948966 ]		ifFalse: [ x arcSin ] ].	! !!RSAthensRenderer methodsFor: 'creating path'!buildBezierPath: bezier	| points |	points := bezier controlPoints.	points size = 2 ifTrue: [ 		builder 			absolute; 			moveTo: points first; 			lineTo: points second.		^ self ].	points size = 3 ifTrue: [ 		builder 			absolute; 			moveTo: points first; 			curveVia: points second 				to: points third.		^ self ].	points size = 4 ifTrue: [ 		builder			absolute; 			moveTo: points first; 			curveVia: points second 				and: points third 				to: points fourth  ].	! !!RSAthensRenderer methodsFor: 'creating path'!buildBoxPath: box	box hasCornerRadius 		ifTrue: [ self buildCornerBoxPath: box ]		ifFalse: [ self buildSimpleBoxPath: box ]	! !!RSAthensRenderer methodsFor: 'creating path'!buildCornerBoxPath: box	| c rectangle e w2 h2 tl tr bl br min |	c := box cornerRadius.	rectangle := box baseRectangle.	e := rectangle extent.	w2 := e x / 2.0.	h2 := e y / 2.0.	min := w2 min: h2.	tl := (c topLeft min: min) max: 0.	tr := (c topRight min: min) max: 0.	bl := (c bottomLeft min: min) max: 0.	br := (c bottomRight min: min) max: 0.		builder		absolute;		moveTo: rectangle topLeft + (tl@0);		lineTo: rectangle topRight - (tr@0);		cwArcTo: rectangle topRight + (0@tr) angle: Float halfPi;		lineTo: rectangle bottomRight- (0 @ br);		cwArcTo: rectangle bottomRight - (br @ 0) angle: Float halfPi;		lineTo: rectangle bottomLeft + (bl @ 0);		cwArcTo: rectangle bottomLeft - (0@ bl) angle: Float halfPi;		lineTo: rectangle topLeft + (0@ tl);		cwArcTo: rectangle topLeft + (tl @0) angle: Float halfPi;		closePath.! !!RSAthensRenderer methodsFor: 'creating path'!buildEllipsePath: ellipse	| extent halfWidth halfHeight |	extent := ellipse baseRectangle extent.	halfWidth := extent x / 2 asFloat.	halfHeight := extent y / 2 asFloat.		builder		absolute;		moveTo: 0@0;		relative;		moveTo: halfWidth negated @ 0;		curveVia: 0 @ (halfHeight negated * 0.55)			and: (0.45 * halfWidth) @ halfHeight negated			to: halfWidth @ halfHeight negated;		curveVia: (halfWidth * 0.55) @ 0			and: halfWidth @ (0.45 * halfHeight)			to: halfWidth @ halfHeight;		curveVia: 0 @ (halfHeight * 0.55)			and: (0.45 * halfWidth negated) @ halfHeight			to: halfWidth negated @ halfHeight;		curveVia: (halfWidth negated * 0.55) @ 0			and: halfWidth negated @ (halfHeight negated * 0.45)			to: halfWidth negated @ halfHeight negated.	! !!RSAthensRenderer methodsFor: 'creating path'!buildLinePath: line	builder		absolute;		moveTo: line startPoint;		lineTo: line endPoint.! !!RSAthensRenderer methodsFor: 'creating path'!buildPolygonPath: polygon	| first radius cp |	builder absolute.	radius := polygon cornerRadii.	cp := polygon points.	[	(radius ~= 0 and: [ cp size > 2 ]) ifTrue: [ 		builder moveTo: (cp first + cp second) /2.		self applyRadius: radius on: cp from: 0 to: cp size-1.		^ self ].	first := true.	cp do: [ :point |		first ifTrue: [ 			first := false.			builder moveTo: point ]		ifFalse: [ 			builder lineTo: point ] ].	] ensure: [ builder closePath. ].			! !!RSAthensRenderer methodsFor: 'creating path'!buildPolylinePath: line	| first cp radius |	builder absolute.	cp := line controlPoints.	radius := line cornerRadii.	(radius ~= 0 and: [ cp size > 2 ]) ifTrue: [ 		builder moveTo: cp first.		self applyRadius: radius on: cp from: 0 to: cp size - 3.		builder lineTo: cp last.		^ self ].	first := true.	cp do: [ :point | 		first ifTrue: [ 			first := false.			builder moveTo: point ]		ifFalse: [ 			builder lineTo: point ] ]! !!RSAthensRenderer methodsFor: 'creating path'!buildRingPath: ring	| aAngle bAngle xAngle i e center ap epsilon aAngle2 bAngle2 	rp da da0 da1 rc x1 x2 x3 x4 y1 y2 y3 y4 rc0 rc1 t41 t23  t14 t32 |	epsilon := 1e-12.	ap := (ring segmentSpacing / 2) degreesToRadians.	aAngle := ring alphaAngle degreesToRadians.	bAngle := ring betaAngle degreesToRadians.	da := da0 := da1 := (aAngle - bAngle) abs.	aAngle2 := aAngle.	bAngle2 := bAngle.	center := 0@0.	i := ring innerRadius asFloat.	e := ring externalRadius asFloat.	e < i ifTrue: [ | r0 | 		r0 := i. i := e. e := r0. ].		builder absolute.	"is it a point? "	e < epsilon ifTrue: [ ^ builder  moveTo: center ].		"or is a circle? "	da0 > (Float pi * 2 - epsilon) ifTrue: [ 		builder 			moveTo: ((e * aAngle cos)@( e * aAngle sin negated)) + center ;			arcAround: center radius: e startAngle: aAngle endAngle: bAngle.		i > epsilon ifTrue: [ 			builder				moveTo: (i * (aAngle cos @ aAngle sin negated) )+ center ;				arcAround: center radius: i startAngle: aAngle endAngle: bAngle ].		builder close.		^ self ]. 	"circle part"	xAngle := (aAngle + bAngle)/2.	rp := ((i*i) + (e*e)) sqrt.	"apply padding"	rp > epsilon ifTrue: [ | p0 p1 |		p0 := i isZero 			ifTrue: [ self asin: Float infinity ]			ifFalse: [ self asin: (rp / i * ap sin) ].		p1 := self asin: (rp / e * ap sin).		da0 := da0 - (p0*2).		da0 > epsilon			ifTrue: [ aAngle2 := aAngle2 + p0. bAngle2 := bAngle - p0 ] 				ifFalse: [ aAngle2 := bAngle2 := (aAngle + bAngle)/2. ].		da1 := da1 - (p1*2).		da1 > epsilon			ifTrue: [ aAngle := aAngle + p1. bAngle := bAngle - p1 ]			ifFalse: [ aAngle := bAngle := xAngle ] ].	x1 := e*aAngle cos.	y1 := e*aAngle sin.	x2 := e*bAngle cos.	y2 := e*bAngle sin.	x4 := i*aAngle2 cos.	y4 := i*aAngle2 sin.	x3 := i*bAngle2 cos.	y3 := i*bAngle2 sin.		"is it small circle part?"	(aAngle - bAngle) abs < 0.001 ifTrue: [ 		builder 			moveTo: (x3@y3) + center;			close.		^ self ].	"apply corner radius"	rc := ((i -e) abs /2) min: ring cornerRadii.	rc0 := rc1 := rc.	(da > epsilon and: [ rc > 0.001 ]) ifTrue: [ 			da < Float pi ifTrue: [ 			| oc ax ay bx by kc lc |			oc := self geomPolygonIntersectC: x1@y1 d: x4@y4 a: x2@y2  b: x3@y3.			ax := x1 - oc x.			ay := y1 - oc y.			bx := x2 - oc x.			by := y2 - oc y.			kc := 1 / (( ((ax*bx) + (ay*by)) /  ( ((ax*ax)+ (ay*ay)) sqrt * ( (bx*bx)+(by*by) ) sqrt ) ) arcCos / 2) sin.			lc := ((oc x * oc x) + (oc y*oc y)) sqrt.			rc0 := rc0 min: ((e - lc) / (kc + 1)).			rc1 := rc1 min: ((i - lc) / (kc - 1)) ].		t41 := self arcCornerTangets: x4@y4 p1: x1@y1 r: e rc: rc0 cw: true.		t23 := self arcCornerTangets: x2@y2 p1: x3@y3 r: e rc: rc0 cw: true.		builder moveTo: t41 key + center.		rc0 == rc ifTrue: [ 			builder 				ellipticalArc2: rc0@rc0 					xrot: 0					large: 0					sweep: 0					to: t41 value + center;				ellipticalArc2: e@e					xrot: 0					large: (self arcSweep: t41 value and: t23 value)					sweep: 0					to: t23 value + center;				ellipticalArc2: rc0@rc0					xrot: 0					large: 0					sweep: 0					to: t23 key + center.				 ]		ifFalse: [ 			builder 				ellipticalArc2: rc0@rc0 					xrot: 0 					large: 1 					sweep: 0					to: t23 key + center ].		(x4 isZero & y4 isZero) ifTrue: [ 			builder lineTo: center. ]		ifFalse: [ 			t14 := self arcCornerTangets: x1@y1 p1: x4@y4 r: i rc: rc1 negated cw: true.			t32 := self arcCornerTangets: x3@y3 p1: x2@y2 r: i rc: rc1 negated cw: true.			builder lineTo: t32 key + center.			(rc == rc1 and: [da0 > 0 ]) ifTrue: [ 				builder 					ellipticalArc2: rc1@ rc1						xrot: 0						large: 0						sweep: 0						to: t32 value + center;					ellipticalArc2: i@i						xrot: 0						large: (self arcSweep: t14 value and: t32 value) 						sweep: 1						to: t14 value + center;					ellipticalArc2: rc1@rc1						xrot: 0						large: 0						sweep: 0						to: t14 key + center			] ifFalse: [ 				builder 					ellipticalArc2: rc1@ rc1						xrot: 0						large: 0						sweep: 0						to: t14 key + center		 ] ]	] ifFalse: [ | l0 l1 |		l1 := (bAngle - aAngle) abs <= Float pi ifTrue: [ 0 ] ifFalse: [ 1 ].		l0 := (bAngle2 - aAngle2) abs <= Float pi ifTrue: [ 0 ] ifFalse: [ 1 ].				builder			moveTo: x1 @ y1 negated;			ellipticalArc2: e@ e negated		 		xrot: 0				large: l1				sweep: 0				to: x2@y2 negated;			lineTo: x3@y3 negated;			ellipticalArc2: i@i negated				xrot: 0				large: l0				sweep: 1				to: x4@y4 negated.	].	builder close.! !!RSAthensRenderer methodsFor: 'creating path'!buildSimpleBoxPath: box	| rectangle |	rectangle := box baseRectangle.	builder		absolute;		moveTo: rectangle topLeft;		lineTo: rectangle topRight;		lineTo: rectangle bottomRight;		lineTo: rectangle bottomLeft;		lineTo: rectangle topLeft;		closePath! !!RSAthensRenderer methodsFor: 'accessing'!builder	^ builder! !!RSAthensRenderer methodsFor: 'visiting - helpers'!drawPathLabel: label	| utf8String act f stroke |	utf8String := label path.	utf8String ifNil: [ 		act := AthensCairoText new.		utf8String := act convertTextUtf8: label text.		label path: utf8String.	 ].	f := CairoScaledFont fromFreetypeFont: label font realFont.		athensCanvas newPath.	f lock.	athensCanvas 		setPathMatrix;		setScaledFont: f.	label paint ifNotNil: [ 		(label paint asAthensPaintOn: athensCanvas)"			setMatrix: athensCanvas paintTransform inverted;"			loadOnCairoCanvas: athensCanvas. ].	athensCanvas textPath: utf8String.	label paint ifNotNil: [ athensCanvas fillPreserve ].	label hasBorder ifTrue: [ 		stroke := label border accept: self.		stroke prepareForDrawingOn: athensCanvas.		athensCanvas stroke.	 ].	f unlock.! !!RSAthensRenderer methodsFor: 'visiting - helpers'!drawSimpleLabel: label	| paint |	paint := label paint.	paint ifNil: [ ^ self ].	athensCanvas 		setFont: label font;		setPaint: paint;		drawString: label text! !!RSAthensRenderer methodsFor: 'utilities'!geomPolygonIntersectC: c d: d a: a b: b	| x1 x3 x21 x43 y1 y3 y21 y43 ua |	x1 := c x.	x3 := a x.	x21 := d x - x1.	x43 := b x - x3.	y1 := c y.	y3 := a y.	y21 := d y - y1.	y43 := b y - y3.	ua := ((x43 *  (y1 - y3)) - (y43 * (x1 - x3))) / ((y43 * x21) - (x43 * y21 )).	^ (x1 + (ua * x21))@	(y1 +(ua * y21))! !!RSAthensRenderer methodsFor: 'creating path'!getOrCreatePathOf: shape	| path |	path := shape path.	path ifNotNil: [ ^ path ].	path := athensCanvas		createPath: [ :pathBuilder |			builder := pathBuilder.			shape buildPathOn: self ].	builder := nil.	shape path: path.	^ path! !!RSAthensRenderer methodsFor: 'paint'!paintFor: shape form: form	form isForm ifFalse: [ ^ form ].		^ CairoBackendCache soleInstance 		at: form		ifAbsentPut: [ 			| paint |			paint := (AthensCairoPatternSurfacePaint 				createForSurface: (AthensCairoSurface 				fromForm: form)).			paint origin: (form extent /2) negated asFloatPoint.			paint ]! !!RSAthensRenderer methodsFor: 'visiting'!visitBorder: border	| stroke style |	stroke := athensCanvas setStrokePaint: border paint.	stroke width: border width asFloat.	style := border style.	style ifNil: [ ^ stroke ].	style dashArray 		ifNotNil: [ :a | stroke dashes: a offset: style dashOffset ].			style capStyle		ifNotNil: [:s | stroke perform: s].	style joinStyle		ifNotNil: [:s | stroke perform: s].	^ stroke.	! !!RSAthensRenderer methodsFor: 'visiting - helpers'!visitBorderIfNecessary: shape	shape hasBorder ifFalse: [ ^ self ].	athensCanvas setShape: shape path.	shape border accept: self.	athensCanvas draw.! !!RSAthensRenderer methodsFor: 'visiting'!visitBoundingShape: shape	| path paint |	athensCanvas setPathMatrix.	path := self getOrCreatePathOf: shape.	athensCanvas pathTransform restoreAfter: [ 		athensCanvas pathTransform			multiplyBy: shape matrix asFloatTransform.		paint := shape paintOn: self.		paint ifNotNil: [ 			athensCanvas 				fillRuleEvenOdd;				setPaint: paint;				drawShape: path ].		self visitBorderIfNecessary: shape.		shape hasChildren ifTrue: [ 			shape children do: [ :s |				s accept: self ] ]		].	! !!RSAthensRenderer methodsFor: 'visiting'!visitLabel: label	athensCanvas pathTransform restoreAfter: [ 		| e ybn |		e := label textExtents.		ybn := e y_bearing negated.		athensCanvas pathTransform			multiplyBy: label matrix asFloatTransform;			translateBy: ((e x_advance + e x_bearing / -2) @ 0);			translateBy: 0@((ybn/2)- ((e height- ybn)/2)). 		label hasBorder			ifTrue: [ self drawPathLabel: label  ]			ifFalse: [ self drawSimpleLabel: label ].				self visitLabelDecoratorsIfNecessary: label.	].	! !!RSAthensRenderer methodsFor: 'visiting - helpers'!visitLabelDecoratorsIfNecessary: label	| advance |	(label isUnderlined or: [label isStruckOut]) ifFalse: [ ^ self ].		athensCanvas setPaint: label paint.	advance := (CairoFontMetricsProvider new			font: label font;			extentsOf: label text) x_advance.	label isUnderlined		ifTrue: [ athensCanvas drawShape: ((0 @ 1 extent: advance @ 1)) ].	label isStruckOut ifFalse:  [ ^ self ]. 		athensCanvas pathTransform		translateBy: (0@ (label textHeight / 4)) negated asFloatPoint.	athensCanvas drawShape: ((0 @ 1 extent: advance @ 1))! !!RSAthensRenderer methodsFor: 'visiting'!visitLine: line	| path paint |	athensCanvas pathTransform restoreAfter: [ 		path := self getOrCreatePathOf: line.		paint := line paintOn: self.		paint ifNotNil: [ 			athensCanvas				setPaint: paint;				drawShape: path ].		self visitBorderIfNecessary: line.		self visitMarkersIfNecessary: line.		].! !!RSAthensRenderer methodsFor: 'visiting - helpers'!visitMarker: marker to: from vector: vector	| shape angle pos |	shape := marker shape.	angle := vector angle + Float halfPi.	pos := from.	shape matrix		loadIdentity;		rotateByRadians: angle.	(marker offset isZero and: [ marker offsetRatio isZero ]) ifFalse: [ 		| unit |		unit := vector / (vector r max: 1).		pos := pos -(vector * marker offsetRatio) - (unit * marker offset)		 ].	shape		position: pos;		accept: self.! !!RSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkerEnd: marker with: controlPoints	| from to |	marker ifNil: [ ^ self ].	controlPoints size < 2 ifTrue: [ ^ self ].	from := controlPoints at: controlPoints size - 1.	to := controlPoints last.	self visitMarker: marker to: to vector: to-from. ! !!RSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkerMid: marker with: controlPoints	marker ifNil: [ ^ self ].	controlPoints size < 3 ifTrue: [ ^ self ].	1 to: controlPoints size -2 do: [ :i | | a b |		a := controlPoints at: i.		b := controlPoints at: i + 1.		self visitMarker: marker to: b vector: b - a. 	 ].	! !!RSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkerStart: marker with: controlPoints	| from to |	marker ifNil: [ ^ self ].	controlPoints size < 2 ifTrue: [ ^ self ].	from := controlPoints first.	to := controlPoints second.	self visitMarker: marker to: from vector: from - to. ! !!RSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkersIfNecessary: line	| cp |	line hasMarkers ifFalse: [ ^ self ].	cp := line controlPoints.	self visitMarkerStart: line markerStart with: cp.	self visitMarkerMid: line markerMid with: cp.	self visitMarkerEnd: line markerEnd with: cp.! !!RSRenderer methodsFor: 'accessing'!canvas	^ athensCanvas ! !!RSRenderer methodsFor: 'accessing'!canvas: aCanvas	"aCanvas is AthensCanvas"	athensCanvas := aCanvas! !!RSRenderer methodsFor: 'accessing'!visitCanvas: canvas! !!Symbol methodsFor: '*Roassal3'!rsValue: anObject 	^ anObject perform: self! !!Announcer methodsFor: '*Roassal3'!handleEventClass: eventClass	"Return true if the receiver has a callback subscripbed for the event class"	^ self subscriptions handleEventClass: eventClass! !!RSScaleChangedEvent methodsFor: 'accessing'!newScale	^ newScale! !!RSScaleChangedEvent methodsFor: 'accessing'!newScale: aNumber	newScale := aNumber! !!RSScaleChangedEvent methodsFor: 'accessing'!oldScale	^ oldScale! !!RSScaleChangedEvent methodsFor: 'accessing'!oldScale: aNumber	oldScale := aNumber! !!RSEvent methodsFor: 'accessing'!camera	^ self canvas camera! !!RSEvent methodsFor: 'accessing'!canvas	^ canvas ifNil: [ canvas := shape canvas ].! !!RSEvent methodsFor: 'accessing'!canvas: aTrachelCanvas	"Set the Trachel canvas"	canvas := aTrachelCanvas! !!RSEvent methodsFor: 'accessing'!morph	^ morph ifNil: [ ^ morph := self canvas morph ]! !!RSEvent methodsFor: 'accessing'!morph: aMorph	morph := aMorph! !!RSEvent methodsFor: 'accessing'!shape	^ shape! !!RSEvent methodsFor: 'accessing'!shape: aShape	"An event should now the shape to which it is related to. 	The shape has to be set before emitting the event."	shape := aShape! !!RSEvent methodsFor: 'accessing'!signalUpdate	"Trigger a refresh of the morph. The method signalUpdate has to be called when some visual properties are changed (e.g., color, position)"	morph notNil ifTrue: [ morph changed ]	! !!RSHighlightableEvent methodsFor: 'accessing'!interaction	^ interaction! !!RSHighlightableEvent methodsFor: 'accessing'!interaction: aInteraction	interaction := aInteraction! !!RSHighlightableEvent methodsFor: 'accessing'!source	^ source! !!RSHighlightableEvent methodsFor: 'accessing'!source: anElementOrView	source := anElementOrView! !!RSExtentChangedEvent methodsFor: 'accessing'!newExtent	^ newExtent! !!RSExtentChangedEvent methodsFor: 'accessing'!newExtent: anObject	newExtent := anObject! !!RSExtentChangedEvent methodsFor: 'accessing'!oldExtent	^ oldExtent! !!RSExtentChangedEvent methodsFor: 'accessing'!oldExtent: anExtent	oldExtent := anExtent! !!RSPositionChangedEvent methodsFor: 'accessing'!newPosition	^ newPosition! !!RSPositionChangedEvent methodsFor: 'accessing'!newPosition: anObject	newPosition := anObject! !!RSPositionChangedEvent methodsFor: 'accessing'!oldPosition	^ oldPosition! !!RSPositionChangedEvent methodsFor: 'accessing'!oldPosition: anObject	oldPosition := anObject! !!RSShapeEvent methodsFor: 'accessing'!position 	^ position ifNil: [ self shape position ]! !!RSShapeEvent methodsFor: 'accessing'!position: anObject	position := anObject ! !!RSShapeEvent methodsFor: 'accessing'!positionFromCamera	"Return the position from the camera. I.e., 0 @ 0 is at the center of the window if the camera has not been translated"	^ canvas 		ifNotNil: [ canvas camera fromPixelToSpace: self position ]		ifNil: [ -250 @ -250 ]! !!RSAbstractMouseEvent methodsFor: 'testing'!isPositionAboveShape	^ shape encompassingRectangle containsPoint: self positionFromCamera! !!RSMouseDragging class methodsFor: 'instance creation'!step: aStepAsPoint	^ self new step: aStepAsPoint! !!RSMouseDragging methodsFor: 'initialize - release'!initialize	super initialize.	step := 0 @ 0.! !!RSMouseDragging methodsFor: 'accessing'!step	^ step! !!RSMouseDragging methodsFor: 'accessing'!step: aPoint	step := aPoint! !!RSMouseWheelEvent methodsFor: 'accessing'!direction	^ direction! !!RSMouseWheelEvent methodsFor: 'accessing'!direction: anObject	direction := anObject! !!RSMouseWheelEvent methodsFor: 'testing'!isDown	^ direction = Character arrowDown! !!RSMouseWheelEvent methodsFor: 'testing'!isLeft	^ direction = Character arrowLeft! !!RSMouseWheelEvent methodsFor: 'testing'!isRight	^ direction = Character arrowRight! !!RSMouseWheelEvent methodsFor: 'testing'!isUp	^ direction = Character arrowUp! !!RSKeyboardEvent methodsFor: 'comparing'!= anotherKeyEvent	"Do we really need this method? It has been imported from Roassal1"	(self class == anotherKeyEvent) ifFalse: [  ^ false ].	^ self keyValue = anotherKeyEvent keyValue! !!RSKeyboardEvent methodsFor: 'initialize'!initialize	super initialize.	keyValue := 0! !!RSKeyboardEvent methodsFor: 'accessing'!keyName	^ keyName! !!RSKeyboardEvent methodsFor: 'accessing'!keyName: aString	keyName := aString! !!RSKeyboardEvent methodsFor: 'accessing'!keyValue	^ keyValue! !!RSKeyboardEvent methodsFor: 'accessing'!keyValue: anObject	keyValue := anObject! !!RSKeyboardEvent methodsFor: 'printing'!printOn: aStream	"Append a sequence of characters to aStream that identify the receiver."	super printOn: aStream.	aStream		nextPutAll: ' keyName: ';		print: keyName.	aStream		nextPutAll: ' keyValue: ';		print: keyValue.	aStream		nextPutAll: ' commandKeyPressed: ';		print: commandKeyPressed.	aStream		nextPutAll: ' controlKeyPressed: ';		print: controlKeyPressed.	aStream		nextPutAll: ' optionKeyPressed: ';		print: optionKeyPressed.	aStream		nextPutAll: ' shiftKeyPressed: ';		print: shiftKeyPressed! !!RSUserInputEvent class methodsFor: 'instance creation'!fromEvent: aUserInputEvent	^ self new		commandKeyPressed: aUserInputEvent commandKeyPressed;		controlKeyPressed: aUserInputEvent controlKeyPressed;		shiftKeyPressed: aUserInputEvent shiftPressed;		optionKeyPressed: aUserInputEvent optionKeyPressed;		yourself! !!RSUserInputEvent methodsFor: 'modifier state'!altKeyPressed	"Answer true if the alt/option key on the keyboard was being held down when this event occurred."	^ self optionKeyPressed! !!RSUserInputEvent methodsFor: 'modifier state'!anyModifierKeyPressed	"Answer true if command, option/alt or control key on the keyboard was being held down when this event occurred. Ignores shift key."	^ self commandKeyPressed or: [ self optionKeyPressed or: [ self controlKeyPressed ] ]! !!RSUserInputEvent methodsFor: 'modifier state'!commandKeyPressed	"Answer true if the command key on the keyboard was being held down when this event occurred."	^ commandKeyPressed! !!RSUserInputEvent methodsFor: 'private - accessing'!commandKeyPressed: aBoolean	commandKeyPressed := aBoolean! !!RSUserInputEvent methodsFor: 'modifier state'!controlKeyPressed	"Answer true if the control key on the keyboard was being held down when this event occurred."	^ controlKeyPressed! !!RSUserInputEvent methodsFor: 'private - accessing'!controlKeyPressed: aBoolean	controlKeyPressed := aBoolean! !!RSUserInputEvent methodsFor: 'initialization'!initialize	super initialize.	commandKeyPressed := false.	controlKeyPressed := false.	optionKeyPressed := false.	shiftKeyPressed := false! !!RSUserInputEvent methodsFor: 'private - accessing'!modifiers: modifiers	commandKeyPressed := modifiers anyMask: 2r01000000.	controlKeyPressed := modifiers anyMask: 2r00010000.	optionKeyPressed := modifiers anyMask: 2r00100000.	shiftKeyPressed := modifiers anyMask: 2r00001000! !!RSUserInputEvent methodsFor: 'modifier state'!optionKeyPressed	"Answer true if the alt/option key on the keyboard was being held down when this event occurred."	^ optionKeyPressed! !!RSUserInputEvent methodsFor: 'private - accessing'!optionKeyPressed: aBoolean	optionKeyPressed := aBoolean! !!RSUserInputEvent methodsFor: 'modifier state'!shiftKeyPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred"	^ shiftKeyPressed! !!RSUserInputEvent methodsFor: 'private - accessing'!shiftKeyPressed: aBoolean	shiftKeyPressed := aBoolean! !!RSUserInputEvent methodsFor: 'modifier state'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred.	This method is here for Morphic compatibility"	^ self shiftKeyPressed! !!SequenceableCollection methodsFor: '*Roassal3'!asGroup	^ (RSGroup new: self size) addAll: self; yourself! !!SequenceableCollection methodsFor: '*Roassal3'!sortedAs: aSortBlockOrSymbol	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection aSortBlock |	aSortedCollection := SortedCollection new: self size.	aSortBlock := 		aSortBlockOrSymbol isSymbol 			ifTrue: [ [:a :b | |t1 t2|							t1 := (a perform: aSortBlockOrSymbol).							t2 := (b perform: aSortBlockOrSymbol).							((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])								ifTrue: [ t1 ]								ifFalse: [ t1 < t2 ] ] ]			ifFalse: [ 				(aSortBlockOrSymbol numArgs = 1)					ifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) < (aSortBlockOrSymbol value: v2) ] ]					ifFalse: [ aSortBlockOrSymbol ] ].	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!RPackage methodsFor: '*Roassal3'!dependentPackages	"	Return the list of packages that I depend on		(RPackageOrganizer default packageNamed: 'Roassal3') dependentPackages	"	^ (self definedClasses flatCollect: #dependentClasses), self extendedClasses collect: #package as: Set! !!SubscriptionRegistry methodsFor: '*Roassal3'!getInteractionsForClass: eventClass	"Return the list of subscription for a given Event class"	| answer |	answer := OrderedCollection new.	subscriptions do: [ :sub | 		((sub subscriber class == eventClass) or: 			[ sub subscriber class inheritsFrom: eventClass ]) ifTrue: [ answer add: sub subscriber ] ].	^ answer! !!SubscriptionRegistry methodsFor: '*Roassal3'!handleEventClass: eventClass	"Return true if the receiver has a callback subscripbed for the event class"	^ subscriptions		anySatisfy: [ :sub | sub announcementClass includesBehavior: eventClass ]! !!AthensCairoSurface methodsFor: '*Roassal3'!hasBeenFreed	"Return true if the external resource has been freed"	^ handle isNull! !!CompiledMethod methodsFor: '*Roassal3'!dependentClassesWithOccurences	"Return the list of classes used myself. The result contains my superclass. The result may contains multiple times the same element."		"(Morph>>#drawOn:) dependentClassesWithOccurences"	"(CompiledMethod>>#dependentClassesWithOccurences) dependentClassesWithOccurences"	| cll | 	cll := OrderedCollection new.		"We unify a class and its metaclass"	self literalsDo: [ :l | 					"We also check if the method is not an extension"					((l isVariableBinding 					and: [ l value notNil ]) 					and: [ l value isBehavior ])  ifTrue: [ cll add: l value ] ].	^ cll asArray! !!RSGroup methodsFor: 'accessing'!add: shape	self resetShapeFromModelCache.	^ super add: shape! !!RSGroup methodsFor: 'accessing'!addAll: shapes	self resetShapeFromModelCache.	^ super addAll: shapes! !!RSGroup methodsFor: 'converting'!asGroup	^ self! !!RSGroup methodsFor: 'accessing'!encompassingRectangle	^ self		ifEmpty: [ (0 @ 0) corner: (0 @ 0) ]		ifNotEmpty: [ Rectangle merging: (self collect: #encompassingRectangle) ]! !!RSGroup methodsFor: 'accessing'!extent	^ self encompassingRectangle extent! !!RSGroup methodsFor: 'accessing'!height 	^ self extent y! !!RSGroup methodsFor: 'accessing'!models: someModels	"Set the model of each shapes contained in the collection. The size of the group must be the same than the someModels collection"	self assert: [ someModels isCollection ] description: 'Must provide a collection'.	self assert: [ self size = someModels size ] description: 'The argument must of the same size then the group'.	self with: someModels do: [ :s :m | s model: m ]! !!RSGroup methodsFor: 'actions'!pushBack 	self do: [:each | each pushBack ]! !!RSGroup methodsFor: 'actions'!pushFront	self do: #pushFront! !!RSGroup methodsFor: 'accessing'!resetShapeFromModelCache	"Reset the cache"	shapeFromModelCache := nil! !!RSGroup methodsFor: 'accessing'!shapeFromModel: anObject	"Return a shape that corresponds to the object provided as parameter. If none is found, then return nil	-=-=-=-=-=-=-=-=-=g := RSGroup new.g add: (RSBox new model: 'hello').g add: (RSEllipse new model: 'world').g shapeFromModel: 'hello'-=-=-=-=-=-=-=-=-==> a RSBox(hello))	"	| t |	self shapeFromModelCache 		at: anObject 		ifPresent: [ :v |			v isCollection ifFalse: [ ^ v ] ].	"We have this line because of a bug of the implementation of CompiledMethod>>#="	t := (anObject class == CompiledMethod) 		ifTrue: [ self detect: [ :el | el model == anObject ] ifNone: [ nil ] ]		ifFalse: [ self detect: [ :el | el model = anObject ] ifNone: [ nil ] ].		self shapeFromModelCache at: anObject put: t.	^ t! !!RSGroup methodsFor: 'accessing'!shapeFromModelCache	"Define a cache for the element lookup from models"	shapeFromModelCache ifNil: [ shapeFromModelCache := Dictionary new ].	^ shapeFromModelCache! !!RSGroup methodsFor: 'accessing'!shapesFromModel: anObject	"Return a shape that corresponds to the object provided as parameter. If none is found, then return nil.For example:-=-=-=-=-=-=-=-=-=g := RSGroup new.g add: (RSBox new model: 'hello').g add: (RSEllipse new model: 'world').g shapesFromModel: 'hello' -=-=-=-=-=-=-=-=-==> a RSGroup(a RSBox(hello))	"		| t key |	self shapeFromModelCache at: anObject ifPresent: [ :v | v isCollection ifTrue: [ ^ v ] ].	"We have this line because of a bug of the implementation of CompiledMethod>>#="	t := (anObject class == CompiledMethod) 				ifTrue: [ self select: [ :el | el model == anObject ] ]				ifFalse: [ self select: [ :el | el model = anObject ] ].	"We have this hack for nil objects because in visualWorks a dictionary cannot have nil as a key"	key := anObject isNil ifTrue: [ 'KeyForNilObjects' ] ifFalse: [ anObject ].	self shapeFromModelCache at: key put: t.	^ t! !!RSGroup methodsFor: 'accessing'!shapesFromModels: objects	"Return elements that corresponds to the objects provided as parameter. If none is found, then return an empty collection"	| answer t |	self assert: [ objects isCollection ] description: 'Provide a set of shapes instead of one single shape'. 	answer := RSGroup new.	objects do: [ :o |		t := self shapesFromModel: o.		t notNil ifTrue: [ answer addAll: t ] ].	^ answer! !!RSGroup methodsFor: 'transforming'!translateBy: delta	self do: [ :e | e translateBy: delta ]! !!RSGroup methodsFor: 'transforming'!translateTo: aPosition	| center |	center := self encompassingRectangle floatCenter.	self translateBy: aPosition - center! !!RSGroup methodsFor: 'converting'!translucent	"Make all shapes in the group as translucent"	self do: [ :s | s color: s color translucent ]! !!RSGroup methodsFor: 'announcing'!when: event do: block	self do: [ :element | element when: event do: block ]! !!RSGroup methodsFor: 'accessing'!width 	^ self extent x! !!AthensAffineTransform methodsFor: '*Roassal3'!asFloatTransform	^ self copy floatValues; yourself	! !!AthensAffineTransform methodsFor: '*Roassal3'!floatValues	"convert all the values to float"	x := x asFloat.	y := y asFloat.	sx := sx asFloat.	sy := sy asFloat.	shx := shx asFloat.	shy := shy asFloat.		! !!AthensAffineTransform methodsFor: '*Roassal3'!printOn: stream	stream << 'x: '. x printOn: stream.	stream << ' y: '. y printOn: stream.	stream << ' sx: '. sx printOn: stream.	stream << ' sy: '. sy printOn: stream.	stream << ' shx: '. shx printOn: stream.	stream << ' shy: '. shy printOn: stream.! !!Class methodsFor: '*Roassal3'!dependentClassesWithOccurences	"Return the list of classes used myself. The result may contains multiple times the same element."		"Morph dependentClassesWithOccurences"	| cll | 	cll := OrderedCollection new.	"A class depends on its superclass"	self superclass ifNotNil: [ cll add: self superclass ].		"We unify a class and its metaclass"	(self methods, self classSide methods) 		do: [ :m | m literalsDo: [ :l | 					"We also check if the method is not an extension"					((((l isVariableBinding 					and: [ l value notNil ]) 					and: [ l value isBehavior ])					and: [ m category notEmpty ] )					and: [ m category first ~= $* ])  ifTrue: [ cll add: l value ] ]  ].	^ cll asArray! !!Class methodsFor: '*Roassal3'!numberOfVariables	"Return the number of variables"		^ self instVarNames size! !!BlockClosure methodsFor: '*Roassal3'!rsValue: value	^ self cull: value! !!RSAthensMorph class methodsFor: 'initialization'!initializeKeyTable	KeyTable := Dictionary new.	#(		16r08f6 Function "XK_function"		16rff08 BackSpace "XK_BackSpace"		9 Tab "XK_Tab"		16rff0a Linefeed "XK_Linefeed"		16rff0b Clear "XK_Clear"		13 Return "XK_Return"		16rff13 Pause "XK_Pause"		16rff14 Scroll_Lock "XK_Scroll_Lock"		16rff15 Sys_Req "XK_Sys_Req"		16rff1b Escape "XK_Escape"		8 Delete "XK_Delete"		16rff50 Home "XK_Home"		16rff51 Left "XK_Left"		16rff52 Up "XK_Up"		16rff53 Right "XK_Right"		16rff54 Down "XK_Down"		16rfe03 Level3Shift "XK_ISO_Level3_Shift"		16r00a1 ExclamationDown "XK_exclamdown"		16r00bf QuestionDown "XK_questiondown"		16r00f1 NTilde "XK_ntilde"		16r00d1 CapitalNTilde "XK_ntilde"		16r00ba Masculine "XK_masculine"		16r00e7 CCedilla "XK_ccedilla"		16r00c7 CapitalCCedilla "XK_ccedilla"		16r00aa FeminineOrdinal "XK_ordfeminine"		16r00b7 MiddlePoint "XK_periodcentered"		"16rff55 Prior ""XK_Prior"		16rff55 Page_Up "XK_Page_Up"		"16rff56 Next" "XK_Next"		16rff56 Page_Down "XK_Page_Down"		16rff57 End "XK_End"		16rff58 Begin "XK_Begin"		32 KP_Space "XK_KP_Space"		16rff89 KP_Tab "XK_KP_Tab"		16rff8d KP_Enter "XK_KP_Enter"		16rff91 KP_F1 "XK_KP_F1"		16rff92 KP_F2 "XK_KP_F2"		16rff93 KP_F3 "XK_KP_F3"		16rff94 KP_F4 "XK_KP_F4"		16rff95 KP_Home "XK_KP_Home"		28 KP_Left "XK_KP_Left"		30 KP_Up "XK_KP_Up"		29 KP_Right "XK_KP_Right"		31 KP_Down "XK_KP_Down"		16rff9a KP_Prior "XK_KP_Prior"		16rff9a KP_Page_Up "XK_KP_Page_Up"		16rff9b KP_Next "XK_KP_Next"		16rff9b KP_Page_Down "XK_KP_Page_Down"		16rff9c KP_End "XK_KP_End"		16rff9d KP_Begin "XK_KP_Begin"		16rff9e KP_Insert "XK_KP_Insert"		16rff9f KP_Delete "XK_KP_Delete"		24 KP_Equal "XK_KP_Equal"		16rffaa KP_Multiply "XK_KP_Multiply"		16rffab KP_Add "XK_KP_Add"		16rffac KP_Separator "XK_KP_Separator"		16rffad KP_Subtract "XK_KP_Subtract"		16rffae KP_Decimal "XK_KP_Decimal"		16rffaf KP_Divide "XK_KP_Divide"		16rffb0 KP_0 "XK_KP_0"		16rffb1 KP_1 "XK_KP_1"		16rffb2 KP_2 "XK_KP_2"		16rffb3 KP_3 "XK_KP_3"		16rffb4 KP_4 "XK_KP_4"		16rffb5 KP_5 "XK_KP_5"		16rffb6 KP_6 "XK_KP_6"		16rffb7 KP_7 "XK_KP_7"		16rffb8 KP_8 "XK_KP_8"		16rffb9 KP_9 "XK_KP_9"		16rffbe F1 "XK_F1"		16rffbf F2 "XK_F2"		16rffc0 F3 "XK_F3"		16rffc1 F4 "XK_F4"		16rffc2 F5 "XK_F5"		16rffc3 F6 "XK_F6"		16rffc4 F7 "XK_F7"		16rffc5 F8 "XK_F8"		16rffc6 F9 "XK_F9"		16rffc7 F10 "XK_F10"		16rffc8 F11 "XK_F11"		16rffc9 F12 "XK_F12"		16rffe1 Shift_L "XK_Shift_L"		16rffe2 Shift_R "XK_Shift_R"		16rffe3 Control_L "XK_Control_L"		16rffe4 Control_R "XK_Control_R"		16rffe5 Caps_Lock "XK_Caps_Lock"		16rffe6 Shift_Lock "XK_Shift_Lock"		16rffe7 Meta_L "XK_Meta_L"		16rffe8 Meta_R "XK_Meta_R"		16rffe9 Alt_L "XK_Alt_L"		16rffea Alt_R "XK_Alt_R"		16rffeb Super_L "XK_Super_L"		16rffec Super_R "XK_Super_R"		16rffed Hyper_L "XK_Hyper_L"		16rffee Hyper_R "XK_Hyper_R"		16rfe50 dead_grave "XK_dead_grave"		16rfe51 dead_acute "XK_dead_acute"		16rfe52 dead_circumflex "XK_dead_circumflex"		16rfe53 dead_tilde "XK_dead_tilde"		16rfe53 dead_perispomeni "XK_dead_perispomeni"		16rfe54 dead_macron "XK_dead_macron"		16rfe55 dead_breve "XK_dead_breve"		16rfe56 dead_abovedot "XK_dead_abovedot"		16rfe57 dead_diaeresis "XK_dead_diaeresis"		16rfe58 dead_abovering "XK_dead_abovering"		16rfe59 dead_doubleacute "XK_dead_doubleacute"		16rfe5a dead_caron "XK_dead_caron"		16rfe5b dead_cedilla "XK_dead_cedilla"		16rfe5c dead_ogonek "XK_dead_ogonek"		16rfe5d dead_iota "XK_dead_iota"		16rfe5e dead_voiced_sound "XK_dead_voiced_sound"		16rfe5f dead_semivoiced_sound "XK_dead_semivoiced_sound"		16rfe60 dead_belowdot "XK_dead_belowdot"		16rfe61 dead_hook "XK_dead_hook"		16rfe62 dead_horn "XK_dead_horn"		16rfe63 dead_stroke "XK_dead_stroke"		16rfe64 dead_abovecomma "XK_dead_abovecomma"		16rfe64 dead_psili "XK_dead_psili"		16rfe65 dead_abovereversedcomma "XK_dead_abovereversedcomma"		16rfe65 dead_dasia "XK_dead_dasia"		16rfe66 dead_doublegrave "XK_dead_doublegrave"		16rfe67 dead_belowring "XK_dead_belowring"		16rfe68 dead_belowmacron "XK_dead_belowmacron"		16rfe69 dead_belowcircumflex "XK_dead_belowcircumflex"		16rfe6a dead_belowtilde "XK_dead_belowtilde"		16rfe6b dead_belowbreve "XK_dead_belowbreve"		16rfe6c dead_belowdiaeresis "XK_dead_belowdiaeresis"		16rfe6d dead_invertedbreve "XK_dead_invertedbreve"		16rfe6e dead_belowcomma "XK_dead_belowcomma"		16rfe6f dead_currency "XK_dead_currency"		16r0020 space "XK_space"		16r0021 exclam "XK_exclam"		16r0022 quotedbl "XK_quotedbl"		16r0023 numbersign "XK_numbersign"		16r0024 dollar "XK_dollar"		16r0025 percent "XK_percent"		16r0026 ampersand "XK_ampersand"		16r0027 apostrophe "XK_apostrophe"		"16r0027 quoteright" "XK_quoteright"		16r0028 parenleft "XK_parenleft"		16r0029 parenright "XK_parenright"		16r002a asterisk "XK_asterisk"		16r002b plus "XK_plus"		16r002c comma "XK_comma"		39 minus "XK_minus"		16r002e period "XK_period"		45 slash "XK_slash"		16r0030 zero "XK_0"		16r0031 one "XK_1"		16r0032 two "XK_2"		16r0033 three "XK_3"		16r0034 four "XK_4"		16r0035 five "XK_5"		16r0036 six "XK_6"		16r0037 seven "XK_7"		16r0038 eight "XK_8"		16r0039 nine "XK_9"		16r003a colon "XK_colon"		16r003b semicolon "XK_semicolon"		16r003c less "XK_less"		193 equal "XK_equal"		16r003e greater "XK_greater"		16r003f question "XK_question"		16r0040 at "XK_at"		97 A "XK_A"		98 B "XK_B"		99 C "XK_C"		100 D "XK_D"		101 E "XK_E"		102 F "XK_F"		103 G "XK_G"		104 H "XK_H"		105 I "XK_I"		106 J "XK_J"		107 K "XK_K"		108 L "XK_L"		109 M "XK_M"		110 N "XK_N"		111 O "XK_O"		112 P "XK_P"		113 Q "XK_Q"		114 R "XK_R"		115 S "XK_S"		116 T "XK_T"		117 U "XK_U"		118 V "XK_V"		119 W "XK_W"		120 X "XK_X"		121 Y "XK_Y"		122 Z "XK_Z"		16r005b bracketleft "XK_bracketleft"		16r005c backslash "XK_backslash"		16r005d bracketright "XK_bracketright"		16r005e asciicircum "XK_asciicircum"		16r005f underscore "XK_underscore"		16r0060 grave "XK_grave"		"16r0060 quoteleft" "XK_quoteleft"		16r007b braceleft "XK_braceleft"		16r007c bar "XK_bar"		16r007d braceright "XK_braceright"		16r007e asciitilde "XK_asciitilde")			pairsDo: [ :keyCode :keyname | KeyTable at: keyCode put: keyname asUppercase].! !!RSAthensMorph class methodsFor: 'public'!keyNameFor: code	"	self keyNameFor: Character space charCode	"		KeyTable ifNil: [ self initializeKeyTable ].	^ KeyTable at: code ifAbsent: [ code asString ].! !!RSAthensMorph class methodsFor: 'initialization'!reset	<script: 'self reset'>	KeyTable := nil.! !!RSAthensMorph methodsFor: 'accessing'!canvas	^ roassalCanvas! !!RSAthensMorph methodsFor: 'accessing'!canvas: aRoassalCanvas	roassalCanvas := aRoassalCanvas! !!RSAthensMorph methodsFor: 'session management'!checkSession	"The mechanism of session is useful in case you have a visualization open, save-and-quit the image, and open the image again.	Naturally, you wish to see the visualization again. The session mechanism makes sure that low-level resources that belongs to Cairo are properly recreated"	session == Smalltalk session ifTrue: [ ^ self ].	surface := nil.	self createSurface.	roassalCanvas shapes do: [ :s | s sessionChanged ].	roassalCanvas fixedShapes do: [ :s | s sessionChanged ].	! !!RSAthensMorph methodsFor: 'surface management'!createSurface	surface := AthensCairoSurface extent: self extent asIntegerPoint.	session := Smalltalk session.! !!RSAthensMorph methodsFor: 'drawing'!drawOn: aCanvas	"Draw the whole visualization"	isDrawing ifTrue: [ ^ self ].	isDrawing := true.	[ 		self checkSession.		self recreateSurfaceIfNecessary.		aCanvas fillRectangle: bounds color: roassalCanvas color.		roassalCanvas playAnimations.		self drawShapes.		surface hasBeenFreed			ifTrue: [ self createSurface ].		[ aCanvas			image: surface asForm			at: self bounds origin asIntegerPoint			sourceRect: (0 @ 0 extent: surface extent)			rule: 34 ]		on: Exception		do: [ :ex |  ] ] 	ensure: [ 		isDrawing := false ]! !!RSAthensMorph methodsFor: 'drawing'!drawOnAthensCanvas: aCanvas	self fullDrawOnAthensCanvas: aCanvas! !!RSAthensMorph methodsFor: 'drawing'!drawOnMockCanvas	"This method is used to trigger all the rendering in a temporary FormCanvas. This method is useful when a bug happens when rendering. Such situation are difficult to debug to the multi-threading and low level graphical primitive. The method #drawOnMockCanvas helps addressing this.Here is an example:v := RTView new.es := RTBox elementsOn: (1 to: 10).v addAll: es.RTGridLayout on: es.v canvas buildMorph drawOnMockCanvas	"	self drawOn: (FormCanvas extent: self extent)! !!RSAthensMorph methodsFor: 'drawing'!drawShapes	"The drawing has to be done when a change in the shapes occured or when there is an animation."		surface drawDuring: [ :athensCanvas | 		| camera canvasRect |		roassalCanvas clearBackground			ifTrue: [ surface clear ].		"We display the elements that are subject to the camera"		camera := roassalCanvas camera.		athensCanvas pathTransform			translateBy: (self extent / 2) asFloatPoint;			scaleBy: camera scale asFloat;			translateBy: camera position negated asFloatPoint.		renderer canvas: athensCanvas.		canvasRect := roassalCanvas visibleRectangle.		roassalCanvas shapes do: [ :roassalShape | 			(roassalShape encompassingRectangle intersects: canvasRect)				ifTrue: [ 					roassalShape accept: renderer ] ].		self showRectanglesIfNecessary: roassalCanvas shapes.		"We display the elements that are _NOT_ subject to the camera"		athensCanvas pathTransform loadIdentity scaleBy: 1.0001.		roassalCanvas fixedShapes do: [ :roassalShape | 			roassalShape accept: renderer ].		"debug mode to show encompassingRectangles"		self showRectanglesIfNecessary: roassalCanvas fixedShapes. ]		! !!RSAthensMorph methodsFor: 'event-processed'!eventKeyDown: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSKeyDown from: aMorphicEvent.	trEvent		position: (roassalCanvas camera fromPixelToSpace: trEvent position);		keyValue: aMorphicEvent keyValue;		keyName: (self class keyNameFor: aMorphicEvent keyValue).	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventKeyUp: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSKeyUp from: aMorphicEvent.	trEvent		position: (roassalCanvas camera fromPixelToSpace: trEvent position);		keyValue: aMorphicEvent keyValue;		keyName: aMorphicEvent key name.	trEvent shape announce: trEvent! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseClick: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: RSMouseClick		ifLeftButton: RSMouseLeftClick		ifRightButton: RSMouseRightClick		from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseDoubleClick: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: RSMouseDoubleClick		ifLeftButton: RSMouseDoubleLeftClick		ifRightButton: RSMouseDoubleRightClick		from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseDragEnd: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseDragEnd from: aMorphicEvent.	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.		eventBeginingDragging := nil.! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseDragStart: aMorphicEvent	| trEvent trEventClass |	eventBeginingDragging := aMorphicEvent copy.		trEventClass := RSMouseDragStart.	aMorphicEvent redButtonChanged		ifTrue: [ trEventClass := RSMouseLeftDragStart ].	aMorphicEvent yellowButtonChanged		ifTrue: [ trEventClass := RSMouseRightDragStart ].	aMorphicEvent blueButtonChanged		ifTrue: [ trEventClass := RSMouseMiddleDragStart ].	trEvent := self eventOfClass: trEventClass actionClass: RSMouseDragging from: aMorphicEvent.	shapeBeingPointed := trEvent shape.	shapeBeingPointed announce: trEvent.	! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseDragging: aMorphicEvent	| trEvent step |	eventBeginingDragging ifNil: [ ^ self ].	step := aMorphicEvent position - eventBeginingDragging position.	trEvent := self eventOfClass: RSMouseDragging from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent step: step.	shapeBeingPointed ifNil: [ shapeBeingPointed := trEvent shape ].	"If the element was removed during the drag then cancel the event"	shapeBeingPointed parent ifNil: [		eventBeginingDragging := nil.		shapeBeingPointed := nil.		^ self ].	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.	eventBeginingDragging := aMorphicEvent copy.	! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseEnter: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseEnter from: aMorphicEvent.	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseLeave: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseLeave from: aMorphicEvent.	shapeBeingPointed ifNotNil: [ 		trEvent shape: shapeBeingPointed].	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseMove: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseMove from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseUp: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: RSMouseUp		ifLeftButton: RSMouseUpLeft  		ifRightButton: RSMouseUpRight		from: aMorphicEvent.	trEvent position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventMouseWheel: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: RSMouseWheelEvent from: aMorphicEvent.	trEvent		direction: aMorphicEvent direction;		position: (roassalCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!RSAthensMorph methodsFor: 'event-processed'!eventOfClass: anEventClass actionClass: anActionClass from: aMorphicEvent	| relativePosition trEvent shape |	relativePosition := self relativePositionFor: aMorphicEvent.	shape := self shapeWithAction: anActionClass forPositionInPixels: relativePosition. 		trEvent := anEventClass fromEvent: aMorphicEvent.	trEvent		morph: self;		canvas: roassalCanvas;		shape: shape;		position: relativePosition.	^ trEvent! !!RSAthensMorph methodsFor: 'event-processed'!eventOfClass: anEventClass from: aMorphicEvent	^ self eventOfClass: anEventClass actionClass: anEventClass from: aMorphicEvent! !!RSAthensMorph methodsFor: 'event-processed'!eventOfClass: anEventClass shape: aShape from: aMorphicEvent	| relativePosition trEvent |	relativePosition := self relativePositionFor: aMorphicEvent.	trEvent := anEventClass fromEvent: aMorphicEvent.	trEvent		morph: self;		canvas: roassalCanvas;		shape: aShape;		position: relativePosition.	^ trEvent! !!RSAthensMorph methodsFor: 'drawing'!fullDrawOnAthensCanvas: aCanvas	isDrawing ifTrue: [ ^ self ].	isDrawing := true.	[  		self checkSession.		self recreateSurfaceIfNecessary.				aCanvas setPaint: roassalCanvas color.		aCanvas drawShape: bounds.		roassalCanvas playAnimations.		self drawShapes.		surface hasBeenFreed ifTrue: [ self createSurface ].			aCanvas pathTransform restoreAfter: [			aCanvas pathTransform loadIdentity.			aCanvas paintMode restoreAfter: [				aCanvas 					setPaint: surface;					drawShape: (0@0 extent: self extent) ] ] ]	ensure: [ 		isDrawing := false ]! !!RSAthensMorph methodsFor: 'events-processing'!handleKeyUp: anEvent	super handleKeyUp: anEvent.	self eventKeyUp: anEvent! !!RSAthensMorph methodsFor: 'event handling'!handleKeystroke: anEvent	super handleKeystroke: anEvent.	self eventKeyDown: anEvent.! !!RSAthensMorph methodsFor: 'events-processing'!handleMouseMove: anEvent	super handleMouseMove: anEvent.	anEvent anyButtonPressed ifFalse: [ self eventMouseMove: anEvent ].		! !!RSAthensMorph methodsFor: 'events-processing'!handleMouseOver: aMorphicEvent	| currentElement trEvent |	super handleMouseOver: aMorphicEvent.	aMorphicEvent wasHandled		ifTrue: [ ^ self ].	"Do nothing if it was already handled"	self isDragging		ifTrue: [ ^ self ].	"Do nothing if we are dragging"	lastMousePosition = aMorphicEvent position 		ifTrue: [ ^ self].		"Do nothing if it is in the same position"	shapeBeingPointed ifNil: [ shapeBeingPointed := self shapeForEvent: aMorphicEvent ].		currentElement := self shapeForEvent: aMorphicEvent.	lastMousePosition := aMorphicEvent position.	currentElement == shapeBeingPointed 		ifTrue: [ ^ self ].	trEvent := self eventOfClass: RSMouseLeave from: aMorphicEvent.	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.	shapeBeingPointed := currentElement.	self eventMouseEnter: aMorphicEvent.! !!RSAthensMorph methodsFor: 'testing'!handlesKeyboard: evt	^true! !!RSAthensMorph methodsFor: 'event handling'!handlesMouseDown: anEvent	^ anEvent wasHandled not	"not interested if handled"! !!RSAthensMorph methodsFor: 'event handling'!handlesMouseOver: evt	^ true! !!RSAthensMorph methodsFor: 'events-processing'!handlesMouseWheel: evt	^true! !!RSAthensMorph methodsFor: 'event handling'!hasFocus	^ true! !!RSAthensMorph methodsFor: 'initialization'!initialize	super initialize.	self createSurface.	session := Smalltalk session.	isDrawing := false! !!RSAthensMorph methodsFor: 'testing'!isDragging	^ eventBeginingDragging notNil! !!RSAthensMorph methodsFor: 'accessing'!isDrawing	^ isDrawing! !!RSAthensMorph methodsFor: 'initialization'!layoutChanged	"react on morph resize"	super layoutChanged.	self checkSession.	! !!RSAthensMorph methodsFor: 'event handling'!mouseDown: evt	eventBeginingDragging		ifNil:			[ evt hand				waitForClicksOrDrag: self				event: evt				selectors: {#eventMouseClick:. #eventMouseDoubleClick:. nil. #eventMouseDragStart:. }				threshold: 5.			^ self ].	evt anyButtonPressed		ifTrue: [ self eventMouseDragging: evt ].	evt wasHandled: true! !!RSAthensMorph methodsFor: 'event handling'!mouseEnter: evt	evt anyButtonPressed		ifFalse: [ self eventMouseEnter: evt ].	evt wasHandled: true! !!RSAthensMorph methodsFor: 'event-processed'!mouseEventOfClass: defaultClass ifLeftButton: leftButtonClass ifRightButton: rightButtonClass from: aMorphicEvent	| trEventClass |	trEventClass := defaultClass.	aMorphicEvent redButtonChanged		ifTrue: [ trEventClass := leftButtonClass ].	aMorphicEvent yellowButtonChanged		ifTrue: [ trEventClass := rightButtonClass ].	^ self eventOfClass: trEventClass actionClass: defaultClass from: aMorphicEvent! !!RSAthensMorph methodsFor: 'event handling'!mouseLeave: evt	evt anyButtonPressed		ifFalse: [ self eventMouseLeave: evt ].	evt wasHandled: true! !!RSAthensMorph methodsFor: 'event handling'!mouseMove: evt	evt anyButtonPressed		ifTrue: [ self eventMouseDragging: evt ]		ifFalse: [ self eventMouseMove: evt ].	evt wasHandled: true! !!RSAthensMorph methodsFor: 'event handling'!mouseUp: evt	self isDragging		ifTrue: [ self eventMouseDragEnd: evt ]		ifFalse: [ self eventMouseUp: evt ].	evt wasHandled: true! !!RSAthensMorph methodsFor: 'event handling'!mouseWheel: evt	self eventMouseWheel: evt.	evt wasHandled: true! !!RSAthensMorph methodsFor: 'recategorized'!recreateSurfaceIfNecessary	surface		ifNotNil: [ self extent asIntegerPoint ~= surface extent				ifTrue: [ self createSurface.					roassalCanvas extent: self extent ] ]! !!RSAthensMorph methodsFor: 'events-roassal'!relativePositionFor: evt	^ evt position - self bounds origin! !!RSAthensMorph methodsFor: 'dependencies'!release	"This method is useful in case some references of TRMorph cannot be garbage collected, as it may happen with GT."	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!RSAthensMorph methodsFor: 'accessing'!renderer	^ renderer! !!RSAthensMorph methodsFor: 'accessing'!renderer: aRenderer	renderer := aRenderer! !!RSAthensMorph methodsFor: 'accessing'!roassalCanvas	"Return the Roassal canvas that I have to render"	^ roassalCanvas! !!RSAthensMorph methodsFor: 'event-processed'!shapeForEvent: anEvent	"Return the Trachel shape for the event provided as argument"	^ self shapeWithActionForPositionInPixels: (self relativePositionFor: anEvent)! !!RSAthensMorph methodsFor: 'accessing'!shapeForPositionInPixels: point	"Return the shape located that contains point"	 ^ roassalCanvas shapeForPositionInPixels: point! !!RSAthensMorph methodsFor: 'accessing'!shapeWithAction: eventClass forPositionInPixels: position	"Return the shape with event handler located that contains point"	 ^ roassalCanvas shapeWithAction: eventClass forPositionInPixels: position! !!RSAthensMorph methodsFor: 'accessing'!shapeWithActionForPositionInPixels: point	"Return the shape with event handler located that contains point"	 ^ roassalCanvas shapeWithActionForPositionInPixels: point! !!RSAthensMorph methodsFor: 'drawing'!showRectanglesIfNecessary: shapes	roassalCanvas showRectangles ifFalse: [ ^ self ].		renderer canvas setPaint: (Color blue alpha: 0.2).	shapes do: [ :shape | | r |		r := shape encompassingRectangle.		r := r origin asFloatPoint corner: r corner asFloatPoint.		renderer canvas drawShape: r.		].! !!RSAthensMorph methodsFor: 'signaling'!signalUpdate	self changed! !!RSAthensMorph methodsFor: 'signaling'!step	self wantsSteps ifFalse: [ ^ self ].	self changed! !!RSAthensMorph methodsFor: 'signaling'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ 20! !!RSAthensMorph methodsFor: 'accessing'!surface	^ surface! !!RSAthensMorph methodsFor: 'accessing'!surface: anAthensCairoSurface 	surface := anAthensCairoSurface! !!RSAthensMorph methodsFor: 'events-processing'!takesKeyboardFocus	^ true! !!RSAthensMorph methodsFor: 'testing'!wantsSteps	^ roassalCanvas hasAnimation ! !!RSAthensMorph methodsFor: 'event handling'!wouldAcceptKeyboardFocusUponTab	"Answer whether the receiver might accept keyboard focus if 	tab were hit in some container playfield"	^ true! !!AthensCairoPathBuilder methodsFor: '*Roassal3'!arcAround: aCenterPoint radius: aRadius startAngle: aStartAngle endAngle: anEndAngle	self 		arcCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius 		startAngle: aStartAngle 		endAngle: anEndAngle ! !!AthensCairoPathBuilder methodsFor: '*Roassal3'!arcAround: aCenterPoint radius: aRadius startAngle: aStartAngle endAngle: anEndAngle cw: aBool	aBool ifTrue: [ 		self		arcNegativeCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius		startAngle: aStartAngle		endAngle: anEndAngle ]	ifFalse: [ self		arcCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius		startAngle: aStartAngle		endAngle: anEndAngle ]	! !!AthensCairoPathBuilder methodsFor: '*Roassal3'!arcCos: num	| temp |	temp := num.	num < -1.0 ifTrue: [ temp := -1.0 ].	num > 1.0 ifTrue: [ temp := 1.0 ].		^ temp arcCos! !!AthensCairoPathBuilder methodsFor: '*Roassal3'!ellipticalArc2: radii xrot: rotationAxis large: largeFlag sweep: sweepFlag to: aPoint	"raddi Point, rotationAxis Number, largeFlag Number, sweepFlag Number, aPoint Point"	"implentation based on the svg specification"	| ep x0 y0 x y dx2 dy2 theta x1 y1 tcos tsin rx ry prx pry px1 py1 d sign coef cx1 cy1 sx2 sy2 cx cy ux uy vx vy n p angleStart angleExtent pi2 |	self flag: 'Not yet for real elliptic arcs'.	pi2 := Float pi * 2.	(radii x = 0 or: [ radii y = 0 ]) ifTrue: [ 		^ self lineTo: aPoint ].	ep := self getCurrentPoint.	x0 := ep x.	y0 := ep y.	x := aPoint x.	y := aPoint y.	dx2 := (x0 - x)/2.0.	dy2 := (y0 - y)/2.0.	theta := rotationAxis degreesToRadians.	tcos := theta cos.	tsin := theta sin.	x1 := (tcos * dx2) + (tsin * dy2).	y1 := (tsin negated* dx2) + (tcos * dy2).	rx := radii x abs.	ry := radii y abs.	prx := rx * rx.	pry := ry * ry.	px1 := x1 * x1.	py1 := y1 * y1.	d := (px1 / prx) + (py1 / pry).	d > 1 ifTrue: [ 		rx := rx * d sqrt.		ry := ry * d sqrt.		prx := rx * rx.		pry := ry * ry ].		sign := largeFlag = sweepFlag ifTrue: [ -1 ] ifFalse: [ 1 ].	coef := sign * (( (prx * pry) - (prx * py1) - (pry * px1) )/( (prx * py1) + (pry * px1) ) max: 0) sqrt.		cx1 := coef * rx * y1 / ry.	cy1 := coef * (ry * x1 / rx) negated.		sx2 := (x0 + x)/2.	sy2 := (y0 + y)/2.	cx := sx2 + ((tcos * cx1) - (tsin * cy1)).	cy := sy2 + ((tsin * cx1) + (tcos * cy1)).		ux := (x1 - cx1)/rx.	uy := (y1 - cy1)/ry.	vx := (x1 + cx1) negated /rx.	vy := (y1 + cy1) negated /ry.	"Angle start"	n := ((ux * ux) + (uy * uy)) sqrt.	p := ux.	sign := uy < 0 ifTrue: [ -1 ] ifFalse: [ 1 ].	angleStart := sign * (self arcCos: p / n).	"angle extent"	n := (((ux * ux) + (uy * uy)) * ((vx * vx) + (vy * vy))) sqrt.	p := (ux * vx) + (uy * vy).	sign := ((ux * vy) - (uy * vx)) < 0 ifTrue: [ -1 ] ifFalse: [ 1 ].	angleExtent := sign * (self arcCos: p / n).	(sweepFlag = 0 and: [ angleExtent > 0]) ifTrue: [ 		angleExtent := angleExtent - pi2.	 ] ifFalse: [ (sweepFlag = 1 and: [ angleExtent < 0 ]) ifTrue: [ 		angleExtent := angleExtent + pi2.		 ] ].	angleExtent := angleExtent % pi2.	angleStart := angleStart % pi2.	self		arcAround: (cx asFloat)@ (cy asFloat)		radius: rx asFloat		startAngle: angleStart asFloat		endAngle: angleExtent asFloat + angleStart		cw: sweepFlag = 0.! !"Roassal3"!!RSAbstractContainerBuilder commentStamp: '' prior: 0!I am the base for roassal visualizations. When a user wants to create a new visualization, he will need to create a new subclass of me.A container builder(RSAbstractContainerBuilder), is an object that creates roassal shapes and keeps those shapes in a container (which could be either a RSCanvas or a RSComposite). The builder can modify the canvas and register new callbacks for events, as for interactions.Methods- #build, because a builder news to build- #container:, to set the container where shapes will be added.- #renderIn:, is abstract class and recives a container, usually a canvas.Example:We can define an new calendar builder, that creates a calendar for a given year.```Smalltalkcard := RSPunchCardBuilder new.card objects: String withAllSubclasses.card addMetric: [:cls | cls numberOfMethods] name: 'NOM'.card build.```Then RSPunchCardBuilder should define 2 methods to run this example `objects:` and `renderIn:`. Check RSPunchCardBuilder for more details.Then you can use this builder to create a canvas with several punch cards```Smalltalkcanvas := RSCanvas new.card := RSPunchCardBuilder new.card addMetric: [:cls | cls numberOfMethods] name: 'NOM'.card addMetric: [:cls | cls linesOfCode ] name: 'NLC'.card addMetric: [:cls | cls numberOfVariables] name: 'NOV'.{ String. Array. StringMorph } do: [ :class | 	composite := RSComposite new.	card 		objects: class withAllSubclasses;		renderIn: composite.	composite adjustToChildren.	canvas add: composite.	 ].RSVerticalLineLayout on: canvas nodes."each node is a calendar for one year"canvas @ RSCanvasController```!!RSAbstractShapesBuilder commentStamp: '' prior: 0!I can create shapesI redefine #renderIn: My subclasses needs to implement #objects and: #shapesFor:!!RSAbstractTreeBuilder commentStamp: '' prior: 0!I am a abstract class to create visual elements based on tree structured in roassal3!!RSPunchCardBuilder commentStamp: '' prior: 0!I am an example!!RSAbstractContainerBuilder methodsFor: 'building'!build	self renderIn: self container.	^ self container! !!RSAbstractContainerBuilder methodsFor: 'accessing'!canvas	^ self container canvas! !!RSAbstractContainerBuilder methodsFor: 'accessing'!container	^ container ifNil: [ container := self defaultContainer ].! !!RSAbstractContainerBuilder methodsFor: 'accessing'!container: aTContainer	container := aTContainer! !!RSAbstractContainerBuilder methodsFor: 'defaults'!defaultContainer	^ RSCanvas new! !!RSAbstractContainerBuilder methodsFor: 'hooks'!renderIn: aCanvas	self subclassResponsibility! !!RSAbstractContainerBuilder methodsFor: 'accessing'!shapes	^ shapes! !!RSAbstractShapesBuilder methodsFor: 'hooks'!objects	^ self subclassResponsibility! !!RSAbstractShapesBuilder methodsFor: 'hooks'!renderIn: aCanvas	aCanvas addAll: (shapes := self shapesFor: self objects).! !!RSAbstractShapesBuilder methodsFor: 'hooks'!shapeFor: anObject index: index	^ self subclassResponsibility! !!RSAbstractShapesBuilder methodsFor: 'hooks'!shapesFor: aCollection	| k |	k := 0.	^ aCollection collect: [ :m |		k := k + 1. 		self shapeFor: m yourself index: k.		 ] as: RSGroup.! !!RSAbstractTreeBuilder methodsFor: 'private'!createElements: atree nesting: block1 leaves: block2 depth: depth	| children e leaves nodes|		e := self shapeFor: atree.	shapes add: e.		children := block1 rsValue: atree.	e properties at: #depth put: depth.	children := children collect: [ :child | | e2 |		e2 := self createElements: child nesting: block1 			leaves: block2 depth: depth + 1.		e2 properties at: #parent put: e.		e2 ] as: Array.	leaves := (block2 rsValue: atree) collect: [:child | | e2 |		e2 := self createElements: child nesting: #() 			leaves: #() depth: depth +1.		e2 properties at: #parent put: e.		e2 ] as: Array.	nodes := OrderedCollection new: (leaves size + children size).	nodes addAll: children; addAll: leaves.			e properties at: self childrenKey put: nodes.	^ e.! !!RSAbstractTreeBuilder methodsFor: 'private'!createElements: atree using: ablock depth: depth	| children shape |		shape := self shapeFor: atree.	shapes add: shape.		children := ablock rsValue: atree.	shape depth: depth.	children := children collect: [ :child | | e2 |		e2 := self createElements: child using: ablock depth: depth + 1.		e2 sparent: shape.		e2 ] as: Array.	shape schildren: children.	^ shape.! !!RSAbstractTreeBuilder methodsFor: 'public - building'!explore: atree nesting: block1 leaves: block2	shapes := RSGroup new.	^ (self from: (Array with: atree) nesting: block1 leaves: block2) first! !!RSAbstractTreeBuilder methodsFor: 'public - building'!explore: atree using: ablock	shapes := RSGroup new.	^ (self from: (Array with: atree) using: ablock) first.	! !!RSAbstractTreeBuilder methodsFor: 'public - building'!from: objects nesting: block1 leaves: block2	shapes := RSGroup new.	rootNodes := objects collect: [:obj | self createElements: obj nesting: block1 leaves: block2 depth: 1 ].	^ rootNodes! !!RSAbstractTreeBuilder methodsFor: 'public - building'!from: objects using: ablock	shapes := RSGroup new.	"This is the main public method. Takes a list of objects, and a block to specify how to recurse"	rootNodes := objects collect: [:obj | self createElements: obj using: ablock depth: 1 ].	^ rootNodes! !!RSAbstractTreeBuilder methodsFor: 'initialization'!initialize	super initialize.	rootNodes := RSGroup new.! !!RSAbstractTreeBuilder methodsFor: 'weight'!leafWeight: block	self weight: [ :shape | self weightLeafShape: shape block: block ].! !!RSAbstractTreeBuilder methodsFor: 'default'!minWeightValue	^ 1! !!RSAbstractTreeBuilder methodsFor: 'hooks'!renderIn: aCanvas	aCanvas addAll: self shapes! !!RSAbstractTreeBuilder methodsFor: 'accessing'!rootNodes	^ rootNodes! !!RSAbstractTreeBuilder methodsFor: 'accessing'!rootNodes: anArray	rootNodes := anArray! !!RSAbstractTreeBuilder methodsFor: 'hooks'!shapeFor: anObject	^ self subclassResponsibility! !!RSAbstractTreeBuilder methodsFor: 'weight'!weight	^ weight! !!RSAbstractTreeBuilder methodsFor: 'weight'!weight: anObject	weight := anObject! !!RSAbstractTreeBuilder methodsFor: 'private'!weightFromChildren: shape block: aBlock	| children weightValue |	children := shape schildren.	weightValue := children		ifEmpty: [ aBlock rsValue: shape model ]		ifNotEmpty: [ 			children 				inject: 0 				into: [ :s :child | s + (self weightLeafShape: child block: aBlock) ] ].	^ weightValue max: self minWeightValue.	! !!RSAbstractTreeBuilder methodsFor: 'accessing - keys'!weightKey	^ #weight! !!RSAbstractTreeBuilder methodsFor: 'private'!weightLeafShape: shape block: aBlock	^ shape		propertyAt: self weightKey		ifAbsentPut: [ 			self weightFromChildren: shape block: aBlock ]! !!RSAbstractTreeBuilder methodsFor: 'weight'!weightOf: aShape	^ self weight rsValue: aShape! !!RSPunchCardBuilder methodsFor: 'accessing'!addMetric: aRoassalValue name: name	metrics at: name put: aRoassalValue.! !!RSPunchCardBuilder methodsFor: 'defaults'!defaultContainer	^ RSCanvas new @ RSCanvasController! !!RSPunchCardBuilder methodsFor: 'initialization'!initialize	super initialize.	metrics := OrderedDictionary new.	size := 10.! !!RSPunchCardBuilder methodsFor: 'hooks'!labelFor: obj	^ RSLabel new		text: obj;		scaleBy: 0.2;		yourself! !!RSPunchCardBuilder methodsFor: 'accessing'!metrics	^ metrics! !!RSPunchCardBuilder methodsFor: 'accessing'!objects	^ objects! !!RSPunchCardBuilder methodsFor: 'accessing'!objects: aCollection	objects := aCollection! !!RSPunchCardBuilder methodsFor: 'hooks'!renderDots: aCanvas	| base |	base := RSEllipse new popup.	objects		doWithIndex: [ :cls :x | 			metrics keys				doWithIndex: [ :k :y | 					| metric res |					metric := metrics at: k.					res := metric rsValue: cls.					aCanvas						add:							(base copy								model: res;								position: x @ y * size;								size: (res + 1) ln + 1;								announcer: base announcer) ] ]! !!RSPunchCardBuilder methodsFor: 'hooks'!renderIn: aCanvas	self 	renderDots: aCanvas;	renderXAxis: aCanvas;	renderYAxis: aCanvas.! !!RSPunchCardBuilder methodsFor: 'hooks'!renderXAxis: aCanvas	| labels |	labels := objects		collectWithIndex: [ :cls :x | 			| label |			label := (self labelFor: cls) rotateByDegrees: -90.			label position: x @ 0 * size.			label ].	RSAlignment new		shapes: labels;		bottom.	aCanvas addAll: labels! !!RSPunchCardBuilder methodsFor: 'hooks'!renderYAxis: aCanvas	| labels |	labels := metrics keys collectWithIndex: [ :k :i |		(self labelFor: k)			position: 0@ i * size;			yourself ].	RSAlignment new		shapes: labels;		right.	aCanvas addAll: labels! !"Roassal3-Builders"!!RSTEdge commentStamp: '' prior: 0!My users have a line shape to interact with it. This trait has common methods to handle lines!!TMarkeable commentStamp: '' prior: 0!I am a trait to create markers in some especific classes!!RSAbstractCPController commentStamp: '' prior: 0!My subclasses can determine the control points for an object usefull for the update process of lines/edges with control points- controlPointsFor: is an abstract method, recibes an edge and it should return a collection of points!!RSAbstractCPAPController commentStamp: '' prior: 0!I apply the attach point, then I return an array with the control points for the current edge.- controlPointsFrom:to: is an abstract method, recives 2 points and it should return a collection of points!!RSHorizontalCPAPController commentStamp: '' prior: 0!I can return the control points for horizontal lines```	v := RSCanvas new.		e1 := RSBox new size: 100; color: Color blue.	e2 := RSBox new size: 100; color: Color red.	e1 translateTo: 100 @ -200.	e1 @ RSDraggable.	e2 @ RSDraggable.	v		add: e1;		add: e2.		l := RSBezier new		withVerticalAttachPoint;		from: e1;		to: e2;		controlPointsController: (RSHorizontalCPAPController new);		yourself.	v add: l.	v open```!!RSVerticalCPAPController commentStamp: '' prior: 0!I can return the control points for vertical lines```v := RSCanvas new.		e1 := RSBox new size: 100; color: Color blue.	e2 := RSBox new size: 100; color: Color red.	e1 translateTo: 100 @ -200.	e1 @ RSDraggable.	e2 @ RSDraggable.	v		add: e1;		add: e2.		l := RSBezier new		withVerticalAttachPoint;		from: e1;		to: e2;		controlPointsController: (RSVerticalCPAPController new);		yourself.	v add: l.	v open```!!RSBlockCPController commentStamp: '' prior: 0!I have am useful to define the control points in a fast way, but if you plan to use this controller in many scenarios, try to create a new subclass of RSAbstractCPController and avoid to use this class!!RSCustomCPController commentStamp: '' prior: 0!I am a custom control points controller to define crazy things with controls points.I am more like an example and not for applications!!RSAttachPoint commentStamp: '' prior: 0!I am the base for attach points!!RSCenteredAttachPoint commentStamp: '' prior: 0!I am the centered attach point-=-=-=-=c := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.lines := RSEdgeBuilder line	canvas: c;	connectFrom: 30 toAll: (31 to: 50).lines do: [ :l | l attachPoint: (RSCenteredAttachPoint new) ].RSGridLayout on: shapes. RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSCanvasController-=-=-=-=!!RSOffsetAttachPoint commentStamp: '' prior: 0!I can define offsets in each side of the attach point!!RSBorderAttachPoint commentStamp: '' prior: 0!I am an attach point that will end the line on the border of the end shapes.Unline ContinuousAttachPoint & co. you don't need to care about what the end shape is, as long as it is one of the basic shapes.Indirect way to use it:-=-=-=-=c := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.RSEdgeBuilder line	canvas: c;	withBorderAttachPoint;	connectFrom: 30 toAll: (31 to: 50).RSGridLayout on: shapes. RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSCanvasController-=-=-=-=Manual way to set an attach point:-=-=-=-=c := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.lines := RSEdgeBuilder line	canvas: c;	connectFrom: 30 toAll: (31 to: 50).lines do: [ :l | l attachPoint: (RSBorderAttachPoint new) ].RSGridLayout on: shapes. RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSCanvasController-=-=-=-=!!RSHorizontalAttachPoint commentStamp: '' prior: 0!Horizontal attach points between elements when drawing lines.  Useful for horizontal tree layout.-=-=-=-=c := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.lines := RSEdgeBuilder line	canvas: c;	connectFrom: 30 toAll: (31 to: 50).lines do: [ :l | l attachPoint: (RSHorizontalAttachPoint new) ].RSGridLayout on: shapes. RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSControlsCanvas-=-=-=-=!!RSVerticalAttachPoint commentStamp: '' prior: 0!Vertical attach points between elements when drawing lines. Useful for (vertical) tree layout-=-=-=-=c := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.lines := RSEdgeBuilder line	canvas: c;	connectFrom: 30 toAll: (31 to: 50).lines do: [ :l | l attachPoint: (RSVerticalAttachPoint new) ].RSGridLayout on: shapes. RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSControlsCanvas-=-=-=-=!!RSBorder commentStamp: '' prior: 0!I represent borders and line styles.A same border can be shared amoung different shapes. Here is an example:```Smalltalkc := RSCanvas new.b := RSBorder new color: Color blue.(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c```Another example, using animation: ```Smalltalkc := RSCanvas new.b := RSBorder new color: Color blue.b dashArray: #(5 1 5).(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c newAnimation 	from: 0;	to: 40;	on: b set: #dashOffset:.c```!!RSCornerRadius commentStamp: '' prior: 0!I have information about the corner radius and methods to create it!!RSEdgeBuilder commentStamp: '' prior: 0!RSEdgeBuilder offers an API to easily build edges.Here is an example:```Smalltalkc := RSCanvas new.classes := Collection withAllSubclasses.boxes := classes collect: [ :cls |				RSBox new					width: (cls instVarNames size * 5 max: 5);					height: (cls numberOfMethods max: 5);					model: cls;					yourself ] as: RSGroup.boxes @ RSDraggable.c addAll: boxes.RSEdgeBuilder orthoVertical	canvas: c;	attachPoint: RSVerticalAttachPoint new;	shapes: boxes;	connectFrom: #superclass.RSTreeLayout on: c nodes.c @ RSCanvasController.c open```Another example:```Smalltalkc := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.lines := RSEdgeBuilder line	canvas: c;	connectFrom: 30 toAll: (31 to: 50).lines do: [ :l | l attachPoint: (RSHorizontalAttachPoint new) ].RSGridLayout on: shapes. RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSCanvasController```!!RSMarker commentStamp: '' prior: 0!I represent a marker for RSLine, RSPolygon and RSBezier!!RSNormalizer commentStamp: '' prior: 0!<keyClass>A normalizer is made to assign a color for a particual visual cue (e.g., size, color, font size). The normalization is performed using the model of the considered shapes.Scales can be set, useful for transformation (e.g., logarithmic).*Responsibility*: normalize a *Collaborators*: interact with `RSShape` and the shape's model*Variables*:- `scale`: refers to `NSScale` - `executeBlock`: one-arg block useful to compute a metric or property from the shape model. The block takes a shape model as argument- `shapes`: shapes that are normalized *Example*:```Smalltalkc := RSCanvas new.shapes := (1 to: 150) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.c addAll: shapes.RSGridLayout on: shapes.RSNormalizer color	shapes: shapes;	scale: NSScale category20b;	normalize: #yourself.c @ RSCanvasController.c``````Smalltalkclasses := Collection withAllSubclasses.c := RSCanvas new.shapes := classes collect: [ :cls |	b := RSBox new.	b model: cls.	b size: cls numberOfMethods.	b @ RSDraggable @ RSPopup.	b ].RSNormalizer color	shapes: shapes;	normalize: #numberOfMethods.c addAll: shapes.RSFlowLayout on: shapes.c @ RSCanvasController ``````Smalltalkcanvas := RSCanvas new.classes := Collection withAllSubclasses.shapes := classes collect: [ :cls |    RSEllipse new        size: 10;        model: cls;        draggable;        yourself ].canvas addAll: shapes.RSNormalizer size    from: 10;    to: 100;    shapes: shapes;    normalize: #numberOfMethods.RSNormalizer color    from: Color green;    to: Color red;    shapes: shapes;    normalize: #numberOfMethods.RSEdgeBuilder orthoVertical    withVerticalAttachPoint;    markerStart: (RSShapeFactory arrow size: 5; color: Color blue);    canvas: canvas;    shapes: shapes;    connectFrom: #superclass.    RSTreeLayout on: shapes.canvas @ RSCanvasController.canvas``````Smalltalkc := RSCanvas new.(30 to: 100 by: 5) do: [ :nb |	c add: (RSEllipse new size: nb; model: nb) ].RSNormalizer size	shapes: c shapes;	normalize: #yourself.RSNormalizer color	shapes: c shapes;	normalize: #yourself.RSFlowLayout on: c shapes.c shapes @ RSPopup.c @ RSCanvasController```!!RSShapeFactory commentStamp: '' prior: 0!I can create shapes in order that the client can modify it!!RSStrokeStyle commentStamp: '' prior: 0!I represent different styles for the stroke!!RSTextExtents commentStamp: '' prior: 0!Extents for RSLabel!!RSAbstractLine commentStamp: '' prior: 0!I represent the abstract lines that have start and end pointsFor example:-=-=-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.circle := RSEllipse new color: Color green; size: 10.box := RSBox new color: Color red; size: 10.c add: circle; add: box.dragMeLabel := RSLabel new text: 'Drag me'.c add: dragMeLabel.RSLocation new	above; center;	stick: dragMeLabel on: box.c add: (RSLine new color: Color veryVeryLightGray; from: 0 @ -1000; to: 0 @ 1000).c add: (RSLine new color: Color veryVeryLightGray; from: -1000 @ 0; to: 1000 @ 0).box translateBy: 50 @ 50.box @ RSDraggable.c add: (RSLine new color: Color blue; from: box; to: circle).c-=-=-=-=-=-=-=-=-=-=-=-=!!RSAbstractControlPointsLine commentStamp: '' prior: 0!I am an abstract class for lines with control points!!RSBezier commentStamp: '' prior: 0!RSBezier represents a bezier lines of one and 2 control points.Here is an example:```Smalltalk	c := RSCanvas new.	c add: (RSBezier new		color: Color red;		controlPoints:			{(0 @ 0).			(100 @ 100).			(200 @ 0).			(300 @ 100)}).	c ```Another example:```Smalltalk	v := RSCanvas new.		e1 := RSBox new size: 100; color: Color blue.	e2 := RSBox new size: 100; color: Color red.	e1 translateTo: 100 @ -200.	e1 @ RSDraggable.	e2 @ RSDraggable.	v		add: e1;		add: e2.		l := RSBezier new		withVerticalAttachPoint;		from: e1;		to: e2;		controlPointsBlock: [ :a :b | 			| mid |			mid := (a + b) / 2.			Array				with: a				with: a x @ mid y				with: b x @ mid y				with: b ];		yourself.	v add: l.	v open```!!RSPolyline commentStamp: '' prior: 0!TODO!!RSAbstractDualLine commentStamp: '' prior: 0!I am an abtract shape that has an start and one end!!RSLine commentStamp: '' prior: 0!RSLine describes a line. A line typically links two shapes.Here is an example:-=-=-=-=| c from to l |c := RSCanvas new.from := RSBox new size: 30.to := RSEllipse new size: 30.from @ RSDraggable.to @ RSDraggable.c add: from.c add: to.l := RSLine new.l attachPoint: RSCenteredAttachPoint new.l from: from.l to: to.c add: l.to translateBy: 50 @ 40.c @ RSCanvasController.c-=-=-=-=Adding single line can be complex in some situation. You may want to look at RSEdgeBuilder to ease the edge creation. !!RSArrowedLine commentStamp: '' prior: 0!RSArrowedLine describes a line with a head or marker. Here is an example:-=-=-=-=| c from to l |c := RSCanvas new.from := RSBox new size: 30.to := RSEllipse new size: 30.from @ RSDraggable.to @ RSDraggable.c add: from.c add: to.l := RSArrowedLine new.l attachPoint: RSCenteredAttachPoint new.l from: from.l to: to.c add: l.to translateBy: 50 @ 40.c @ RSCanvasController.c-=-=-=-=Adding single line can be complex in some situation. You may want to look at RSEdgeBuilder arrowedLine!!RSBoundingShape commentStamp: '' prior: 0!My subclasses has an extent and a transformation matrix!!RSBitmap commentStamp: '' prior: 0!I can draw Forms!!RSBox commentStamp: '' prior: 0!<keyClass>`RSBox` represents a box shape, which can be decorated in many ways.*Responsibility*: represents a 2 dimentional box *Collaborators*: may interact with many classes covering composite shapes (e.g., `RSComposite`, `RSGroup`), the `RSCanvas` class, and interaction (e.g., `RSDraggable`, `RSPopup`).*Variables*:- `cornerRadius`: angle of the radius. If no radius is applied, the variable is nil*Example*:```SmalltalkRSCanvas new	add: (RSBox new size: 30);	yourself```A slightly more complex example could be:```Smalltalkgradient := LinearGradientPaint new colorRamp: {  0 -> Color red. 1 -> Color black }.gradient			start: -50 asPoint;			stop: 50 asPoint.c := RSCanvas new.s := RSBox new size: 80; cornerRadius: 20.s color: gradient.c add: s.	c```!!RSComposite commentStamp: '' prior: 0!I am a composite shapes. I can therefore contain other shapes.Here is a simple example:-=-=-=c := RSCanvas new.box := RSBox new width: 40; height: 10; color: Color blue.label := RSLabel new text: 'Hello Roassal3'.RSLocation new above; move: box on: label.composite := RSComposite new.composite shapes: { label . box }.composite @ RSDraggable.c add: composite.c-=-=-=A composite can also have a background color. Simply use #color: for this:-=-=-=c := RSCanvas new.box := RSBox new width: 40; height: 10; color: Color blue.label := RSLabel new text: 'Hello Roassal3'.RSLocation new above; move: box on: label.composite := RSComposite new.composite color: Color gray.composite shapes: { label . box }.composite @ RSDraggable.c add: composite.c-=-=-=A padding describes a space between the border of the composite element and the inner shapes. It can be adjusted using the message #padding:-=-=-=c := RSCanvas new.box := RSBox new width: 40; height: 10; color: Color blue.label := RSLabel new text: 'Hello Roassal3'.RSLocation new above; move: box on: label.composite := RSComposite new.composite color: Color gray.composite shapes: { label . box }.composite @ RSDraggable.composite padding: 10.c add: composite.c-=-=-=Inner nodes can be layouted:-=-=-=classes := RSObject withAllSubclasses.c := RSCanvas new.classes do: [ :cls |	label := RSLabel new text: cls name.	methods := 		cls methods collect: [ :m |			RSBox new model: m; size: m sourceCode size sqrt; color: Color blue ] as: RSGroup.	RSGridLayout on: methods.	methods @ RSPopup.	RSLocation new above; move: label on: methods.	composite := RSComposite new.	composite color: Color gray.	composite shapes: { label }, methods.	composite @ RSDraggable.	composite padding: 10.	c add: composite.].RSFlowLayout on: c shapes.c @ RSControlsCanvas-=-=-=Lines can be added between composite. Here is an example:-=-=-=classes := RSObject withAllSubclasses.c := RSCanvas new.classes do: [ :cls |	label := RSLabel new text: cls name.	methods := 		cls methods collect: [ :m |			RSBox new model: m; size: m sourceCode size sqrt; color: Color blue ] as: RSGroup.	RSGridLayout on: methods.	methods @ RSPopup.	RSLocation new above; move: label on: methods.	composite := RSComposite new.	composite model: cls.	composite color: Color gray.	composite shapes: { label }, methods.	composite @ RSDraggable.	composite padding: 10.	c add: composite.].RSEdgeBuilder orthoVertical	canvas: c;	withVerticalAttachPoint;	connectFrom: #superclass.RSTreeLayout on: c nodes.c @ RSControlsCanvas-=-=-=!!RSEllipse commentStamp: '' prior: 0!I am an ellipse shapeHere an example:c := RSCanvas new.(30 to: 150 by: 10) do: [ :nb |	b := RSBox new size: nb.	c add: b ].RSFlowLayout on: c nodes.c @ RSControlsCanvas!!RSLabel commentStamp: '' prior: 0!I represent simple label text!!RSPieSlice commentStamp: '' prior: 0!A ring shape to draw ring in a circle shape, not in a ellipse.!!RSPolygon commentStamp: '' prior: 0!Define a polygon shape, ready to be added to a Roassal canvas.For example:-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.polygon := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: 'FFAE0B'.polygon cornerRadii: 5.		polygon2 := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: Color red trans.		polygon2 rotateByDegrees: 90.polygon2 translateBy: 0 @ -50.c add: polygon.c add: polygon2.c-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=!!RSTEdge methodsFor: 'public - shape'!addInteraction: anInteraction	self shape addInteraction: anInteraction! !!RSTEdge methodsFor: 'public - shape'!border	^ self shape border! !!RSTEdge methodsFor: 'public - shape'!border: aBorder	self shape border: aBorder! !!RSTEdge methodsFor: 'public - shape'!borderColor: aColor	self shape borderColor: aColor! !!RSTEdge methodsFor: 'public - shape'!capRound	self shape capRound! !!RSTEdge methodsFor: 'public - shape'!color: aColor	self shape color: aColor! !!RSTEdge methodsFor: 'public - shape'!controlPointsController	^ self shape controlPointsController! !!RSTEdge methodsFor: 'public - shape'!controlPointsController: aCPController	self shape controlPointsController: aCPController! !!RSTEdge methodsFor: 'public - shape'!cornerRadii: aNumber	^ self shape cornerRadii: aNumber! !!RSTEdge methodsFor: 'public - shape'!dashArray: anArray	^ self shape dashArray: anArray! !!RSTEdge methodsFor: 'public - shape'!dashed	self shape dashed! !!RSTEdge methodsFor: 'public - shape'!fmt: aString	"format for lines"	(RSShapeFactory shapeFromString: aString) 		ifNotNil: [ :shape |self shape marker: (shape size: self width * 4) ].	(RSStrokeStyle fromString: aString)		ifNotNil: [ :style | self shape border style: style ]	! !!RSTEdge methodsFor: 'public - shape'!format: aString		"want more markers? submit a new issue in roassal3"	| marker bs |	marker := RSShapeFactory shapeFromString: aString.	bs := RSStrokeStyle fromString: aString.	marker ifNotNil: [ self shape marker: marker ].	! !!RSTEdge methodsFor: 'public - shape'!joinRound	self shape joinRound! !!RSTEdge methodsFor: 'public - shape'!markerEnd: aMarker	self shape markerEnd: aMarker! !!RSTEdge methodsFor: 'public - shape'!markerStart: aMarker	self shape markerStart: aMarker! !!RSTEdge methodsFor: 'public - shape'!noBorder	self shape noBorder! !!RSTEdge methodsFor: 'public - shape'!paint: aPaint	self shape paint: aPaint! !!RSTEdge methodsFor: 'public - shape'!shape	^ self explicitRequirement! !!RSTEdge methodsFor: 'public - shape'!shape: aRSAbstractLine	self explicitRequirement! !!RSTEdge methodsFor: 'public - shape'!width	^ self shape border width! !!RSTEdge methodsFor: 'public - shape'!width: aNumber	"Set the width of the line. For example:	-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	width: 10;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=	"	self shape width: aNumber! !!TMarkeable methodsFor: 'accessing - markers'!marker: aMarker	| m |	m := aMarker asMarker. 	self 		markerStart: m;		markerMid: m;		markerEnd: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markerEnd	^ self markers third.! !!TMarkeable methodsFor: 'accessing - markers'!markerEnd: marker	| m| 	m := marker asMarker.	self markers at: 3 put: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markerMid	^ self markers second.! !!TMarkeable methodsFor: 'accessing - markers'!markerMid: marker	| m| 	m := marker asMarker.	self markers at: 2 put: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markerStart 	^ self markers first.! !!TMarkeable methodsFor: 'accessing - markers'!markerStart: marker	| m| 	m := marker asMarker.	self markers at: 1 put: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markerStartEnd: aMarker	| m |	m := aMarker asMarker. 	self 		markerStart: m;		markerEnd: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markers	^ nil! !!TMarkeable methodsFor: 'accessing - markers'!markersDo: block	self markers do: [ :m | m ifNotNil: block  ].! !!GEllipse methodsFor: '*Roassal3-Shapes'!rsScaleWith: anAthensAffineTransform	| m |	m := anAthensAffineTransform.	^ self class 		center: (m transform: center)		vertex: (m transform: coVertex)		coVertex: (m transform: vertex)! !!RSAbstractCPAPController methodsFor: 'hooks'!controlPointsFor: anEdge	| ap |	ap := anEdge attachPoint.	^ self		controlPointsFrom: (ap startingPointOf: anEdge)		to: (ap endingPointOf: anEdge).! !!RSAbstractCPAPController methodsFor: 'hooks'!controlPointsFrom: fromPoint to: toPoint	^ self subclassResponsibility! !!RSHorizontalCPAPController methodsFor: 'hooks'!controlPointsFrom: from to: to	| mid |	mid := (from + to)/2.	^ Array 		with: from		with: mid x @ from y		with: mid x @ to y		with: to ! !!RSVerticalCPAPController methodsFor: 'hooks'!controlPointsFrom: from to: to	| mid |	mid := (from + to)/2.	^ Array		with: from		with: from x @ mid y		with: to x @ mid y		with: to! !!RSAbstractCPController methodsFor: 'hooks'!controlPointsFor: anEdge	"return an array of points generated from the edge"	^ self subclassResponsibility ! !!RSBlockCPController methodsFor: 'accessing'!block	^ block! !!RSBlockCPController methodsFor: 'accessing'!block: aBlockClosure	block := aBlockClosure! !!RSBlockCPController methodsFor: 'hooks'!controlPointsFor: anEdge	^ block cull: anEdge! !!RSCustomCPController methodsFor: 'hooks'!controlPointFor: model		! !!RSCustomCPController methodsFor: 'hooks'!controlPointFor: model at: anEdge	| point |	model isPoint ifTrue: [ ^ model ].	point  := model value.	(model isKindOf: RSShape) ifTrue: [ 		model addConnectedEdge: anEdge.		point := model position ].	^ point! !!RSCustomCPController methodsFor: 'hooks'!controlPointsFor: anEdge	^ self models collect: [ :m | self controlPointFor: m at: anEdge ].! !!RSCustomCPController methodsFor: 'accessing'!models	^ models! !!RSCustomCPController methodsFor: 'accessing'!models: aCollection	models := aCollection! !!RSAttachPoint class methodsFor: 'instance creation'!centered	^ RSCenteredAttachPoint new! !!RSAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ self subclassResponsibility ! !!RSAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ self subclassResponsibility ! !!RSAttachPoint methodsFor: 'private'!commonParents: shape in: anEdge	| current parents |	current := shape parent.	parents := OrderedCollection new.	[ current = anEdge parent ] whileFalse: [ 		current ifNil: [ ^ nil ].		current parent = current ifTrue: [ ^ nil ].		parents add: current.		current := current parent ].	^ parents! !!RSAttachPoint methodsFor: 'public - hooks'!endingPointOf: aLine	"Return the end point of a line.		b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSBorderAttachPoint new.	l update.	b1 @ RSDraggable.	b2 @ RSDraggable.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.		l attachPoint startingPointOf: l=> 	50 @ 45	"	(aLine from = aLine to) 		ifTrue: [ ^ self positionFor: aLine from in: aLine ].    ^ inverted        ifTrue: [ self basicStartingPointOf: aLine ]        ifFalse: [ self basicEndingPointOf: aLine ]! !!RSAttachPoint methodsFor: 'private'!hasParents: shape in: anEdge	^ shape parent notNil and: [ anEdge parent notNil ]! !!RSAttachPoint methodsFor: 'public - hooks'!initialize	super initialize.	inverted := false.! !!RSAttachPoint methodsFor: 'private'!matrixFor: commonParents	| matrix |	matrix := AthensAffineTransform new.	commonParents reverseDo: [ :s | matrix multiplyBy: s matrix ].	^ matrix! !!RSAttachPoint methodsFor: 'private'!positionFor: shape in: anEdge	shape isPoint ifTrue: [ ^ shape ].	^ self positionFor: shape in: anEdge point: shape position! !!RSAttachPoint methodsFor: 'private'!positionFor: shape in: anEdge point: pos	| commonParents |	shape isPoint ifTrue: [ ^ shape ].	(self hasParents: shape in: anEdge) ifFalse: [ ^ pos ].	shape parent = anEdge parent ifTrue: [ ^ pos ].		"TODO we can cache this info"	commonParents := self commonParents: shape in: anEdge.	commonParents ifNil: [ ^ pos ].	^ (self matrixFor: commonParents) transform: pos. ! !!RSAttachPoint methodsFor: 'public - hooks'!startingPointOf: aLine"Return the starting point of a line.		b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSBorderAttachPoint new.	l update.	b1 @ RSDraggable.	b2 @ RSDraggable.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.		l attachPoint startingPointOf: l=> 	30 @ 35	"	(aLine from = aLine to) 		ifTrue: [ ^ self positionFor: aLine from in: aLine ].    ^ inverted        ifTrue: [ self basicEndingPointOf: aLine ]        ifFalse: [ self basicStartingPointOf: aLine ]! !!RSCenteredAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ self positionFor: anEdge to in: anEdge.	! !!RSCenteredAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ self positionFor: anEdge from in: anEdge.	! !!RSBorderAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ self		basicPointFrom: anEdge to		to: anEdge from		of: anEdge		offset: endOffset! !!RSBorderAttachPoint methodsFor: 'public - hooks'!basicPointFrom: fromShape to: toShape of: anEdge offset: aNumber	| source target line shift res vector unit |	source := self geometryFor: fromShape edge: anEdge.	target := self geometryFor: toShape edge: anEdge.	shift := self offsetNormalFor: anEdge.	line := GLine through: source center and: target center.	vector := line v2 asPoint - line v1 asPoint.	vector := vector x @ vector y.	unit := vector / (vector r max: 1).	shift := vector normal * shift.	anEdge from = toShape		ifTrue: [ shift := shift * -1 ].	line := GLine		through: source center asPoint + shift		and: target center asPoint + shift.	res := self borderPointFrom: source to: target via: line.	^ res asPoint + (unit * aNumber)! !!RSBorderAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ self 		basicPointFrom: anEdge from 		to: anEdge to 		of: anEdge 		offset: startOffset! !!RSBorderAttachPoint methodsFor: 'public - hooks'!borderPointFrom: aSource to: aTarget via: aLine	^ ((aLine intersectionsWith: aSource) detectMin: [ :p | p asPoint dist: aLine v2 ])		ifNil: [ aSource center ]! !!RSBorderAttachPoint methodsFor: 'public - hooks'!geometryFor: shape edge: anEdge	| g commonParents matrix |	g := shape geometry.	(self hasParents: shape in: anEdge)		ifFalse: [ ^ g ].	shape parent = anEdge parent		ifTrue: [ ^ g ].	commonParents := self commonParents: shape in: anEdge.	commonParents ifNil: [ ^ g ].	matrix := self matrixFor: commonParents.	g := g rsScaleWith: matrix.	^ g! !!RSBorderAttachPoint methodsFor: 'initialization'!initialize	super initialize.	offset := 5! !!RSBorderAttachPoint methodsFor: 'accessing'!offset	^ offset! !!RSBorderAttachPoint methodsFor: 'accessing'!offset: aNumber	offset := aNumber! !!RSBorderAttachPoint methodsFor: 'public - hooks'!offsetNormalFor: anEdge	"Return the offset in case of multiple edges with the same starting and ending points"	| indexOfEdge multipleEdges |	multipleEdges := OrderedCollection new.	multipleEdges		addAll:			(anEdge to connectedEdges				select: [ :e | e from == anEdge from and: [ e to == anEdge to ] ]).	multipleEdges		addAll:			(anEdge to connectedEdges				select: [ :e | e to == anEdge from and: [ e from == anEdge to ] ]).	multipleEdges size <= 1		ifTrue: [ ^ 0 @ 0 ].	indexOfEdge := multipleEdges indexOf: anEdge.	^ (indexOfEdge - 1 - (multipleEdges size / 2)) * offset! !!RSHorizontalAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: edge	^ self 		positionFor: edge to 		in: edge 		point: edge to encompassingRectangle leftCenter + (endOffset@0)! !!RSHorizontalAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: edge	^ self 		positionFor: edge from		in: edge 		point: edge from encompassingRectangle rightCenter + (startOffset@0)! !!RSOffsetAttachPoint methodsFor: 'accessing'!endOffset	^ endOffset! !!RSOffsetAttachPoint methodsFor: 'accessing'!endOffset: aNumber	endOffset := aNumber! !!RSOffsetAttachPoint methodsFor: 'public - hooks'!initialize 	super initialize.	startOffset := endOffset := 0.! !!RSOffsetAttachPoint methodsFor: 'accessing'!startOffset	^ startOffset! !!RSOffsetAttachPoint methodsFor: 'accessing'!startOffset: aNumber	startOffset := aNumber.! !!RSVerticalAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ self 		positionFor: anEdge to 		in: anEdge 		point: anEdge to encompassingRectangle topCenter + (0@endOffset)! !!RSVerticalAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ self 		positionFor: anEdge from		in: anEdge 		point: anEdge from encompassingRectangle bottomCenter + (0@startOffset)! !!RSBorder methodsFor: 'visiting'!accept: visitor	^ visitor visitBorder: self! !!RSBorder methodsFor: 'style-cap'!capButt	self pStyle capStyle: #capButt.! !!RSBorder methodsFor: 'style-cap'!capRound	self pStyle capStyle: #capRound.! !!RSBorder methodsFor: 'style-cap'!capSquare	self pStyle capStyle: #capSquare.! !!RSBorder methodsFor: 'accessing'!color	^ paint! !!RSBorder methodsFor: 'accessing'!color: aColor	paint := aColor.	paint isColor ifTrue: [ ^ self ].	paint := Color colorFrom: aColor.! !!RSBorder methodsFor: 'style-dashes'!dashArray: arrayOfNumbers	"Set the pattern for the dash. For example:-=-=-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.b := RSBorder new color: Color blue.b dashArray: #(1 5 10 15).(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c-=-=-=-=-=-=-=-=-=-=-=-=	"	self pStyle dashArray: arrayOfNumbers	! !!RSBorder methodsFor: 'accessing'!dashOffset	^ self pStyle dashOffset! !!RSBorder methodsFor: 'accessing'!dashOffset: offset	"Set the offset for the dash. The offset is useful when animating. ```Smalltalkc := RSCanvas new.b := RSBorder new color: Color blue.b dashArray: #(5 1 5).(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c newAnimation 	from: 0;	to: 40;	on: b set: #dashOffset:.c```	"	self pStyle dashOffset: offset! !!RSBorder methodsFor: 'initialization'!initialize	super initialize.	paint := Color black.	width := 1.	style := nil! !!RSBorder methodsFor: 'style-join'!joinBevel	self pStyle joinStyle: #joinBevel! !!RSBorder methodsFor: 'style-join'!joinMiter	self pStyle joinStyle: #joinMiter! !!RSBorder methodsFor: 'style-join'!joinRound	self pStyle joinStyle: #joinRound! !!RSBorder methodsFor: 'private'!pStyle 	^ style ifNil: [ style := RSStrokeStyle new ].! !!RSBorder methodsFor: 'accessing'!paint 	^ paint! !!RSBorder methodsFor: 'accessing'!paint: aPaint	paint := aPaint! !!RSBorder methodsFor: 'accessing'!style	^style! !!RSBorder methodsFor: 'accessing'!style: aStyle	style := aStyle! !!RSBorder methodsFor: 'accessing'!width 	^ width! !!RSBorder methodsFor: 'accessing'!width: anInteger 	"Set the width of the border. 	For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new border: (RSBorder new color: Color red; width: 3); model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.RSNormalizer size	shapes: shapes;	normalize: #yourself.interaction := RSHighlightable new.interaction highlightColor: Color blue.interaction highlightBorder: (RSBorder new color: Color black; width: 3).shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```	"	width := anInteger! !!RSCornerRadius methodsFor: 'accessing'!bottom: aNumber	bottomLeft := bottomRight := aNumber! !!RSCornerRadius methodsFor: 'accessing'!bottomLeft 	^ bottomLeft! !!RSCornerRadius methodsFor: 'accessing'!bottomLeft: aNumber	bottomLeft := aNumber! !!RSCornerRadius methodsFor: 'accessing'!bottomRight	^ bottomRight ! !!RSCornerRadius methodsFor: 'accessing'!bottomRight: aNumber	bottomRight := aNumber! !!RSCornerRadius methodsFor: 'initialization'!initialize	super initialize.	self radius: 0.! !!RSCornerRadius methodsFor: 'transforming'!interpolateTo: other at: t	"other is an instance of RSCornerRadius	t is a float between 0 and 1"	| |	^ self class new		topLeft: (self topLeft interpolateTo: other topLeft at: t);		topRight: (self topRight interpolateTo: other topRight at: t);		bottomLeft: (self bottomLeft interpolateTo: other bottomLeft at: t);		bottomRight: (self bottomRight interpolateTo: other bottomRight at: t);		yourself! !!RSCornerRadius methodsFor: 'accessing'!left: aNumber	topLeft := bottomLeft := aNumber! !!RSCornerRadius methodsFor: 'accessing'!max	^ topLeft max: (topRight max: (bottomLeft max: bottomRight))! !!RSCornerRadius methodsFor: 'accessing'!min	^ topLeft min: (topRight min: (bottomLeft min: bottomRight))! !!RSCornerRadius methodsFor: 'accessing'!radius: aNumber	topLeft := topRight := bottomLeft := bottomRight := aNumber! !!RSCornerRadius methodsFor: 'accessing'!right: aNumber	topRight := bottomRight := aNumber! !!RSCornerRadius methodsFor: 'accessing'!top: aNumber	topLeft := topRight := aNumber! !!RSCornerRadius methodsFor: 'accessing'!topLeft	^ topLeft ! !!RSCornerRadius methodsFor: 'accessing'!topLeft: aNumber	topLeft := aNumber! !!RSCornerRadius methodsFor: 'accessing'!topRight	^ topRight! !!RSCornerRadius methodsFor: 'accessing'!topRight: aNumber	topRight := aNumber! !!RSEdgeBuilder class methodsFor: 'instance creation'!arrowedLine	^ self new: RSShapeFactory arrowedLine! !!RSEdgeBuilder class methodsFor: 'instance creation'!arrowedLineWithOffset: aFloat	"[0 1] value"	| inst |	inst := self arrowedLine.	inst shape markerEnd offsetRatio: aFloat.	^ inst! !!RSEdgeBuilder class methodsFor: 'instance creation'!bezier	^ self new: RSBezier new! !!RSEdgeBuilder class methodsFor: 'instance creation'!horizontalBezier	^ self horizontalLine: RSBezier new! !!RSEdgeBuilder class methodsFor: 'instance creation'!horizontalLine: aShape	^ (self new: aShape)		controlPointsController: RSHorizontalCPAPController new;		yourself.	! !!RSEdgeBuilder class methodsFor: 'instance creation'!line	^ self new: RSLine new! !!RSEdgeBuilder class methodsFor: 'instance creation'!new	^ self error: 'Should not use #new to create an edge builder. Instead, use a #line, #arrowedLine.'! !!RSEdgeBuilder class methodsFor: 'instance creation'!new: aTSShape	 ^ super new 		shape: aTSShape;		yourself		! !!RSEdgeBuilder class methodsFor: 'instance creation'!orthoHorizontal	^ self horizontalLine: RSPolyline new.! !!RSEdgeBuilder class methodsFor: 'instance creation'!orthoVertical	^ self verticalLine: RSPolyline new.! !!RSEdgeBuilder class methodsFor: 'instance creation'!polyline	^ self new: RSPolyline new! !!RSEdgeBuilder class methodsFor: 'instance creation'!verticalBezier	^ self verticalLine: RSBezier new! !!RSEdgeBuilder class methodsFor: 'instance creation'!verticalLine: aShape	^ (self new: aShape)		controlPointsController: RSVerticalCPAPController new;		yourself.	! !!RSEdgeBuilder methodsFor: 'public repetition'!allowRepetition	allowRepetition := true! !!RSEdgeBuilder methodsFor: 'public - attach point'!attachPoint	^ self shape attachPoint! !!RSEdgeBuilder methodsFor: 'public - attach point'!attachPoint: anAttachPoint	self shape attachPoint: anAttachPoint! !!RSEdgeBuilder methodsFor: 'public - configuration'!beDirectional	"When edges are created, this allow for having edges going from A to B, and from B to A"	beDirectional := true! !!RSEdgeBuilder methodsFor: 'accessing'!canvas	^ canvas! !!RSEdgeBuilder methodsFor: 'accessing'!canvas: aCanvas	"Provide a reference to the Roassal canvas in which (i) shapes will be looked up and (ii) lines will be added"	canvasHasBeenManuallySet := true.	canvas := aCanvas! !!RSEdgeBuilder methodsFor: 'accessing'!canvasNodes	"Return the nodes of the canvas"	canvas ifNil: [ ^ #() ].	^ canvas nodes! !!RSEdgeBuilder methodsFor: 'public'!connectFrom: aBlockOrASymbol	"Connect each shapes with the shapes for which the model matches aBlockOrASymbol"	^ self connectFrom: aBlockOrASymbol to: [ :each | each ]! !!RSEdgeBuilder methodsFor: 'public'!connectFrom: aFromBlock to: aBlockOrASymbol	| toElement fromElement |	self resetCreatedEdges.	self fromShapes copy do: [ :e | 			fromElement := self fromShapes shapeFromModel: (aFromBlock rsValue: e model).			toElement := self toShapes shapeFromModel: (aBlockOrASymbol rsValue: e model).			toElement ifNotNil: [ self createEdgeIfNecessaryFrom: fromElement to: toElement ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'public'!connectFrom: aFromBlock toAll: aBlockOrASymbol	"Define edges from a particular element to another set of elements. For example:-=-=-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.shapes := (30 to: 50) collect: [ :nb |	RSEllipse new size: nb; model: nb; yourself.	 ] as: RSGroup.c addAll: shapes.RSEdgeBuilder line	canvas: c;	withBorderAttachPoint;	connectFrom: 30 toAll: (31 to: 50).RSGridLayout on: shapes. RSLocation new	above;	move: shapes first on: shapes allButFirst.shapes @ RSDraggable.c @ RSControlsCanvas-=-=-=-=-=-=-=-=-=-=-=-=	"	| fromElement tes |	self resetCreatedEdges.	self fromShapes copy do: [ :e | 		fromElement := self fromShapes shapeFromModel: (aFromBlock rsValue: e model).		tes := self toShapes shapesFromModels: (aBlockOrASymbol rsValue: e model).		tes ifNotNil: [ 			tes do: [ :toE | 				self createEdgeIfNecessaryFrom: fromElement to: toE ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges ! !!RSEdgeBuilder methodsFor: 'public'!connectFromAll: aFromBlockOrSymbol	^ self connectFromAll: aFromBlockOrSymbol to: [ :each | each ]! !!RSEdgeBuilder methodsFor: 'public'!connectFromAll: aFromBlockOrSymbol to: aBlockOrASymbol	| toElement tfromElements |	self resetCreatedEdges.	self fromShapes copy do: [ :e | 		tfromElements := self fromShapes shapesFromModels: (aFromBlockOrSymbol rsValue: e model). 		toElement := self toShapes shapeFromModel: (aBlockOrASymbol rsValue: e model).		tfromElements ifNotNil: [ 			tfromElements do: [ :fromElement | 				self createEdgeIfNecessaryFrom: fromElement to: toElement ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'public'!connectTo: aBlockOrASymbol	^ self connectFrom: [ :each | each ] to: aBlockOrASymbol! !!RSEdgeBuilder methodsFor: 'public'!connectToAll: aBlockOrASymbol	"Should this method use connectFrom:ToAll: ?????"	| tmptoElements |	self resetCreatedEdges.	self fromShapes copy do: [ :e | 		tmptoElements := self toShapes shapesFromModels: (aBlockOrASymbol rsValue: e model).		tmptoElements ifNotNil: [ 			tmptoElements do: [ :toE | 				self createEdgeIfNecessaryFrom: e to: toE ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'private - utility'!createEdgeIfNecessaryFrom: fromElement to: toElement	"This is a private method. Create, if necessary, an edge between two elements"	(self shouldCreateEdgeFrom: fromElement to: toElement)		ifTrue: [ createdEdges add: (self edgeFrom: fromElement to: toElement) ]! !!RSEdgeBuilder methodsFor: 'private - utility'!edgeFrom: source to: target 	"source and target are elements"	| edge |	edge := self shape copy		model: source model -> target model;		from: source;		to: target;		yourself.	edge border: (self shape border copy).	canvas ifNotNil: [ canvas add: edge ].	^ edge! !!RSEdgeBuilder methodsFor: 'accessing'!fromObjects	"Return the list of objects considered as targets for the edges"	^ self fromShapes collect: #model! !!RSEdgeBuilder methodsFor: 'accessing'!fromObjects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ canvasHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	 	(someObjectsOrABlock isCollection and: [ someObjectsOrABlock isSymbol not ])		ifTrue: [ self fromShapes: (canvas shapesFromModels: someObjectsOrABlock) ]		ifFalse: [ self fromShapes: (canvas nodes select: [ :el | someObjectsOrABlock rsValue: el model ]) ]! !!RSEdgeBuilder methodsFor: 'accessing'!fromShapes	fromShapes ifNil: [ ^ self canvasNodes ].	^ fromShapes! !!RSEdgeBuilder methodsFor: 'accessing'!fromShapes: someShapes	fromShapes := someShapes asGroup! !!RSEdgeBuilder methodsFor: 'initialization'!initialize	super initialize.	self noRepetition.	shouldMoveBehind := false.		"The view has to be explicitly set by the end-user"	canvasHasBeenManuallySet := false.	"We could have edges from A to B, and from B to A"	self beDirectional.! !!RSEdgeBuilder methodsFor: 'testing'!isBidirectional	"Return true or false, indicating whether the edge builder is bidirectional or not (i.e., if 	edges from A to B, __and__ B to A can be created"	^ beDirectional ! !!RSEdgeBuilder methodsFor: 'accessing'!moveBehind	"Set the builder as such that edge that are built and added in the view _behind_ the extremities of each edges"	shouldMoveBehind := true! !!RSEdgeBuilder methodsFor: 'private - utility'!moveBehindIfNecessary: someEdges	shouldMoveBehind ifFalse: [ ^ self ].	someEdges pushBack! !!RSEdgeBuilder methodsFor: 'public - configuration'!noBidirectional	"When edges are created, this does not allow for having edges going from A to B, and from B to A. Only A to B, __OR__, B to A is created"	beDirectional := false! !!RSEdgeBuilder methodsFor: 'public - configuration'!noRepetition	"	Avoid having more than one edge between two elements	b := RTMondrian new.	b nodes: (1 to: 3).	b shape line		color: Color red trans;		withVerticallAttachPoint.	b edges noRepetition; useAssociations: { 1 -> 2 . 2 -> 3 . 1 -> 2}.	b layout grid.	b build.	b view numberOfEdges	"	allowRepetition := false! !!RSEdgeBuilder methodsFor: 'accessing'!object: anObject	^ self objects: (Array with: anObject)! !!RSEdgeBuilder methodsFor: 'accessing'!objects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ canvasHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	self toObjects: someObjectsOrABlock.	self fromObjects: someObjectsOrABlock.! !!RSEdgeBuilder methodsFor: 'private - utility'!resetCreatedEdges	createdEdges := RSGroup new! !!RSEdgeBuilder methodsFor: 'public - shape'!shape	^ shape! !!RSEdgeBuilder methodsFor: 'public - shape'!shape: aTSShape	self assert: aTSShape isEdge.	shape := aTSShape! !!RSEdgeBuilder methodsFor: 'accessing'!shapes: someShapes	self toShapes: someShapes.	self fromShapes: someShapes! !!RSEdgeBuilder methodsFor: 'public repetition'!shouldAllowRepetition	^ allowRepetition! !!RSEdgeBuilder methodsFor: 'testing'!shouldCreateEdgeFrom: fromElement to: toElement	"Return true if an edge has to be created"	fromElement == toElement ifTrue: [ ^ false ].	(fromElement isNil or: [ toElement isNil ]) ifTrue: [ ^ false ].	beDirectional ifFalse: [ ^ (toElement isDirectlyConnectedTo: fromElement) not ].	allowRepetition ifFalse: [ ^ fromElement outgoingEdges noneSatisfy: [ :edge | edge to == toElement ] ].	^ true! !!RSEdgeBuilder methodsFor: 'public using source'!source: objects connectFrom: fromblock to: toBlock	"Define some edges from objects that are not part of the canvas"	"	nbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges) 				collect: [ :notUsed | nodes atRandom -> nodes atRandom ].b := RSCanvas new .b addAll: (nodes collect: [ :n|	RSEllipse new		model: n;		size: 5;		color: (Color black alpha: 0.5)]).RSEdgeBuilder line	color: (Color gray alpha: 0.3);	canvas: b;	source: edges connectFrom: #key to: #value.RSForceBasedLayout on: b nodes.b"	| assocs allObjects |	self assert: [ objects notNil ] description: 'Cannot provide a nil value as the source'.	self assert: [ objects isCollection ] description: 'Need to provide a collection as the source'.	allObjects := Set new.		assocs := objects collect: [ :o | 		| f t |		f := fromblock rsValue: o.		t := toBlock rsValue: o.		allObjects add: f; add: t.		f -> t ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSEdgeBuilder methodsFor: 'public using source'!source: objects connectFrom: fromblock toAll: toBlock	"Define some edges from objects that are not part of the view	nbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges) 				collect: [ :notUsed | nodes atRandom -> {nodes atRandom . nodes atRandom} ].b := RSCanvas new .b addAll: (nodes collect: [ :n|	RSEllipse new		model: n;		size: 5;		color: (Color black alpha: 0.5)]).RSEdgeBuilder line	color: (Color gray alpha: 0.3);	canvas: b;	source: edges connectFrom: #key toAll: #value.RSForceBasedLayout on: b nodes.b"	| assocs allObjects |	allObjects := Set new.	assocs := objects flatCollect: [ :o | 		| cc |		cc := toBlock rsValue: o.		cc collect: [ :ccc | 			| t |			t := fromblock rsValue: o.			allObjects add: t; add: ccc.			t -> ccc ] ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSEdgeBuilder methodsFor: 'public using source'!source: objects connectFromAll: fromBlock to: toBlock	"Define some edges from objects that are not part of the view	nbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges) 				collect: [ :notUsed | {nodes atRandom . nodes atRandom} -> nodes atRandom ].b := RSCanvas new .b addAll: (nodes collect: [ :n|	RSEllipse new		model: n;		size: 5;		color: (Color black alpha: 0.5)]).RSEdgeBuilder line	color: (Color gray alpha: 0.3);	canvas: b;	source: edges connectFromAll: #key to: #value.RSForceBasedLayout on: b nodes.b"	| assocs allObjects |	allObjects := Set new.	assocs := objects flatCollect: [ :o | 		| cc |		cc := fromBlock rsValue: o.		cc collect: [ :ccc | 			| t |			t := toBlock rsValue: o.			allObjects add: ccc; add: t.			ccc -> t ] ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSEdgeBuilder methodsFor: 'accessing'!toObject: anObject	^ self toObjects: (Array with: anObject)! !!RSEdgeBuilder methodsFor: 'accessing'!toObjects	"Return the list of objects considered as sources for the edges"	^ self toShapes collect: #model! !!RSEdgeBuilder methodsFor: 'accessing'!toObjects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ canvasHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	 	(someObjectsOrABlock isCollection and: [ someObjectsOrABlock isSymbol not ])		ifTrue: [ self toShapes: (canvas shapesFromModels: someObjectsOrABlock) ]		ifFalse: [ self toShapes: (canvas nodes select: [ :el | someObjectsOrABlock rsValue: el model ]) ]! !!RSEdgeBuilder methodsFor: 'accessing'!toShapes	toShapes ifNil: [ ^ self canvasNodes ].	^ toShapes! !!RSEdgeBuilder methodsFor: 'accessing'!toShapes: someShapes	toShapes := someShapes asGroup! !!RSEdgeBuilder methodsFor: 'public associations'!useAssociation: assoc	"assoc have to be between model objects"	| result |	self assert: [ assoc isKindOf: Association ] description: 'Please, provide an association instead'.		result := self useAssociations: (Array with: assoc).	result ifEmpty: [ ^ nil ].	^ result first! !!RSEdgeBuilder methodsFor: 'public associations'!useAssociations: associations	"Draw edges between shapes using associations. Each association has to follow the pattern: startmodel -> endmodel	For example-=-=-=-=-=-=-=-=-=b := RSCanvas  new.b addAll: ((1 to: 3) collect: [:i |	RSEllipse new		model: i;		size: 5]).RSEdgeBuilder line	color: Color red translucent;	canvas: b;	withVerticalAttachPoint;	noRepetition;	useAssociations: { 1 -> 2 . 2 -> 3 . 1 -> 2}.RSGridLayout on: b nodes.b @ RSCanvasController-=-=-=-=-=-=-=-=-="	| fromElement toElement |	createdEdges := RSGroup new.	associations do: [ :assoc |		fromElement := self fromShapes shapeFromModel: assoc key.		toElement := self toShapes shapeFromModel: assoc value.		(fromElement notNil and: [ toElement notNil ])			ifTrue: [ self createEdgeIfNecessaryFrom: fromElement to: toElement ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'public associations'!useElementAssociations: associationsBetweenElements	associationsBetweenElements do: [ :assoc |		self edgeFrom: assoc key to: assoc value ]! !!RSEdgeBuilder methodsFor: 'public - attach point'!withBorderAttachPoint	"Make the produced line use a border attach point. For example:-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	withBorderAttachPoint;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=	"	self attachPoint: RSBorderAttachPoint new.! !!RSEdgeBuilder methodsFor: 'public - attach point'!withHorizontalAttachPoint	"Make the produced line use a vertical attach point. For example:-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	withHorizontalAttachPoint;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=	"	self attachPoint: RSHorizontalAttachPoint new.! !!RSEdgeBuilder methodsFor: 'public - attach point'!withVerticalAttachPoint	"Make the produced line use a vertical attach point. For example:-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.from := RSBox new size: 30; model: 'from'.to := RSEllipse new size: 30; model: 'to'.c add: from.c add: to.RSEdgeBuilder line	canvas: c;	withVerticalAttachPoint;	connectFrom: 'from' to: 'to'.from @ RSDraggable.to @ RSDraggable.to translateTo: 50 @ 40.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=	"	self attachPoint: RSVerticalAttachPoint new.! !!RSMarker methodsFor: 'converting'!asMarker	^ self! !!RSMarker methodsFor: 'initialization'!initialize	super initialize.	offset := 0.	offsetRatio :=0.! !!RSMarker methodsFor: 'accessing'!offset	^ offset! !!RSMarker methodsFor: 'accessing'!offset: anObject	offset := anObject! !!RSMarker methodsFor: 'accessing'!offsetRatio	^ offsetRatio! !!RSMarker methodsFor: 'accessing'!offsetRatio: aFloat	"[0 1] value"	offsetRatio := aFloat! !!RSMarker methodsFor: 'accessing'!shape	^ shape! !!RSMarker methodsFor: 'accessing'!shape: anObject	shape := anObject! !!RSNormalizer class methodsFor: 'instance creation'!color 	| n |	n := self new.	n from: Color green.	n to: Color red.	n executeBlock: [ :shape :scaledValue | shape color: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation'!fontSize "Here is example-=-=-=-=-=-=-=v := RSView new.v @ RSControlsView.sb := RSShapeBuilder label.sb interactionDo: #draggable.sb text: #asString.elements := sb elementsOn: (Collection withAllSubclasses).elements do: [ :e | e translateTo: (Random new nextInt: 300) @ (Random new nextInt: 300) ].v addAll: elements.RSNormalizer fontSize	elements: elements;	to: 30;	normalize: #numberOfMethods.v zoomToFit.v open-=-=-=-=-=-=-="	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape fontSize: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation'!height 	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape height: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation'!position 	"Create a normalizer for position.	Here is an example:-=-=-=classes := Collection withAllSubclasses.v := RSView new.es := RSShapeBuilder circle			color: (Color gray alpha: 0.3);			elementsOn: classes.es @ RSPopup.v addAll: es.RSNormalizer size	elements: es;	from: 5;	to: 20;	normalize: [ :cls | cls instVarNames size ].	RSNormalizer position	to: 500 @ -500;	elements: es;	normalize: [ :cls | cls numberOfMethods @ cls linesOfCode ].v open		-=-=-=		and a more elaborated example:-=-=-=classes := Collection withAllSubclasses.v := RSView new.line := RSSingleEdgeBuilder polyline 	width: 2;	controlPoints: { 0@ -600. 0@0. 600@0 };	markerStartEnd: (RSShapeBuilder triangle		size: 20;		color: Color black;		element);	edge.es := RSShapeBuilder circle	interactionDo: [ :i | i popup; browseable ];	border: TSBorder new;	color: TSColorPalette sequential orrd9;	elementsOn: classes.v addAll: es.v add: line.RSNormalizer size	from: 5;	to: 20;	elements: es;	normalize: [ :cls | cls instVarNames size ].	RSNormalizer position	from: 0@0;	to: 600@ -600;	elements: es;	normalize: [ :cls | cls numberOfMethods @ cls linesOfCode ].v @ RSControlsView.v -=-=-=	"	| n |	n := self new.	n from: 0 @ 0.	n to: 100 @ 100.	n executeBlock: [ :shape :scaledValue | shape translateTo: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation'!size 	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape size: scaledValue ].	^ n! !!RSNormalizer class methodsFor: 'instance creation'!width 	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :shape :scaledValue | shape width: scaledValue ].	^ n! !!RSNormalizer methodsFor: 'private - accessing'!executeBlock: anOneArgBlock	"Set the block to be executed for the normalizer. The end user should not call this method	Instead, it is called from methods on the class side"	executeBlock := anOneArgBlock! !!RSNormalizer methodsFor: 'accessing'!from: aValue	"Set the lower limit of the normalized value. For example:```Smalltalkv := RSCanvas new.classes := Collection withAllSubclasses.es := classes collect: [ :cls | RSEllipse new model: cls ] as: RSGroup.v addAll: es.es @ RSPopup @ RSDraggable.RSNormalizer size	shapes: es;	from: 5;	to: 20;	normalize: #numberOfMethods.	RSNormalizer color	shapes: es;	to: Color pink;	normalize: #numberOfMethods.RSGridLayout on: es.v @ RSCanvasController.v  ```"	scale from: aValue! !!RSNormalizer methodsFor: 'initialization'!initialize	super initialize.	scale := NSScale linear.	shapes := #().	minAndMaxBlock := #yourself! !!RSNormalizer methodsFor: 'private - accessing'!key	^ #normalizerValue! !!RSNormalizer methodsFor: 'accessing'!minAndMaxBlock: aOneArgBlock	"This method sets the min and the max values for the provided shapes. It is useful to override the value found in the shapes. The argument is evaluated with one argument of a tupple of size 2"	minAndMaxBlock := aOneArgBlock! !!RSNormalizer methodsFor: 'private - accessing'!minAndMaxFor: anOneArgBlockOrSymbol	| min max |	min := SmallInteger maxVal.	max := SmallInteger minVal.	shapes do: [ :shape | | res |		res := anOneArgBlockOrSymbol rsValue: shape model.		shape propertyAt: self key put: res.		min := min min: res.		max := max max: res ].	^ minAndMaxBlock rsValue: { min . max }! !!RSNormalizer methodsFor: 'normalizer'!normalize: anOneArgBlockOrSymbol	"Trigger the normalization using a particular metric to normalize.	The metric is computed on each model of the shapes that are considered.	"	| minAndMax |	minAndMax := self minAndMaxFor: anOneArgBlockOrSymbol.	scale domain: minAndMax.	shapes do: [ :shape |		| scaledValue objectValue |		objectValue := shape propertyAt: self key.		scaledValue := scale scale: objectValue.		executeBlock value: shape value: scaledValue ]! !!RSNormalizer methodsFor: 'accessing'!scale	^ scale! !!RSNormalizer methodsFor: 'accessing'!scale: aNSScale	"Set the scale of the normalizer. For example	```Smalltalkc := RSCanvas new.shapes := (1 to: 150) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.c addAll: shapes.RSGridLayout on: shapes.RSNormalizer color	shapes: shapes;	scale: NSScale category20b;	normalize: #yourself.c @ RSCanvasController.c```"	scale := aNSScale.	! !!RSNormalizer methodsFor: 'accessing'!shapes	"Return the shapes that should be normalized"	^ shapes! !!RSNormalizer methodsFor: 'accessing'!shapes: someShapes	"Set to the normalizer the elements that should be normalized"	someShapes ifNil: [ self error: 'Should not provide nil' ].	shapes := someShapes! !!RSNormalizer methodsFor: 'accessing'!to: aValue	"Set the upper limit of the normalized value. For example:```Smalltalkv := RSCanvas new.classes := Collection withAllSubclasses.es := classes collect: [ :cls | RSEllipse new model: cls ] as: RSGroup.v addAll: es.es @ RSPopup @ RSDraggable.RSNormalizer size	shapes: es;	to: 20;	normalize: #numberOfMethods.	RSNormalizer color	shapes: es;	to: Color pink;	normalize: #numberOfMethods.RSGridLayout on: es.v @ RSCanvasController.v  ```"	scale to: aValue! !!RSShapeFactory class methodsFor: 'shapes'!arc	^ RSPieSlice new! !!RSShapeFactory class methodsFor: 'shapes'!arrow	"inverted vee"	^ self polygonWithPoints: (Array		with: 1 @ 1		with: 0 @ 0.333		with: -1 @ 1		with: 0 @ -1)! !!RSShapeFactory class methodsFor: 'lines'!arrowedLine	^ RSArrowedLine new! !!RSShapeFactory class methodsFor: 'lines'!arrowedLineWithOffset: aFloat	"[0 1] value"	| inst |	inst := self arrowedLine.	inst shape markerEnd offsetRatio: aFloat.	^ inst! !!RSShapeFactory class methodsFor: 'shapes'!bitmap	^ RSBitmap new! !!RSShapeFactory class methodsFor: 'shapes'!box	^ self rectangle! !!RSShapeFactory class methodsFor: 'shapes'!circle	^ self ellipse! !!RSShapeFactory class methodsFor: 'shapes'!composite 	^ RSComposite new! !!RSShapeFactory class methodsFor: 'shapes'!diamond	^ self polygonWithPoints: (Array		with: 0 @ 1		with: 1 @ 0		with: 0 @ -1		with: -1 @ 0)! !!RSShapeFactory class methodsFor: 'shapes'!ellipse	^ RSEllipse new! !!RSShapeFactory class methodsFor: 'shapes'!heptagon	^ self polygonWithPoints: (RSPolygon generatePointsFitSquare: 7)! !!RSShapeFactory class methodsFor: 'shapes'!hexagon	^ self polygonWithPoints: (RSPolygon generatePointsFitSquare: 6)! !!RSShapeFactory class methodsFor: 'shapes'!label	^ RSLabel new! !!RSShapeFactory class methodsFor: 'shapes'!octagon	^ self polygonWithPoints: (RSPolygon generatePointsFitSquare: 8)! !!RSShapeFactory class methodsFor: 'shapes'!pentagon	^ self polygonWithPoints: (RSPolygon generatePointsFitSquare: 5)! !!RSShapeFactory class methodsFor: 'shapes'!plus	| t t1 |	t := 2 / 6 asFloat.	t1 := t negated.	^ self polygonWithPoints:		{(-1 @ t1).		(t1 @ t1).		(t1 @ -1).		(t @ -1).		(t @ t1).		(1 @ t1).		(1 @ t).		(t @ t).		(t @ 1).		(t1@ 1).		(t1@ t).		(-1@ t)}! !!RSShapeFactory class methodsFor: 'shapes'!polygon	^ RSPolygon new! !!RSShapeFactory class methodsFor: 'utils'!polygonWithPoints: points	^ self polygon		privatePoints: points;		yourself! !!RSShapeFactory class methodsFor: 'shapes'!rectangle	^ RSBox new! !!RSShapeFactory class methodsFor: 'shapes'!rhomboid	^ self polygonWithPoints: (Array		with: -1 @ -1		with: 0.333 @ -1		with: 1 @ 1		with: -0.333 @ 1)! !!RSShapeFactory class methodsFor: 'utils'!shapeFromString: aString	"self shapeFromString: 'd'"	#(o circle	^ arrow	s square	p pentagon	h hexagon	+ plus	d diamond	* star ) pairsDo: [ :k :sel |		(aString includesSubstring: k)			ifTrue: [ ^ sel value: self ] ].	^ nil	! !!RSShapeFactory class methodsFor: 'shapes'!square	^ self polygonWithPoints: (RSPolygon generatePointsFitSquare: 4)! !!RSShapeFactory class methodsFor: 'shapes'!star	| star5Points outerPoints innerPoints innerRadius ar |	star5Points := Array new: 10.	outerPoints := RSPolygon generateUnitNgonPoints: 5 rotation: 0.	innerPoints := RSPolygon generateUnitNgonPoints: 5 rotation: Float pi / -5.	"Outer radius is 1; inner radius of star is smaller"	innerRadius := 0.5.	innerPoints		doWithIndex: [ :p :i | innerPoints at: i put: (p x * innerRadius) @ (p y * innerRadius) ].	star5Points		doWithIndex: [ :p :i | 			ar := i even				ifTrue: [ outerPoints ]				ifFalse: [ innerPoints ].			star5Points at: i put: (ar at: i // 2 + (i % 2)) ].	star5Points := RSPolygon fitPolygonToSquare: star5Points.	^ self polygonWithPoints: star5Points! !!RSShapeFactory class methodsFor: 'shapes'!triangle	^ self polygonWithPoints: (RSPolygon generatePointsFitSquare: 3)! !!RSShapeFactory class methodsFor: 'shapes'!vee	^ self polygonWithPoints: (Array		with: -1 @ -1		with: 0 @ -0.333		with: 1 @ -1		with: 0 @ 1)! !!RSStrokeStyle class methodsFor: 'instance creation'!fromString: aString 	| inst |	inst := self new.	(aString includesSubstring: '--')		ifTrue: [ ^ inst dashArray: #(4 2) ].	(aString includesSubstring: '-.')		ifTrue: [ ^ inst dashArray: #(4 1 1 1) ].	(aString includesSubstring: '.')		ifTrue: [ ^ inst dashArray: #(1) ].	^ nil! !!RSStrokeStyle methodsFor: 'accessing'!capStyle	^ capStyle! !!RSStrokeStyle methodsFor: 'accessing'!capStyle: symbol	capStyle := symbol! !!RSStrokeStyle methodsFor: 'accessing'!dashArray	^ dashArray! !!RSStrokeStyle methodsFor: 'accessing'!dashArray: array	self assert: array isArray description: 'enter an array of numbers'.	dashArray := array! !!RSStrokeStyle methodsFor: 'accessing'!dashOffset	^ dashOffset! !!RSStrokeStyle methodsFor: 'accessing'!dashOffset: aNumber	dashOffset := aNumber! !!RSStrokeStyle methodsFor: 'initialization'!initialize	super initialize.	dashOffset := 0! !!RSStrokeStyle methodsFor: 'accessing'!joinStyle	^ joinStyle! !!RSStrokeStyle methodsFor: 'accessing'!joinStyle: symbol	joinStyle := symbol! !!RSTextExtents methodsFor: 'public'!from: ref 	"ref is a CairoTextExtents"	self 		width: ref width;		height: ref height;		x_advance: ref x_advance;		y_advance: ref y_advance;		x_bearing: ref x_bearing;		y_bearing: ref y_bearing.! !!RSTextExtents methodsFor: 'accessing'!height	^ height! !!RSTextExtents methodsFor: 'accessing'!height: aNumber	height := aNumber! !!RSTextExtents methodsFor: 'printing'!printOn: s	s << self className; << '('.	#(x_bearing y_bearing width height x_advance y_advance) do: [ :sel |		s << sel; << ':'; << String tab.		(sel value: self) printOn: s.		 ] separatedBy: [ s << String crlf ].	s << ')'.! !!RSTextExtents methodsFor: 'accessing'!width	^ width! !!RSTextExtents methodsFor: 'accessing'!width: aNumber	width := aNumber! !!RSTextExtents methodsFor: 'accessing'!x_advance	^ x_advance! !!RSTextExtents methodsFor: 'accessing'!x_advance: aNumber	x_advance := aNumber! !!RSTextExtents methodsFor: 'accessing'!x_bearing	^ x_bearing! !!RSTextExtents methodsFor: 'accessing'!x_bearing: aNumber	x_bearing := aNumber! !!RSTextExtents methodsFor: 'accessing'!y_advance	^ y_advance! !!RSTextExtents methodsFor: 'accessing'!y_advance: aNumber	y_advance := aNumber! !!RSTextExtents methodsFor: 'accessing'!y_bearing	^ y_bearing! !!RSTextExtents methodsFor: 'accessing'!y_bearing: aNumber	y_bearing := aNumber! !!RSCanvas methodsFor: '*Roassal3-Shapes'!asShape	| g |	g := self shapes copy.	g do: #remove.	^ RSComposite new		shapes: g;		yourself.	! !!GPolygon methodsFor: '*Roassal3-Shapes'!rsScaleWith: anAthensAffineTransform	^ self class vertices: (self vertices collect: [ :p | anAthensAffineTransform transform: p ])! !!GPoint methodsFor: '*Roassal3-Shapes'!asPoint	^ self x @ self y! !!GPoint methodsFor: '*Roassal3-Shapes'!center	^ self! !!GPoint methodsFor: '*Roassal3-Shapes'!rsScaleWith: anAthensAffineTransform	^ (anAthensAffineTransform transform: self) asGPoint! !!GradientPaint class methodsFor: '*Roassal3-Shapes'!fromArray: array	^ self new 		colorRamp: (array collect: [ :as | as key -> (Color colorFrom: as value)]);		yourself! !!BlockClosure methodsFor: '*Roassal3-Shapes'!shapeFor: model	^ self cull: model! !!RSAbstractControlPointsLine class methodsFor: 'testing'!isAbstract	^ self =  RSAbstractControlPointsLine! !!RSAbstractControlPointsLine methodsFor: 'actions'!basicTranslateBy: delta	controlPoints := controlPoints collect: [:p | p + delta ].! !!RSAbstractControlPointsLine methodsFor: 'accessing'!controlPoints	^ controlPoints ifNil: [ controlPoints := { 0@0. 0@0 } ].! !!RSAbstractControlPointsLine methodsFor: 'accessing'!controlPoints: anArrayOfPoints	controlPoints := anArrayOfPoints collect: #asFloatPoint.	self resetPath.! !!RSAbstractControlPointsLine methodsFor: 'accessing'!controlPointsController	^ controlPointsController! !!RSAbstractControlPointsLine methodsFor: 'accessing'!controlPointsController: aCPController	controlPointsController := aCPController! !!RSAbstractControlPointsLine methodsFor: 'accessing'!endPoint	^ self controlPoints last! !!RSAbstractControlPointsLine methodsFor: 'accessing'!endPoint: aPoint	self controlPoints 		at: self controlPoints size		put: aPoint.	self resetPath.! !!RSAbstractControlPointsLine methodsFor: 'testing'!isControlPointsLine	^ true! !!RSAbstractControlPointsLine methodsFor: 'accessing - markers'!markers	^ markers ifNil: [ markers := Array new: 3 ].! !!RSAbstractControlPointsLine methodsFor: 'accessing - markers'!privateMarkers	^ markers! !!RSAbstractControlPointsLine methodsFor: 'accessing'!startPoint	^ self controlPoints first! !!RSAbstractControlPointsLine methodsFor: 'accessing'!startPoint: aPoint	self controlPoints at: 1 put: aPoint.	self resetPath.! !!RSAbstractControlPointsLine methodsFor: 'update'!update	controlPointsController ifNil: [ ^ self ].	self		controlPoints: (controlPointsController controlPointsFor: self);		notifyExtentChanged.! !!RSBezier methodsFor: 'visiting'!buildPathOn: visitor	visitor buildBezierPath: self.! !!RSBezier methodsFor: 'accessing'!controlPoints: anArrayOfPoints	self		assert: anArrayOfPoints notNil 		description: 'The argument can not be nil';		assert: (anArrayOfPoints size between: 2 and: 4)		description: 'The array size must be between 2 and 4 points'.	super controlPoints: anArrayOfPoints! !!RSBezier methodsFor: 'initialization'!initialize	super initialize.	controlPoints := { 0@0. 100@100 }.! !!RSPolyline methodsFor: 'visiting'!buildPathOn: visitor	visitor buildPolylinePath: self! !!RSPolyline methodsFor: 'accessing'!cornerRadii	^ radius ifNil: [ 0 ].! !!RSPolyline methodsFor: 'accessing'!cornerRadii: aNumber	radius := aNumber abs.	self resetPath.! !!RSPolyline methodsFor: 'testing'!includesPoint: aPoint	"Answer whether any segment of this polyline includes aPoint."	self hasBorder ifFalse: [ ^ false ].	self controlPoints overlappingPairsDo: [ :a :b | 		(aPoint onLineFrom: a to: b within: self includedRadius)			ifTrue: [ ^ true ] ].	^ false! !!RSAbstractDualLine class methodsFor: 'testing'!isAbstract	^ self = RSAbstractDualLine! !!RSAbstractDualLine methodsFor: 'transforming'!basicTranslateBy: delta	self translateBy: delta! !!RSAbstractDualLine methodsFor: 'accessing'!controlPoints 	^ Array with: self startPoint with: self endPoint! !!RSAbstractDualLine methodsFor: 'accessing'!endPoint	^ endPoint! !!RSAbstractDualLine methodsFor: 'accessing'!endPoint: point	endPoint := point.	self resetPath.	self notifyExtentChanged.! !!RSAbstractDualLine methodsFor: 'initialization'!initialize	super initialize.	startPoint := 0@0.	endPoint := 100@100.! !!RSAbstractDualLine methodsFor: 'accessing - markers'!markers	^ markers ifNil: [ markers := Array new: 3 ].! !!RSAbstractDualLine methodsFor: 'transforming'!position	^ self encompassingRectangle floatCenter! !!RSAbstractDualLine methodsFor: 'private'!privateMarkers	^ markers! !!RSAbstractDualLine methodsFor: 'accessing'!startPoint 	^ startPoint! !!RSAbstractDualLine methodsFor: 'accessing'!startPoint: point	startPoint := point.	self resetPath! !!RSAbstractDualLine methodsFor: 'transforming'!translateBy: delta	self		startPoint: startPoint + delta;		endPoint: endPoint + delta.	self resetPath! !!RSAbstractDualLine methodsFor: 'transforming'!translateTo: delta	| center |	center := (startPoint + endPoint ) /2.	self translateBy: delta - center! !!RSAbstractDualLine methodsFor: 'update'!update	"Note that before calling this method, an attach point has to be set. Consider the following example:-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	b1 := RSBox new size: 20.b2 := RSBox new size: 20.b1 translateTo: 20 @ 30.b2 translateTo: 40 @ 50.l := RSLine new from: b1; to: b2.l attachPoint: RSBorderAttachPoint new .l update.-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=Removing the call to #attachPoint: raised an error	"	(attachPoint isNil | from isNil | to isNil) ifTrue: [ ^ self ].	self		startPoint: (attachPoint startingPointOf: self);		endPoint: (attachPoint endingPointOf: self);		notifyExtentChanged.! !!RSArrowedLine methodsFor: 'border'!border: aRSBorder	super border: aRSBorder.	self markersDo: [ :m | m shape border: aRSBorder ].! !!RSArrowedLine methodsFor: 'initialization'!copy	| copy head |	copy := super copy.	head := copy markerEnd shape.	copy markerEnd: self markerEnd copy.	copy markerEnd shape: head.	^ copy! !!RSArrowedLine methodsFor: 'initialization'!defaultHead	^ RSPolygon new		privatePoints: { -5@5. 0@0. 5@5. 0@0 };		border: self border;		yourself! !!RSArrowedLine methodsFor: 'initialization'!initialize	super initialize.	self markerEnd: self defaultHead.! !!RSArrowedLine methodsFor: 'initialization'!postCopy	super postCopy.	markers := nil.	self markerEnd: self defaultHead.	self border: self border copy.! !!RSLine methodsFor: 'visiting'!buildPathOn: visitor	visitor buildLinePath: self! !!RSLine methodsFor: 'testing'!includesPoint: aPoint	self hasBorder ifFalse: [ ^ false ].	 	^ aPoint		onLineFrom: self startPoint 		to: self endPoint 		within: self includedRadius! !!RSAbstractLine class methodsFor: 'testing'!isAbstract	^ self =  RSAbstractLine! !!RSAbstractLine methodsFor: 'visiting'!accept: visitor	visitor visitLine: self.! !!RSAbstractLine methodsFor: 'attach point'!attachPoint	^ attachPoint! !!RSAbstractLine methodsFor: 'attach point'!attachPoint: ap	attachPoint := ap! !!RSAbstractLine methodsFor: 'style-cap'!capButt	self border capButt! !!RSAbstractLine methodsFor: 'style-cap'!capRound	self border capRound! !!RSAbstractLine methodsFor: 'style-cap'!capSquare	self border capSquare! !!RSAbstractLine methodsFor: 'accessing'!color	^ self strokePaint! !!RSAbstractLine methodsFor: 'accessing'!color: aColor	self strokePaint: aColor! !!RSAbstractLine methodsFor: 'accessing'!computeEncompassingRectangle	| cp |	cp := self controlPoints.	^ cp 			ifEmpty: [ 0@0 corner: 0@0 ]			ifNotEmpty: [ Rectangle encompassing: cp ]! !!RSAbstractLine methodsFor: 'accessing'!controlPoints	^ self subclassResponsibility! !!RSAbstractLine methodsFor: 'style-dashes'!dashArray: arrayOfNumbers	self border dashArray: arrayOfNumbers	! !!RSAbstractLine methodsFor: 'style-dashes'!dashed	self dashArray: #(4).! !!RSAbstractLine methodsFor: 'accessing'!endPoint	^ self subclassResponsibility! !!RSAbstractLine methodsFor: 'accessing'!endPoint: aPoint	self subclassResponsibility! !!RSAbstractLine methodsFor: 'accessing'!from	^ from! !!RSAbstractLine methodsFor: 'accessing'!from: aShapeOrAPoint	"Set the end point of the line"	from := self setAnchor: from shape: aShapeOrAPoint! !!RSAbstractLine methodsFor: 'testing'!hasMarkers	| m |	m := self privateMarkers.	^ m notNil and: [ 		m anySatisfy: [ :mar | mar notNil ].  ]! !!RSAbstractLine methodsFor: 'accessing'!includedRadius	^ self border width / 2! !!RSAbstractLine methodsFor: 'initialization'!initialize 	super initialize.	self		withBorder;		noPaint;		withCenteredAttachPoint.	! !!RSAbstractLine methodsFor: 'testing'!isControlPointsLine	^ false! !!RSAbstractLine methodsFor: 'testing'!isEdge	^ true! !!RSAbstractLine methodsFor: 'style-join'!joinBevel	self border joinBevel! !!RSAbstractLine methodsFor: 'style-join'!joinMiter	self border joinMiter! !!RSAbstractLine methodsFor: 'style-join'!joinRound	self border joinRound! !!RSAbstractLine methodsFor: 'actions'!loadShape: other	self shouldBeImplemented ! !!RSAbstractLine methodsFor: 'event handling'!notifyExtentChanged	self announce: [ RSExtentChangedEvent new 		shape: self;		oldExtent: nil;		newExtent: self controlPoints first - self controlPoints last ]! !!RSAbstractLine methodsFor: 'private'!privateMarkers	^ nil! !!RSAbstractLine methodsFor: 'adding'!remove	parent ifNil: [ ^ self ].	parent removeEdge: self.	self 		removeFromParent: to;		removeFromParent: from.	super remove! !!RSAbstractLine methodsFor: 'private'!removeFromParent: aShape	aShape ifNil: [ ^ self ].	aShape isPoint ifTrue: [ ^ self ].	aShape connectedEdges remove: self ifAbsent: [  ].! !!RSAbstractLine methodsFor: 'adding'!renderOn: aCanvas	aCanvas addEdge: self.	self update.! !!RSAbstractLine methodsFor: 'path'!resetPath	super resetPath.	self resetBBox! !!RSAbstractLine methodsFor: 'path'!sessionChanged	"This method releases all the native graphical resources. This method is typically invoked when starting a Pharo image with a visualization that was previously open"	self resetPath.	self hasMarkers ifFalse: [ ^ self ].	self markersDo: [ :mark | mark shape sessionChanged ].	! !!RSAbstractLine methodsFor: 'private'!setAnchor: ref shape: anObject	ref isNotNil ifTrue: [ ref removeConnectedEdge: self ].	anObject isPoint ifFalse: [ anObject addConnectedEdge: self ].	^ anObject! !!RSAbstractLine methodsFor: 'accessing'!startPoint	^ self subclassResponsibility! !!RSAbstractLine methodsFor: 'accessing'!startPoint: aPoint	self subclassResponsibility! !!RSAbstractLine methodsFor: 'accessing'!strokeColor: aColor	self strokePaint: aColor! !!RSAbstractLine methodsFor: 'accessing'!strokePaint	^ self border paint! !!RSAbstractLine methodsFor: 'accessing'!strokePaint: aPaint	self border paint: aPaint.	self markersDo: [:m | m shape paint: aPaint ].! !!RSAbstractLine methodsFor: 'accessing'!to 		^ to! !!RSAbstractLine methodsFor: 'accessing'!to: aShapeOrAPoint	"Set the end point of the line"	to := self setAnchor: to shape: aShapeOrAPoint! !!RSAbstractLine methodsFor: 'update'!update	self subclassResponsibility! !!RSAbstractLine methodsFor: 'accessing'!width: aNumber	self border width: aNumber.! !!RSAbstractLine methodsFor: 'attach point'!withBorderAttachPoint	self attachPoint: RSBorderAttachPoint new.! !!RSAbstractLine methodsFor: 'attach point'!withCenteredAttachPoint	self attachPoint: RSCenteredAttachPoint new.! !!RSAbstractLine methodsFor: 'attach point'!withHorizontalAttachPoint	self attachPoint: RSHorizontalAttachPoint new.! !!RSAbstractLine methodsFor: 'attach point'!withVerticalAttachPoint	self attachPoint: RSVerticalAttachPoint new.! !!RSBitmap methodsFor: 'private'!computeRectangle	baseRectangle := Rectangle floatCenter: 0@0 extent: (form 		ifNil: [ 0@0 ]		ifNotNil: [ form extent ])! !!RSBitmap methodsFor: 'accessing'!extent: newExtent	| oldExtent |	oldExtent := self extent.	(oldExtent = (0 @ 0)) ifTrue: [ ^ self ].	matrix scaleBy: newExtent / oldExtent.! !!RSBitmap methodsFor: 'accessing'!form	^ form! !!RSBitmap methodsFor: 'accessing'!form: aForm	aForm ifNil: [ ^ self ].	form := aForm.	self computeRectangle.! !!RSBitmap methodsFor: 'accessing'!paintOn: visitor	^ visitor paintFor: self form: self form! !!RSBitmap methodsFor: 'visiting'!path	^ self baseRectangle! !!RSBoundingShape class methodsFor: 'testing'!isAbstract	^ self == RSBoundingShape! !!RSBoundingShape methodsFor: 'visiting'!accept: visitor	visitor visitBoundingShape: self! !!RSBoundingShape methodsFor: 'edges'!addConnectedEdge: anEdge	self assert: anEdge isEdge.	(self connectedEdges includes: anEdge) 		ifFalse: [ self connectedEdges add: anEdge ]! !!RSBoundingShape methodsFor: 'accessing'!baseRectangle	^ baseRectangle! !!RSBoundingShape methodsFor: 'matrix'!basicTranslateBy: delta	self updateEdgesOFF.	self position: self position + delta.	self updateEdgesON.! !!RSBoundingShape methodsFor: 'accessing'!computeEncompassingRectangle	^ self computeEncompassingRectangleFor: self baseRectangle.	! !!RSBoundingShape methodsFor: 'accessing'!computeEncompassingRectangleFor: rect 	^ self computeEncompassingRectangleFor: rect matrix: self matrix! !!RSBoundingShape methodsFor: 'accessing'!computeEncompassingRectangleFor: rect matrix: aMatrix	| points |	points := #(topLeft topRight bottomRight bottomLeft)		collect: [ :s | aMatrix transform: (s value: rect) ].	^ Rectangle encompassing: points.	! !!RSBoundingShape methodsFor: 'edges'!connectedEdges	"Return the list of connected egdes (i.e., incoming and outgoing edges)"	connectedEdges ifNil: [ connectedEdges := RSGroup new ].	^ connectedEdges! !!RSBoundingShape methodsFor: 'accessing'!extent: aPoint	| oldExtent extent |	extent := baseRectangle extent.	extent = aPoint ifTrue: [ ^ self ].	self assert: aPoint isPoint.	oldExtent := extent.	baseRectangle := Rectangle floatCenter: 0@0 extent: aPoint.	self resetBBox; resetPath.	self announce: [ RSExtentChangedEvent new 		shape: self;		oldExtent: oldExtent;		newExtent: extent ]! !!RSBoundingShape methodsFor: 'initialization'!fromRectangle: aRectangle	"Set the position and extent of the shape, using a rectangle as argument.	For example:	-=-=-=-=-=-=-=-=-=	c := RSCanvas new.box := RSBox new.box fromRectangle: (10 @ 10 corner: 50 @ 40).c add: box.c-=-=-=-=-=-=-=-=-="	self 		translateTo: aRectangle floatCenter;		extent: aRectangle extent! !!RSBoundingShape methodsFor: 'geometry'!geometry	| rect e |	rect := self encompassingRectangle.	e := rect extent.	e = (0@0) ifTrue: [ ^ rect floatCenter asGPoint ].	^ GRectangle		origin: rect origin 		corner: rect corner! !!RSBoundingShape methodsFor: 'matrix'!globalMatrix	^ parent globalMatrix multiplyBy: matrix.! !!RSBoundingShape methodsFor: 'testing'!hasEdges	^ connectedEdges notNil! !!RSBoundingShape methodsFor: 'accessing'!height: aNumber	self extent: self extent x @ aNumber! !!RSBoundingShape methodsFor: 'testing'!includesPoint: aPoint	| invertedPoint |	invertedPoint := matrix inverseTransform: aPoint.	^ self baseRectangle containsPoint: invertedPoint.! !!RSBoundingShape methodsFor: 'edges'!incomingEdges	"Return the list of incoming edges from the node"	connectedEdges ifNil: [ ^ #() ].	^ self connectedEdges select: [ :e | e to == self ]! !!RSBoundingShape methodsFor: 'initialization'!initialize	super initialize.	self initializeMatrix; updateEdgesON.	baseRectangle := 0@0 corner: 0@0.! !!RSBoundingShape methodsFor: 'initialization'!initializeMatrix	matrix := AthensAffineTransform new! !!RSBoundingShape methodsFor: 'edges'!isDirectlyConnectedTo: aShape	connectedEdges ifNil: [ ^ false ].	^ connectedEdges anySatisfy: [ :edge | edge to == aShape ]! !!RSBoundingShape methodsFor: 'testing'!isNode	^ true! !!RSBoundingShape methodsFor: 'actions'!loadBoundingShape: aShape	self 		extent: aShape extent;		matrix: aShape matrix;		border: aShape border;		paint: aShape paint;		announcer: aShape announcer;		parent: aShape parent.! !!RSBoundingShape methodsFor: 'actions'!loadShape: aShape	self loadBoundingShape: aShape.! !!RSBoundingShape methodsFor: 'matrix'!matrix	^ matrix! !!RSBoundingShape methodsFor: 'matrix'!matrix: aMatrix	matrix := aMatrix! !!RSBoundingShape methodsFor: 'matrix'!matrixDo: aBlock	aBlock value: matrix.	self resetBBox.! !!RSBoundingShape methodsFor: 'edges'!outgoingEdges	"Return the list of outgoing edges from the node"	connectedEdges ifNil: [ ^ #() ].	^ self connectedEdges select: [ :e | e from == self ]! !!RSBoundingShape methodsFor: 'matrix'!position 	^ matrix translation! !!RSBoundingShape methodsFor: 'matrix'!position: aPoint	self 		assert: (aPoint x isNaN | aPoint y isNaN) not		description: 'you must provide a real point'.	matrix translation: aPoint.	self resetBBox.	self updateConnectedEdges.! !!RSBoundingShape methodsFor: 'accessing'!positionInCanvas	^ self globalMatrix transform: 0@0.! !!RSBoundingShape methodsFor: 'copying'!postCopy	super postCopy.	self matrix: self matrix copy! !!RSBoundingShape methodsFor: 'actions'!remove	parent ifNil: [ ^ self ].	parent removeNode: self.	self removeConnectedEdges.	super remove! !!RSBoundingShape methodsFor: 'edges'!removeConnectedEdge: anEdge	[  anEdge isEdge ] assert.	self connectedEdges remove: anEdge ifAbsent: [ ]! !!RSBoundingShape methodsFor: 'edges'!removeConnectedEdges	"Remove all the edges connected (incoming and outgoing)."	self connectedEdges copy do: [ :edge | edge remove ]! !!RSBoundingShape methodsFor: 'adding'!renderOn: aCanvas	aCanvas addNode: self! !!RSBoundingShape methodsFor: 'matrix'!rotateByDegrees: angle	"Rotate the shape. Here is an exanmple:-=-=-=c := RSCanvas new.polygon := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: 'FFAE0B'.polygon cornerRadii: 5.polygon rotateByDegrees: -45.		c add: polygon.c	-=-=-=	"	matrix rotateByDegrees: angle! !!RSBoundingShape methodsFor: 'matrix'!scale	^ matrix scale! !!RSBoundingShape methodsFor: 'matrix'!scaleBy: scale 	"Scale the shape. For example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.polygon := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: 'FFAE0B'.polygon cornerRadii: 5.polygon rotateByDegrees: -45.		polygon scaleBy: 4.c add: polygon.c-=-=-=-=-=-=-=-=-=	"	matrix scaleBy: scale! !!RSBoundingShape methodsFor: 'testing'!shouldUpdateEdges	^ shouldUpdateEdges and: [ connectedEdges notNil ]! !!RSBoundingShape methodsFor: 'accessing'!size: anInteger	self extent: anInteger asPoint! !!RSBoundingShape methodsFor: 'matrix'!transform: aPoint	"useful for attachpoints"	^ matrix transform: aPoint! !!RSBoundingShape methodsFor: 'actions' prior: 33888998!translateTo: aPoint	| oldPosition |	oldPosition := self position.	oldPosition = aPoint ifTrue: [ ^ self ].	self position: aPoint.	self announce: [RSPositionChangedEvent new 		shape: self; 		oldPosition: oldPosition;		newPosition: aPoint ].! !!RSBoundingShape methodsFor: 'edges'!updateConnectedEdges	self shouldUpdateEdges		ifFalse: [ ^ self ].	self connectedEdges do: [ :edge | edge update ].! !!RSBoundingShape methodsFor: 'edges'!updateEdgesOFF	shouldUpdateEdges := false! !!RSBoundingShape methodsFor: 'edges'!updateEdgesON	shouldUpdateEdges := true! !!RSBoundingShape methodsFor: 'accessing'!width: aNumber	self extent: aNumber @ self extent y! !!RSBoundingShape methodsFor: 'matrix'!x: aNumber	"recibes a number"	self position: aNumber @ self position y! !!RSBoundingShape methodsFor: 'matrix'!y: aNumber	"recibes a number"	self position: self position x @ aNumber! !!RSBox methodsFor: 'visiting'!buildPathOn: visitor	visitor buildBoxPath: self! !!RSBox methodsFor: 'accessing'!cornerRadius	^ cornerRadius! !!RSBox methodsFor: 'accessing'!cornerRadius: aRSCornerRadius	"Set the radius of the corners. Accept a number as argument or a RSCornerRadius.	For example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.box := RSBox new extent: 120 @ 180; color: Color gray; cornerRadius: 10.c add: box.c-=-=-=-=-=-=-=-=-="	cornerRadius := aRSCornerRadius isNumber 		ifTrue: [ RSCornerRadius new radius: aRSCornerRadius ]		ifFalse: [ aRSCornerRadius ].	self resetPath.! !!RSBox methodsFor: 'testing'!hasCornerRadius	^ cornerRadius notNil		and: [ cornerRadius max > 0 and: [ cornerRadius min >= 0 ] ]! !!RSComposite methodsFor: 'adding'!addBasicShape: aShape	self shapes add: aShape! !!RSComposite methodsFor: 'adding'!addFixedShape: aShape	self error: 'Composite can not add a fixed shape'! !!RSComposite methodsFor: 'adding'!addShape: aShape	"Add a shape in a composite shape"	aShape addedIn: self! !!RSComposite methodsFor: 'adding'!addShape: aShape before: otherShape 	"Add a shape in a composite shape"	aShape addedIn: self.	self children		remove: aShape;		add: aShape before: otherShape! !!RSComposite methodsFor: 'public'!adjustToChildren"Recompute the encompassing rectangle of the composite shape from the positio of the children. Consider the following example:```Smalltalkbox := RSBox new size: 20.circle := RSEllipse new size: 20.g := RSGroup new.g add: box; add: circle.composite := g asShape.composite extent. '=> (20.0@20.0)'RSVerticalLineLayout on: g.composite extent. '=> (20.0@20.0)'composite adjustToChildren.composite extent '=> (20.0@50.0)'```"	| rect delta |	children ifNil: [ ^ self ].	rect := children encompassingRectangle.	delta := rect floatCenter negated.		children do: [ :s | s basicTranslateBy: delta ].	self 		extent: rect extent;		translateTo: delta negated.! !!RSComposite methodsFor: 'accessing'!camera	^ parent camera! !!RSComposite methodsFor: 'accessing'!children	^ children ifNil: [ children := RSGroup new ]! !!RSComposite methodsFor: 'accessing'!children: aRSGroup	"	create a groups of elements or trachel shapes, then added them to this composite shape	this method changes the position of the shapes and set the position of this composite shape	to the center of the encompassingRectangle.	"	aRSGroup copy do: [ :s | 		s isInACanvas 			ifTrue: [ s remove ] ].	self addAll: aRSGroup.	self adjustToChildren.	! !!RSComposite methodsFor: 'testing'!hasChildren	^ children notNil and: [ children isNotEmpty ]! !!RSComposite methodsFor: 'initialization'!initialize	super initialize.	paint := nil.	self resetPath.	! !!RSComposite methodsFor: 'accessing'!padding: anObject	"anObject can be a number, a point or Margin"	"Shapes should be set in the composite before calling #padding:For example:```Smalltalkbox := RSBox new    color: Color blue translucent;    fromRectangle: ((-38.5@ -20.0) corner: (38.5@20.0));    yourself.label := RSLabel new    text: 'Smalltalk';    yourself.g := RSGroup new.g add: box.g add: label.composite := g asShape.composite padding: 20.composite color: Color red.c := RSCanvas new.c add: composite.c```	"		| margin rect center temp |	temp := children 		ifNil: [ RSGroup new: 0 ]		ifNotNil: [children].	margin := anObject asMargin. 	rect := temp encompassingRectangle.	rect := margin expandRectangle: rect.	self extent: rect extent.		(center := rect floatCenter) = (0@0) ifTrue: [ ^ self ].	center := center negated.	temp do: [ :s | s basicTranslateBy: center ].! !!RSComposite methodsFor: 'private' prior: 33887783!privateEdges	^ edges! !!RSComposite methodsFor: 'private' prior: 33887864!privateEdges: aRSGroup	edges := aRSGroup! !!RSComposite methodsFor: 'private' prior: 33887953!privateNodes	^ nodes! !!RSComposite methodsFor: 'private' prior: 33888034!privateNodes: aRSGroup	nodes := aRSGroup! !!RSComposite methodsFor: 'actions'!pushBack: aShape	children		remove: aShape;		addFirst: aShape! !!RSComposite methodsFor: 'actions'!pushFront: shape	children 		remove: shape ifAbsent: [];		addLast: shape. 	! !!RSComposite methodsFor: 'removing'!removeShape: shape	| evt |	children remove: shape.	shape parent: nil.	evt := RSShapeRemovedEvent new shape: shape.	self announce: evt.	shape announce: evt.	! !!RSComposite methodsFor: 'path'!resetPath	path := baseRectangle! !!RSComposite methodsFor: 'path'!sessionChanged	"This method releases all the native graphical resources. This method is typically invoked when starting a Pharo image with a visualization that was previously open"	self resetPath.	children ifNil: [ ^ self ].	children do: #sessionChanged! !!RSComposite methodsFor: 'accessing - computed'!shapeWithAction: eventClass forPosition: position	| res pos |	pos := self matrix inverseTransform: position.	self shapes reverseDo: [ :s |		res := s shapeWithAction: eventClass forPosition: pos.		res ifNotNil: [ ^ res] ].		^ super shapeWithAction: eventClass forPosition: position.! !!RSComposite methodsFor: 'accessing - computed'!shapeWithActionForPosition: position	| res pos |	pos := self matrix inverseTransform: position.	self shapes reverseDo: [ :s |		res := s shapeWithActionForPosition: pos.		res ifNotNil: [ ^ res] ].	^ super shapeWithActionForPosition: position.! !!RSComposite methodsFor: 'accessing' prior: 33888675!shapes	^ self children! !!RSComposite methodsFor: 'accessing'!shapes: aRSGroup	self children: aRSGroup! !!RSComposite methodsFor: 'edges'!updateConnectedEdges	"Update the edge connected to elements contained in the composite. This happens when a shape is drag and dropped. For example:	-=-=-=-=-=-=-=-=-=c := RSCanvas new.c add: (RSLabel new text: 'I am connected to'; model: 0).c shapes first translateBy: -50 @ 50.g := RSGroup new.g add: (RSLabel new text: '1'; model: 1).g add: (RSLabel new text: '2'; model: 2).RSHorizontalLineLayout on: g.composite := g asShape.composite color: Color lightBlue.c add: composite.c shapes @ RSDraggable.c add: (RSLine new color: Color red; from: c shapes first; to: g first).c add: (RSLine new color: Color red; from: c shapes first; to: g second).c @ RSCanvasController-=-=-=-=-=-=-=-=-="	self shouldUpdateEdges 		ifTrue: [ connectedEdges do: [ :edge | edge update ] ].	self children do: [ :child | 		child isNode			ifTrue: [ child updateConnectedEdges ] ]! !!RSEllipse methodsFor: 'visiting'!buildPathOn: visitor	visitor buildEllipsePath: self! !!RSEllipse methodsFor: 'geometry'!geometry 	| rect e p |	rect := self encompassingRectangle.	e := rect extent / 2.	p := self position.	e = (0@0) ifTrue: [ ^ p asGPoint ].	^ GEllipse 		center: p		vertex: p + (e x@ 0)		coVertex: p + (0@ e y)! !!RSEllipse methodsFor: 'testing'!includesPoint: aPoint	"Implementation is taken over from EllipseMorph>>containsPoint:"	| invertedPoint radius other delta xOverY t1 t2 rect |	invertedPoint := matrix inverseTransform: aPoint.	rect := self baseRectangle.	(rect containsPoint: invertedPoint) ifFalse: [ ^ false ]. "quick elimination"	radius := rect height asFloat / 2.	other := rect width asFloat / 2.	delta := invertedPoint - rect topLeft - (other@radius).	xOverY := rect width asFloat / rect height asFloat.	t1 := (delta x asFloat / xOverY) squared + delta y squared.	t2 := radius squared.	^ (t1 < t2)  or: [ t1 closeTo: t2 ].! !!RSEllipse methodsFor: 'accessing'!radius	^ self extent x / 2! !!RSEllipse methodsFor: 'accessing'!radius: integer	self extent: integer * 2 asPoint! !!RSLabel class methodsFor: 'public'!defaultFont	^ StandardFonts defaultFont! !!RSLabel class methodsFor: 'public'!familyFontName	"	self familyFontName	"	| fontList |	fontList := LogicalFontManager current allFamilies collect: #familyName.		(fontList includes: 'Source Sans Pro') ifTrue: [ ^ 'Source Sans Pro' ].	(fontList includes: 'DejaVu Sans') ifTrue: [ ^ 'DejaVu Sans' ].	fontList ifEmpty: [ ^ StandardFonts defaultFont familyName ].		(fontList includes: StandardFonts listFont familyName ) 		ifTrue: [ ^ StandardFonts listFont familyName ].				^  StandardFonts defaultFont familyName ! !!RSLabel methodsFor: 'visiting'!accept: visitor	visitor visitLabel: self.! !!RSLabel methodsFor: 'managing font'!bold"Make the font bold| c lbl1 lbl2 |c := TSCanvas new.lbl1 := TSLabel new bold; text: 'hello'.c addShape: lbl1.lbl2 := TSLabel new text: 'world'.c addShape: lbl2.RSLocate new below; move: lbl2 on: lbl1.c open"	self emphasisAdd: TextEmphasis bold.! !!RSLabel methodsFor: 'private'!computeTextExtents	| ext |	ext := CairoFontMetricsProvider new		font: font;		extentsOf: text.	^ RSTextExtents new		from: ext;		yourself! !!RSLabel methodsFor: 'accessing'!descent	^ font descent! !!RSLabel methodsFor: 'accessing'!emphasis"| c lbl |c := TSCanvas new.lbl := TSLabel new text: 'hello'.c addShape: lbl.c open"	^ emphasis! !!RSLabel methodsFor: 'accessing'!emphasis: anEmphasis	emphasis := anEmphasis.	self resetCache.! !!RSLabel methodsFor: 'managing font'!emphasisAdd: anEmphasis	emphasis add: anEmphasis.	self resetCache! !!RSLabel methodsFor: 'accessing'!font	^ font! !!RSLabel methodsFor: 'accessing'!font: aFont	font := aFont! !!RSLabel methodsFor: 'accessing'!fontName	^ fontName! !!RSLabel methodsFor: 'accessing'!fontName: string	"	LogicalFontManager current allFamilies inspect	"	fontName := string.	self resetCache.	! !!RSLabel methodsFor: 'accessing'!fontSize	^ fontSize ! !!RSLabel methodsFor: 'accessing'!fontSize: integer	"Set the size of the label.Here is an example:-=-=-=-=-=-=c := RSCanvas new.(1 to: 100 by: 5) shuffled do: [ :i |	lbl := RSLabel new fontSize: i; text: 'hello'; model: i.	c add: lbl.	lbl @ RSPopup.].RSFlowLayout on: c shapes.c @ RSControlsCanvas-=-=-=-=-=-="	fontSize := integer.	self resetCache! !!RSLabel methodsFor: 'initialization'!initialize	| defaultFont |	super initialize.	paint := Color black.	text := 'UNASSIGNED'.	defaultFont := self class defaultFont.	fontSize := defaultFont pixelSize.	emphasis := TextEmphasis normal.		self fontName: (defaultFont realFont class == StrikeFont 		ifTrue: [ self class familyFontName ]		ifFalse: [ defaultFont familyName ]). ! !!RSLabel methodsFor: 'testing'!is: anInteger	"anInteger is a valid code"	^ (emphasis emphasisCode bitAnd: anInteger) > 0! !!RSLabel methodsFor: 'testing'!isBold	^ self is: 1! !!RSLabel methodsFor: 'testing'!isItalic	^ self is: 2! !!RSLabel methodsFor: 'testing'!isNormal	^ emphasis emphasisCode = 0! !!RSLabel methodsFor: 'testing'!isStruckOut	^ self is: 16! !!RSLabel methodsFor: 'testing'!isUnderlined	^ self is: 4! !!RSLabel methodsFor: 'managing font'!italic"Make the font italic| c lbl1 lbl2 |c := TSCanvas new.lbl1 := TSLabel new italic; text: 'hello'.c addShape: lbl1.lbl2 := TSLabel new text: 'world'.c addShape: lbl2.RSLocate new below; move: lbl2 on: lbl1.c open"	self emphasisAdd: TextEmphasis italic.! !!RSLabel methodsFor: 'managing font'!normal	self emphasis: TextEmphasis normal.! !!RSLabel methodsFor: 'managing font'!resetCache 	font := LogicalFont 		familyName: fontName		pointSize: fontSize.		font := font emphasized: emphasis emphasisCode.	textExtents := nil.		self extent: self textWidth @ self textHeight.! !!RSLabel methodsFor: 'managing font'!struckOut	self emphasisAdd: TextEmphasis struckOut.! !!RSLabel methodsFor: 'accessing'!text	^ text! !!RSLabel methodsFor: 'accessing'!text: string	text = string ifTrue: [ ^ self ].	text := string asString.	self resetCache; resetPath.! !!RSLabel methodsFor: 'accessing'!textExtents	^ textExtents ifNil: [ textExtents := self computeTextExtents ].! !!RSLabel methodsFor: 'accessing'!textHeight	"without any transformation"	^ self textExtents height! !!RSLabel methodsFor: 'accessing'!textWidth	"without any transformation"		^ self textExtents x_advance! !!RSLabel methodsFor: 'managing font'!underline"Make the font underlined| c lbl1 lbl2 |c := TSCanvas new.lbl1 := TSLabel new underline; text: 'hello'.c addShape: lbl1.lbl2 := TSLabel new text: 'world'.c addShape: lbl2.RSLocate new below; move: lbl2 on: lbl1.c open"	self emphasisAdd: TextEmphasis underlined.! !!RSLabel methodsFor: 'accessing'!x_bearing	^ self textExtents x_bearing! !!RSPieSlice methodsFor: 'accessing'!alphaAngle	^ alphaAngle! !!RSPieSlice methodsFor: 'accessing'!alphaAngle: stAngle	"Starting angle"	| old |	old := alphaAngle.	alphaAngle := stAngle.	old = alphaAngle ifTrue: [ ^ self ].	self resetPath.! !!RSPieSlice methodsFor: 'public'!arcRadiusAuto	| e i |	e := externalRadius.	i := innerRadius.	self cornerRadii: ((i * i) + (e * e)) sqrt! !!RSPieSlice methodsFor: 'accessing'!betaAngle	^ betaAngle! !!RSPieSlice methodsFor: 'accessing'!betaAngle: ndAngle	"Finishing angle"	| old |	old := betaAngle.	betaAngle := ndAngle.	old = betaAngle ifTrue: [ ^ self ].	self resetPath.! !!RSPieSlice methodsFor: 'visiting'!buildPathOn: visitor	visitor buildRingPath: self! !!RSPieSlice methodsFor: 'accessing'!centroid: off	| r a |	r := innerRadius isZero		ifTrue: [ 0 ]		ifFalse: [ (innerRadius + externalRadius)/2 ].	r := r + off.	a := self middleAngle degreesToRadians.	^ (a cos @ (a sin negated) * r)  + self position.! !!RSPieSlice methodsFor: 'accessing'!cornerRadii	^ cornerRadii! !!RSPieSlice methodsFor: 'accessing'!cornerRadii: aNumber	| old |	self 		assert: [ aNumber >= 0 ]		description: 'Corner radius must be a non-negative!!'.	old := cornerRadii.	cornerRadii := aNumber.	old = cornerRadii ifTrue: [ ^ self ].	self resetPath.! !!RSPieSlice methodsFor: 'utilities'!emphasizeWith: anInteger 	self translateBy: (self centroid: anInteger)! !!RSPieSlice methodsFor: 'accessing'!extent: aPoint	super extent: aPoint.	externalRadius := (aPoint x min: aPoint y)/2.! !!RSPieSlice methodsFor: 'accessing'!externalRadius	^ externalRadius! !!RSPieSlice methodsFor: 'accessing'!externalRadius: eR	self extent: (eR * 2) asPoint.! !!RSPieSlice methodsFor: 'testing'!includesPoint: aPoint	| invertedPoint a b i e n d |	invertedPoint := matrix inverseTransform: aPoint.	(self baseRectangle containsPoint: invertedPoint)		ifFalse: [ ^ false ].	i := innerRadius.	e := externalRadius.	d := invertedPoint dist: 0 @ 0.	(d between: i and: e)		ifFalse: [ ^ false ].	n := invertedPoint angle negated radiansToDegrees.	a := alphaAngle.	b := betaAngle.	n := (360 + (n % 360)) % 360.	a := (3600000 + a) % 360.	b := (3600000 + b) % 360.	^ a < b		ifTrue: [ n between: a and: b ]		ifFalse: [ a <= n | (n <= b) ]! !!RSPieSlice methodsFor: 'initialization'!initialize	super initialize.	cornerRadii := innerRadius := externalRadius := betaAngle := alphaAngle := segmentSpacing := 0.	! !!RSPieSlice methodsFor: 'accessing'!innerRadius	^ innerRadius! !!RSPieSlice methodsFor: 'accessing'!innerRadius: iR	| old |	old := innerRadius.	innerRadius := iR asFloat.	old = innerRadius ifTrue: [ ^ self ].	self resetPath.! !!RSPieSlice methodsFor: 'accessing'!middleAngle	^ (alphaAngle + betaAngle) / 2! !!RSPieSlice methodsFor: 'accessing'!segmentSpacing	^ segmentSpacing! !!RSPieSlice methodsFor: 'accessing'!segmentSpacing: anAngleInDegrees	| old |	old := segmentSpacing.	segmentSpacing := anAngleInDegrees.	old = segmentSpacing ifTrue: [ ^self ].	self resetPath.! !!RSPieSlice methodsFor: 'accessing'!shiftAngles: aNumber 	self 		alphaAngle: alphaAngle + aNumber;		betaAngle: betaAngle + aNumber	! !!RSPolygon class methodsFor: 'utilities'!fitPolygonToSquare: points	| maxx minx maxy miny sx sy x y |	minx := maxx :=  points first x.	miny := maxy :=  points first y.	points do: [ :p | 		minx := minx min: p x.		miny := miny min: p y.		maxx := maxx max: p x.		maxy := maxy max: p y ].	"stretch factors"	sx := 2/(maxx - minx).	sy := 2/(maxy - miny).	points doWithIndex: [ :p :i|		x := p x * sx.		y := p y * sy.		points at: i put: x@y.		minx := minx min: x.		miny := miny min: y.		maxx := maxx max: x.		maxy := maxy max: y ].	miny < -1 ifTrue: [ 		points doWithIndex: [ :p :i |			points at: i put: p x @ ( p y - 1 - miny ) ] ].	^ points.! !!RSPolygon class methodsFor: 'utilities'!generatePointsFitSquare: sides	| points |	points := self generateUnitNgonPoints: sides rotation: 0.	points := self fitPolygonToSquare: points.	^ points! !!RSPolygon class methodsFor: 'utilities'!generateUnitNgonPoints: sides rotation: rotationAngle		^ self generateUnitNgonPoints: sides  rotation: rotationAngle		angle: [ :a :i | a negated ] 		radius: [ :a :i | 1 ]! !!RSPolygon class methodsFor: 'utilities'!generateUnitNgonPoints: sides rotation: rotationAngle angle: angleBloc radius: radiusBloc	"sides a Number	rotation is a number in radians	angle is a function of 2 args(current angle and index of angle) this return an angle	radius is a function of 2 args (current angle and index of angle) this retunr a number "	| increment startAngle points currentAngle currentRadius |	increment := 1.0 / sides * 2 * Float pi.	startAngle := sides even		ifTrue: [ (Float pi / 2) + (increment / 2) ]		ifFalse: [ Float pi / 2 ].	startAngle := startAngle + rotationAngle.	points := Array new: sides.	0 to: sides - 1 do: [ :i | 		currentAngle := i * increment + startAngle.		currentAngle := angleBloc value: currentAngle value: i.		currentRadius := radiusBloc value: currentAngle value: i.		points at: i+1 put: (currentAngle cos @ currentAngle sin) * currentRadius ].	^ points! !!RSPolygon methodsFor: 'visiting'!buildPathOn: visitor	visitor buildPolygonPath: self! !!RSPolygon methodsFor: 'private'!centerPoints	"Private method, should not be used externally"	| r center |	r := points 		ifEmpty: [ 0@0 corner: 0@0 ]		ifNotEmpty: [ Rectangle encompassing: points ].	center := r floatCenter.	points := points collect: [ :p | p - center ].	^ r! !!RSPolygon methodsFor: 'accessing'!cornerRadii 	"Return the corner radii, indicating how smooth the polygon corners shoulid be"	^ radius ifNil: [ 0 ]! !!RSPolygon methodsFor: 'accessing'!cornerRadii: aNumber	"Set the corner radii. Has the effect to make corners smooth 	For example:c := RSCanvas new.polygon := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: 'FFAE0B'.polygon cornerRadii: 5.		polygon2 := RSPolygon new		points: { 0 @ -50 . 50 @ 0 . -50 @ 0 };		color: Color red trans.		polygon2 rotateByDegrees: 90.polygon2 translateBy: 0 @ -50.c add: polygon.c add: polygon2.c	"	radius := aNumber abs.	self resetPath.! !!RSPolygon methodsFor: 'private'!extent: newExtent	| min max s extent |	self hasPoints 		ifFalse: [ ^ self ].	extent := baseRectangle extent.	extent = newExtent		ifTrue: [ ^ self ].	min := Float fmax asPoint.	max := Float fmin asPoint.	points do: [ :p | 		min := min min: p.		max := max max: p ].	s := newExtent / (max - min).	points := points collect: [ :p | p * s ].	super extent: newExtent! !!RSPolygon methodsFor: 'geometry'!geometry	| rect e |	rect := self encompassingRectangle.	e := rect extent.	e = (0@0) ifTrue: [ ^ rect floatCenter asGPoint ].	^ GPolygon		vertices: self points + self position! !!RSPolygon methodsFor: 'testing'!hasPoints	^ points notNil and: [ points isNotEmpty ]! !!RSPolygon methodsFor: 'testing'!includesPoint: aPoint	"Return true or false if a point is contained in the shape"	| invertedPoint |	invertedPoint := matrix inverseTransform: aPoint.	^ (self baseRectangle containsPoint: invertedPoint)		ifFalse: [ false ]		ifTrue: [(AthensPolygonTester new 			polygon: points) includesPoint: invertedPoint]! !!RSPolygon methodsFor: 'initialization'!initialize	super initialize.	points := #().! !!RSPolygon methodsFor: 'accessing'!points	"Return the points defining the polygon"	^ points! !!RSPolygon methodsFor: 'accessing'!points: anArray	"Set the points used to draw the polygon."	| rec |	self privatePoints: anArray.	rec := self centerPoints.	self translateTo: rec floatCenter.	super extent: rec extent! !!RSPolygon methodsFor: 'private'!privatePoints: anArray	"Private method, should bot be used externally"	points := anArray! !!RSShape methodsFor: '*Roassal3-Shapes'!asMarker	^ RSMarker new shape: self! !!RSShape methodsFor: '*Roassal3-Shapes'!borderDo: aBlock	border ifNil: [ border := RSBorder new ].	aBlock value: border! !!RSShape methodsFor: '*Roassal3-Shapes'!withBorder	self border: RSBorder new! !!RSGroup methodsFor: '*Roassal3-Shapes'!asShape	"Convert a RSGroup into a shape. Pretty convenient to create a group of shapes as a composite.Consider the following example:-=-=-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.classes := Collection withAllSubclasses.elements := classes collect: [ :cls |	g := RSGroup new		add: (RSLabel new text: cls name);		add: (RSEllipse new size: (cls numberOfMethods + 5) sqrt; color: Color blue );		yourself.	RSVerticalLineLayout new center; on: g.	g asShape ] as: RSGroup.c addAll: elements.elements @ RSHighlightable defaultRed.RSGridLayout on: elements.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=-=-="	^ self asShapeFor: nil! !!RSGroup methodsFor: '*Roassal3-Shapes'!asShapeFor: model	"Convert a RSGroup into a shape, and tis shape has a model. Pretty convenient to create a group of shapes as a composite.Consider the following example:-=-=-=-=-=-=-=-=-=-=-=-=c := RSCanvas new.classes := Collection withAllSubclasses.elements := classes collect: [ :cls |	g := RSGroup new		add: (RSLabel new text: cls name);		add: (RSEllipse new size: (cls numberOfMethods + 5) sqrt; color: Color blue );		yourself.	RSVerticalLineLayout new center; on: g.	g asShapeFor: cls ] as: RSGroup.c addAll: elements.elements @ RSHighlightable defaultRed.RSGridLayout on: elements.c @ RSCanvasController-=-=-=-=-=-=-=-=-=-=-=-="	^ RSComposite new 		model: model;		shapes: self		yourself! !"Roassal3-Shapes"!!RSAbstractAnimation commentStamp: '' prior: 0!I am the abstract class that defines animations for roassal3!!RSCompositeAnimation commentStamp: '' prior: 0!Super class of composite animations!!RSParallelAnimation commentStamp: '' prior: 0!I excecute my animations at the same time!!RSSequentialAnimation commentStamp: '' prior: 0!I wait until one animation ends to start the another animation!!RSTransitionAnimation commentStamp: '' prior: 0!I am an animation that provides a number interpolating between 0 and 1. and apply it the value to one block!!RSAbstractTimer commentStamp: '' prior: 0!Users can set the timer of the canvas this will affect the animations process, by changing the speed of all of them in a canvas!!RSDefaultTimer commentStamp: '' prior: 0!The default timer uses the pharo current time!!RSVariableTimer commentStamp: '' prior: 0!This roassal timer, changes the time depending the user's needs. Ideally you add time when you complete a task with the canvas!!RSAnimationEvent commentStamp: '' prior: 0!I an an event for animations in trachel!!RSAnimationEndEvent commentStamp: '' prior: 0!For when the animation is removed or ends from the canvas!!RSAnimationLoopEvent commentStamp: '' prior: 0!for loop events!!RSAnimationStartEvent commentStamp: '' prior: 0!When the animation starts!!RSEasing commentStamp: '' prior: 0!Given the specified normalized time t, typically in the range [0,1], returns the “eased” time tʹ, also typically in [0,1]. 0 represents the start of the animation and 1 represents the end. A good implementation returns 0 if t = 0 and 1 if t = 1.I am highli inspired in d3js source code https://github.com/d3/d3-transition and in the base animation of Bloc https://github.com/pharo-graphics/Bloc!!RSBackInterpolator commentStamp: '' prior: 0!TSEasing backInAnticipatory easing, like a dancer bending his knees before jumping off the floor. The degree of overshoot is configurable; if not specified, it defaults to 1.70158.TSEasing backOut Reverse anticipatory easing; equivalent to 1 - (backIn value: 1 - t).TSEasing back TSEasing backInOutSymmetric anticipatory easing; scales backIn for t in [0, 0.5] and backOut for t in [0.5, 1].!!RSBounceInterpolator commentStamp: '' prior: 0!TSEasing bounceInBounce easing, like a rubber ball.TSEasing bounceTSEasing bounceOutReverse bounce easing; equivalent to 1 - bounceIn(1 - t).TSEasing bounceInOutSymmetric bounce easing; scales bounceIn for t in [0, 0.5] and bounceOut for t in [0.5, 1].!!RSCircleInterpolator commentStamp: '' prior: 0!TSEasing circleInCircular easing.TSEasing circleOutIs Reverse circular easing; equivalent to 1 - interpolateIn: 1 - t.TSEasing circleInOutTSEasing circleSymmetric circular easing; scales circleIn for t in {0. 0.5} and circleOut for t in {0.5, 1}.!!RSCubicInterpolator commentStamp: '' prior: 0!TSEasing cubicInCubic easing; equivalent to: TSEasing poly exponent: 3.TSEasing cubicOutReverse cubic easing; equivalent to 1 - TSEasing cubicIn interpolate: (1 - t). Also equivalent to TSEasing polyOut exponent: 3.TSEasing cubic TSEasing cubicInOut Symmetric cubic easing; scales cubicIn for t in {0. 0.5} and cubicOut for t in {0.5. 1}. Also equivalent to TSEasing poly exponent: 3.!!RSElasticInterpolator commentStamp: '' prior: 0!TSEasing elasticInElastic easing, like a rubber band. The amplitude and period of the oscillation are configurable; if not specified, they default to 1 and 0.3, respectively.TSEasing elasticOutReverse elastic easing; equivalent to 1 - elasticIn(1 - t).TSEasing elastic TSEasing elasticInOut.Symmetric elastic easing; scales elasticIn for t in [0, 0.5] and elasticOut for t in [0.5, 1].!!RSExpInterpolator commentStamp: '' prior: 0!TSEasing expInExponential easing; raises 2 to the exponent 10 * (t - 1).TSEasing expOut Reverse exponential easing; equivalent to 1 - expIn(1 - t).TSEasing exp TSEasing expInOut Symmetric exponential easing; scales expIn for t in [0, 0.5] and expOut for t in [0.5, 1].!!RSPolyInterpolator commentStamp: '' prior: 0!linear := TSEasing poly exponent: 1.quad := TSEasing poly exponent: 2.cubic := TSEasing poly exponent: 3TSEasing polyIn Polynomial easing; raises t to the specified exponent. If the exponent is not specified, it defaults to 3, equivalent to cubicIn.TSEasing polyOutReverse polynomial easing; equivalent to 1 - polyIn(1 - t). If the exponent is not specified, it defaults to 3, equivalent to cubicOut.TSEasing poly TSEasing polyInOut Symmetric polynomial easing; scales polyIn for t in [0, 0.5] and polyOut for t in [0.5, 1]. If the exponent is not specified, it defaults to 3, equivalent to cubic.!!RSQuadInterpolator commentStamp: '' prior: 0!TSEasing quadInQuadratic easing. Equivalent to: TSEasing polyIn exponent: 2TSEasing quadOutReverse quadratic easing. Equivalent to 1 - (1 - t) quadIn. Also equivalent to: TSEasing polyOut exponent: 2.TSEasing quad TSEasing quadInOut Symmetric quadratic easing; scales quadIn for t in [0, 0.5] and quadOut for t in [0.5, 1].Also equivalent to TSEasing poly exponent: 2.!!RSSinInterpolator commentStamp: '' prior: 0!TSEasing sinInSinusoidal easing; returns sin(t).TSEasing sinOutReverse sinusoidal easing; equivalent to 1 - sinIn(1 - t).TSEasing sin TSEasing sinInOutSymmetric sinusoidal easing; scales sinIn for t in [0, 0.5] and sinOut for t in [0.5, 1].!!RSLinearInterpolator commentStamp: '' prior: 0!I return the linear interpolation!!RSCanvas methodsFor: '*Roassal3-Animation'!animationFrom: array	^ self compositeAnimation: self sequentialAnimation from: array! !!RSCanvas methodsFor: '*Roassal3-Animation'!compositeAnimation: aRSCompositeAnimation from: array	aRSCompositeAnimation addAll: array.	self addAnimation: aRSCompositeAnimation.	^ aRSCompositeAnimation	! !!RSCanvas methodsFor: '*Roassal3-Animation'!currentTime	^ self timer currentTime.	! !!RSCanvas methodsFor: '*Roassal3-Animation'!newAnimation	"Define a new transition animation, schedule it, and return it (useful to tune it).-=-==-=-=-=	c := RSCanvas new.	b := RSBox new		extent: 100@100;		withBorder.	c add: b.	c newAnimation			from: -100 @ -100;			to: 100 @ 100;			on: b set: #position:.	c-=-==-=-=-=			"	| anime |	anime := self transitionAnimation.	self addAnimation: anime.	^ anime! !!RSCanvas methodsFor: '*Roassal3-Animation'!parallelAnimation 	^ RSParallelAnimation new! !!RSCanvas methodsFor: '*Roassal3-Animation'!parallelAnimationFrom: array	^ self compositeAnimation: self parallelAnimation from: array	! !!RSCanvas methodsFor: '*Roassal3-Animation'!sequentialAnimation 	^ RSSequentialAnimation new! !!RSCanvas methodsFor: '*Roassal3-Animation'!timer	^ self propertyAt: #timer ifAbsentPut: [ RSDefaultTimer new ].! !!RSCanvas methodsFor: '*Roassal3-Animation'!timer: aRSAbstractTimer	self propertyAt: #timer put: aRSAbstractTimer! !!RSCanvas methodsFor: '*Roassal3-Animation'!transitionAnimation 	^ RSTransitionAnimation new! !!RSAbstractAnimation class methodsFor: 'public'!defaultDuration	^ self subclassResponsibility! !!RSAbstractAnimation methodsFor: 'accessing'!allDuration	^  self duration * (self isRepeating		ifTrue: [ 1 ]		ifFalse: [ self loops ])! !!RSAbstractAnimation methodsFor: 'events'!announce: anEvent	announcer ifNil: [ ^ self ].	announcer announce: anEvent value! !!RSAbstractAnimation methodsFor: 'events'!announcer	^ announcer ifNil: [ announcer := Announcer new ]! !!RSAbstractAnimation methodsFor: 'events'!announcer: anAnnouncer	announcer := anAnnouncer! !!RSAbstractAnimation methodsFor: 'accessing'!canvas	^ canvas ! !!RSAbstractAnimation methodsFor: 'accessing'!canvas: aCanvas	canvas := aCanvas! !!RSAbstractAnimation methodsFor: 'actions'!continue	isPaused ifFalse: [ ^ self ].	isPaused := false.	endPauseTime := self currentTime.	pauseTime := pauseTime + endPauseTime - startPauseTime.! !!RSAbstractAnimation methodsFor: 'accessing'!currentLoop	^ currentLoop! !!RSAbstractAnimation methodsFor: 'private'!currentTime	^ canvas currentTime! !!RSAbstractAnimation methodsFor: 'accessing'!delay 	^ delay! !!RSAbstractAnimation methodsFor: 'accessing'!delay: aDuration	delay := aDuration asMilliSeconds! !!RSAbstractAnimation methodsFor: 'accessing'!duration	^ self subclassResponsibility! !!RSAbstractAnimation methodsFor: 'accessing'!endPauseTime	^ endPauseTime! !!RSAbstractAnimation methodsFor: 'accessing'!endTime	^ endTime! !!RSAbstractAnimation methodsFor: 'testing'!hasCompleted	 ^ hasCompleted! !!RSAbstractAnimation methodsFor: 'initialization'!initialize	super initialize.	self reset.	canvas := RSDefaultTimer new.! !!RSAbstractAnimation methodsFor: 'testing'!isDelayDone	delay ifNil: [ ^ true ].	^ startTime + delay < self currentTime.! !!RSAbstractAnimation methodsFor: 'testing'!isPaused	^ isPaused! !!RSAbstractAnimation methodsFor: 'testing'!isRepeating	^ loops isInfinite.! !!RSAbstractAnimation methodsFor: 'testing'!isRunning 	^ isRunning! !!RSAbstractAnimation methodsFor: 'private'!loopDone	currentLoop := currentLoop + 1.	startPauseTime := endPauseTime := pauseTime := 0.	startLoopTime := self currentTime.	self announce: (RSAnimationLoopEvent new animation: self).! !!RSAbstractAnimation methodsFor: 'accessing'!loops	^ loops! !!RSAbstractAnimation methodsFor: 'accessing'!loops: aNumber	self assert: aNumber >= 1 description: 'The number of times to repeat this animation'.	loops := aNumber! !!RSAbstractAnimation methodsFor: 'api - running'!noRepeat	self loops: 1! !!RSAbstractAnimation methodsFor: 'actions'!pause	isPaused ifTrue: [ ^ self ].	isPaused := true.	startPauseTime := self currentTime.	! !!RSAbstractAnimation methodsFor: 'accessing'!pauseTime	^ pauseTime! !!RSAbstractAnimation methodsFor: 'refresing'!refresh	self hasCompleted		ifTrue: [ ^ self ].	self isDelayDone		ifFalse: [ ^ self ].	self isPaused 		ifTrue: [ ^ self ].	self step.	! !!RSAbstractAnimation methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!RSAbstractAnimation methodsFor: 'actions'!remove	canvas animations remove: self ifAbsent: [  ].	endTime := self currentTime.	isRunning := false.	currentLoop := nil.	startLoopTime := nil.	self announce: (RSAnimationEndEvent new animation: self)	! !!RSAbstractAnimation methodsFor: 'api - running'!repeat	"make receiver to be a repeating timer"	self loops: Float infinity! !!RSAbstractAnimation methodsFor: 'initialization'!reset	isRunning := false.	self noRepeat.	hasCompleted := false.	isPaused := false.	currentLoop := nil.	startLoopTime := nil.	startPauseTime := 0.	endPauseTime := 0.	pauseTime := 0.! !!RSAbstractAnimation methodsFor: 'actions'!start	isRunning := true.	hasCompleted := false.	startTime := self currentTime.	self announce: (RSAnimationStartEvent new animation: self)! !!RSAbstractAnimation methodsFor: 'accessing'!startLoopTime	^ startLoopTime ! !!RSAbstractAnimation methodsFor: 'accessing'!startPauseTime	^ startPauseTime! !!RSAbstractAnimation methodsFor: 'private'!startStep	currentLoop 		ifNil: [ currentLoop := 0 ].	startLoopTime 		ifNil: [ startLoopTime := self currentTime ].! !!RSAbstractAnimation methodsFor: 'accessing'!startTime	^ startTime ! !!RSAbstractAnimation methodsFor: 'refresing'!step	self subclassResponsibility! !!RSAbstractAnimation methodsFor: 'actions'!stop	isRunning := false.	hasCompleted := true.! !!RSAbstractAnimation methodsFor: 'actions'!toggle	self isPaused 		ifTrue: [ self continue ]		ifFalse: [ self pause ]! !!RSAbstractAnimation methodsFor: 'private'!updateHasCompleted	hasCompleted ifFalse: [ hasCompleted := currentLoop >= loops ].! !!RSAbstractAnimation methodsFor: 'events'!when: event do: aBlock	self announcer when: event do: aBlock! !!RSCompositeAnimation class methodsFor: 'public'!defaultDuration	^ 0 seconds! !!RSCompositeAnimation methodsFor: 'adding'!add: anAnimation	animations add: anAnimation ! !!RSCompositeAnimation methodsFor: 'adding'!addAll: array	animations addAll: array.! !!RSCompositeAnimation methodsFor: 'accessing'!animations	^ animations! !!RSCompositeAnimation methodsFor: 'initialization'!reset	super reset.	animations := OrderedCollection new.! !!RSCompositeAnimation methodsFor: 'private'!startIfNessesary: animation	animation isRunning ifTrue: [ ^ self ].	animation canvas: self canvas.	animation start! !!RSParallelAnimation methodsFor: 'actions'!continue	super continue.	animations do: #continue.! !!RSParallelAnimation methodsFor: 'accessing'!duration	animations ifEmpty: [ ^ 0 asDuration ].	^ (animations collect: #allDuration) max! !!RSParallelAnimation methodsFor: 'actions'!pause	super pause.	animations do: #pause.! !!RSParallelAnimation methodsFor: 'actions'!start	super start.	animations do: [ :anime | self startIfNessesary: anime ]! !!RSParallelAnimation methodsFor: 'refresing'!step	| activeAnimations activeSize |	self startStep.	activeAnimations := animations reject: [ :animation | animation hasCompleted ].	activeSize := 0.	activeAnimations do: [ :animation | 		self startIfNessesary: animation.		animation refresh.		animation hasCompleted 			ifTrue: [ animation remove ]			ifFalse: [ activeSize := activeSize + 1 ] ].	activeSize isZero ifTrue: [ self loopDone ].	self updateHasCompleted.		! !!RSSequentialAnimation methodsFor: 'actions'!continue	super continue.	self currentDo: #continue.! !!RSSequentialAnimation methodsFor: 'refresing'!current	^ animations at: currentIndex ifAbsent: [ nil ].! !!RSSequentialAnimation methodsFor: 'actions'!currentDo: block	| current |	current := self current.	current ifNil: [ ^ self ].	block value: current.! !!RSSequentialAnimation methodsFor: 'refresing'!currentHasCompleted	| current |	current := self current.	current ifNil: [ ^ false ].	^ current hasCompleted! !!RSSequentialAnimation methodsFor: 'accessing'!duration	animations ifEmpty: [ ^ 0 asDuration ].	^ (animations collect: #allDuration) sum! !!RSSequentialAnimation methodsFor: 'actions'!pause	super pause.	self currentDo: #pause.! !!RSSequentialAnimation methodsFor: 'actions'!start	super start.	currentIndex := 1.! !!RSSequentialAnimation methodsFor: 'refresing'!step	self startStep.	self stepCurrent.	self currentHasCompleted ifTrue: [ 		self current remove.		currentIndex := currentIndex + 1. ].	currentIndex > animations size ifTrue: [ 		currentIndex := 1.		self loopDone ].	self updateHasCompleted.! !!RSSequentialAnimation methodsFor: 'refresing'!stepCurrent	| current |	current := self current.	current ifNil: [ ^ self ].	self startIfNessesary: current.	current refresh.! !!RSTransitionAnimation class methodsFor: 'public'!defaultDuration	^ 2 seconds! !!RSTransitionAnimation methodsFor: 'accessing'!duration	^ Duration milliSeconds: duration! !!RSTransitionAnimation methodsFor: 'accessing'!duration: aDuration	duration := aDuration asMilliSeconds! !!RSTransitionAnimation methodsFor: 'accessing'!easing	^ easing! !!RSTransitionAnimation methodsFor: 'accessing'!easing: anInterpolator	easing := anInterpolator ! !!RSTransitionAnimation methodsFor: 'accessing'!from	^ scale range first! !!RSTransitionAnimation methodsFor: 'accessing'!from: anObject	scale from: anObject! !!RSTransitionAnimation methodsFor: 'initialization'!initialize	super initialize.	self onStepDo: [ :t | ].	! !!RSTransitionAnimation methodsFor: 'action handling'!on: object set: setSelector	"Key method to set an animation. the first argument receives an object, typically a shape, a border, a line. The second argument is a selector that will be used to set the animated value. The selector must take one argument as parameter. Here is an example:-=-=-=-=c := RSCanvas new.b := RSBorder new color: Color blue.b dashArray: #(5 1 5).(30 to: 60) do: [ :nb |	box := RSBox new size: nb.	ellipse := RSEllipse new width: nb; height: nb + 10.	box border: b.	ellipse border: b.	c add: box; add: ellipse.	 ].RSFlowLayout on: c shapes.c @ RSControlsCanvas.c newAnimation 	from: 0;	to: 40;	on: b set: #dashOffset:.c-=-=-=-=Another example, simpler: -=-=-=-=c := RSCanvas new.b := RSBox new size: 30.c add: b.c newAnimation 	from: 0 @ 0;	to: 100 @ 100;	on: b set: #position:.c-=-=-=-=	"	| sel |	sel := setSelector asSymbol.	self 		assert: (object class canUnderstand: sel) 		description: 'Invalid input'.		self onStepDo: [ :t |		object perform: sel withArguments: { t }.		canvas signalUpdate.	]		! !!RSTransitionAnimation methodsFor: 'action handling'!onStepDo: aBlock	stepAction := aBlock! !!RSTransitionAnimation methodsFor: 'action handling'!onStepDo: aBlockClosure with: anObject	self onStepDo: [ :t | aBlockClosure value: t value: anObject ]! !!RSTransitionAnimation methodsFor: 'accessing - computed'!progress 	| progress |	self startStep.	progress := (self currentTime - pauseTime - startLoopTime)/ duration asFloat.	progress > 1 ifTrue: [ 		self loopDone.		progress := 1.		 ].		^ progress! !!RSTransitionAnimation methodsFor: 'accessing - computed'!progressValue: progress	| value |	"interpolate the progress"	value := easing interpolate: progress.	"apply progress to the value"	^ self scale scale: value.! !!RSTransitionAnimation methodsFor: 'accessing'!ramp: arrayOfAssociations	scale := NSScale linear		domain: (arrayOfAssociations collect: #key);		range: (arrayOfAssociations collect: #value)! !!RSTransitionAnimation methodsFor: 'accessing'!range: aTwoArrayOfNumbers	scale range: aTwoArrayOfNumbers! !!RSTransitionAnimation methodsFor: 'initialization'!reset	super reset.	self duration: self class defaultDuration.	easing := RSLinearInterpolator new.	scale := NSScale linear.! !!RSTransitionAnimation methodsFor: 'accessing'!scale	^ scale! !!RSTransitionAnimation methodsFor: 'accessing'!scale: aScale	scale := aScale! !!RSTransitionAnimation methodsFor: 'refresing'!step 	| value |	value := self progressValue: self progress.	stepAction cull: value.	self updateHasCompleted		! !!RSTransitionAnimation methodsFor: 'accessing'!stepAction	^ stepAction! !!RSTransitionAnimation methodsFor: 'accessing'!to	^ scale range last! !!RSTransitionAnimation methodsFor: 'accessing'!to: aValue	scale to: aValue.! !!RSAbstractTimer methodsFor: 'public'!currentTime	^ self subclassResponsibility! !!RSDefaultTimer methodsFor: 'public'!currentTime	^ Time millisecondClockValue! !!RSVariableTimer methodsFor: 'public'!addTime: aDuration	currentTime := currentTime + aDuration asMilliSeconds.! !!RSVariableTimer methodsFor: 'public'!currentTime	^ currentTime! !!RSVariableTimer methodsFor: 'initialization'!initialize	super initialize.	currentTime := RSDefaultTimer new currentTime.! !!RSAnimationEvent methodsFor: 'accessing'!animation	^ animation! !!RSAnimationEvent methodsFor: 'accessing'!animation: anAnimation	animation := anAnimation.! !!RSAnimationLoopEvent methodsFor: 'accessing'!currentLoop	^ animation currentLoop! !!RSBackInterpolator methodsFor: 'initialization'!initialize	super initialize.	overshoot := 1.70158! !!RSBackInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ t * t * ((overshoot + 1) * t - overshoot)! !!RSBackInterpolator methodsFor: 'interpolation'!interpolateInOut: i	"((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;"	| t |	t := i * 2.	^ (t < 1		ifTrue: [ t * t * ((overshoot + 1) * t - overshoot) ]		ifFalse: [ 			t := t -2.			t * t * ((overshoot + 1) * t + overshoot) + 2 ])/2! !!RSBackInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i -1.	^ t * t * ((overshoot + 1) * t + overshoot) + 1! !!RSBackInterpolator methodsFor: 'accessing'!overshoot	^ overshoot! !!RSBackInterpolator methodsFor: 'accessing'!overshoot: aNumber	overshoot := aNumber! !!RSBounceInterpolator methodsFor: 'initialization'!initialize	super initialize.	b1 := 4 / 11.	b2 := 6 / 11.	b3 := 8 / 11.	b4 := 3 / 4.	b5 := 9 / 11.	b6 := 10 / 11.	b7 := 15 / 16.	b8 := 21 / 22.	b9 := 63 / 64.	b0 := 1 / b1 / b1! !!RSBounceInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ 1 - (self interpolateOut: 1 - t)! !!RSBounceInterpolator methodsFor: 'interpolation'!interpolateInOut: i	"((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;"	| t |	t := i * 2.	^ (t <= 1		ifTrue: [ 1 - (self interpolateOut: 1 -t) ]		ifFalse: [ (self interpolateOut: t - 1) + 1 ] )/2! !!RSBounceInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i.	^ t < b1 		ifTrue: [ b0 * t * t ]		ifFalse: [ 			t < b3 ifTrue: [ 				t := t - b2.				b0 * t * t + b4 ]			ifFalse: [ 				t < b6 ifTrue: [ 					t := t - b5.					b0 * t * t + b7 ]				ifFalse: [ 					t := t - b8.					b0 * t * t + b9 ] ] ] ! !!RSCircleInterpolator methodsFor: 'interpolation'!interpolateIn:  t	^ 1 - (1 - (t * t) ) sqrt! !!RSCircleInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2.	^ (t<=1		ifTrue: [ 1 - (1 - (t*t)) sqrt ]		ifFalse: [ 			t := t - 2.			(1 - (t*t)) sqrt + 1 ])/2! !!RSCircleInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i -1.	^ (1 - (t* t)) sqrt.! !!RSCubicInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ t * t * t! !!RSCubicInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2.	^ (t <= 1 		ifTrue: [ t * t * t  ]		ifFalse: [ 			t := t - 2.			t * t * t + 2 ])/2! !!RSCubicInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i -1.	^ t * t * t + 1! !!RSEasing class methodsFor: 'back'!back	^ self backInOut! !!RSEasing class methodsFor: 'back'!backIn	^ RSBackInterpolator new in! !!RSEasing class methodsFor: 'back'!backInOut	^ RSBackInterpolator new! !!RSEasing class methodsFor: 'back'!backOut	^ RSBackInterpolator new out! !!RSEasing class methodsFor: 'bounce'!bounce	^ self bounceOut! !!RSEasing class methodsFor: 'bounce'!bounceIn	^ RSBounceInterpolator new in! !!RSEasing class methodsFor: 'bounce'!bounceInOut	^ RSBounceInterpolator new! !!RSEasing class methodsFor: 'bounce'!bounceOut	^ RSBounceInterpolator new out! !!RSEasing class methodsFor: 'circle'!circle	^ self circleInOut! !!RSEasing class methodsFor: 'circle'!circleIn	^ RSCircleInterpolator new in! !!RSEasing class methodsFor: 'circle'!circleInOut	^ RSCircleInterpolator new! !!RSEasing class methodsFor: 'circle'!circleOut	^ RSCircleInterpolator new out! !!RSEasing class methodsFor: 'cubic'!cubic	^ self cubicInOut! !!RSEasing class methodsFor: 'cubic'!cubicIn	^ RSCubicInterpolator new in! !!RSEasing class methodsFor: 'cubic'!cubicInOut	^ RSCubicInterpolator new! !!RSEasing class methodsFor: 'cubic'!cubicOut	^ RSCubicInterpolator new out! !!RSEasing class methodsFor: 'elastic'!elastic	^ self elasticInOut! !!RSEasing class methodsFor: 'elastic'!elasticIn	^ RSElasticInterpolator new in! !!RSEasing class methodsFor: 'elastic'!elasticInOut	^ RSElasticInterpolator new! !!RSEasing class methodsFor: 'elastic'!elasticOut	^ RSElasticInterpolator new out! !!RSEasing class methodsFor: 'exp'!exp	^ self expInOut! !!RSEasing class methodsFor: 'exp'!expIn	^ RSExpInterpolator new in! !!RSEasing class methodsFor: 'exp'!expInOut	^ RSExpInterpolator new! !!RSEasing class methodsFor: 'exp'!expOut	^ RSExpInterpolator new out! !!RSEasing class methodsFor: 'linear'!linear	^ RSLinearInterpolator new! !!RSEasing class methodsFor: 'poly'!poly	^ self polyInOut! !!RSEasing class methodsFor: 'poly'!polyIn	^ RSPolyInterpolator new in! !!RSEasing class methodsFor: 'poly'!polyInOut	^ RSPolyInterpolator new.! !!RSEasing class methodsFor: 'poly'!polyOut	^ RSPolyInterpolator new out! !!RSEasing class methodsFor: 'quad'!quad	^ self quadInOut! !!RSEasing class methodsFor: 'quad'!quadIn	^ RSQuadInterpolator new in! !!RSEasing class methodsFor: 'quad'!quadInOut	^ RSQuadInterpolator new! !!RSEasing class methodsFor: 'quad'!quadOut	^ RSQuadInterpolator new out! !!RSEasing class methodsFor: 'sin'!sin	^ self sinInOut! !!RSEasing class methodsFor: 'sin'!sinIn	^ RSSinInterpolator new in! !!RSEasing class methodsFor: 'sin'!sinInOut	^ RSSinInterpolator new! !!RSEasing class methodsFor: 'sin'!sinOut	^ RSSinInterpolator new out! !!RSEasing methodsFor: 'actions'!in	useIn := true.! !!RSEasing methodsFor: 'actions'!inOut	useIn := useOut := false! !!RSEasing methodsFor: 'initialization'!initialize	super initialize.	self inOut.! !!RSEasing methodsFor: 'interpolation'!interpolate: t	useIn ifTrue: [ ^ self interpolateIn: t ].	useOut ifTrue: [ ^ self interpolateOut: t ].	^ self interpolateInOut: t.! !!RSEasing methodsFor: 'interpolation'!interpolateIn: t	^ self subclassResponsibility! !!RSEasing methodsFor: 'interpolation'!interpolateInOut: t	^ self subclassResponsibility ! !!RSEasing methodsFor: 'interpolation'!interpolateOut: t	^ self subclassResponsibility! !!RSEasing methodsFor: 'actions'!out 	useOut := true.! !!RSElasticInterpolator methodsFor: 'accessing'!amplitude	^ amplitude! !!RSElasticInterpolator methodsFor: 'accessing'!amplitude: a	amplitude := a.	period := period * tau.	self calculateS.! !!RSElasticInterpolator methodsFor: 'accessing'!calculateS	"var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);"	amplitude := 1 max: amplitude.	period := period / tau.	s := (1 / amplitude) arcSin * period ! !!RSElasticInterpolator methodsFor: 'initialization'!initialize	super initialize.	tau := 2* Float pi.	amplitude := 1.	period := 0.3.		self calculateS! !!RSElasticInterpolator methodsFor: 'interpolation'!interpolateIn: i	| t |	t := i -1.	^ amplitude * (2 raisedTo: 10*t) * ((s - t) / period) sin! !!RSElasticInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2 - 1.	^ (t < 0		ifTrue: [ amplitude * (2 raisedTo: 10 * t) * ((s - t)/period) sin ]		ifFalse: [ 2 - (amplitude * (2 raisedTo: -10 * t) * ((s + t)/period) sin )   ]) / 2.! !!RSElasticInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ 1 - (amplitude * (2 raisedTo: -10 * t ) * ((t + s) / period) sin )! !!RSElasticInterpolator methodsFor: 'accessing'!period	^ period! !!RSElasticInterpolator methodsFor: 'accessing'!period: p	period := p.	self calculateS.! !!RSExpInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ 2 raisedTo: (10 * t - 10).! !!RSExpInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2. 	^ (t <= 1		ifTrue: [ 2 raisedTo: 10 * t - 10 ]		ifFalse: [ 2 - (2 raisedTo: 10 - (10 * t)) ])/2! !!RSExpInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ 1 - (2 raisedTo: -10 * t).! !!RSPolyInterpolator methodsFor: 'accessing'!exponent	^ exponent! !!RSPolyInterpolator methodsFor: 'accessing'!exponent: aNumber	exponent := aNumber! !!RSPolyInterpolator methodsFor: 'initialization'!initialize	super initialize.	self exponent: 3.! !!RSPolyInterpolator methodsFor: 'interpolation'!interpolateIn: i	^ i raisedTo: exponent.! !!RSPolyInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2.	^ (t <= 1		ifTrue: [ t raisedTo: exponent ]		ifFalse: [ 2 - ( ( 2 - t) raisedTo: exponent ) ]) / 2	! !!RSPolyInterpolator methodsFor: 'interpolation'!interpolateOut:  t	^ 1 - ((1 -t) raisedTo: exponent).! !!RSQuadInterpolator methodsFor: 'interpolation'!interpolateIn: t	 ^ t*t! !!RSQuadInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i *2.	^ (t <= 1 		ifTrue: [ t*t ]		ifFalse: [ 			t := t-1.			t * (2- t)+1 ]) /2	! !!RSQuadInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ t * (2 - t)! !!RSSinInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ 1 - (t * Float halfPi) cos! !!RSSinInterpolator methodsFor: 'interpolation'!interpolateInOut: t	^ (1 - (Float pi * t) cos ) / 2.! !!RSSinInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ (t * Float halfPi) sin! !!RSLinearInterpolator methodsFor: 'interpolation'!interpolate: aNumber	^ aNumber! !!RSShape methodsFor: '*Roassal3-Animation'!newAnimation	"Create a new animation"	^ parent newAnimation! !"Roassal3-Animation"!!RSLabelGenerator commentStamp: '' prior: 0!Reference: 	[1] An Extension of Wilkinson's Algorithm for positioning Tick Labels on Axes  (Justin Talbot, Sharon Lin, Pat Hanrahan)!!RSNiceLabel commentStamp: '' prior: 0!I am an utility class for RSLabelGenerator.-=-=-=-=-=-=-=-=-=values := #(1 2.3 4.3).c := RSChart new.d := RSScatterPlot new x: values y: values.c addPlot: d.c addDecoration: RSHorizontalTick new.tick := RSVerticalTick new.c addDecoration: tick.c build.tick createNiceLabelIn: c -=-=-=-=-=-=-=-=-=prints the following: "(Score: 0.75) 1.00	2.00	3.00	4.00	5.00	"					The min and max represents the range of the ticks!!RSNiceStep commentStamp: '' prior: 0!I am an utility class for RTNiceStepSizeGenerator>>next!!RSNiceStepSizeGenerator commentStamp: '' prior: 0!Nice numbers are just step sizes and used for tick spacing. We will use only niceStep tick spaces and place tick marks at multiples of tick spacing.    References:  	[1] An Extension of Wilkinson's Algorithm for positioning Tick Labels on Axes  		 				(Justin Talbot, Sharon Lin, Pat Hanrahan)   [2] Nice Numbers for Graph Labels (Paul S. Heckbert, Graphic Gems I)Here is an example on how to use it:-=-=-=-=-=-=-=-=-=nice := RSNiceStepSizeGenerator new.lg := RSLabelGenerator nice: nice.lg setLooseFlag: true.label := lg searchMin: -98.0 max: 18.0 desired: 3.label asString-=-=-=-=-=-=-=-=-=This prints  '(Score: 0.14) -100.00	-60.00	-20.00	20.00	'!!RSChart commentStamp: '' prior: 0!<keyClass>`RSChart` is the main class to build charts.*Responsibility*: maintain and render plots*Collaborators*: a chart closely interact with plots and decorations. *Variables*:- `plots`: the list of plots - `extent`: size of the produced chart. Note that this extent is for the area on which plots are draw. It does not comprise ticks and axis titles- `decorations`: collection of decorations to annotate the chart- `generator`: nice label generator, useful to have labels that are visually appealing- `colors`: default color palette*Example*:Here is an example that adjust the font size used for the title, and axis labels:```Smalltalkx := -3.14 to: 3.14 by: 0.1.y := x sin.c := RSChart new.c addPlot: (RSLinePlot new x: x y: y).c addDecoration: (RSChartTitleDecoration new title: 'hello'; fontSize: 20).c addDecoration: (RSXLabelDecoration new title: 'My X Axis'; fontSize: 12).c addDecoration: (RSYLabelDecoration new title: 'My Y Axis'; fontSize: 15; vertical).c```!!RSAbstractChartElement commentStamp: '' prior: 0!TODO!!RSAbstractPlot commentStamp: '' prior: 0!TODO!!RSAbstractTick commentStamp: '' prior: 0!TODO!!RSHorizontalTick commentStamp: '' prior: 0!TODO!!RSVerticalTick commentStamp: '' prior: 0!TODO!!RSBarPlot commentStamp: '' prior: 0!<keyClass>`RSBarPlot` is a plot for Roassal's chart that represents a bar chart.*Responsibility*: display a bar chart, with adequate color & bar width value per default.*Collaborators*: a bar plot is added to `RSChart`.*Variables*:- `barWidth`: width of a bar. A default computed value is assigned.*Example*:```Smalltalkdata := #(4 10 5 9).c := RSChart new.d := RSBarPlot new.d color: Color green darker darker darker.d y: data.c addPlot: d.c addDecoration: (RSVerticalTick new integer).c addDecoration: (RSHorizontalTick new).c addDecoration: (RSYLabelDecoration new title: 'Difference'; rotationAngle: -90; offset: -25 @ 0).c addDecoration: (RSXLabelDecoration new title: 'Evolution').c```!!RSLinePlot commentStamp: '' prior: 0!TODO!!RSScatterPlot commentStamp: '' prior: 0!<keyClass>`RSScatterPlot` is a scatter plot. Shapes are defined using two components, X and Y. *Responsibility*: create shapes that represent a scatter plot.*Collaborators*: used by `RSChart`*Variables*:- `processBlock`: is either `nil` or refer to a one argument block. This block is used to particularize the shapes.*Example*:```Smalltalkx := OrderedCollection new.y := OrderedCollection new.z := OrderedCollection new.r := Random seed: 42.1 to: 100 do: [ :i |	x add: i + (r nextInt: 10).	y add: i + (r nextInt: 10).	z add: i + (r nextInt: 10).].c := RSChart new.p := RSScatterPlot new x: x y: y.p color: Color blue translucent.p processBlock: [ :shapes | 		shapes models: z.		RSNormalizer size			shapes: shapes;			from: 2;			to: 10;			normalize: #yourself.		RSNormalizer color			shapes: shapes;			normalize: #yourself.						 ].c addPlot: p. c addDecoration: (RSHorizontalTick new doNotUseNiceLabel asFloat: 3).c addDecoration: RSVerticalTick new.c```!!RSChartDecoration commentStamp: '' prior: 0!TODO!!RSAbstractLabelDecoration commentStamp: '' prior: 0!TODO!!RSChartTitleDecoration commentStamp: '' prior: 0!TODO!!RSXLabelDecoration commentStamp: '' prior: 0!TODO!!RSYLabelDecoration commentStamp: '' prior: 0!TODO!!RSAbstractMarkerDecoration commentStamp: '' prior: 0!Set a marker in the chart. For example:=-=-=-==-=-=-==-=-=-=x := (-3.14 to: 3.14 by: 0.01).c := RSChart new.p := RSLinePlot new.p x: x y: x sin * 0.22.c addPlot: p.p := RSLinePlot new.p x: x y: x cos * 0.18.c addPlot: p.c addDecoration: RSHorizontalTick new.c addDecoration: (RSVerticalTick new asFloat).c addDecoration: (RSYMarkerDecoration new ).c =-=-=-==-=-=-==-=-=-=!!RSXMarkerDecoration commentStamp: '' prior: 0!Set some markers along the X axis. -=-=-=-=-=-=-=-=-=x := (-3.14 to: 3.14 by: 0.01).c := RSChart new.p := RSLinePlot new.p x: x y: x sin * 0.22 + 0.5.c addPlot: p.c addDecoration: RSHorizontalTick new.c addDecoration: (RSVerticalTick new asFloat).c addDecoration: (RSYMarkerDecoration new average).c addDecoration: (RSYMarkerDecoration new min).c addDecoration: (RSYMarkerDecoration new max).c addDecoration: (RSXMarkerDecoration new max).c addDecoration: (RSXMarkerDecoration new min).c addDecoration: (RSXMarkerDecoration new value: 0).c -=-=-=-=-=-=-=-=-=!!RSYMarkerDecoration commentStamp: '' prior: 0!Set some markers along the Y axis. -=-=-=-=-=-=-=-=-=x := (-3.14 to: 3.14 by: 0.01).c := RSChart new.p := RSLinePlot new.p x: x y: x sin * 0.22 + 0.5.c addPlot: p.c addDecoration: RSHorizontalTick new.c addDecoration: (RSVerticalTick new asFloat).c addDecoration: (RSYMarkerDecoration new average).c addDecoration: (RSYMarkerDecoration new min).c addDecoration: (RSYMarkerDecoration new max).c addDecoration: (RSXMarkerDecoration new max).c addDecoration: (RSXMarkerDecoration new min).c addDecoration: (RSXMarkerDecoration new value: 0).c -=-=-=-=-=-=-=-=-=!!RSChartSpineDecoration commentStamp: '' prior: 0!The PLTSpineDecoration class represent the spine of a matplot visualization. It represents the surrounding box that contains plots and scatters.The class has the responsibilty to draw a usually black box around a visualization. The class collaborates with PLT and PLTTitleDecoration. The PLTTitleDecoration class requires the shape in order to put a title above.The method is not meant to be used by a normal user as it represents a functionality to be used directly by PLT, and does not offer much configuration.  Instance Variables	shape:		<TSBox>	The box that surrounds the visualization!!RSTickConfiguration commentStamp: '' prior: 0!<keyClass>`RSTickConfiguration` describes a configuration for a vertical or horizontal tick. Note that the same configuration can be shared for the two tick objects.*Responsibility*: maintain the different configurable attributes for vertical or horizontal tickis.*Collaborators*: used by `RSAbstractTick`*Variables*:- `numberOfTicks`: number of ticks the tick decoration should have- `shouldHaveLabels`: a boolean indicating whether a the tick should have labels or not- `labelConversion`: one arg block to transform a value. E.g., `[ :p | 'V', p asString ]`- `shouldUseNiceLabel`: a boolean indicating whether the tick should use the nice tick label generator (e.g., `RSNiceLabel`)- `labelRotation`: rotation degree of the label- `fontSize`: size of the label font- `tickSize`: size of the tick, in pixels*Example*:```Smalltalkclasses := RSObject withAllSubclasses.x := classes collect: [ :c | c numberOfMethods ].y := classes collect: [ :c | c linesOfCode ].c := RSChart new.d := RSScatterPlot new.d color: Color blue translucent.d x: x y: y.c addPlot: d.tickConfiguration := RSTickConfiguration new		numberOfTicks: 5;		fontSize: 5;		labelRotation: 0;		shouldHaveLabels: true;		shouldUseNiceLabel: true;		labelConversion: [ :value | value ] ;		tickSize: 3;		yourself.c addDecoration: (RSHorizontalTick new configuration: tickConfiguration).c addDecoration: (RSVerticalTick new configuration: tickConfiguration).c```Another similar example:```Smalltalkclasses := RSObject withAllSubclasses.x := classes collect: [ :c | c numberOfMethods ].y := classes collect: [ :c | c linesOfCode ].c := RSChart new.d := RSScatterPlot new.d color: Color blue translucent.d x: x y: y.c addPlot: d.tickConfiguration := RSTickConfiguration new.tickConfiguration labelConversion: [ :p | 'V', p asString ].c addDecoration: (RSHorizontalTick new configuration: tickConfiguration).c```!!Number methodsFor: '*Roassal3-Chart'!to: step count: count	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by step."	^ self to: step by: (step - self) / (count - 1)! !!RSLabelGenerator class methodsFor: 'instance creation'!nice: aNiceGenerator	^ self new nice: aNiceGenerator! !!RSLabelGenerator methodsFor: 'private'!coverageMin: dmin max: dmax lmin: lmin lmax: lmax	| a b c|	a := dmax - lmax.	b := dmin - lmin.	c := 0.1 * (dmax - dmin).	^ 1 - ( 0.5 * (((a * a) + (b * b))/ (c * c)) )	! !!RSLabelGenerator methodsFor: 'private'!coverageMin: dmin max: dmax span: span	| range r half|	range := dmax - dmin.	(span > range) ifTrue: [ 		half := (span - range)/2.		r := 0.1*range.		^ 1 - (half * half / (r * r) )].	^ 1.0! !!RSLabelGenerator methodsFor: 'private'!density: k m: m dmin: dmin dmax: dmax lmin: lmin lmax: lmax	"* k		number of labels	 * m		number of desired labels	 * dmin	data range minimum	 * dmax	data range maximum	 * lmin	label range minimum	 * lmax	label range maximum	 * ^	density	  	 k-1 number of intervals between labels	 m-1 number of intervals between desired number of labels	 r   label interval length/label range	 rt  desired label interval length/actual range"	| r rt |	r := (k -1)/(lmax - lmin).	rt := (m - 1)/((lmax max: dmax) - (lmin min: dmin) ).	^ 2 - ( (r/rt) max: (rt/r) ).! !!RSLabelGenerator methodsFor: 'private'!densityMax: k m: m	(k >= m) ifTrue: [ ^ 2 - ((k-1)/(m-1)) ].	^ 1! !!RSLabelGenerator methodsFor: 'private'!epsilon	" Compute the machine epsilon for the float type, the largest positive  	floating-point value that, when added to 1, results in a value equal to 1 due to  	roundoff."	| temp |	epsilon ifNotNil: [ ^ epsilon ].	temp := 0.5.	[ (1 + temp) > 1 ] whileTrue: [ temp := temp / 2 ].	epsilon := temp.	^ epsilon.	! !!RSLabelGenerator methodsFor: 'private'!flooredMod: a n: num	^ a - (num * (a / num) floor).! !!RSLabelGenerator methodsFor: 'initialization'!initialize	super initialize.	nice := nil.	loose := false.	w := #(0.25 0.2 0.5 0.05).	self nice: RSNiceStepSizeGenerator new.! !!RSLabelGenerator methodsFor: 'private'!legibility: min max: max step: step	^ 1! !!RSLabelGenerator methodsFor: 'public'!nice: aNiceGenerator	nice := aNiceGenerator! !!RSLabelGenerator methodsFor: 'public'!searchMin: dmin max: dmax desired: desiredNumberOfTicks	| best sm dm cm delta bestScore k |	best := RSNiceLabel new.	bestScore := -2.	desiredNumberOfTicks <= 0 ifTrue: [ self error: 'The minimun value of desiredNumberOfTicks is 1' ].		"In case of a particular situation"	(dmin = 0 and: [ dmax = 0 ]) ifTrue: [ 		best			min: 0;			max: 1;			step: 1;			score: bestScore.		^ best ].		[ :break |		[ true ] whileTrue: [ 			n := nice next.			sm := self simplicityMax.			((self w: sm c: 1 d: 1 l: 1) < bestScore)				ifTrue: [ break value ].			k := 2.			[ :break2 |				[ true ] whileTrue: [ | z |					dm := [ self densityMax: k m: desiredNumberOfTicks ] on: ZeroDivide do: [ :ex | self error: 'Please increase the value of desiredNumberOfTicks/labels' ].					((self w: sm c: 1 d: dm l: 1) < bestScore) 						ifTrue: [ break2 value ].					delta := (dmax - dmin)/(k+1)/ n j/ (nice qat: n i).					z := (nice logB: delta) ceiling.					[ :break3|						[ true ] whileTrue: [ 							[ :continue | | minStart maxStart step |								step := n j * (nice qat: n i) * (nice base raisedTo: z).								cm := self coverageMin: dmin max: dmax span: step * (k-1).								((self w: sm c: cm d: dm l: 1) < bestScore) 									ifTrue: [ break3 value ].								minStart := ((dmax / step) floor - (k-1)) * n j.								maxStart := (dmin / step) ceiling * n j.								(minStart > maxStart) ifTrue: [ 									z := z +1.									continue value. ].														(minStart to: maxStart) do: [ :start |									| lmin lmax lstep c s d l score |									lmin := start * step / n j. 									lmax := lmin + (step * (k -1)).									lstep := step.									c := self coverageMin: dmin max: dmax lmin: lmin lmax: lmax.									s := self simplicity: lmin max: lmax step: lstep.									d := self density: k m: desiredNumberOfTicks dmin: dmin dmax: dmax lmin: lmin lmax: lmax.									l := self legibility: lmin max: lmax step: lstep.									score := self w: s c: c d: d l: l.																((score > bestScore) and: 									[ loose not or: [ (lmin <= dmin) and: 														  [ lmax >= dmax ] ] ]) ifTrue: [										best											min: lmin;											max: lmax;											step: lstep;											score: score.											bestScore := score.									 ].								].								z := z +1.							] valueWithExit.						].					] valueWithExit. 					k := k +1.				].			] valueWithExit.		 ]	] valueWithExit.		nice reset.		^ best.! !!RSLabelGenerator methodsFor: 'public'!setLooseFlag: aBool	"Configuration to 'loose' labelings.	The extreme labels can be placement both inside(setLooseFlag: false) and outside (setLooseFlag: true) of the range of the data.		Example	.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=	lg setLooseFlag: true.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self assert: label asString = '(Score: 0.14) -100.00	-60.00	-20.00	20.00	'.	lg setLooseFlag: false.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self assert: label asString = '(Score: 0.62) -100.00	-50.00	0.00	'.	.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=	"	loose := aBool.	nice reset.! !!RSLabelGenerator methodsFor: 'private'!simplicity: min max: max step: step	(nice qvar size > 1) ifTrue: [ 		^ 1 - (n i/ (nice qvar size - 1)) - n j + (self vMin: min max: max step: step) ].	^ 1 - n j + (self vMin: min max: max step: step)		! !!RSLabelGenerator methodsFor: 'private'!simplicityMax	(nice qvar size > 1) ifTrue: [ ^ 1 - ((n i )/(nice qvar size -1)) - n j + 1.0 ].	 ^ 1 - n j + 1.0! !!RSLabelGenerator methodsFor: 'private'!vMin: min max: max step: step	^ ((self flooredMod: min n: step) < (self epsilon) 	and: [ min <= 0 and: [ max >= 0 ] ]) ifTrue: [ 1 ] ifFalse: [ 0 ]! !!RSLabelGenerator methodsFor: 'private'!w: s c: c d: d l: l	^ (w first * s) + (w second * c) + (w third * d) + (w fourth * l)! !!RSNiceLabel methodsFor: 'initialization'!initialize	super initialize.	score := 0.! !!RSNiceLabel methodsFor: 'accessing'!max	^ max! !!RSNiceLabel methodsFor: 'accessing'!max: aNumber	max := aNumber! !!RSNiceLabel methodsFor: 'accessing'!min	^ min! !!RSNiceLabel methodsFor: 'accessing'!min: aNumber	min := aNumber! !!RSNiceLabel methodsFor: 'accessing'!numberOfTicks	^ self ticks / step.! !!RSNiceLabel methodsFor: 'printing'!printOn: aStream	| x |	aStream 		nextPutAll: '(Score: ';		nextPutAll: (score printShowingDecimalPlaces: 2);		nextPutAll: ') '.	x := min.	[x <= max ] whileTrue: [ 		aStream nextPutAll: (x printShowingDecimalPlaces: 2).		aStream nextPutAll: String tab.		x := x + step ].		! !!RSNiceLabel methodsFor: 'accessing'!score	^ score! !!RSNiceLabel methodsFor: 'accessing'!score: aNumber	score := aNumber! !!RSNiceLabel methodsFor: 'accessing'!step	^ step! !!RSNiceLabel methodsFor: 'accessing'!step: aNumber	step := aNumber! !!RSNiceLabel methodsFor: 'accessing'!ticks	^  min < 0 ifTrue: [ 		 max < 0 			ifTrue: [ (max - min) abs ] 			ifFalse: [ max + min abs  ]	] ifFalse: [ max - min ]! !!RSNiceStep methodsFor: 'accessing'!i	^ i! !!RSNiceStep methodsFor: 'accessing'!i: aNumber	i := aNumber! !!RSNiceStep methodsFor: 'accessing'!j	^ j! !!RSNiceStep methodsFor: 'accessing'!j: aNumber	j := aNumber! !!RSNiceStep methodsFor: 'accessing'!offset	^ offset! !!RSNiceStep methodsFor: 'accessing'!offset: aNumber	offset := aNumber! !!RSNiceStep methodsFor: 'accessing'!stepSize	^ stepSize! !!RSNiceStep methodsFor: 'accessing'!stepSize: aNumber	stepSize := aNumber! !!RSNiceStepSizeGenerator methodsFor: 'accessing'!base	^ base! !!RSNiceStepSizeGenerator methodsFor: 'initialization'!initialize	"Generates a NiceNumberGenerator"		super initialize.	niceStep := RSNiceStep new.	o := 0.0.	self setQ: #(1 5 2 2.5 4 3) base: 10.	! !!RSNiceStepSizeGenerator methodsFor: 'private'!logB: a	^ a ln / base ln! !!RSNiceStepSizeGenerator methodsFor: 'public'!next	| oSet |		niceStep		stepSize: ss;		offset: o;		i: i; "all output and calculations shouls add 1 because wilkinsons index start from 1"		j: j.	"Keep track of existing offsets and stepSizes to avoid duplicate returns of 	step size, offset pairs"	(ssOffMap includesKey: ss) ifTrue: [ 		oSet := ssOffMap at: ss.		[ | b | 			b := oSet includes: o.			oSet add: o.			b not and: [io < (ovar size - 1)] ] whileTrue: [			 io := io +1.			 niceStep offset: (o := ovar at: io +1 ). ].		 ] ifFalse: [ 		oSet := Set new.		oSet add: o.		ssOffMap at: ss put: oSet.		 ].	io := io +1."position for next offset if it exists"		"iterate for next call"	io < ovar size ifTrue: [ o := ovar at: io +1  ]	ifFalse: [ 		io := 0.		i := (i< (qvar size - 1) ) ifTrue: [ i+1 ] ifFalse: [ 0 ] .		j := i = 0 ifTrue: [ j+1 ] ifFalse: [ j ].		q := self qat: i.		ss := self stepSize: j q: q.		ovar := self offsets: j q: q.		o := ovar at: io + 1.	].	resetRequired := true.	^ niceStep! !!RSNiceStepSizeGenerator methodsFor: 'private'!offsets: tj q: tq	| offs |	offs := Array new: tj.	(0 to: tj-1) do: [ :ti |		offs at: ti+1 put: ((tq*ti) raisedTo: (self logB: tj*tq) ) ].	^ offs! !!RSNiceStepSizeGenerator methodsFor: 'private'!qat: index	^ qvar at: index + 1! !!RSNiceStepSizeGenerator methodsFor: 'accessing'!qvar	^ qvar! !!RSNiceStepSizeGenerator methodsFor: 'public'!reset	resetRequired ifFalse: [ ^ self ].	i := 0.	io := 0.	j := 1.	q := self qat: i.	ss := self stepSize: j q: q.	ssOffMap := Dictionary new.	resetRequired := false.! !!RSNiceStepSizeGenerator methodsFor: 'initialization'!setQ: anArray base: aNumber	"anArray: preference ordered list of niceStep step sizes. 	The deault is set by the initializer selector		aNumber: is a number of logs and exps usually changed together with Q"	qvar := anArray.	base := aNumber.	i := 0.	io := 0.	j := 1.	q := self qat: i.	ss := self stepSize: j q: q.	ovar := self offsets: j q: q.	ssOffMap := Dictionary new.	resetRequired := false.		! !!RSNiceStepSizeGenerator methodsFor: 'private'!stepSize: tj q: tq	^ tj * tq / (base raisedTo: (self logB: tj*tq ) floor ).	! !!RSChart methodsFor: 'adding'!addDecoration: aDecoration	"Add a decoration to the chartFor example:```Smalltalkx := -3.14 to: 3.14 by: 0.1.y := x sin.c := RSChart new.c addPlot: (RSLinePlot new x: x y: y).c addDecoration: (RSHorizontalTick new).c addDecoration: (RSVerticalTick new).c```"	decorations add: aDecoration.	aDecoration chart: self! !!RSChart methodsFor: 'adding'!addPlot: aPlot	"Add a plot to the chart.	For example:```Smalltalkx := -3.14 to: 3.14 by: 0.1.y := x sin.c := RSChart new.c addPlot: (RSLinePlot new x: x y: y).c```	"	plots add: aPlot.	aPlot chart: self! !!RSChart methodsFor: 'color'!colorFor: aRSPlot 	"Return a color for the given plot. Colors are defined as in #defaultPlotColors"	^ colors scale: aRSPlot! !!RSChart methodsFor: 'accessing'!colors	"Return the palette"	^ colors! !!RSChart methodsFor: 'accessing'!colors: someColors	"Set the palette to be use to plots"	colors := someColors! !!RSChart methodsFor: 'accessing'!decorations	"Return the list of decorations used to annotate plots"	^ decorations! !!RSChart methodsFor: 'defaults'!defaultContainer	^ RSCanvas new @ RSCanvasController! !!RSChart methodsFor: 'color'!defaultPlotColors	^ NSScale category20! !!RSChart methodsFor: 'accessing'!extent	^ extent! !!RSChart methodsFor: 'accessing'!extent: aPoint	extent := aPoint! !!RSChart methodsFor: 'visualization'!gtInspectorViewIn: composite	<gtInspectorPresentationOrder: -10>	composite roassal3		title: ['Canvas'];		initializeCanvas: [ self build; canvas ]		! !!RSChart methodsFor: 'initialization'!initialize	super initialize.	plots := OrderedCollection new.	extent := 200 @ 200.	self initializeDecorations.	colors := self defaultPlotColors.! !!RSChart methodsFor: 'initialization'!initializeDecorations	decorations := OrderedCollection new.	self addDecoration: RSChartSpineDecoration new.! !!RSChart methodsFor: 'accessing'!maxValueX 	^ maxValueX ifNil: [ maxValueX := (plots collect: #maxValueX) max ].! !!RSChart methodsFor: 'accessing'!maxValueX: aNumber	maxValueX := aNumber! !!RSChart methodsFor: 'accessing'!maxValueY	^ maxValueY ifNil: [ maxValueY := (plots collect: #maxValueY) max ]! !!RSChart methodsFor: 'accessing'!maxValueY: aNumber	maxValueY := aNumber! !!RSChart methodsFor: 'accessing'!minValueX 	^ minValueX ifNil: [ minValueX := (plots collect: #minValueX) min ]! !!RSChart methodsFor: 'accessing'!minValueX: aNumber	minValueX := aNumber! !!RSChart methodsFor: 'accessing'!minValueY		^ minValueY ifNil: [ minValueY := (plots collect: #minValueY) min ]! !!RSChart methodsFor: 'accessing'!minValueY: aNumber	minValueY := aNumber! !!RSChart methodsFor: 'public - configuration'!mustInclude0inX	"Make sure that the 0 value is in the chart"	((self minValueX to: self maxValueX) includes: 0) ifTrue: [ ^ self ].		self maxValueX > 0 		ifTrue: [ self minValueX: 0 ]		ifFalse: [ self maxValueX: 0 ]! !!RSChart methodsFor: 'public - configuration'!mustInclude0inY	"Make sure that the 0 value is in the chart"	((self minValueY to: self maxValueY) includes: 0) ifTrue: [ ^ self ].		self maxValueY > 0 		ifTrue: [ self minValueY: 0 ]		ifFalse: [ self maxValueY: 0 ]! !!RSChart methodsFor: 'accessing'!niceGenerator	"Produce a generator for nice labels. Whether nice labels are used or not is a choice made by the horizontal or vertical ticks."	^ generator ifNil: [ 		generator := RSLabelGenerator new.		generator setLooseFlag: true.		generator ].! !!RSChart methodsFor: 'accessing'!numberOfPlots	"Return the number of plots contained in the chart"	^ plots size! !!RSChart methodsFor: 'public'!open	"Open the chart in a new window. For example-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=x := (-3.14 to: 3.14 by: 0.1).y := x sin * 0.22.c := RSChart new.p := RSLinePlot new.p x: x y: y.c addPlot: p.c addDecoration: RSHorizontalTick new.c addDecoration: (RSVerticalTick new asFloat).c open-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	"	self build.	^ self canvas open! !!RSChart methodsFor: 'accessing'!plots	^ plots! !!RSChart methodsFor: 'building'!renderDecorationIn: aCanvas	decorations do: [ :d | d renderIn: aCanvas ]! !!RSChart methodsFor: 'hooks'!renderIn: aCanvas	decorations, plots do: [ :e | e beforeRenderingIn: self ].	self renderDecorationIn: aCanvas.	self renderPlotsIn: aCanvas! !!RSChart methodsFor: 'building'!renderPlotsIn: aCanvas	plots do: [ :p | p renderIn: aCanvas ].	! !!RSChart methodsFor: 'building'!show	^ self open! !!RSChart methodsFor: 'accessing'!title: aTitle	"Set the title of a chart. For example:	```Smalltalkc := RSChart new.c addPlot: (RSLinePlot new x: (1 to: 200) y: (1 to: 200) sqrt).c title: 'Square root'.c```	"	self addDecoration: (RSChartTitleDecoration new title: aTitle)! !!RSChart methodsFor: 'public - scales'!xLinear	^ self xScale: NSScale linear! !!RSChart methodsFor: 'public - scales'!xLn	^ self xScale: NSScale ln! !!RSChart methodsFor: 'public - scales'!xLog	^ self xScale: NSScale symlog! !!RSChart methodsFor: 'public - scales'!xRawLog	self xScale: NSScale log! !!RSChart methodsFor: 'public - scales'!xScale: aScale	plots, decorations do: [ :e | e xScale: aScale ].	^ aScale! !!RSChart methodsFor: 'public - scales'!xSqrt	^ self xScale: NSScale sqrt! !!RSChart methodsFor: 'decoration'!xlabel: aTitle	self addDecoration: (RSXLabelDecoration new title: aTitle)! !!RSChart methodsFor: 'public - scales'!yLinear	^ self yScale: NSScale linear! !!RSChart methodsFor: 'public - scales'!yLn	^ self yScale: NSScale ln! !!RSChart methodsFor: 'public - scales'!yLog	^ self yScale: NSScale symlog! !!RSChart methodsFor: 'public - scales'!yRawLog	"ensure all your data and axis do not contains zero"	^ self yScale: NSScale log! !!RSChart methodsFor: 'public - scales'!yScale: aScale	plots, decorations do: [ :e | e yScale: aScale ].	^ aScale! !!RSChart methodsFor: 'public - scales'!ySqrt	^ self yScale: NSScale sqrt! !!RSChart methodsFor: 'decoration'!ylabel: aTitle	self addDecoration: (RSYLabelDecoration new title: aTitle)! !!RSAbstractChartElement methodsFor: 'rendering'!addShape: aShape	"Add a shape to the canvas"	chart canvas add: aShape! !!RSAbstractChartElement methodsFor: 'rendering'!beforeRenderingIn: aChart	"do nothing here"! !!RSAbstractChartElement methodsFor: 'accessing'!chart	^ chart! !!RSAbstractChartElement methodsFor: 'accessing'!chart: aChart	chart := aChart! !!RSAbstractChartElement methodsFor: 'public'!computeColor	"Return the color used by the chart element. The color is computed from the chart and from the colorBlock variable"	^ self color ifNil:  [ chart colorFor: self ].! !!RSAbstractChartElement methodsFor: 'rendering'!createXScale	xScale ifNil: [ xScale := NSScale linear ].	xScale		domain:			{chart minValueX.			chart maxValueX};		range:			{0.			chart extent x}! !!RSAbstractChartElement methodsFor: 'rendering'!createYScale	yScale ifNil: [ yScale := NSScale linear ].	yScale		domain:			{chart minValueY.			chart maxValueY};		range:			{0.			chart extent y negated}! !!RSAbstractChartElement methodsFor: 'rendering'!renderIn: canvas	"Need to be overridden in subclasses. This methods has to be use trachel to enrich a visualization"	self subclassResponsibility! !!RSAbstractChartElement methodsFor: 'rendering'!spine	"Return the Trachel shape that describe the spine"	^ (chart decorations		detect: [ :d | d class == RSChartSpineDecoration ]		ifNone: [ self error: 'No spine is added in the plt, you need to add one' ])		shape! !!RSAbstractChartElement methodsFor: 'accessing'!xScale	^ xScale! !!RSAbstractChartElement methodsFor: 'accessing'!xScale: aScale	xScale := aScale! !!RSAbstractChartElement methodsFor: 'accessing'!yScale	^ yScale! !!RSAbstractChartElement methodsFor: 'accessing'!yScale: aScale	yScale := aScale! !!RSAbstractPlot methodsFor: 'rendering'!beforeRenderingIn: aChart	super beforeRenderingIn: aChart.	self createXScale.	self createYScale! !!RSAbstractPlot methodsFor: 'testing'!checkAssertion	self		assert: [ xValues notNil and: [ yValues notNil ] ]		description: 'X and Y values must be added'.	self		assert: [ xValues size = yValues size ]		description: 'X and Y values have not the same size, and they should'! !!RSAbstractPlot methodsFor: 'public - shape'!color	^ self shape color! !!RSAbstractPlot methodsFor: 'public - shape'!color: aColor	self shape color: aColor! !!RSAbstractPlot methodsFor: 'initialization'!defaultShape	^ self subclassResponsibility! !!RSAbstractPlot methodsFor: 'rendering'!definedValuesX	"Return the list of X values that are defined"	^ xValues select: [ :v | v isNaN not and: [ v isInfinite not ] ]! !!RSAbstractPlot methodsFor: 'rendering'!definedValuesY	"Return the list Y values that are defined"	^ yValues select: [ :v | v isNaN not and: [ v isInfinite not ] ]! !!RSAbstractPlot methodsFor: 'accessing'!index	"Return the index of the plot within the list of plots to display in the plt object"	^ chart plots indexOf: self! !!RSAbstractPlot methodsFor: 'initialization'!initialize	super initialize.	shape := self defaultShape! !!RSAbstractPlot methodsFor: 'testing'!isPointWellDefined: aPoint	"Indicate whether the point deserves to be displayed"	^ (aPoint x isInfinite not and: [ aPoint y isInfinite not ])		and: [ (aPoint x isNaN not and: [ aPoint y isNaN not ]) ]! !!RSAbstractPlot methodsFor: 'rendering'!maxValueX	"Return the maximum X value of the plot, excluding NaN and infinite"	^ self definedValuesX max! !!RSAbstractPlot methodsFor: 'rendering'!maxValueY	"Return the maximum Y value of the plot, excluding NaN and infinite"	^ self definedValuesY max! !!RSAbstractPlot methodsFor: 'rendering'!minValueX	"Return the minimum X value of the plot, excluding NaN and infinite"	^ self definedValuesX min! !!RSAbstractPlot methodsFor: 'rendering'!minValueY	"Return the minimum Y value of the plot, excluding NaN and infinite"	^ self definedValuesY min! !!RSAbstractPlot methodsFor: 'public - shape'!shape	^ shape! !!RSAbstractPlot methodsFor: 'public - shape'!shape: aShape	shape := aShape! !!RSAbstractPlot methodsFor: 'public'!x: aCollection y: aCollection2 	"Define a plot with the X and Y coordinates. Both X and Y are collections of the same size.		For example:-=-=-=-=-=-=-=-=-=x := (-3.14 to: 3.14 by: 0.01).c := RSChart new.p := RSLinePlot new.p x: x y: x sin * 0.22.c addPlot: p.p := RSLinePlot new.p x: x y: x cos * 0.18.c addPlot: p.c addDecoration: RSHorizontalTick new.c addDecoration: (RSVerticalTick new asFloat).c addDecoration: (RSYMarkerDecoration new ).c -=-=-=-=-=-=-=-=-=	"	xValues := aCollection.	yValues := aCollection2! !!RSAbstractPlot methodsFor: 'public'!y: aCollection	"Define a plot with only a Y coordinate. The X coordinate is the index of the data point.		For example:-=-=-=-=-=-=-=-=-=x := (-3.14 to: 3.14 by: 0.01).c := RSChart new.p := RSLinePlot new.p y: x sin * 0.22.c addPlot: p.p := RSLinePlot new.p y: x cos * 0.18.c addPlot: p.c addDecoration: RSHorizontalTick new.c addDecoration: (RSVerticalTick new asFloat).c -=-=-=-=-=-=-=-=-=	"	self x: (1 to: aCollection size) y: aCollection! !!RSAbstractTick methodsFor: 'public'!asFloat	self asFloat: 3! !!RSAbstractTick methodsFor: 'public'!asFloat: numberOfDecimals	"Do not convert the value when determining labels"	self labelConversion: [ :value | value asFloat round: numberOfDecimals ]! !!RSAbstractTick methodsFor: 'rendering'!beforeRenderingIn: aChart	niceLabel := self configuration shouldUseNiceLabel 		ifTrue: [ self createNiceLabelIn: aChart ]		ifFalse: [ self defaultNiceLabel ].	super beforeRenderingIn: aChart.! !!RSAbstractTick methodsFor: 'accessing'!configuration	^ configuration ifNil: [ configuration := self defaultConfiguration ]! !!RSAbstractTick methodsFor: 'accessing'!configuration: aRSTickConfiguration	configuration := aRSTickConfiguration! !!RSAbstractTick methodsFor: 'rendering'!createLabelFor: aValue	"Create a label and returns it."	^ self configuration createLabelFor: aValue! !!RSAbstractTick methodsFor: 'rendering'!createLabelFor: aValue index: index	"Create a label and returns it."	| tick lbl |	tick := self ticks at: index.	lbl := self configuration createLabelFor: aValue.	self labelLocation move: lbl on: tick.	^ lbl	! !!RSAbstractTick methodsFor: 'accessing'!createNiceLabelIn: aChart	| nice |	nice := aChart niceGenerator 		searchMin: self min		max: self max		desired: self configuration numberOfTicks.	^ nice! !!RSAbstractTick methodsFor: 'rendering'!createTickLineFor: aNumber	^ self subclassResponsibility! !!RSAbstractTick methodsFor: 'accessing - defaults'!defaultConfiguration	^ RSTickConfiguration new		numberOfTicks: 5;		fontSize: 5;		labelRotation: 0;		shouldHaveLabels: true;		shouldUseNiceLabel: true;		labelConversion: [ :value | value ] ;		tickSize: 3;		yourself! !!RSAbstractTick methodsFor: 'accessing - defaults'!defaultLabelLocation	^ self subclassResponsibility! !!RSAbstractTick methodsFor: 'accessing - defaults'!defaultNiceLabel	| nice |	nice := RSNiceLabel new.	nice		min: self min;		max: self max;		step: nice ticks / self configuration numberOfTicks.	^ nice! !!RSAbstractTick methodsFor: 'initialization'!defaultShape	^ RSLine new! !!RSAbstractTick methodsFor: 'public'!doNotUseNiceLabel	"Ticks use RSNiceLabelGenerator"	self configuration shouldUseNiceLabel: false! !!RSAbstractTick methodsFor: 'accessing'!fontSize: fontSizeToSet	"Set the font size used by the labels associated to ticks"	"For example:-=-=-=-=-=-=-=-=-=x := (-10 to: 10).y := x * x.c := RSChart new.d := RSLinePlot new x: x y: y.c addPlot: d.c extent: 400 @ 400.c addDecoration: (RSVerticalTick new fontSize: 20).c addDecoration: (RSHorizontalTick new fontSize: 20).c-=-=-=-=-=-=-=-=-="	self configuration fontSize: fontSizeToSet! !!RSAbstractTick methodsFor: 'public'!integer	"Do not convert the value when determining labels"	self labelConversion: [ :value | value asInteger ]! !!RSAbstractTick methodsFor: 'public'!integerWithCommas	"Do not convert the value when determining labels"	self labelConversion: [ :value | value asInteger asStringWithCommas ]! !!RSAbstractTick methodsFor: 'public'!labelConversion: oneArgBlock	"This method is used to convert numerical values into a label. This is useful to particularlize labels on the X or Y axes. The parameter block accepts one argument, which is a numerical value. The block should return a string or any other object. When displayed, the message asString will be sent to it. 		For example:-=-=-=-=-=-=-=-=-=x := #(-2 -1 0 1 2).y := #(5 10 12 14 20).c := RSChart new.d := RSLinePlot new x: x y: y.c addPlot: d.c addDecoration: (RSVerticalTick new).c addDecoration: (RSHorizontalTick new 							numberOfTicks: x size; 							labelConversion: [ :val | Date today addDays: val ] ).c mustInclude0inY.c-=-=-=-=-=-=-=-=-=	"	self configuration labelConversion: oneArgBlock ! !!RSAbstractTick methodsFor: 'accessing'!labelLocation	^ labelLocation ifNil: [ labelLocation := self defaultLabelLocation ].! !!RSAbstractTick methodsFor: 'accessing'!labelRotation	^ self configuration labelRotation! !!RSAbstractTick methodsFor: 'accessing'!labelRotation: aNumber	^ self configuration labelRotation: aNumber! !!RSAbstractTick methodsFor: 'accessing'!labels	^ labels! !!RSAbstractTick methodsFor: 'accessing'!max	^ self subclassResponsibility! !!RSAbstractTick methodsFor: 'accessing'!min	^ self subclassResponsibility! !!RSAbstractTick methodsFor: 'public'!noConvertion	"Do not convert the value when determining labels"	self labelConversion: [ :value | value ]! !!RSAbstractTick methodsFor: 'accessing'!numberOfTicks: aNumber	"Set the number of ticks to be used. Can be used with doNotUseNiceLabels or not.	For example:```Smalltalkx := (-3.14 to: 3.14 count: 20).y := x sin.c := RSChart new.d := RSLinePlot new x: x y: y.c addPlot: d.c addDecoration: (RSVerticalTick new).c addDecoration: (RSHorizontalTick new numberOfTicks: 10; asFloat: 2).c```Smalltalk	"	self configuration numberOfTicks: aNumber! !!RSAbstractTick methodsFor: 'rendering'!renderIn: canvas	| ticksData |	niceLabel step isZero ifTrue: [ niceLabel step: 1 ].	ticksData := niceLabel min to: niceLabel max by: niceLabel step. 	ticks := ticksData collect: [ :value | self createTickLineFor: value ].	canvas addAll: ticks.	self configuration shouldHaveLabels ifFalse: [ ^ self ].	labels := ticksData collectWithIndex: [ :value :index | 		self createLabelFor: value index: index ].	canvas addAll: labels.! !!RSAbstractTick methodsFor: 'accessing'!ticks	^ ticks! !!RSAbstractTick methodsFor: 'public'!useNiceLabel	"Ticks use RSNiceLabelGenerator"	self configuration shouldUseNiceLabel: true! !!RSAbstractTick methodsFor: 'public'!withLabels	"Make the tick have label"	self configuration shouldHaveLabels: true! !!RSAbstractTick methodsFor: 'public'!withNoLabels	"Ticks have no label"	self configuration shouldHaveLabels: false! !!RSHorizontalTick methodsFor: 'rendering'!createNiceLabelIn: aChart	| nice |	nice := super createNiceLabelIn: aChart.	aChart 		minValueX: nice min;		maxValueX: nice max.	^ nice! !!RSHorizontalTick methodsFor: 'rendering'!createTickLineFor: aNumber	^ self shape copy		startPoint: (xScale scale: aNumber) @ 0;		endPoint: (xScale scale: aNumber) @ self configuration tickSize;		yourself! !!RSHorizontalTick methodsFor: 'accessing - defaults'!defaultLabelLocation	^ RSLocation new below offset: 0@3! !!RSHorizontalTick methodsFor: 'public'!fromNames: aCollectionOfStrings	self		doNotUseNiceLabel;		numberOfTicks: aCollectionOfStrings size.	self labelRotation: -45.	self labelConversion: [ :x | 		x isZero 			ifTrue: [ '' ]			ifFalse: [aCollectionOfStrings at: x  ] ].		! !!RSHorizontalTick methodsFor: 'accessing'!max	^ chart maxValueX! !!RSHorizontalTick methodsFor: 'accessing'!min	^ chart minValueX! !!RSVerticalTick methodsFor: 'rendering'!createNiceLabelIn: aChart	| nice |	nice := super createNiceLabelIn: aChart.	aChart 		minValueY: nice min;		maxValueY: nice max.	^ nice! !!RSVerticalTick methodsFor: 'rendering'!createTickLineFor: aNumber	| scaledNumber |	scaledNumber := yScale scale: aNumber.	self assert: [ scaledNumber isInfinite not ].	self assert: [ scaledNumber isNaN not ].	^ self shape copy		startPoint: 0 @ scaledNumber;		endPoint: self configuration tickSize negated @ scaledNumber;		yourself! !!RSVerticalTick methodsFor: 'accessing - defaults'!defaultLabelLocation	^ RSLocation new outer; left; offset: -2@0! !!RSVerticalTick methodsFor: 'accessing'!max	^ chart maxValueY! !!RSVerticalTick methodsFor: 'accessing'!min	^ chart minValueY! !!RSBarPlot methodsFor: 'accessing'!barScale	^ NSOrdinalScale new 		domain: xValues;		rangeBands: xScale range padding: 0.1.! !!RSBarPlot methodsFor: 'accessing'!barWidth	"Return the width of each bar"	^ barWidth! !!RSBarPlot methodsFor: 'accessing'!barWidth: aBarWidth	"Set the width of the bar"	barWidth := aBarWidth! !!RSBarPlot methodsFor: 'rendering'!beforeRenderingIn: aChart	super beforeRenderingIn: aChart.		aChart xScale: self barScale.	"aChart decorations do: [ :e | e beforeRenderingIn: aChart ].		"! !!RSBarPlot methodsFor: 'initialization'!defaultShape	^ RSBox new noPaint! !!RSBarPlot methodsFor: 'rendering'!definedValuesY	"Return the list Y values that are defined"	^ yValues, {0} select: [ :v | v isNaN not and: [ v isInfinite not ] ]! !!RSBarPlot methodsFor: 'rendering'!renderIn: canvas	| color width myScale |	self checkAssertion.	color := self computeColor."	myScale := self barScale."	myScale := xScale.	width := self barWidth.	width ifNil: [ width := myScale rangeBand ].	xValues doWithIndex: [ :xt : i | 		| yt origin corner r |		yt := yValues at: i.		origin := (myScale scale: xt) @ (yScale scale: yt).		corner := origin x @ (yScale scale: 0).		((self isPointWellDefined: origin) and: [ self isPointWellDefined: corner ]) ifTrue: [			r := Rectangle origin: origin corner: corner + (width@0).			canvas add: (self shape copy				color: color;				fromRectangle: r;				yourself).			  ] ].! !!RSLinePlot methodsFor: 'initialization'!defaultShape	^ RSPolyline new color: nil.! !!RSLinePlot methodsFor: 'rendering'!renderIn: canvas	| controlPoints |	self checkAssertion. 	controlPoints := OrderedCollection new.	(1 to: xValues size) do: [ :i |			| xt yt |			xt := xValues at: i.			yt := yValues at: i.			(self isPointWellDefined: xt @ yt)				ifTrue: [ controlPoints add: (xScale scale: xt) @ (yScale scale: yt) ] ].	canvas add: (self shape		color: self computeColor;		controlPoints: controlPoints;		yourself).! !!RSLinePlot methodsFor: 'public - shape' prior: 34003845!shape	^ shape! !!RSLinePlot methodsFor: 'public - shape' prior: 34003921!shape: aShape	self shouldNotImplement! !!RSScatterPlot methodsFor: 'initialization'!defaultShape	^ RSEllipse new noPaint! !!RSScatterPlot methodsFor: 'accessing'!processBlock	^ processBlock! !!RSScatterPlot methodsFor: 'accessing'!processBlock: oneArgBlock	"Set the process block, which is a one-arg block that is executed on the set of shapes after the rendering. It is a hook for particularizing some visual aspects of the plot.	"	processBlock := oneArgBlock! !!RSScatterPlot methodsFor: 'rendering'!renderIn: canvas	| shapes newPoint color |	color := self computeColor.	self checkAssertion.	shapes := (1 to: xValues size)		collect: [ :notUsed | 			self shape copy				radius: 2;				color: color ] as: RSGroup.	1 to: xValues size do: [ :i | 		| xt yt et |		et := shapes at: i.		xt := xValues at: i.		yt := yValues at: i.		newPoint := (xScale scale: xt) @ (yScale scale: yt).		(self isPointWellDefined: newPoint)			ifTrue: [ et translateTo: newPoint.				canvas addShape: et ] ].			processBlock rsValue: shapes.! !!RSAbstractLabelDecoration methodsFor: 'rendering'!createLabel	"Utility method to create a label"	^ RSLabel new		text: title;		fontSize: fontSize;		color: Color black;		rotateByDegrees: rotationAngle! !!RSAbstractLabelDecoration methodsFor: 'accessing'!fontSize	"Return the font size to use when generating labels"	^ fontSize! !!RSAbstractLabelDecoration methodsFor: 'accessing'!fontSize: fontSizeToUse	"Set the font size to use when generating labels"	fontSize := fontSizeToUse! !!RSAbstractLabelDecoration methodsFor: 'accessing'!horizontal	"Set the label horizontal"	self rotationAngle: 0! !!RSAbstractLabelDecoration methodsFor: 'initialization'!initialize	super initialize.	rotationAngle := 0.	fontSize := 10! !!RSAbstractLabelDecoration methodsFor: 'accessing'!offset	^ offset! !!RSAbstractLabelDecoration methodsFor: 'accessing'!offset: aNumber	"Set the translation distance to set the label"	offset := aNumber! !!RSAbstractLabelDecoration methodsFor: 'accessing'!rotationAngle	^ rotationAngle! !!RSAbstractLabelDecoration methodsFor: 'accessing'!rotationAngle: anAngleAsFloat	"Set the rotation the label should have"	rotationAngle := anAngleAsFloat! !!RSAbstractLabelDecoration methodsFor: 'accessing'!title	^ title! !!RSAbstractLabelDecoration methodsFor: 'accessing'!title: aLabelAsString	"This method is useful to set the name of an axis"	title := aLabelAsString! !!RSAbstractLabelDecoration methodsFor: 'accessing'!vertical	"Set the label vertical"	self rotationAngle: -90! !!RSChartTitleDecoration methodsFor: 'rendering'!defaultFontSize	^ 15! !!RSChartTitleDecoration methodsFor: 'rendering'!initialize	super initialize.	self fontSize: self defaultFontSize.	self rotationAngle: 0! !!RSChartTitleDecoration methodsFor: 'rendering'!renderIn: canvas	| label |	label := self createLabel.	canvas add: label.	RSLocation new		offset: 0@ -2;		above; center;		stick: label on: self spine.! !!RSXLabelDecoration methodsFor: 'initialization'!initialize	super initialize.	self offset: 5! !!RSXLabelDecoration methodsFor: 'rendering'!renderIn: canvas	| label |	label := self createLabel.	RSLocation new		offset: offset;		below;		center;		move: label on: canvas encompassingRectangle.	canvas add: label.! !!RSYLabelDecoration methodsFor: 'initialization'!initialize	super initialize.	self offset: -5.	self vertical.! !!RSYLabelDecoration methodsFor: 'rendering'!renderIn: canvas	| label |	label := self createLabel.		RSLocation new		offset: offset;		center;		left;		outer;		move: label on: canvas encompassingRectangle.	canvas add: label.! !!RSAbstractMarkerDecoration methodsFor: 'public - configuration'!average	self subclassResponsibility! !!RSAbstractMarkerDecoration methodsFor: 'rendering'!createMarkerLineFromPlot: aPlot	"This method should be overriden to produce a line"	self subclassResponsibility! !!RSAbstractMarkerDecoration methodsFor: 'rendering'!defaultDashStyle	^ #(2 2 2)! !!RSAbstractMarkerDecoration methodsFor: 'initialization'!defaultMarkerColor	^ Color red! !!RSAbstractMarkerDecoration methodsFor: 'rendering'!getValueToBeMarkedFromPlot: p	^ getRelevantValueBlock rsValue: p! !!RSAbstractMarkerDecoration methodsFor: 'initialization'!initialize	super initialize.		"Per default, mark the max value"	self max.	markerColor := self defaultMarkerColor! !!RSAbstractMarkerDecoration methodsFor: 'public - configuration'!max	self subclassResponsibility! !!RSAbstractMarkerDecoration methodsFor: 'public - configuration'!min	self subclassResponsibility! !!RSAbstractMarkerDecoration methodsFor: 'rendering'!renderIn: canvas	| line |		chart plots		do: [ :p | 			line := self createMarkerLineFromPlot: p.			line				dashArray: self defaultDashStyle;				color: markerColor;				yourself.			self addShape: line ]! !!RSAbstractMarkerDecoration methodsFor: 'public - configuration'!value: aValue	"Mark the value"	getRelevantValueBlock := aValue! !!RSXMarkerDecoration methodsFor: 'public - configuration'!average	getRelevantValueBlock := [ :aPlot | aPlot definedValuesX average ]! !!RSXMarkerDecoration methodsFor: 'rendering'!createMarkerLineFromPlot: aPlot	| value |	value := self getValueToBeMarkedFromPlot: aPlot.	^ RSLine new			from: (aPlot xScale scale: value) @ 0;			to: (aPlot xScale scale: value) @ chart extent y negated! !!RSXMarkerDecoration methodsFor: 'public - configuration'!max	getRelevantValueBlock := [ :p | p maxValueX ]! !!RSXMarkerDecoration methodsFor: 'public - configuration'!min	getRelevantValueBlock := [ :p | p minValueX ]! !!RSYMarkerDecoration methodsFor: 'public - configuration'!average	getRelevantValueBlock := [ :aPlot | aPlot definedValuesY average ]! !!RSYMarkerDecoration methodsFor: 'rendering'!createMarkerLineFromPlot: aPlot	| value |	value := self getValueToBeMarkedFromPlot: aPlot.	^ RSLine new			from: 0 @ (aPlot yScale scale: value);			to: chart extent x @ (aPlot yScale scale: value)! !!RSYMarkerDecoration methodsFor: 'public - configuration'!max	getRelevantValueBlock := [ :p | p maxValueY ]! !!RSYMarkerDecoration methodsFor: 'public - configuration'!min	getRelevantValueBlock := [ :p | p minValueY ]! !!RSChartDecoration methodsFor: 'rendering'!renderIn: canvas	"Need to be overridden in subclasses. Useful to enrich a visualization"	self subclassResponsibility! !!RSChartSpineDecoration methodsFor: 'rendering'!renderIn: canvas	shape := RSBox new color: nil; extent: chart extent; withBorder.	shape translateTo: (chart extent x / 2) @ (chart extent y negated / 2).	canvas add: shape! !!RSChartSpineDecoration methodsFor: 'rendering'!shape	^ shape! !!RSTickConfiguration methodsFor: 'public'!createLabelFor: aValue	^ RSLabel new 		fontSize: self fontSize; 		text: (self labelConversion rsValue: aValue); 		rotateByDegrees: self labelRotation;		yourself! !!RSTickConfiguration methodsFor: 'accessing'!fontSize	^ fontSize! !!RSTickConfiguration methodsFor: 'accessing'!fontSize: aNumber	fontSize := aNumber! !!RSTickConfiguration methodsFor: 'initialization'!initialize	super initialize.	self numberOfTicks: 5;		fontSize: 5;		labelRotation: 0;		shouldHaveLabels: true;		shouldUseNiceLabel: true;		labelConversion: [ :value | value ];		tickSize: 3! !!RSTickConfiguration methodsFor: 'accessing'!labelConversion	^ labelConversion! !!RSTickConfiguration methodsFor: 'accessing'!labelConversion: aOneArgBlock	labelConversion := aOneArgBlock! !!RSTickConfiguration methodsFor: 'accessing'!labelRotation	^ labelRotation! !!RSTickConfiguration methodsFor: 'accessing'!labelRotation: degreesAsNumber	labelRotation := degreesAsNumber! !!RSTickConfiguration methodsFor: 'accessing'!numberOfTicks	^ numberOfTicks! !!RSTickConfiguration methodsFor: 'accessing'!numberOfTicks: aNumber	numberOfTicks := aNumber! !!RSTickConfiguration methodsFor: 'accessing'!shouldHaveLabels	^ shouldHaveLabels! !!RSTickConfiguration methodsFor: 'accessing'!shouldHaveLabels: aBoolean	shouldHaveLabels := aBoolean! !!RSTickConfiguration methodsFor: 'accessing'!shouldUseNiceLabel	^ shouldUseNiceLabel! !!RSTickConfiguration methodsFor: 'accessing'!shouldUseNiceLabel: aBoolean	shouldUseNiceLabel := aBoolean! !!RSTickConfiguration methodsFor: 'accessing'!tickSize	^ tickSize! !!RSTickConfiguration methodsFor: 'accessing'!tickSize: aNumber	tickSize := aNumber! !"Roassal3-Chart"!!RSControlConfiguration commentStamp: '' prior: 0!A control configuration is made to set a configuration for the canvas. For example, by modifying a control configuraiton, you can decide if you wish to have an horizontal scrollbar or no, the minimum zoom, or maximum zoom, the padding, ...For example:-=-=--=-=--=-=--=-=-c := RSCanvas new. controller := RSCanvasController new.controller configuration: (RSControlConfiguration new maxScale: 10).c @ controller.-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-canvas := RSCanvas new.shapes := #('hello' 'world' 'from' 'Roassal3') collect: [ :s | RSLabel new text: s ] as: RSGroup.canvas addAll: shapes.RSVerticalLineLayout on: shapes.int := RSCanvasController new.int configuration	minScale: 1;	maxScale: 3.canvas @ int.canvas-=-=--=-=--=-=--=-=-!!RSInteraction commentStamp: '' prior: 0!I am the top class for interactions in roassal.You can add an interaction to an instance of RSElement or RSEdge or RSView with: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=element addInteraction: RSDraggable.edge addInteraction: (RSHighlightable new).view @ RSDraggableView.-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=!!RSAbstractCanvasInteraction commentStamp: '' prior: 0!Subclasses of myself are interaction for the view.!!RSAbstractCanvasMonitor commentStamp: '' prior: 0!I am an interaction for RSView, I can add to the a fixed shape that contains basic information aboutFrames per second, this number show the quantity of frames rendered. useful to debug animations!!RSGraphCanvasMonitor commentStamp: '' prior: 0!I have a canvas monitor!!RSSimpleCanvasMonitor commentStamp: '' prior: 0!I am a simple monitor!!RSAbstractControlCanvas commentStamp: '' prior: 0!I interact with RSControlsView. my subclasses are added to the controls!!RSDraggableCanvas commentStamp: '' prior: 0!I set the drag event for view, I use a basic bars to do that.Use example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.c add: (RSBox new size: 30).c @ RSDraggableCanvas-=-=-=-=-=-=-=-=-=!!RSKeyNavigationCanvas commentStamp: '' prior: 0!I add key events to the view to move it, zoom it with the key board!!RSScrollBarsCanvas commentStamp: '' prior: 0!I put a scrool shapes to the view when the view moves!!RSScrollWheelCanvas commentStamp: '' prior: 0!I am a interaction for translate the canvas in vertical position with the mouse wheel!!RSSearchInCanvas commentStamp: '' prior: 0!`RSSearchInCanvas` am an option for the canvas controller. You can use `RSSearchInCanvas` as follows (press the S key and the R key):```Smalltalkc := RSCanvas new.shapes := Collection withAllSubclasses collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.eb := RSEdgeBuilder line.eb canvas: c.eb connectFrom: #superclass.RSTreeLayout on: shapes.con := RSCanvasController new.con addInteraction: RSSearchInCanvas new.c @ con.``````Smalltalkc := RSCanvas new.shapes := (1 to: 10) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.c addAll: shapes.RSGridLayout on: shapes.shapes @ RSPopup.con := RSCanvasController new.con addInteraction: RSSearchInCanvas new.c @ con.```Another example:```Smalltalkc := RSCanvas new.classes := Collection withAllSubclasses.elements := classes collect: [ :cls |	g := RSGroup new		add: (RSLabel new text: cls name);		add: (RSEllipse new size: (cls numberOfMethods + 5) sqrt; color: Color blue );		yourself.	RSVerticalLineLayout new center; on: g.	g asShapeFor: cls ] as: RSGroup.c addAll: elements.high := RSHighlightable defaultRed.elements @ high.RSGridLayout new	lineItemsCount: 5;	on: elements.con := RSCanvasController new.con addInteraction: (search := RSSearchInCanvas new 	colorToHighlight: Color blue translucent;	yourself).c @ con.```!!RSZoomToFitCanvas commentStamp: '' prior: 0!I add an interaction for the view!!RSZoomableCanvas commentStamp: '' prior: 0!I handle the zoom interaction with mouse wheel event, also I handle all the zoom process!!RSCanvasController commentStamp: '' prior: 0!I the main interaction that handles roassal3 general control about a view.I interact with the Abstract class RSAbstractControlView. I creates instances of all subclasses of RSAbstractControlsView !!RSAbstractPopup commentStamp: '' prior: 0!I defined basic behaviors about popups in general, my subclasses needs to override:**!!RSMorphicPopup commentStamp: '' prior: 0!I am a popup that uses Morphic and can be visible outside of the RSCanvas.!!RSPopup commentStamp: '' prior: 0!I can add a popup on an element when a move over event occurs.Here is an example:-=-=-=-=c := RSCanvas new.classes := RSObject withAllSubclasses.scale := TSScale linear	domain: { (classes collect: #numberOfMethods) min . (classes collect: #numberOfMethods) max};	range: { 'red'. 'blue' }.classes do: [ :cls |	| b |	b := RSEllipse new.	b size: cls numberOfMethods.	b color: (scale scale: cls numberOfMethods).	b model: cls.	b @ RSPopup.	c add: b ].RSFlowLayout on: c shapes.c @ RSControlsCanvas-=-=-=-=!!RSAnimatedPopup commentStamp: '' prior: 0!I am a basic popup for animated content in a view of roassal3!!RSAbstractScaleInteraction commentStamp: '' prior: 0!I define accessors for min and max scale value for some scale interactions!!RSKeepBorderWidthRatio commentStamp: '' prior: 0!I am a simple interaction that allows to shapes keep size ratio or with in the case of the borderHere is an example:| v sb label box |	v := RSView new.	label := RSShapeBuilder label.	box := RSShapeBuilder box		border: TSBorder new;		cornerRadius: (TSCornerRadius new right: 10);		extent: [ :lb | lb extent + 5 ].	sb := RSShapeBuilder composite		interactionDo: #draggable;		shapes: [ :m | | l |			l := label elementOn: m.			TSGroup with: (box elementOn: l) with: l].	v addAll: (sb elementsOn: ArrayedCollection withAllSubclasses).	v @ RSControlsView.	RSEdgeBuilder orthoHorizontal		markerEnd: (TSMarker new 			offsetRatio: 0.1;			shape: (RSShapeBuilder triangle 				color: Color red;				size: 10;				element));		attachPoint: RSHorizontalAttachPoint new; 		border: (TSBorder new);		view: v;		elements: v elements;		connectFrom: #superclass.	"v edges @ RSKeepBorderWidthRatio. Not necessary since all edges shares the same border"		v edges first @ RSKeepBorderWidthRatio. 	v edges first @ RSKeepMarkersSizeRatio.	RSHorizontalTreeLayout new on: v elements.	v open setLabel: 'Horizontal Tree'!!RSKeepMarkersSizeRatio commentStamp: '' prior: 0!I am an interaction for edges becacuse I access to markers from edges.I change the size of the marker allow it to remain in the same sizeExample:| v sb label box |	v := RSView new.	label := RSShapeBuilder label.	box := RSShapeBuilder box		border: TSBorder new;		cornerRadius: (TSCornerRadius new right: 10);		extent: [ :lb | lb extent + 5 ].	sb := RSShapeBuilder composite		interactionDo: #draggable;		shapes: [ :m | | l |			l := label elementOn: m.			TSGroup with: (box elementOn: l) with: l].	v addAll: (sb elementsOn: ArrayedCollection withAllSubclasses).	v @ RSControlsView.	RSEdgeBuilder orthoHorizontal		markerEnd: (TSMarker new 			offsetRatio: 0.1;			shape: (RSShapeBuilder triangle 				color: Color red;				size: 10;				element));		attachPoint: RSHorizontalAttachPoint new; 		border: (TSBorder new);		view: v;		elements: v elements;		connectFrom: #superclass.	"v edges @ RSKeepBorderWidthRatio. Not necessary since all edges shares the same border"		v edges first @ RSKeepBorderWidthRatio. 	v edges first @ RSKeepMarkersSizeRatio.	RSHorizontalTreeLayout new on: v elements.	v open setLabel: 'Horizontal Tree'	!!RSDraggable commentStamp: '' prior: 0!I can move an element from its position!!RSHighlightable commentStamp: '' prior: 0!<keyClass>`RSHighlightable` is an interaction for shapes to make them highlightable. *Responsibility*: make shapes highlightable*Collaborators*: closely colaborate with `RSShape`*Variables*:- `announcer`: highlightable uses announcement to trigger the interaction. - `copyKey`: symbol that is used to keep in the property the previous color. One needs to modity the `copyKey` to avoid conflict between several highlightable interactions.- `highlightShapes`: refers to a one-arg-block that takes as parameter a shape and returns the shapes that must be highlighted. - `propertyKey`: symbol that is used in the property of the `RSCanvas` to keep highlighted shapes. This is useful to avoid conflicts between different highlightable.   *Example*:```Smalltalkc := RSCanvas new.shapes := (1 to: 10) collect: [ :v | RSEllipse new size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup @ RSDraggable.RSGridLayout on: shapes.eb := RSEdgeBuilder arrowedLineWithOffset: 0.5.eb canvas: c.eb connectTo: [ :v | 1 ].int := RSHighlightable new withEdges highlightColor: Color red.shapes @ int.c @ RSCanvasController```Another example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new border: (RSBorder new color: Color red; width: 3); model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.RSNormalizer size	shapes: shapes;	normalize: #yourself.interaction := RSHighlightable new.interaction highlightColor: Color blue.interaction highlightBorder: (RSBorder new color: Color black; width: 3).shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```Another example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSEllipse new  model: v; size: 10 ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.RSEdgeBuilder line	canvas: c;	withBorderAttachPoint;	connectFrom: [ :v | v // 2 ].interaction := RSHighlightable new.interaction highlightBorder: (RSBorder new color: Color black; width: 3).interaction withEdges.shapes @ interaction.RSTreeLayout on: shapes.c @ RSCanvasController``````Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new  size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.interaction := RSHighlightable new.interaction highlightBorder: (RSBorder new width: 3; color: Color pink).shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```!!RSLabeled commentStamp: '' prior: 0!<keyClass>`RSLabeled` adds a label on shape. Per default, it is added on top of the shape. The label may be particularized using #text: in the default string representation is not sufficient. *Responsibility*: locate a label on top of a shape.*Collaborators*: can be added to any Roassal shape*Variables*:- `location`: a `RSLocation` indicating where the label should be located- `isHighlightable`: a boolean indicating whether the label should be highlighted- `lowColor`: a boolean indicating whether the label should be highlighted*Example*:```Smalltalkc := RSCanvas new.shapes := RSGroup new.1 to: 3 do: [ :v |	shapes add: (RSBox new model: v) ].shapes @ (RSLabeled new text: [ :m | 'Value = ', m asString ]).RSNormalizer size	shapes: shapes;	from: 20; to: 40;	normalize: [ :aModel | aModel ].c addAll: shapes.RSVerticalLineLayout new gapSize: 30; on: shapes.c @ RSCanvasController```Another example:```Smalltalkc := RSCanvas new.shapes := (1 to: 10) collect: [ :v | RSBox new model: v; size: 30 ] as: RSGroup.c addAll: shapes.shapes @ RSLabeled new highlightable.RSNormalizer size shapes: shapes; normalize: #yourself.RSGridLayout on: shapes.c @ RSCanvasController.c ```!!RSMenuActivable commentStamp: '' prior: 0!With the mouse right click event I show a basic popupExample:-=-=-=-=v := RSView new.boxes := RSShapeBuilder composite				color: Color blue trans;				shapes: [ :nb | 					TSGroup with: (RSShapeBuilder label elementOn: nb)					 ]; 				size: 30;				elementsOn: (1 to: 100).v addAll: boxes.RSGridLayout on: boxes.boxes @ (RSMenuActivable new menuDo: [ :menu :element | menu add: 'Inspect' target: element model selector: #inspect ]).v @ RSControlsView.v open-=-=-=-=!!RSRotated commentStamp: '' prior: 0!I can rotate one shape on its parent!!RSTransformable commentStamp: '' prior: 0!I provide element resizing in all eight directions. Resizing handles are displayed after clicking on an associated shape, and are automatically removed when clicked on a canvas or another shape.!!!! AssumptionsYou must provide this class with aCanvas instance or the initialized element must be already added to the canvas.!!RSMultilineLabelBuilder commentStamp: '' prior: 0!I am a builder that can create labels with multiline in roassal3 from objects```Smalltalkcanvas := RSCanvas new.shapeBuilder := RSMultilineLabelBuilder new.shapeBuilder labelShape	font: 20;	italic.canvas add:(shapeBuilder shapeFor: '"tu est loin, très loin de tous ces regards vicieux qui s''alimentent de ta lumière"').canvas nodes when: RSMouseClick do: [ :evt | canvas nodes last inspect ].canvas showEncompassingRectangles.canvas```!!RSSimplePopupBuilder commentStamp: '' prior: 0!I create a popup from an object!!RSConfigurableCamera commentStamp: '' prior: 0!I am a camera to control the zoom interaction!!RSGroup methodsFor: '*Roassal3-Interaction'!@ interaction	"Apply an interaction on each shape contained in the group.	For example:-=-=-=-=-=-=-=-=-=g := RSGroup new.g add: (RSBox new size: 10; model: 'hello').g add: (RSBox new size: 10; model: 'World').RSHorizontalLineLayout on: g.g @ RSPopup.c := RSCanvas new.c addAll: g.c-=-=-=-=-=-=-=-=-="	self do: [ :e | e @ interaction ].! !!RSCanvas methodsFor: '*Roassal3-Interaction'!controllerInteraction	^ self propertyAt: RSCanvasController! !!RSCanvas methodsFor: '*Roassal3-Interaction'!controllerInteraction: aCanvasController	self propertyAt: RSCanvasController put: aCanvasController! !!RSControlConfiguration methodsFor: 'scrollbar managing'!hasHorizontalScrolling	^ hasHorizontalScrolling! !!RSControlConfiguration methodsFor: 'scrollbar managing'!hasHorizontalScrolling: aBool	hasHorizontalScrolling := aBool! !!RSControlConfiguration methodsFor: 'scrollbar managing'!hasVerticalScrolling	^ hasVerticalScrolling! !!RSControlConfiguration methodsFor: 'scrollbar managing'!hasVerticalScrolling: aBool	hasVerticalScrolling := aBool! !!RSControlConfiguration methodsFor: 'initialization'!initialize	super initialize.	self 		minScale: 0.04;		maxScale: 7;		padding: 25;		useZoomToFitOnExtendChanged;		useZoomToFitOnStart;		noBasicZoom;		hasHorizontalScrolling: true;		hasVerticalScrolling: true.! !!RSControlConfiguration methodsFor: 'accessing'!maxScale	^ maxScale! !!RSControlConfiguration methodsFor: 'accessing'!maxScale: aNum	"Set the maximum scale for the configuration"	maxScale := aNum! !!RSControlConfiguration methodsFor: 'accessing'!minScale	^ minScale! !!RSControlConfiguration methodsFor: 'accessing'!minScale: aNum	"Set the minimum scale allowed by the configuration."	minScale := aNum! !!RSControlConfiguration methodsFor: 'configuration'!noBasicZoom	shouldUseBasicZoom := false.! !!RSControlConfiguration methodsFor: 'configuration'!noZoomToFitOnExtendChanged	zoomToFitOnExtent := false! !!RSControlConfiguration methodsFor: 'configuration'!noZoomToFitOnStart	zoomToFitOnStart := false.! !!RSControlConfiguration methodsFor: 'accessing'!padding	^ padding! !!RSControlConfiguration methodsFor: 'accessing'!padding: aMargin	padding := aMargin asMargin! !!RSControlConfiguration methodsFor: 'testing'!shouldUseBasicZoom	^ shouldUseBasicZoom! !!RSControlConfiguration methodsFor: 'testing'!shouldZoomToFitOnExtendChanged	^ zoomToFitOnExtent! !!RSControlConfiguration methodsFor: 'testing'!shouldZoomToFitOnStart	^ zoomToFitOnStart! !!RSControlConfiguration methodsFor: 'configuration'!useBasicZoom	shouldUseBasicZoom := true.! !!RSControlConfiguration methodsFor: 'configuration'!useZoomToFitOnExtendChanged	zoomToFitOnExtent := true! !!RSControlConfiguration methodsFor: 'configuration'!useZoomToFitOnStart	zoomToFitOnStart := true.! !!RSAbstractCanvasInteraction methodsFor: 'hooks'!onShape: aCanvas	self subclassResponsibility! !!RSAbstractCanvasMonitor methodsFor: 'accessing'!currentTime	^ canvas currentTime! !!RSAbstractCanvasMonitor methodsFor: 'initialization'!initialize	super initialize.	self initializeShape.! !!RSAbstractCanvasMonitor methodsFor: 'initialization'!initializeShape	self subclassResponsibility.! !!RSAbstractCanvasMonitor methodsFor: 'accessing'!lastFrameCPUConsumption	| res current |	current := self currentTime.	lastFrameEndTime ifNil: [ 		lastFrameEndTime := current ].	res := (current - lastFrameEndTime) * 1e-3.	lastFrameEndTime := current.	^ res! !!RSAbstractCanvasMonitor methodsFor: 'accessing'!lastFramePerSecond	| delta |	delta := self lastFrameCPUConsumption.	^ (1.0 / (delta max: 0.001) ) asInteger! !!RSAbstractCanvasMonitor methodsFor: 'hooks'!onShape: aCanvas	| location |	self assert: shape notNil description: 'Define your monitor shape'.	shape isFixed: true.	aCanvas addShape: shape. 	location := RSLocation new inner; bottom; left; offset: 10@0.	canvas := aCanvas.	aCanvas newAnimation		repeat;		onStepDo: [ :t |			self updateShape.			location move: shape on: aCanvas basicRectangle ].! !!RSAbstractCanvasMonitor methodsFor: 'accessing'!shape	^ shape! !!RSAbstractCanvasMonitor methodsFor: 'accessing'!shape: aShape	shape := aShape! !!RSAbstractCanvasMonitor methodsFor: 'update'!updateShape	self subclassResponsibility! !!RSGraphCanvasMonitor methodsFor: 'accessing'!box	^ RSBox new		extent: 100@ 50;		color: Color lightGray translucent;		cornerRadius: 5;		yourself.! !!RSGraphCanvasMonitor methodsFor: 'defaults'!defaultLabel	^ RSLabel new		bold;		text: '';		position: 25 @ 15;		color: Color blue;		yourself! !!RSGraphCanvasMonitor methodsFor: 'defaults'!defaultPolygon	^ RSPolygon new		paint: ((LinearGradientPaint fromArray:				{0  -> Color red translucent.				0.5 -> Color orange translucent.				1   -> Color green translucent. } )			start: 0@25;			stop: 0@ -20;			yourself);		cornerRadii: 5;		yourself! !!RSGraphCanvasMonitor methodsFor: 'defaults'!defaultPolyline	^ RSPolyline new		controlPoints: #();		border: (RSBorder new			paint: ((LinearGradientPaint fromArray:					{0  -> 'red'.					0.5 -> 'orange'.					1   -> 'gree'})				start: 0@25;				stop: 0@ -20;				yourself))! !!RSGraphCanvasMonitor methodsFor: 'initialization'!initialize	polyScale := NSScale linear		domain: { 1@0. 100@65 };		range: { -50 @ 25. 50@ -25 }.	frames := OrderedCollection new.	super initialize.		! !!RSGraphCanvasMonitor methodsFor: 'initialization'!initializeShape	shape := RSShapeFactory composite		noPaint;		shapes: { self box. self polygon. self  polyline. self label};		padding: 5;		yourself! !!RSGraphCanvasMonitor methodsFor: 'accessing'!label	^ label ifNil: [ label := self defaultLabel ]! !!RSGraphCanvasMonitor methodsFor: 'accessing'!polygon	^ polygon ifNil: [ polygon := self defaultPolygon ]! !!RSGraphCanvasMonitor methodsFor: 'accessing'!polyline	^ polyline ifNil: [ polyline := self defaultPolyline ]! !!RSGraphCanvasMonitor methodsFor: 'update'!updateShape	| cp |	frames add: self lastFramePerSecond.		frames size > shape shapes first extent x		ifTrue: [ frames removeFirst ].	self label text: frames last asString, 'fps'.	frames first = 1000 ifTrue: [ frames removeFirst ].	cp := frames collectWithIndex: [ :frame :i |		polyScale scale: i @ frame ].	self polyline controlPoints: cp.	cp := cp copy.	cp 		add: (polyScale scale: cp size @ 0);		add: (polyScale scale: 1@0).	self polygon points: cp! !!RSSimpleCanvasMonitor methodsFor: 'initialization'!initializeShape	shape := RSLabel new		color: Color green;		yourself! !!RSSimpleCanvasMonitor methodsFor: 'update'!updateShape	shape text: self lastFramePerSecond asString, 'fps'! !!RSAbstractControlCanvas methodsFor: 'accessing'!configuration	^ limits ifNil: [ limits := RSControlConfiguration new ]! !!RSAbstractControlCanvas methodsFor: 'accessing'!configuration: aRSControlLimits	limits := aRSControlLimits! !!RSAbstractControlCanvas methodsFor: 'utilities'!correctCameraPosition: evt 	^ self 		correctCameraPosition: evt		inRectangle: (self expandedRectangle: evt)		position: evt camera position		scale: evt camera scale! !!RSAbstractControlCanvas methodsFor: 'utilities'!correctCameraPosition: evt inRectangle: rectangle position: position scale: scale	| aCanvas canvasRect x y p |	aCanvas := evt canvas.	p := position.	canvasRect := Rectangle		floatCenter: p		extent: aCanvas extent / scale.	x := rectangle width <= canvasRect width		ifTrue: [rectangle origin x < canvasRect origin x			ifTrue: [ p x - (canvasRect origin x - rectangle origin x) ]			ifFalse: [ rectangle corner x < canvasRect corner x				ifTrue: [ p x ]				ifFalse: [ p x - (canvasRect corner x - rectangle corner x) ] ] ]		ifFalse: [ canvasRect origin x < rectangle origin x			ifTrue: [ p x - (canvasRect origin x - rectangle origin x) ]			ifFalse: [ rectangle corner x < canvasRect corner x				ifTrue: [ p x - (canvasRect corner x - rectangle corner x) ]				ifFalse: [ p x ] ] ].	y := rectangle height <= canvasRect height		ifTrue: [rectangle origin y < canvasRect origin y			ifTrue: [ p y - (canvasRect origin y - rectangle origin y) ]			ifFalse: [ rectangle corner y < canvasRect corner y				ifTrue: [ p y ]				ifFalse: [ p y - (canvasRect corner y - rectangle corner y) ] ] ]		ifFalse: [ canvasRect origin y < rectangle origin y			ifTrue: [ p y - (canvasRect origin y - rectangle origin y) ]			ifFalse: [ rectangle corner y < canvasRect corner y				ifTrue: [ p y - (canvasRect corner y - rectangle corner y) ]				ifFalse: [ p y ] ] ].	^ x@y! !!RSAbstractControlCanvas methodsFor: 'utilities'!correctCameraPosition: evt scale: scale	^ self 		correctCameraPosition: evt		inRectangle: (self expandedRectangle: evt)		position: evt camera position		scale: scale! !!RSAbstractControlCanvas methodsFor: 'utilities'!encompassingRectangleFor: aCanvas	^ aCanvas propertyAt: #encompassingRectangle 		ifAbsentPut: [ aCanvas encompassingRectangle  ].! !!RSAbstractControlCanvas methodsFor: 'utilities'!expandedRectangle: evt	| key | 	key := #expanedEncompassingRectangle.	^ evt canvas propertyAt: key ifAbsentPut: [ 		| rectangle |		rectangle := self encompassingRectangleFor: evt canvas.		self configuration padding expandRectangle: rectangle ].	! !!RSAbstractControlCanvas methodsFor: 'utilities'!removeRectanglesFor: aCanvas	aCanvas 		removeKey: #encompassingRectangle;		removeKey: #expanedEncompassingRectangle! !!RSAbstractControlCanvas methodsFor: 'rendering'!renderLegendOn: aLegendBuilder	self subclassResponsibility! !!RSAbstractControlCanvas methodsFor: 'utilities'!scaleFor: aScale	| l |	l := self configuration.	^ (l maxScale min: aScale ) max: l minScale! !!RSDraggableCanvas class methodsFor: 'accessing'!left	^ self new left! !!RSDraggableCanvas class methodsFor: 'accessing'!middle	^ self new middle! !!RSDraggableCanvas class methodsFor: 'accessing'!right	^ self new right! !!RSDraggableCanvas methodsFor: 'mouse'!all	"Any mouse button can be used to drag and drop the view"	mouseEvent := RSMouseDragStart.! !!RSDraggableCanvas methodsFor: 'computing'!checkCamera: aCanvas	| camera p correct |	camera := aCanvas camera.	p := camera position.	correct := self correctCameraPosition: aCanvas.	correct = p ifTrue: [ ^ self ].		self removeRectanglesFor: aCanvas.		aCanvas newAnimation		easing: RSEasing cubicIn;		duration: 200 milliSeconds;		from: p;		to: correct;		on: camera set: #translateTo:.! !!RSDraggableCanvas methodsFor: 'initialize'!initialize	super initialize.	self all.	isMoving := false.! !!RSDraggableCanvas methodsFor: 'mouse'!left	mouseEvent := RSMouseLeftDragStart! !!RSDraggableCanvas methodsFor: 'mouse'!middle	mouseEvent := RSMouseMiddleDragStart! !!RSDraggableCanvas methodsFor: 'events'!mouseEnd: evt	| threshold aCanvas camera delta p correct |	isMoving := false.	lastStep ifNil: [ ^ self ].	aCanvas := evt canvas.	camera := evt camera.	threshold := 4.	(lastStep dist: 0@0) < threshold		ifTrue: [ ^ self checkCamera: aCanvas ].			delta := lastStep * 2.5.	camera translateBy: delta.	correct := self correctCameraPosition: evt.	camera translateBy: delta negated.				p := (correct - camera position) abs max: 1@1.	p := p x sqrt @ p y sqrt.		aCanvas newAnimation 		easing: RSEasing cubicOut;		duration: 200 milliSeconds;		from: camera position; to: camera position + (delta / p);		on: camera set: #translateTo:;		when: RSAnimationEndEvent do: [ self checkCamera: aCanvas ].		! !!RSDraggableCanvas methodsFor: 'mouse'!mouseEvent	^ mouseEvent! !!RSDraggableCanvas methodsFor: 'events'!mouseMove: evt	| camera p correct |	isMoving ifFalse: [ ^ self ].	camera := evt camera.	lastStep := evt step negated / camera scale.	correct  := self correctCameraPosition: evt.	p := (correct - camera position) abs max: 1@1.	p := p x sqrt @ p y sqrt.	camera translateBy: lastStep/ p.	evt signalUpdate.! !!RSDraggableCanvas methodsFor: 'events'!mouseStart: evt	isMoving := true.	lastStep := nil.! !!RSDraggableCanvas methodsFor: 'hooks'!onShape: aCanvas	aCanvas 		when: self mouseEvent do: [ :evt | self mouseStart: evt ];		when: RSMouseDragging do: [ :evt | self mouseMove: evt ];		when: RSMouseDragEnd do: [ :evt | self mouseEnd: evt ].! !!RSDraggableCanvas methodsFor: 'rendering'!renderLegendOn: lb	lb text: 'Mouse click' description: 'To move the view''s camera'! !!RSDraggableCanvas methodsFor: 'mouse'!right	mouseEvent := RSMouseRightDragStart.! !!RSKeyNavigationCanvas methodsFor: 'events-processing'!expandCollapse: evt	evt canvas morph owner expandBoxHit! !!RSKeyNavigationCanvas methodsFor: 'initialization'!initialize	super initialize.	steps := Set new.	speed := 1.			! !!RSKeyNavigationCanvas methodsFor: 'hooks'!onShape: aCanvas	aCanvas 		when: RSKeyDown do: [ :evt | self processKeyDown: evt ];		when: RSKeyUp do: [ :evt | self processKeyUp: evt ].! !!RSKeyNavigationCanvas methodsFor: 'events'!processKeyDown: evt	| keyName rect lastMS |	keyName := evt keyName.	self configuration hasHorizontalScrolling ifTrue: [ 		keyName = #KP_LEFT ifTrue: [ steps add: -1@0 ].		keyName = #KP_RIGHT ifTrue: [ steps add: 1@0 ].	].	self configuration hasVerticalScrolling ifTrue: [ 		keyName = #KP_UP ifTrue: [ steps add: 0@ -1 ].		keyName = #KP_DOWN ifTrue: [ steps add: 0@ 1 ].	].		speedMult := evt shiftKeyPressed		ifTrue: [ 4 ] 		ifFalse: [ 1 ].	animation ifNotNil: [ ^ self ].	steps ifEmpty: [ ^ self ].	rect := self encompassingRectangleFor: evt canvas.	speed := (rect width min: rect height) * 0.0005.	animation := nil.	lastMS := nil.	animation := evt canvas newAnimation repeat onStepDo: [ :t |		| step camera correct position deltaMS current |		current := animation currentTime.		lastMS ifNil: [ lastMS := current-1 ].		deltaMS := current - lastMS.		lastMS := current.		step := steps inject: 0@0 into: [:p :s |p+s ].		camera := evt camera.		camera translateBy: step / (evt canvas camera scale / (speed * speedMult * deltaMS)).		position := camera position.		correct := self correctCameraPosition: evt.		correct = position 			ifFalse: [ camera position: correct ].		evt signalUpdate.		].! !!RSKeyNavigationCanvas methodsFor: 'events'!processKeyUp: evt	| keyName |	steps removeAll.	keyName := evt keyName.	keyName = #I ifTrue: [ ^ self zoomIn: evt ].	keyName = #O ifTrue: [ ^ self zoomOut: evt ].	keyName = #M ifTrue: [ ^ self expandCollapse: evt ].	animation ifNil: [ ^ self ].	self removeRectanglesFor: evt canvas.	animation stop.	animation := nil.! !!RSKeyNavigationCanvas methodsFor: 'rendering'!renderLegendOn: lb	lb		text: '↑ ↓ → ←' description: 'Arrow keys to move the view';		text: 'Shift + arrows' description: 'Accelerate the move';		text: 'M' description: 'Maximize or restore the window';		text: 'I' description: 'Zoom in';		text: 'O' description: 'Zoom out'.! !!RSKeyNavigationCanvas methodsFor: 'events-processing'!zoomIn: evt	self zoomMove: evt delta: 1.5! !!RSKeyNavigationCanvas methodsFor: 'events-processing'!zoomMove: evt delta: delta	| scale camera newScale correct |	camera := evt camera.	scale := camera scale.	newScale := self scaleFor: delta * scale. 	evt canvas newAnimation 		easing: RSEasing backOut;		duration: 200 milliSeconds;		from: scale;		to: newScale;		on: camera set: #scale:.	correct := self 		correctCameraPosition: evt		scale: newScale.	correct = camera position ifTrue: [ ^ self ].	evt canvas newAnimation 		easing: RSEasing backOut;		duration: 200 milliSeconds;		from: camera position;		to: correct;		on: camera set: #translateTo:.! !!RSKeyNavigationCanvas methodsFor: 'events-processing'!zoomOut: evt	self zoomMove: evt delta: 0.5.	! !!RSScrollBarsCanvas methodsFor: 'hooks'!addScrollBars: aCanvas	vertical := self barShapeCopy.	horizontal := self barShapeCopy.		aCanvas addShape: vertical; addShape: horizontal.	! !!RSScrollBarsCanvas methodsFor: 'hooks'!barShapeCopy	^ barShape copy		announcer: barShape announcer;		border: (RSBorder new			color: self scrollBorderColor;			width: 0.5;			yourself);		yourself! !!RSScrollBarsCanvas methodsFor: 'private'!color: color1 border: color2	| c1 c2 extent |	c1 := color1.	c2 := color2.	extent := vertical parent extent.	vertical height >= extent y		ifTrue: [ c1 := c2 := Color transparent ].	vertical		color: c1;		borderColor: c2.	c1 := color1.	c2 := color2.	horizontal width >= extent x		ifTrue: [ c1 := c2 := Color transparent ].	horizontal	 	color: c1;		borderColor: c2.! !!RSScrollBarsCanvas methodsFor: 'initialization'!initialize	super initialize.	self initializeShape.! !!RSScrollBarsCanvas methodsFor: 'initialization'!initializeHideAnimation	| sc1 sc2 |	sc1 := NSScale linear range: { self scrollColor. Color transparent }.	sc2 := NSScale linear range: { self scrollBorderColor. Color transparent }.	hideAnimation := vertical parent transitionAnimation		duration: 1 second;		onStepDo: [ :t | 			self 				color: (sc1 scale: t) 				border: (sc2 scale: t).			vertical signalUpdate. ] ! !!RSScrollBarsCanvas methodsFor: 'initialization'!initializeShape	barShape := RSBox new		cornerRadius: (RSCornerRadius new radius: 5);		size: 10;		noPaint;		isFixed: true;		when: RSMouseDragging do: [:evt| self moveScroll: evt ];		when: RSMouseEnter do: [ :evt| | shape |			self updateScrollbars.			shape := evt shape.			shape color isTransparent 				ifFalse: [ shape color: (self scrollColor alpha: 1) ].			animation stop.			hideAnimation stop ];		when: RSMouseLeave do: [ :evt| | shape |			shape := evt shape.			shape color isTransparent 				ifFalse: [ shape color: self scrollColor ].			self removeRectanglesFor: evt canvas.			vertical parent addAnimation: animation ];		yourself! !!RSScrollBarsCanvas methodsFor: 'hooks'!moveScroll: evt	| shape delta position camera canvasExtent shapesRect correct |	shape := evt shape.	delta := evt step.	delta := shape = vertical shape		ifTrue: [ 0@delta y ]		ifFalse: [ delta x@0 ].	shape translateBy: delta.	canvasExtent := evt canvas extent.	shapesRect := self encompassingRectangleFor: evt canvas.	position := horizontal position x @ vertical position y.	position := position * shapesRect extent / canvasExtent.		camera := evt camera.	camera position: position + shapesRect origin.	correct := self correctCameraPosition: evt canvas.	correct = camera position ifFalse: [ 		camera position: correct.		self updateBasicScrollbars. ].	evt signalUpdate. ! !!RSScrollBarsCanvas methodsFor: 'hooks'!onShape: aCanvas	self addScrollBars: aCanvas.		aCanvas when: RSPositionChangedEvent do: [ self updateScrollbars ].	aCanvas when: RSScaleChangedEvent do: [ self updateScrollbars ].! !!RSScrollBarsCanvas methodsFor: 'rendering'!renderLegendOn: lb 	lb text: '' description: 'Use scrool bars to navigate'! !!RSScrollBarsCanvas methodsFor: 'accessing'!scrollBorderColor	^ Color lightGray translucent! !!RSScrollBarsCanvas methodsFor: 'accessing'!scrollColor	^ Color lightGray translucent.! !!RSScrollBarsCanvas methodsFor: 'accessing'!shape	^ barShape! !!RSScrollBarsCanvas methodsFor: 'hooks'!updateAnimation	| canvas |	canvas := vertical parent.	hideAnimation 		ifNil: [ self initializeHideAnimation ].	animation ifNotNil: [ 		animation stop.		hideAnimation stop.		^ canvas addAnimation: animation.		].	animation := canvas newAnimation		duration: 700 milliSeconds;		onStepDo: [ :t | canvas signalUpdate ];		when: RSAnimationLoopEvent do: [ 			canvas addAnimation: hideAnimation ].		! !!RSScrollBarsCanvas methodsFor: 'hooks'!updateBasicScrollbars	| canvas canvasRect shapesRect p pd ext scrollExtent |	canvas := vertical parent.	canvasRect := canvas visibleRectangle.	shapesRect := self encompassingRectangleFor: canvas.		scrollExtent := vertical width @ horizontal height.	p := canvas extent - 1 - (scrollExtent / 2).		pd := canvas extent * (canvasRect floatCenter - shapesRect origin) / shapesRect extent.	ext := canvasRect extent * canvas extent / shapesRect extent.	vertical position: p x @ pd y ; height: ext y.	horizontal position: pd x @ p y; width: ext x.! !!RSScrollBarsCanvas methodsFor: 'hooks'!updateScrollbars	self updateBasicScrollbars.	self color: self scrollColor border: self scrollBorderColor.	self updateAnimation.	vertical signalUpdate! !!RSScrollWheelCanvas methodsFor: 'hooks'!onShape: aCanvas	aCanvas when: RSMouseWheelEvent do: [ :evt | self processEvent: evt ]! !!RSScrollWheelCanvas methodsFor: 'events-processing'!processEvent: evt	| delta correct p |	delta := (evt isUp		ifTrue: [ -1]		ifFalse: [ 1 ]) * 30.	correct := self correctCameraPosition: evt.	p := (correct - evt camera position) abs max: 1@1.	p := p x sqrt @ p y sqrt.	evt camera translateBy: (0@ delta)/p.	evt signalUpdate.		animation ifNotNil: [ animation stop ].	animation := evt canvas newAnimation		duration: 300 milliSeconds;		onStepDo: [ :t | evt canvas signalUpdate ];		when: RSAnimationLoopEvent do: [ :e | 			evt canvas newAnimation				duration: 200 milliSeconds;				from: evt camera position;				to: (self correctCameraPosition: evt);				onStepDo: [ :t | 					evt camera translateTo: t.					evt signalUpdate					 ].			].			! !!RSScrollWheelCanvas methodsFor: 'rendering'!renderLegendOn: aLegendBuilder	! !!RSSearchInCanvas methodsFor: 'public'!adjustRegExpIfNecessary: regExp	^ useExactMatch ifTrue: [ regExp ] ifFalse: [ '*', regExp, '*' ]! !!RSSearchInCanvas methodsFor: 'util'!candidateShapes	"Return shapes for which the model has to be matched. 	 Only shapes that are not a line and having a model may be eligeable to be highligted"	self assert: [ canvas notNil ] description: 'Canvas should be set first'.	^ canvas shapes select: [ :s | s model notNil and: [ s isNode ] ]! !!RSSearchInCanvas methodsFor: 'accessing'!canvas: aCanvas	"Set the canvas from which shapes should be searched in"	canvas := aCanvas! !!RSSearchInCanvas methodsFor: 'public - configuration'!colorToHighlight: aColor	"Set the color to highlight shapes when searching"	highlightable := RSHighlightable new		highlightColor: aColor;		yourself.! !!RSSearchInCanvas methodsFor: 'public - configuration'!doNotUseExactMatch	"Expect a regular expression as input, but a * is prepended and appended to the regexp"	useExactMatch := false! !!RSSearchInCanvas methodsFor: 'util'!highlightShapes: shapesToHighlight	shapesToHighlight do: [ :s | self highlightShape: s ]! !!RSSearchInCanvas methodsFor: 'accessing'!highlightable	^ highlightable! !!RSSearchInCanvas methodsFor: 'initialization'!initialize	super initialize.	"The variable highlightedShapes contains the shapes that have been searched and therefore highlighted"	self 		colorToHighlight: Color red;		doNotUseExactMatch! !!RSSearchInCanvas methodsFor: 'util'!isRegExpValid: regExp	"Is the regular expression relevant to be processed"	^ regExp notNil and: [ regExp notEmpty ]! !!RSSearchInCanvas methodsFor: 'configuration'!keyForReset	^ 'R'! !!RSSearchInCanvas methodsFor: 'configuration'!keyForSearch	^ 'S'! !!RSSearchInCanvas methodsFor: 'util'!numberOfHighlightedShapes	"Return the number of shapes that have been highlited"	^ (canvas propertyAt: highlightable propertyKey)		ifNil: [ 0 ]		ifNotNil: [ :col | col size ]! !!RSSearchInCanvas methodsFor: 'private'!obtainRegExpToHighlight	"Open a UI"	^ UIManager default		request: 'Enter a reg exp to search for an item'		initialAnswer: '*value*'! !!RSSearchInCanvas methodsFor: 'public'!onShape: aCanvas	aCanvas 		when: RSKeyDown do: [ :evt | self processKeyDown: evt ]! !!RSSearchInCanvas methodsFor: 'private'!processKeyDown: evt	| keyName |	self canvas: evt canvas.	keyName := evt keyName.	keyName = self keyForSearch ifTrue: [ self searchForShapes ].	keyName = self keyForReset ifTrue: [ self resetAllHighlightedShapes ]! !!RSSearchInCanvas methodsFor: 'rendering'!renderLegendOn: aLegendBuilder	aLegendBuilder		text: self keyForSearch		description: 'Search and highlight items'.	aLegendBuilder		text: self keyForReset		description: 'Unhighlight all items'! !!RSSearchInCanvas methodsFor: 'public'!resetAllHighlightedShapes	"Restore the colors of all the highlighted shapes"	highlightable unhighlightRecordedShapes: canvas.	canvas signalUpdate.! !!RSSearchInCanvas methodsFor: 'public'!searchForShapes	"callback called when some shapes have to be search"	| regExp |	regExp := self obtainRegExpToHighlight.	(self isRegExpValid: regExp)		ifFalse: [ ^ self ].	self searchForShapes: regExp! !!RSSearchInCanvas methodsFor: 'public'!searchForShapes: regExp	"callback called when some shapes have to be search"	| shapesToHighlight |	shapesToHighlight := self shapesToHighlightUsingRegExp: (self adjustRegExpIfNecessary: regExp).			"No need to pursue if we have not found anything"	shapesToHighlight ifEmpty: [ ^ self ].		highlightable doHighlightShapes: shapesToHighlight.	canvas signalUpdate! !!RSSearchInCanvas methodsFor: 'util'!shapesToHighlightUsingRegExp: regExp	"Return the shapes to be highlighted"		| candidateShapes shapesToHighlight |	candidateShapes := self candidateShapes.	shapesToHighlight := candidateShapes		select: [ :s | regExp match: s model asString ].	^ shapesToHighlight! !!RSSearchInCanvas methodsFor: 'util'!unhighlightShape: s	^ RSHighlightable new restore: s selector: #color! !!RSSearchInCanvas methodsFor: 'util'!unhighlightShapes: shapesToHighlight	shapesToHighlight do: [ :s | self unhighlightShape: s ]! !!RSSearchInCanvas methodsFor: 'public - configuration'!useExactMatch	"Expect a regular expression as input"	useExactMatch := true! !!RSZoomToFitCanvas methodsFor: 'zoom animation'!animatedZoomToFit: aCanvas	| sc position scale camera pos |	camera := aCanvas camera.	sc := camera scale.	pos := camera position.	aCanvas zoomToFit. 		position := NSScale linear		from: pos;		to: camera position.	scale := NSScale linear		from: sc;		to: camera scale.	camera translateTo: pos; scale: sc.	sc < 1 ifTrue: [ 		aCanvas newAnimation			duration: 500 milliSeconds;			easing: RSEasing backOut;			onStepDo: [ :t | 				camera					position: (position scale: t);					scale: (scale scale: t).				aCanvas signalUpdate ].		^ self ].	aCanvas newAnimation 		delay: 150 milliSeconds;		duration: 700 milliSeconds;		easing: RSEasing backOut;		onStepDo: [:t |			camera position: (position scale: t).			aCanvas signalUpdate].	aCanvas newAnimation		duration: 300 milliSeconds;		easing: RSEasing exp;		onStepDo: [ :t | 				camera scale: (scale scale: t).				aCanvas signalUpdate ]		! !!RSZoomToFitCanvas methodsFor: 'hooks'!cameraFor: aCanvas	^ RSConfigurableCamera new		canvas: aCanvas;		zoomInteraction: self;		yourself! !!RSZoomToFitCanvas methodsFor: 'hooks'!onShape: aCanvas	aCanvas when: RSKeyUp do: [ :evt | self processKeyUp: evt ].	aCanvas when: RSExtentChangedEvent do: [ self zoomToFitIfNecessary: aCanvas ].	aCanvas camera: (self cameraFor: aCanvas). 	self configuration shouldZoomToFitOnStart ifFalse: [ ^ self ].	aCanvas zoomToFit.! !!RSZoomToFitCanvas methodsFor: 'private - events'!processKeyUp: evt	evt keyName = #KP_SPACE ifFalse:  [ ^ self ].	self animatedZoomToFit: evt canvas! !!RSZoomToFitCanvas methodsFor: 'rendering'!renderLegendOn: lb	lb text: 'Space' description: 'To zoom to fit the view'.! !!RSZoomToFitCanvas methodsFor: 'zoom animation'!zoomToFitIfNecessary: aCanvas	self configuration shouldZoomToFitOnExtendChanged ifFalse: [ ^ self ].	aCanvas zoomToFit! !!RSZoomableCanvas methodsFor: 'hooks'!onShape: aCanvas	aCanvas when: RSMouseWheelEvent do: [ :evt | self processEvent: evt ]! !!RSZoomableCanvas methodsFor: 'events-processing'!processEvent: evt	| sc delta camera dist scale position correct |	animation ifNotNil: [ ^ self ].	delta := evt isUp		ifTrue: [ 1.25@0.2 ]		ifFalse: [ 0.8@ -0.25 ].	camera := evt camera.	sc := camera scale * delta x.	sc = (self scaleFor: sc) ifFalse: [ ^ self ].	dist := evt position - camera position.	correct := self		correctCameraPosition: evt 		inRectangle: (self expandedRectangle: evt)		position: camera position + (dist * delta y)		scale: sc.	scale := NSScale sqrt range: { camera scale. sc }.	position := NSScale sqrt range: { camera position. correct }.	animation := evt canvas newAnimation		duration: 200 milliSeconds;		onStepDo: [ :t |			camera 				scale: (scale scale: t);				translateTo: (position scale: t).			evt signalUpdate ];		when: RSAnimationEndEvent do: [ animation := nil ]! !!RSZoomableCanvas methodsFor: 'rendering'!renderLegendOn: lb	lb text: 'Wheel' description: 'To zoom in-out the view'.! !!RSZoomableCanvas methodsFor: 'rendering'!renderOn: lb	lb text: 'Wheel' description: 'To zoom in-out the view'.! !!RSCanvasController methodsFor: 'accessing'!addInteraction: anInteractionObject	self interactions: (self interactions, (Array with: anInteractionObject class -> anInteractionObject)).	anInteractionObject configuration: configuration! !!RSCanvasController methodsFor: 'accessing'!configuration	^ configuration! !!RSCanvasController methodsFor: 'accessing'!configuration: aRSControlLimits	configuration := aRSControlLimits.	self interactions do: [ :i | i configuration: configuration ].! !!RSCanvasController methodsFor: 'initialization'!defaultInteractions	"create a subclass of RSControslView and define your own custom interactions for your views :V"	^ { RSDraggableCanvas. RSKeyNavigationCanvas. RSZoomToFitCanvas. RSZoomableCanvas. RSScrollBarsCanvas }! !!RSCanvasController methodsFor: 'initialization'!initialize	super initialize.	self interactions: (self defaultInteractions collect: #new).	self		withLegend;		configuration: RSControlConfiguration new.! !!RSCanvasController methodsFor: 'accessing'!interactions	^ interactions! !!RSCanvasController methodsFor: 'accessing'!interactions: aCollectionOfInteractions	interactions := OrderedDictionary new.	aCollectionOfInteractions do: [ :int |		interactions at: int class put: int ].	! !!RSCanvasController methodsFor: 'configuration'!noLegend	withLegend := false! !!RSCanvasController methodsFor: 'hooks'!onShape: aCanvas	aCanvas controllerInteraction ifNotNil: [ ^ self ].	aCanvas controllerInteraction: self.	self interactions do: [ :int | int onShape: aCanvas ].	self renderLegendOn: aCanvas.	! !!RSCanvasController methodsFor: 'hooks'!renderLegendOn: aCanvas	| lb |	self shouldShowLegend ifFalse: [ ^ self ].	lb := RSLegend new 		container: aCanvas;		yourself.	lb defaultTitle fontSize: 12.	lb defaultLabel fontSize: 10.	lb defaultBoldText fontSize: 10.	lb leyendDo: [ :l |		l 			border: RSBorder new;			color: (Color white alpha: 0.8);			padding: 10.		].	lb title: 'Shortcuts'.	self interactions do: [ :int | int renderLegendOn: lb ].	lb onDemand.	lb build.! !!RSCanvasController methodsFor: 'testing'!shouldShowLegend	^ withLegend! !!RSCanvasController methodsFor: 'configuration'!withLegend	withLegend := true! !!RSAbstractPopup class methodsFor: 'accessing'!activationEvent	^ RSMouseMove! !!RSAbstractPopup class methodsFor: 'accessing'!removeEvents	^ removeEvents ifNil: [ 		removeEvents := { RSMouseClick. RSMouseEnter. RSMouseLeave. RSMouseDragging } ]! !!RSAbstractPopup class methodsFor: 'instance creation'!reset	<script: 'self reset'>	super reset.	removeEvents := nil.! !!RSAbstractPopup methodsFor: 'hooks'!createOrGetPopupOn: aShape event: event	"Create a popup and register it"	| prop popupShape key |	prop := event canvas properties.	key := self popupKey.	"We checked if the very same shape has emitted the popup.	If this is the case, then we use the popup previously created, 	else, we remove it"	((prop includesKey: key) and: [ (prop includesKey: #shapeWithPopup) ])		ifTrue: [ | popup |			popup := prop at: key.			(prop at: #shapeWithPopup) == aShape				ifTrue: [ ^ popup ]				ifFalse: [ self releasePopup: popup ] ].	popupShape := self createPopupFor: aShape event: event.	prop at: key put: popupShape.	prop at: #shapeWithPopup put: aShape.	^ popupShape	! !!RSAbstractPopup methodsFor: 'hooks'!createPopupFor: aShape event: event	^ self subclassResponsibility! !!RSAbstractPopup methodsFor: 'hooks'!onShape: aShape	aShape removeInteractionIfPresent: self class.		self registerRemoveEventsOn: aShape.	aShape		when: self class activationEvent do: [ :evt | | popup |			popup := self createOrGetPopupOn: evt shape event: evt.			self translatePopup: popup event: evt.			evt signalUpdate. ]! !!RSAbstractPopup methodsFor: 'accessing'!popupKey	^ #popup! !!RSAbstractPopup methodsFor: 'hooks'!registerRemoveEventsOn: aShape	self class removeEvents do: [ :clsEvent | 		aShape 			when: clsEvent			do: [ :evt | self removePopupOn: evt  ] ]! !!RSAbstractPopup methodsFor: 'hooks'!releasePopup: popup	self subclassResponsibility! !!RSAbstractPopup methodsFor: 'hooks'!removePopupOn: evt	| att popup key |	"It may happen that the canvas is not set. This is the case when an element is not added to a view.	If the element is not part of a view, then there is nothing to remove, so we exit early."	evt canvas ifNil: [ ^ self ].	att := evt canvas properties.	key := self popupKey.	(att includesKey: key) ifFalse: [ ^ self ].	popup := att at: key.	self releasePopup: popup.	att removeKey: key.	evt signalUpdate.! !!RSAbstractPopup methodsFor: 'hooks'!translatePopup: popup event: evt	self subclassResponsibility! !!RSMorphicPopup methodsFor: 'accessing'!backgroundColor	^ Smalltalk ui theme backgroundColor! !!RSMorphicPopup methodsFor: 'hooks'!createPopupFor: aShape event: event	| popup vertices targetMorph world |	targetMorph := self morphBuilder cull: aShape model.	vertices := SimpleBalloonMorph getVertices: targetMorph bounds.	popup := SimpleBalloonMorph new		color: self backgroundColor;		addMorph: targetMorph;		setTarget: nil;		setVertices: vertices.	world := event canvas morph world.	world ifNil: [ ^ popup ].	world addMorphFront: popup.	world activeHand balloonHelp: popup.	^ popup! !!RSMorphicPopup methodsFor: 'initialization'!initialize	super initialize.	self morphBuilder: [ :model | model asString asTextMorph ].! !!RSMorphicPopup methodsFor: 'accessing'!morphBuilder	^ morphBuilder! !!RSMorphicPopup methodsFor: 'accessing'!morphBuilder: aBlock	morphBuilder := aBlock! !!RSMorphicPopup methodsFor: 'hooks'!popupKey	^ #popupMorph! !!RSMorphicPopup methodsFor: 'hooks'!releasePopup: popup	popup delete! !!RSMorphicPopup methodsFor: 'hooks'!translatePopup: aMorph event: evt 	| position xdelta ydelta cMorph world |	cMorph := evt canvas morph.	world := cMorph world.	position := (evt camera fromSpaceToPixel: evt position) + cMorph position.	xdelta := ydelta := 0.		(position x + aMorph width) > world width 		ifTrue: [ xdelta := aMorph width negated ].	(position y + aMorph height) > world height 		ifTrue: [ ydelta := aMorph height negated ].		aMorph		lock;		fullBounds;		setProperty: #morphicLayerNumber toValue: aMorph morphicLayerNumber.		aMorph position: ((position x + xdelta) max: 0) @ ((position y + ydelta) max: 0)! !!RSAnimatedPopup class methodsFor: 'accessing'!activationEvent	^ RSMouseEnter! !!RSAnimatedPopup class methodsFor: 'accessing'!removeEvents	^ removeEvents ifNil: [ 		removeEvents := { RSMouseClick. RSMouseLeave. RSMouseDragging } ]! !!RSAnimatedPopup methodsFor: 'hooks'!translatePopup: popup event: evt 	| p pscale canvasExtent side scale |	p := evt shape positionInCanvas.	evt shape isFixed		ifFalse: [ p := evt canvas camera fromSpaceToPixel: p ].	popup translateTo: 0@0.	p := p + (0@(evt shape height + popup height + 10 / 2)).	canvasExtent := evt shape canvas extent.	side := popup width / 2.	p x + side > canvasExtent x		ifTrue: [ p := (canvasExtent x - side - 5)@ p y ].		popup translateTo: p.		"animation part"	pscale := NSScale linear range: { p x @ (p y - (popup height / 2) ) . p }.	scale := popup matrix sx @ popup matrix sy.	evt shape newAnimation 		duration: 300 milliSeconds; 		from: 0.05; to: 1;		easing: RSEasing backOut;		onStepDo: [ :t | 			popup matrix 				loadIdentity;				translation: (pscale scale: t);				scaleBy: (1@t) * scale.			popup signalUpdate.			].! !!RSPopup class methodsFor: 'accessing'!text: anObject	| inst |	inst := self new.	inst shapeBuilder textBlock: anObject.	^ inst! !!RSPopup methodsFor: 'hooks'!createPopupFor: aShape event: event	| popupShape |	popupShape := shapeBuilder shapeFor: aShape model.	popupShape isFixed: true.	event canvas addShape: popupShape.	^ popupShape.! !!RSPopup methodsFor: 'initialization'!initialize	super initialize.	shapeBuilder := RSSimplePopupBuilder new.! !!RSPopup methodsFor: 'hooks'!releasePopup: popup	popup remove! !!RSPopup methodsFor: 'accessing'!shapeBuilder	^ shapeBuilder! !!RSPopup methodsFor: 'accessing'!shapeBuilder: aShapeBuilder	shapeBuilder := aShapeBuilder! !!RSPopup methodsFor: 'accessing'!text: oneArgBlock	"The block is evaluated with the model provided as argument"	self shapeBuilder textBlock: oneArgBlock! !!RSPopup methodsFor: 'hooks'!translatePopup: popup event: evt 	| p e extent |	p := evt camera fromSpaceToPixel: evt position.	extent := popup canvas extent.	e := (popup extent /2) + 5.	p x + popup width > extent x ifTrue: [ 		e := e x negated @ e y.		p x - popup width < 0		ifTrue: [ e := p x negated + (popup width/2 + 4) @ e y ].		].	p y + popup height > extent y ifTrue: [ 		e := e x @ e y negated.		p y - popup height < 0		ifTrue: [ e := e x @ ( p y negated + (popup height/2 + 4) ) ]		]. 	popup translateTo: p + e.! !!RSAbstractScaleInteraction methodsFor: 'accessing'!initialize	super initialize.	self 		minScale: 0.1;		maxScale: 3.! !!RSAbstractScaleInteraction methodsFor: 'accessing'!maxScale	^ maxScale! !!RSAbstractScaleInteraction methodsFor: 'accessing'!maxScale: aNumber	maxScale := aNumber! !!RSAbstractScaleInteraction methodsFor: 'accessing'!minScale	^ minScale! !!RSAbstractScaleInteraction methodsFor: 'accessing'!minScale: aNumber	minScale := aNumber! !!RSAbstractScaleInteraction methodsFor: 'accessing'!scaleFor: anEvent	| delta |	delta := 1 / anEvent newScale.	^ (maxScale min: delta ) max: minScale.! !!RSKeepBorderWidthRatio methodsFor: 'hooks'!onShape: aShape	| width |	aShape isInACanvas ifFalse: [ self error: 'aShape needs to be part of one canvas' ].	width := aShape border width.	aShape canvas when: RSScaleChangedEvent do: [:evt | 		aShape border width: (self scaleFor: evt) * width.		evt signalUpdate ]. ! !!RSKeepMarkersSizeRatio methodsFor: 'hooks'!onShape: anEdge	| markers sizes offsets |	anEdge isInACanvas ifFalse: [ self error: 'add this edge to a canvas first' ].	markers := anEdge markers select: #notNil.	sizes := markers collect: [:marker | marker shape extent].	offsets := markers collect: #offset.	anEdge canvas when: RSScaleChangedEvent do: [ :evt | | delta |		delta := self scaleFor: evt.		markers doWithIndex: [ :marker :index | 			marker shape extent: delta * (sizes at: index).			marker offset: delta * (offsets at: index)  ] ].! !!RSDraggable class methodsFor: 'instance creation'!wantsUniqueInstance	^ true! !!RSDraggable methodsFor: 'hooks'!onShape: aShape	aShape		when: RSMouseDragging		do: [ :evt | 			| d |			d := evt camera distanceFromPixelToSpace: evt step.			evt shape translateBy: d.			evt signalUpdate ]! !!RSHighlightable class methodsFor: 'instance creation'!defaultRed	| inst |	inst := self new.	inst highlightColor: Color red.	^ inst	! !!RSHighlightable methodsFor: 'announce'!announce: anEvent	announcer ifNil: [ ^ self ].	announcer announce: anEvent value! !!RSHighlightable methodsFor: 'announce'!announceHighlight: shape source: shapeOrCanvas	self announce: [ RSHighlightEvent new		interaction: self;		shape: shape;		source: shapeOrCanvas ].! !!RSHighlightable methodsFor: 'announce'!announceUnHightlight: shape source: shapeOrCanvas	self announce: [ RSUnHighlightEvent new		interaction: self;		shape: shape;		source: shapeOrCanvas ].! !!RSHighlightable methodsFor: 'announce'!announcer	^ announcer ifNil: [ announcer := Announcer new ].! !!RSHighlightable methodsFor: 'announce'!announcer: anAnnouncer	announcer := anAnnouncer! !!RSHighlightable methodsFor: 'accessing - keys'!copyKey	^ copyKey ifNil: [ copyKey := #original ].! !!RSHighlightable methodsFor: 'accessing - keys'!copyKey: aSymbol	copyKey := aSymbol! !!RSHighlightable methodsFor: 'actions'!doHighlight: shape	| shapes |	self unhighlightRecordedShapes: shape.	shapes := self highlightShapesFor: shape.	shapes do: [ :e | self announceHighlight: e source: shape ].		shape topParent propertyAt: self propertyKey put: shapes.! !!RSHighlightable methodsFor: 'actions'!doHighlightShapes: shapes	| allHShapes |	shapes ifEmpty: [ ^ self ].	self unhighlightRecordedShapes: shapes first.	allHShapes := shapes flatCollect: [ :s | | hshapes |		hshapes := self highlightShapesFor: s.		hshapes do: [ :hs | self announceHighlight: hs source: s ].		hshapes ].	shapes first canvas propertyAt: self propertyKey put: allHShapes.! !!RSHighlightable methodsFor: 'actions'!doUnhighlight: aShape	self unhighlightRecordedShapes: aShape! !!RSHighlightable methodsFor: 'public'!highlightBorder: aBorder	"Set the border. For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new  size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.interaction := RSHighlightable new.interaction highlightBorder: (RSBorder new width: 3; color: Color pink).shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```	"	self 		when: RSHighlightEvent do: [ :evt | self record: evt shape selector: #border value: aBorder ];		when: RSUnHighlightEvent do: [ :evt | self restore: evt shape selector: #border ].! !!RSHighlightable methodsFor: 'public'!highlightColor: aColor	"Set the highlight color. For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 30) collect: [ :v | RSBox new  size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup.interaction := RSHighlightable new.interaction highlightColor: Color blue.shapes @ interaction.RSGridLayout on: shapes.c @ RSCanvasController```Here is another example:```Smalltalkc := RSCanvas new.shapes := (1 to: 10) collect: [ :v | RSEllipse new size: 20; model: v ] as: RSGroup.c addAll: shapes.shapes @ RSPopup @ RSDraggable.RSGridLayout on: shapes.eb := RSEdgeBuilder arrowedLineWithOffset: 0.5.eb canvas: c.eb connectTo: [ :v | 1 ].int := RSHighlightable new withEdges highlightColor: Color red.shapes @ int.c @ RSCanvasController```	"	self 		when: RSHighlightEvent do: [ :evt | self record: evt shape selector: #color value: aColor ];		when: RSUnHighlightEvent do: [ :evt | self restore: evt shape selector: #color ].! !!RSHighlightable methodsFor: 'accessing'!highlightShapes	^ highlightShapes! !!RSHighlightable methodsFor: 'accessing'!highlightShapes: aBlockOnArg	"the block should return a collection of shapes"	highlightShapes := aBlockOnArg! !!RSHighlightable methodsFor: 'public - hooks'!highlightShapes: aBlock butKeep: aRSHighlightable	"aBlock recives an element and return a collection of shapes"	self highlightShapes: [ :e | 		| shapes |		shapes := aBlock value: e.		e canvas properties			at: aRSHighlightable propertyKey			ifPresent: [ :hshapes | 				shapes reject: [ :hs | hshapes includes: hs ] ]			ifAbsent: [ shapes ] ]! !!RSHighlightable methodsFor: 'public - hooks'!highlightShapesButKeep: aRSHighlightable	self 		highlightShapes: [ :e | { e } ]		butKeep: aRSHighlightable! !!RSHighlightable methodsFor: 'private'!highlightShapesFor: aShape	^ highlightShapes rsValue: aShape! !!RSHighlightable methodsFor: 'initialization'!initialize	super initialize.	self highlightShapes: [ :shape | Array with: shape ].! !!RSHighlightable methodsFor: 'public'!lowColor: lowColor highColor: highColor	self 		when: RSHighlightEvent do: [ :evt | evt shape color: highColor  ];		when: RSUnHighlightEvent do: [ :evt | evt shape color: lowColor ].	! !!RSHighlightable methodsFor: 'hooks'!onShape: aShape	aShape		when: RSMouseEnter do: [ :evt | self doHighlight: evt shape. evt signalUpdate ];		when: RSMouseLeave do: [ :evt | self doUnhighlight: evt shape. evt signalUpdate ]! !!RSHighlightable methodsFor: 'accessing - keys'!propertyKey	^ propertyKey ifNil: [ propertyKey := self hash asString ]! !!RSHighlightable methodsFor: 'accessing - keys'!propertyKey: aSymbol	propertyKey := aSymbol.! !!RSHighlightable methodsFor: 'private'!record: aShape selector: selector value: anObject	"Main method to change an attribute of a shape (e.g., colors, border)	For example:	-=-=-=-=	c := RSCanvas new.	shapes := (1 to: 10) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.	c addAll: shapes.	RSGridLayout on: shapes.	RSHighlightable new record: shapes fifth selector: #color value: Color blue.	c	-=-=-=-=		"	| savedValues |	savedValues := aShape properties		at: self copyKey , selector		ifAbsentPut: [ OrderedCollection new ].	savedValues add: (aShape perform: selector).		aShape		perform: selector asMutator		with: (anObject rsValue: aShape)! !!RSHighlightable methodsFor: 'actions'!resetHighlightedShapes: shapeOrCanvas	| att |	att := shapeOrCanvas topParent properties.	(att includesKey: self propertyKey) ifFalse: [ ^ self ].	att removeKey: self propertyKey! !!RSHighlightable methodsFor: 'private'!restore: aShape selector: selector	"Main method to restore the attribute of a shape.	-=-=-=-=-=-=-=-=-=-=-=-=	c := RSCanvas new.	shapes := (1 to: 10) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.	c addAll: shapes.	RSGridLayout on: shapes.	RSHighlightable new record: shapes fifth selector: #color value: Color blue.	RSHighlightable new restore: shapes fifth selector: #color.	c	-=-=-=-=-=-=-=-=-=-=-=-="	| key savedValues |	key := self copyKey, selector.	savedValues := aShape properties 		at: key		ifAbsent: [ ^ self ].	aShape		perform: selector asMutator		with: savedValues removeLast.	savedValues ifEmpty: [ aShape properties removeKey: key ]	! !!RSHighlightable methodsFor: 'public'!setupAntAnimation	self withEdges.	self when: RSHighlightEvent do: [ :evt | | shape border |		shape := evt shape.		border := shape border.		shape propertyAt: #ob put: border.		border ifNil: [ border := RSBorder new ].		shape border: (RSBorder new width: border width * 2; color: border color).		shape isNode ifTrue: [ 			| array anime |			array := #(4).			shape connectedEdges do: [ :edge | edge border 				color: Color blue; 				width: 2;				dashArray: array. ].			anime := shape newAnimation				repeat;				from: 0;				to: -8;				duration: 1 second;				onStepDo: [ :t |					shape connectedEdges do: [ :ed |ed border dashOffset: t ].					shape signalUpdate ].			shape topParent propertyAt: #antAnimation put: anime.		].	].	self when: RSUnHighlightEvent do: [ :evt | 		| att shape |		shape := evt shape.		shape border: (shape propertyAt: #ob).		shape removeKey: #ob.		shape isNode ifTrue: [ 			att := shape topParent properties.			(att at: #antAnimation) stop.			att removeKey: #antAnimation.		 ]	].! !!RSHighlightable methodsFor: 'actions'!unhighlightRecordedShapes: shapeOrCanvas	shapeOrCanvas topParent properties 		at: self propertyKey 		ifPresent: [ :shapes |			shapes do: [ :s | self announceUnHightlight: s source: shapeOrCanvas ].		 ].	self resetHighlightedShapes: shapeOrCanvas! !!RSHighlightable methodsFor: 'announcing'!when: event do: aBlock	self announcer when: event do: aBlock! !!RSHighlightable methodsFor: 'public - hooks'!withEdges	self highlightShapes: [ :s | 		| list |		list := s connectedEdges copy.		list add: s.		list ].! !!RSHighlightable methodsFor: 'public - hooks'!withIncomingEdges	self highlightShapes: [ :s | 		| list |		list := s incomingEdges collect: #yourself as: RSGroup.		list add: s.		list ].! !!RSHighlightable methodsFor: 'public - hooks'!withOutgoingEdges	self highlightShapes: [ :s | 		| list |		list := s outgoingEdges collect: #yourself as: RSGroup.		list add: s.		list ].! !!RSInteraction class methodsFor: 'instance creation'!instance	^ instance ifNil: [ instance := self new ].! !!RSInteraction class methodsFor: 'instance creation'!onShape: aShape	| inst |	inst := self wantsUniqueInstance 		ifTrue: [ self instance ]		ifFalse: [ self new ].	inst onShape: aShape.	^ inst! !!RSInteraction class methodsFor: 'instance creation'!reset	<script: 'self reset'>	instance := nil! !!RSInteraction class methodsFor: 'instance creation'!wantsUniqueInstance 	^ false! !!RSInteraction methodsFor: 'hooks'!onShape: aShape	self subclassResponsibility 	! !!RSLabeled methodsFor: 'hooks'!createLabel: aShape	| label color set targetLabel |	label := self shapeBuilder shapeFor: (self modelFor: aShape).	location stick: label on: aShape.	isHighlightable 		ifFalse: [ ^ label ].	targetLabel := target value: label.	color := targetLabel color.	targetLabel color: self lowColor.	set := [ :c | 		label pushFront.		targetLabel color: c.		label signalUpdate ].	aShape 		when: RSMouseEnter do: [ set value: color ];		when: RSMouseLeave do: [ set value: lowColor ];		when: RSShapeRemovedEvent do: [ label remove ].	^ label! !!RSLabeled methodsFor: 'hooks'!getOrCreateLabel: aShape	| label parent |	label := aShape properties 		at: #RSLabeled		ifAbsentPut: [ self createLabel: aShape ].	parent :=aShape parent.	(label isInACanvas not and: [parent notNil ]) 		ifTrue: [ parent addShape: label shape ].	^ label! !!RSLabeled methodsFor: 'public - configuration'!highlightable	"Make the label highlightable.For example:```Smalltalkc := RSCanvas new.shapes := (1 to: 10) collect: [ :v | RSBox new model: v; size: 30 ] as: RSGroup.c addAll: shapes.shapes @ RSLabeled new highlightable.RSNormalizer size shapes: shapes; normalize: #yourself.RSGridLayout on: shapes.c @ RSCanvasController.c ```"	isHighlightable := true.	self 		lowColor: Color veryVeryLightGray;		target: #yourself.! !!RSLabeled methodsFor: 'initialization'!initialize 	super initialize.	self shapeBuilder: RSMultilineLabelBuilder new.	self model: #model.	location := RSLocation new above.	isHighlightable := false.! !!RSLabeled methodsFor: 'accessing'!location	^ location! !!RSLabeled methodsFor: 'accessing'!lowColor	^ lowColor! !!RSLabeled methodsFor: 'accessing'!lowColor: aColor	lowColor := aColor! !!RSLabeled methodsFor: 'accessing'!model	^ modelBlock! !!RSLabeled methodsFor: 'accessing'!model: aBlock	modelBlock := aBlock! !!RSLabeled methodsFor: 'hooks'!modelFor: anElement	^ modelBlock rsValue: anElement.! !!RSLabeled methodsFor: 'hooks'!onShape: aShape		aShape isInACanvas 		ifTrue: [ self getOrCreateLabel: aShape ]		ifFalse: [ aShape when: RSShapeAddedEvent do: [ :evt | 			self getOrCreateLabel: evt shape ] ].! !!RSLabeled methodsFor: 'accessing'!shapeBuilder	^ shapeBuilder! !!RSLabeled methodsFor: 'accessing'!shapeBuilder: aShapeBuilder	shapeBuilder := aShapeBuilder! !!RSLabeled methodsFor: 'accessing'!target	^ target! !!RSLabeled methodsFor: 'accessing'!target: aBlock	target := aBlock! !!RSLabeled methodsFor: 'public - configuration'!text: aBlockOrSymbol	shapeBuilder textBlock: aBlockOrSymbol! !!RSMenuActivable methodsFor: 'enumerating'!menuDo: block	"a block with two args	first arg, a MenuMorph	second arg, a RSElement or RSView	"	menuBlock := block! !!RSMenuActivable methodsFor: 'hooks'!onShape: aShape	"No need to do anything if empty"	menuBlock isNil ifTrue: [ ^ self ].	aShape when: RSMouseRightClick do: [ :evt | 		| menu |		menu := MenuMorph new.		menuBlock value: menu value: aShape.		menu popUpInWorld ].	! !!RSRotated methodsFor: 'hooks'!dragEnd: evt	drag := false.	prevAngle := nil.! !!RSRotated methodsFor: 'hooks'!dragStart: evt	drag := true.! !!RSRotated methodsFor: 'hooks'!dragging: evt	| angle |	drag ifFalse: [ ^ self ].	angle := evt position angle.	totalAngle ifNil: [ totalAngle := 0 ].	prevAngle ifNil: [ prevAngle := angle ].	totalAngle := totalAngle + (angle - prevAngle).	prevAngle := angle.	targetShape matrix		loadIdentity;		rotateByRadians: totalAngle.	evt signalUpdate! !!RSRotated methodsFor: 'initialization'!initialize	super initialize.	drag := false.! !!RSRotated methodsFor: 'hooks'!onShape: aShape	targetShape := aShape.	aShape parent		when: RSMouseLeftDragStart do: [ :evt|  self dragStart: evt ];		when: RSMouseDragging do: [ :evt | self dragging: evt ];		when: RSMouseDragEnd do: [ :evt | self dragEnd: evt ].! !!RSTransformable methodsFor: 'rectangle'!bottomCenter: position rectangle: rectangle 	^ rectangle origin -> (rectangle corner x @ position y)! !!RSTransformable methodsFor: 'rectangle'!bottomLeft: position rectangle: rectangle 	^ (position x @ rectangle origin y) -> (rectangle corner x @ position y)! !!RSTransformable methodsFor: 'rectangle'!bottomRight: position rectangle: rectangle 	^ rectangle origin -> position! !!RSTransformable methodsFor: 'accessing - shapes'!boxShape	^ RSPolygon new		noPaint;		border: (RSBorder new			color: Color gray);		yourself				! !!RSTransformable methodsFor: 'accessing'!cornersAndSides	^ {		#topLeft -> #topLeft.	#topCenter -> #top.	#topRight -> #topRight.	#rightCenter -> #right.	#bottomRight -> #bottomRight.	#bottomCenter -> #bottom.	#bottomLeft -> #bottomLeft.	#leftCenter -> #left.}.! !!RSTransformable methodsFor: 'accessing - shapes'!createHandleFor: association	| handle |	handle := RSEllipse new		size: 20;		model: association;		color: Color white;		border: (RSBorder new width: 5; color: Color gray);		draggable;		yourself.	handle announcer		when: RSMouseEnter send: #showCursor: to: self;		when: RSMouseLeave send: #removeCursor to: self;		when: RSMouseDragStart send: #saveCurrentShapeState to: self;		when: RSPositionChangedEvent send: #updateCurrentShape: to: self.	^ handle! !!RSTransformable methodsFor: 'accessing - shapes'!createHandlesFor: shape	| handles circles |	handles := RSGroup new.	currentShape := shape.	self saveCurrentShapeState.	handles add: self boxShape.	circles := self cornersAndSides collect: [ :sel | self createHandleFor: sel ].	handles addAll: circles.	"TODO	handles add: self rotationShape."	self saveHandles: handles evt: shape.	self updateHandles: shape.	^ handles.				! !!RSTransformable methodsFor: 'cursor'!cursorForCorner: aCorner	^ Cursor perform: ('resize' , aCorner capitalized) asSymbol! !!RSTransformable methodsFor: 'public'!disableHandles: evt	| shape key bool |	shape := evt shape.	key := self key.	bool := shape hasProperty: key.	self removeHandles: evt.	bool ifFalse: [ ^ self ].	shape propertyAt: key put: #disable.! !!RSTransformable methodsFor: 'public'!enableHandles: evt	| shape key |	shape := evt shape.	key := self key.	(shape hasProperty: key) ifFalse: [ ^ self ].	shape removeKey: key.	self showHandles: evt.	! !!RSTransformable methodsFor: 'accessing'!key	^ self class name! !!RSTransformable methodsFor: 'rectangle'!leftCenter: position rectangle: rectangle 	^ (position x @ rectangle origin y) -> rectangle corner! !!RSTransformable methodsFor: 'hooks'!onShape: aShape	aShape isNode ifFalse: [ ^ self ].	aShape announcer		when: RSMouseLeftClick send: #showHandles: to: self;		when: RSMouseDragStart send: #disableHandles: to: self;		when: RSMouseDragEnd send: #enableHandles: to: self.! !!RSTransformable methodsFor: 'private'!registerCanvasEventsIfNecessary: evt	| canvas |	canvas := evt canvas.	(canvas hasInteraction: self class) ifTrue: [ ^ self ].	canvas announcer		when: RSMouseClick 		send: #removeHandles:		to: self! !!RSTransformable methodsFor: 'cursor'!removeCursor	self setCursor: nil	! !!RSTransformable methodsFor: 'public'!removeHandles: evt	| canvas key handles |	canvas := evt canvas.	key := self key.	handles := canvas propertyAt: key.	handles ifNil: [ ^ self ].	evt shape ifNotNil: [ :s | s removeKey: key ].		handles do: #remove.	canvas removeKey: key.	canvas signalUpdate.! !!RSTransformable methodsFor: 'rectangle'!rightCenter: position rectangle: rectangle 	^ rectangle origin -> (position x @ rectangle corner y)! !!RSTransformable methodsFor: 'accessing - shapes'!rotationShape	"TODO"	^ RSBitmap new		form: (self iconNamed: #smallUpdate);		scaleBy: 2;		when: RSMouseEnter send: #showRotationCursor to: self;		when: RSMouseLeave send: #removeCursor to: self;		yourself! !!RSTransformable methodsFor: 'private'!saveCurrentShapeState	| r matrix |	currentShape ifNil: [ ^ self ].	matrix := currentShape matrix.	r := matrix.	r := r sx sign @ r sy sign.	r := currentShape extent * r / 2.		baseRectangle := Rectangle basicNew		privateSetOrigin: r negated;		privateSetCorner: r;		yourself.			currentMatrix := matrix copy		loadIdentity;		translation: currentShape position.! !!RSTransformable methodsFor: 'private'!saveHandles: handles evt: evt	evt canvas propertyAt: self key put: handles.! !!RSTransformable methodsFor: 'cursor'!setCursor: cursor	self currentWorld currentHand showTemporaryCursor: cursor! !!RSTransformable methodsFor: 'cursor'!showCursor: evt	self setCursor: (self cursorForCorner: evt shape model value).! !!RSTransformable methodsFor: 'public'!showHandles: evt 		| parent shape handles |	self removeHandles: evt.	self registerCanvasEventsIfNecessary: evt.	shape := evt shape.	shape propertyAt: self key put: #enable.	handles := self createHandlesFor: shape.		parent := shape parent.	parent addAll: handles.	evt signalUpdate.												! !!RSTransformable methodsFor: 'cursor'!showRotationCursor	self setCursor: Cursor webLink! !!RSTransformable methodsFor: 'rectangle'!topCenter: position rectangle: rectangle 	^ (rectangle origin x @ position y) -> rectangle corner! !!RSTransformable methodsFor: 'rectangle'!topLeft: position rectangle: rectangle 	^ position -> rectangle corner! !!RSTransformable methodsFor: 'rectangle'!topRight: position rectangle: rectangle 	^ (rectangle origin x @ position y) -> (position x @ rectangle corner y)! !!RSTransformable methodsFor: 'update'!updateCurrentShape: evt	| handle  newRec scale pos rect  e |	currentShape ifNil: [ ^ self ].	handle := evt shape.	pos := currentMatrix inverseTransform: handle position.	newRec := self 		perform: (handle model key, ':rectangle:') asSymbol		withArguments: { pos. baseRectangle}.	scale := (newRec value - newRec key) / currentShape baseRectangle extent.		e := Float epsilon.	scale x abs < e ifTrue: [ scale := (e * scale x sign) @ scale y ].	scale y abs < e ifTrue: [ scale := scale x @ (e * scale y sign) ].		rect := newRec value corner: newRec key.	rect := currentShape 		computeEncompassingRectangleFor: (newRec key corner: newRec value)		matrix: currentMatrix.	currentShape matrix		loadIdentity.	currentShape scaleBy: scale.	currentShape translateTo: rect floatCenter.		self updateHandles: evt.	evt signalUpdate.! !!RSTransformable methodsFor: 'update'!updateHandles: evt	| canvas handles rect base points circles matrix  |	currentShape ifNil: [ ^ self ].	canvas := evt canvas.	handles := canvas propertyAt: self key ifAbsent: [ ^ self ].	rect := currentShape baseRectangle.	base := handles first.	circles := handles copyFrom: 2 to: handles size.	points := Array new: circles size.	matrix := currentShape matrix.	circles doWithIndex: [ :h :index | | position |		position := matrix transform: (h model key value: rect).		h position: position.		points at: index put: position ].	base points: points.		"TODO	rotate := handles last.	rotate position: (matrix transform: rect topCenter - (0@30) )."! !!RSMultilineLabelBuilder methodsFor: 'accessing'!compositeLabelFor: lines 	| shapes |	shapes := lines collect: [:line | 		self singleLabelFor: (line copyReplaceAll: String tab with: '   ') ].	self layout on: shapes.	^ RSComposite new		shapes: shapes;		position: 0@0;		yourself.! !!RSMultilineLabelBuilder methodsFor: 'initialization'!initialize	super initialize.	self labelShape: RSLabel new; textBlock: #asString! !!RSMultilineLabelBuilder methodsFor: 'accessing'!labelShape	^ labelShape! !!RSMultilineLabelBuilder methodsFor: 'accessing'!labelShape: aLabelShape	labelShape := aLabelShape! !!RSMultilineLabelBuilder methodsFor: 'accessing'!layout	^ layout ifNil: [ layout := RSVerticalLineLayout new 		alignLeft; 		gapSize: 0;		yourself ].! !!RSMultilineLabelBuilder methodsFor: 'hooks'!shapeFor: anObject	| text lines |	text := self textFor: anObject.	lines := text lines.	^ lines size = 1		ifTrue: [ self singleLabelFor: text ]		ifFalse: [ self compositeLabelFor: lines ]	! !!RSMultilineLabelBuilder methodsFor: 'accessing'!singleLabelFor: text	^ self labelShape copy		text: text;		yourself		! !!RSMultilineLabelBuilder methodsFor: 'accessing'!textBlock: aBlock	textBlock := aBlock! !!RSMultilineLabelBuilder methodsFor: 'accessing'!textFor: anObject	^ (textBlock rsValue: anObject) asString! !!RSSimplePopupBuilder methodsFor: 'hooks'!boxFor: lbl	^ RSBox new		color: (Color colorFrom: 'efefef');		cornerRadius: 5;		border: (RSBorder new color: Color gray);		extent: lbl extent + (10@7);		yourself! !!RSSimplePopupBuilder methodsFor: 'initialization'!initialize	super initialize.	self labelBuilder: RSMultilineLabelBuilder new.! !!RSSimplePopupBuilder methodsFor: 'initialization'!labelBuilder	^ labelBuilder! !!RSSimplePopupBuilder methodsFor: 'initialization'!labelBuilder: aLabelBuilder	labelBuilder := aLabelBuilder! !!RSSimplePopupBuilder methodsFor: 'hooks'!labelFor: anObject	^ labelBuilder shapeFor: anObject! !!RSSimplePopupBuilder methodsFor: 'hooks'!shapeFor: anObject	| lbl box |	lbl := self labelFor: anObject.	box := self boxFor: lbl.	^ RSComposite new		shapes: {box. lbl};		yourself! !!RSSimplePopupBuilder methodsFor: 'hooks'!textBlock: aBlock	labelBuilder textBlock: aBlock! !!RSShape methodsFor: '*Roassal3-Interaction'!draggable	self @ RSDraggable.! !!RSShape methodsFor: '*Roassal3-Interaction'!labeled	self @ RSLabeled.! !!RSShape methodsFor: '*Roassal3-Interaction'!popup	self @ RSPopup.! !!RSShape methodsFor: '*Roassal3-Interaction'!popupText: aBlock	self @ (RSPopup text: aBlock).! !!RSConfigurableCamera methodsFor: 'accessing'!zoomInteraction	^ zoomInteraction! !!RSConfigurableCamera methodsFor: 'accessing'!zoomInteraction: anInteraction	zoomInteraction := anInteraction! !!RSConfigurableCamera methodsFor: 'zoom'!zoomToFit	| shapesRect extent sc canvasRect original int |	int := self zoomInteraction.	shapesRect := int encompassingRectangleFor: canvas.	extent := canvas extent * 0.9.	sc := extent / (self class maxExtentFor: shapesRect).	original := sc x min: sc y.	sc := int scaleFor: original.	canvasRect := Rectangle 		floatCenter: shapesRect floatCenter		extent: canvas extent / 1.	self translateTo: shapesRect floatCenter.	int configuration shouldUseBasicZoom ifTrue: [ 		(canvasRect containsRect: shapesRect )			ifTrue: [ self scale: 1]			ifFalse: [				int configuration minScale: original.				self scale: original ]	] ifFalse: [ self scale: sc].	int removeRectanglesFor: canvas.	canvas signalUpdate.	! !"Roassal3-Interaction"!!RSLegend commentStamp: '' prior: 0!I am an handy class to build legend in a visualization!!RSLegend methodsFor: 'hooks'!basicRenderIn: aCanvas	| legend |	legend := self legend.	location move: legend on: aCanvas shapes.	aCanvas addShape: legend.! !!RSLegend methodsFor: 'public - specific'!customText: anObject shape: aShape	| shape |	"general propuse, you can add and define anything in aShape to be a legend"	shape := aShape copy text: anObject.	shapes add: shape.	^ shape.! !!RSLegend methodsFor: 'accessing'!defaultBoldText	^ defaultBoldText ifNil: [ defaultBoldText := RSLabel new bold ].! !!RSLegend methodsFor: 'accessing'!defaultBox	^ defaultBox ifNil: [ defaultBox := RSBox new size: 15 ].! !!RSLegend methodsFor: 'accessing'!defaultCircle	^ defaultCircle ifNil: [ defaultCircle := RSEllipse new size: 15. ]! !!RSLegend methodsFor: 'accessing'!defaultLabel	^ defaultLabel ifNil: [ defaultLabel := RSLabel new ].! !!RSLegend methodsFor: 'accessing'!defaultLabel: aShape	defaultLabel := aShape! !!RSLegend methodsFor: 'accessing'!defaultTitle	^ defaultTitle ifNil: [ defaultTitle := RSLabel new fontSize: 20; bold ].! !!RSLegend methodsFor: 'accessing'!defaultTitle: aShape	defaultTitle := aShape! !!RSLegend methodsFor: 'initialization'!initialize	super initialize.	self reset.! !!RSLegend methodsFor: 'testing'!isOnDemand	^ menuShape notNil! !!RSLegend methodsFor: 'layout'!layout 	^ layout! !!RSLegend methodsFor: 'accessing'!legend	| legend |	layout on: self shapes.	legend := RSComposite new		shapes: self shapes;		yourself.	legendBlock value: legend.	^ legend! !!RSLegend methodsFor: 'public'!leyendDo: aBlock	legendBlock := aBlock! !!RSLegend methodsFor: 'accessing'!location	^ location! !!RSLegend methodsFor: 'accessing'!menuShape	^ menuShape! !!RSLegend methodsFor: 'public'!onDemand	^ self onDemand: 'Help'.! !!RSLegend methodsFor: 'public'!onDemand: text	^ menuShape := RSLabel new		text: text;		color: Color lightGray;		@ (RSHighlightable new lowColor: Color lightGray highColor: Color blue);		yourself! !!RSLegend methodsFor: 'public - specific'!polymetricWidth: labelWidth height: labelHeight box: labelBox	"very very specific shape"	| box s marker line g l1 l2 l3 line1 line2  |	box := RSBox new		size: 100.	marker := RSShapeFactory triangle		color: Color black;		size: 5.	line := RSLine new 		marker: marker;		yourself.	g := RSGroup new.	l1 := defaultLabel copy text: labelWidth.	l2 := defaultLabel copy text: labelHeight.	l3 := defaultLabel copy text: labelBox.	l1 position: 0@70.	l3 scaleBy: 90/ l3 width.	l2 position: l2 width / 2 negated - 60 @ 0.	line1 := line copy startPoint:  -50@60; endPoint: 50@60.	line2 := line copy startPoint: -60@ -50; endPoint: -60@ 50.	g addAll: {box. l1. l2. l3. line1. line2 }.	s := RSComposite new		shapes: g.	self shapes add: s.	! !!RSLegend methodsFor: 'hooks'!renderIn: aCanvas	self isOnDemand 		ifTrue: [ self renderOnDemandIn: aCanvas ]		ifFalse: [self basicRenderIn: aCanvas ].	! !!RSLegend methodsFor: 'hooks'!renderOnDemandIn: aView	| i legendLabels update |	menuShape isFixed: true.	aView addShape: menuShape.	i := RSAnimatedPopup new.	i shapeBuilder: [ self legend ].	menuShape @ i.	legendLabels := nil.	update := [ 		RSHorizontalLineLayout on: legendLabels.		RSLocation new			inner; top; right;			move: legendLabels 				on: aView basicRectangle.	].	legendLabels := aView propertyAt: #legendLabels		ifAbsentPut: [ 			aView when: RSExtentChangedEvent do: update.			RSGroup new: 5 ].	legendLabels add: menuShape.	update value.	! !!RSLegend methodsFor: 'initialization'!reset	legendBlock := [ :l | l draggable ].	shapes := RSGroup new.	location := RSLocation new below.	layout := RSLayoutBuilder new.	layout vertical gapSize: 0.	defaultBox := defaultCircle := defaultLabel := defaultTitle := nil.				! !!RSLegend methodsFor: 'utilities'!shape: aShape withColor: color	| copy |	copy := aShape copy.	copy color: (color rsValue: copy).	^ copy! !!RSLegend methodsFor: 'public'!text: aString	^ self customText: aString shape: self defaultLabel! !!RSLegend methodsFor: 'public'!text: aString description: desc	| text tshapes line l d|	text := self defaultBoldText copy.	text text: aString.	d := self defaultLabel copy text: desc.	tshapes := RSGroup with: text with: d.	l := RSHorizontalLineLayout new center.	l on: tshapes.	line := RSComposite new		shapes: tshapes;		yourself.	self shapes add: line.	^ line! !!RSLegend methodsFor: 'public'!text: aString withBoxColor: color	^ self text: aString withShape: (self shape: self defaultBox withColor: color).! !!RSLegend methodsFor: 'public'!text: aString withCircleColor: color	^ self text: aString withShape: (self shape: self defaultCircle withColor: color).! !!RSLegend methodsFor: 'public - specific'!text: aString withFadingRamp: ramp	| gradient s |	"very specific shape"	gradient := LinearGradientPaint fromArray: ramp.	gradient start: -20@0; stop: 20@0.	s := RSBox new		extent: 40@20;		paint: gradient;		yourself.	^ self text: aString withShape: s.	! !!RSLegend methodsFor: 'public'!text: aString withShape: aShape	| text tshapes line l |	text := self defaultLabel copy.	text text: aString.	tshapes := RSGroup with: aShape with: text.	l := RSHorizontalLineLayout new center.	l on: tshapes.	line := RSComposite new		shapes: tshapes;		yourself.	self shapes add: line.	^ line! !!RSLegend methodsFor: 'public'!title: aString	^ self customText: aString shape: self defaultTitle! !"Roassal3-Legend"!!RSPieLabeled commentStamp: '' prior: 0!I can create labels for a pie builder and set the position acording to arc!!RSPieTitle commentStamp: '' prior: 0!I can add a basic title in a pie!!RSAbstractPieDecorator commentStamp: '' prior: 0!I can decorate builders inspired on decorator pattern!!RSRotatedPieLabelDecoration commentStamp: '' prior: 0!I am a specific interaction based on the example23RotatedAnimation!!RSShowProgressLabelDecorator commentStamp: '' prior: 0!I put interactions on the shapes and a label for updating!!RSPie commentStamp: '' prior: 0!I am the basic pie builder, check my examples.About me * My shape is an "arc"... not really my shape is an instance of "RSShapeBuilder arc"* the default background color of each arc even* I use a layout to set the arcs position * I also have a #label to create labels around my arcs.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=| b classes |classes := { Array. String. Dictionary. Set }.b := RSPieBuilder new.b objects: classes.b slice: #numberOfMethods.sb build.b open.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=.=!!RSPieLabeled methodsFor: 'initialization'!initialize	super initialize.	self labelShape: RSLabel new.	self labelColor: Color black.	offset := 0.	rotated := false.! !!RSPieLabeled methodsFor: 'testing'!isRotated	^ rotated! !!RSPieLabeled methodsFor: 'accessing'!labelColor	^ labelColor! !!RSPieLabeled methodsFor: 'accessing'!labelColor: aColor	"can be a color, a block or color scale"	"self labelColor: Color white"	"self labelColor: [:model | model modelColor ]"	"self labelColor: TSScale category20"	labelColor := aColor! !!RSPieLabeled methodsFor: 'accessing - keys'!labelKey	^ #RSPieLabeled! !!RSPieLabeled methodsFor: 'accessing'!labelShape	^ labelShape! !!RSPieLabeled methodsFor: 'accessing'!labelShape: aLabel	labelShape := aLabel! !!RSPieLabeled methodsFor: 'accessing'!labelText	^ labelText! !!RSPieLabeled methodsFor: 'accessing'!labelText: anObject	"can be an object or block"	"self labelText: 'Hi'"	"self labelText: [:model | 'The model: ', model asString]"	labelText := anObject! !!RSPieLabeled methodsFor: 'accessing'!offset	^ offset! !!RSPieLabeled methodsFor: 'accessing'!offset: aNumber	offset := aNumber! !!RSPieLabeled methodsFor: 'hooks'!onShape: aShape	| label parent |	label := self shapeFor: aShape.	aShape propertyAt: self labelKey put: label.	parent := aShape parent.	parent add: label.! !!RSPieLabeled methodsFor: 'accessing'!rotated	rotated := true.! !!RSPieLabeled methodsFor: 'hooks'!shapeFor: aPieSliceShape	| res arc ang |	arc := aPieSliceShape.	res := labelShape copy		text: (self labelText rsValue: arc model);		color: (self labelColor rsValue: arc model);		position: (arc centroid: self offset) + arc position;		yourself.	self isRotated ifFalse: [ ^ res ].	ang := arc middleAngle.	(ang between: 90 and: 270) ifTrue: [ ang := ang - 180 ].	res rotateByDegrees: ang negated.	^ res! !!RSPieTitle methodsFor: 'initialization'!initialize	super initialize.	labelBuilder := RSMultilineLabelBuilder new.	labelBuilder layout alignCenter.! !!RSPieTitle methodsFor: 'accessing'!labelShape	^ labelBuilder labelShape! !!RSPieTitle methodsFor: 'accessing'!labelText	^ labelText! !!RSPieTitle methodsFor: 'accessing'!labelText: aString	labelText := aString! !!RSPieTitle methodsFor: 'hooks'!onShape: aCanvas	| label |	label := labelBuilder shapeFor: self labelText.	aCanvas add: label.		! !!RSAbstractPieDecorator class methodsFor: 'instance creation'!on: aPieBuilder	self new builder: aPieBuilder; render! !!RSAbstractPieDecorator methodsFor: 'accessing'!builder	^ builder! !!RSAbstractPieDecorator methodsFor: 'accessing'!builder: aBuilder	builder := aBuilder! !!RSAbstractPieDecorator methodsFor: 'rendering'!render	self subclassResponsibility! !!RSRotatedPieLabelDecoration methodsFor: 'rendering'!createAnimation	animation := builder container newAnimation		from: 0;		to: 360;		repeat;		duration: 15 seconds;		onStepDo: [ :t | self stepShapes: t ]! !!RSRotatedPieLabelDecoration methodsFor: 'rendering'!createLabels	labels := builder objects collect: [ :obj |		RSLabel new			text: obj;			yourself ]! !!RSRotatedPieLabelDecoration methodsFor: 'rendering'!createLines	lines := builder objects collect: [ :obj | 		RSPolyline new			dashArray: #( 4 );			yourself ]! !!RSRotatedPieLabelDecoration methodsFor: 'rendering'!render	| container |	self createLabels.	self createLines.	container := self builder container.	container		addAll: lines;		addAll: labels.	builder shapes when: RSMouseClick do: [ animation toggle ].	self createAnimation.	self stepShapes: 0! !!RSRotatedPieLabelDecoration methodsFor: 'rendering'!stepShapes: t	builder shapes doWithIndex: [ :shape :index | 		  | a b label ang ext x p1 p2 p3 line |		  a := shape propertyAt: #a ifAbsentPut: [ shape alphaAngle ].		  b := shape propertyAt: #b ifAbsentPut: [ shape betaAngle ].		  shape			  alphaAngle: a + t;			  betaAngle: b + t.		  label := labels at: index.		  ang := shape alphaAngle + shape betaAngle / 2 % 360.		  ext := label extent x / 2 @ 0.		  x := -250.		  (ang between: 90 and: 270) ifFalse: [ 			  ext := ext negated.			  x := x negated ].		  p1 := shape centroid: 0.		  p2 := shape centroid: 50.		  p3 := x @ p2 y.		  line := lines at: index.		  line shape controlPoints: { 				  p1.				  p2.				  p3 }.		  label position: p3 - ext ]! !!RSShowProgressLabelDecorator methodsFor: 'initialization'!initialize	super initialize.	labelShape := RSLabel new.	highlight := RSHighlightable new.	highlight 		highlightColor: [ :shape | shape color adjustBrightness: 0.08 ]; 		when: RSHighlightEvent do: [ :evt | self updateLabel: evt shape ];		when: RSUnHighlightEvent do: [ :evt | self updateLabel: nil ].	! !!RSShowProgressLabelDecorator methodsFor: 'accessing'!labelShape	^ labelShape! !!RSShowProgressLabelDecorator methodsFor: 'updating'!progressFor: aShape	^ ((builder values at: aShape index) * 100 / builder totalSum) rounded! !!RSShowProgressLabelDecorator methodsFor: 'accessing'!progressLabel	^ progressLabel! !!RSShowProgressLabelDecorator methodsFor: 'rendering'!render	| canvas |	progressLabel := self labelShape copy.	progressLabel text: ''.	canvas := builder container.	canvas add: progressLabel.	builder shapes @ highlight.	! !!RSShowProgressLabelDecorator methodsFor: 'updating'!updateLabel: aShape	aShape ifNil: [ ^ progressLabel text: '' ].	progressLabel		color: aShape color;		text: (self progressFor: aShape) asString, '%'! !!RSPie methodsFor: 'accessing - computed'!alphaAngleFor: aShape	values ifNil: [ self slice: #yourself ].	^ (sumValues at: aShape index) * 360 / totalSum.! !!RSPie methodsFor: 'accessing - computed'!betaAngleFor: aShape	^ ((sumValues at: aShape index) + (values at: aShape index )) * 360 / totalSum.! !!RSPie methodsFor: 'initialization'!initialize	super initialize.	self sliceColor: [ :slice | 		slice index even 			ifTrue: [ Color lightGray ]			ifFalse: [ Color gray ] ].	sliceShape := RSPieSlice new		segmentSpacing: 0;		cornerRadii: 0;		innerRadius: 0;		externalRadius: 120.! !!RSPie methodsFor: 'accessing'!objects	^ objects! !!RSPie methodsFor: 'accessing'!objects: someObjects	objects := someObjects! !!RSPie methodsFor: 'hooks'!shapeFor: anObject	| slice |	slice := self sliceShape copy.	slice		model: anObject;		color: (self sliceColor rsValue: slice);		alphaAngle: (self alphaAngleFor: slice);		betaAngle: (self betaAngleFor: slice);		popup.	^ slice! !!RSPie methodsFor: 'hooks'!shapeFor: anObject index: index	| slice |	slice := self sliceShape copy.	slice		model: anObject;		index: index;		color: (self sliceColor rsValue: slice);		alphaAngle: (self alphaAngleFor: slice);		betaAngle: (self betaAngleFor: slice);		popup.	^ slice! !!RSPie methodsFor: 'public'!slice: aBlockOrASymbol	"Set the way we give a pie share for each element."	| tempSum |	values := objects collect: [:m | aBlockOrASymbol value: m value ] as: Array.	sumValues := Array new: objects size.	tempSum := 0.	values doWithIndex: [ :v :i |		sumValues at: i put: tempSum.		tempSum := tempSum + v		 ].	totalSum := tempSum.! !!RSPie methodsFor: 'accessing'!sliceColor	^ sliceColor! !!RSPie methodsFor: 'accessing'!sliceColor: anObject	"a block or object that can anwser rsValue:"	sliceColor := anObject 	! !!RSPie methodsFor: 'accessing'!sliceShape	"you can modify with simples values all atributes of slices except color and angles"	"review #sliceColor and #slice:"	^ sliceShape! !!RSPie methodsFor: 'accessing - computed'!totalSum	^ totalSum! !!RSPie methodsFor: 'accessing'!values	^ values! !"Roassal3-Pie"!!RSUMLCalypsoSettings commentStamp: '' prior: 0!Settings for UML use within Calypso!!RSAbstractUMLRenderer commentStamp: '' prior: 0!Abstract renderer for UML!!RSAbstractUMLClassRenderer commentStamp: '' prior: 0!I have the roassal shapes to build the visualizacion!!RSBasicUMLClassRenderer commentStamp: '' prior: 0!I am the default renderer that RSUMLClassBuilder !!RSTorchUMLClassRenderer commentStamp: '' prior: 0!I am a second different way to draw an UML class, similar to the system Torch.Here is an example:-=-=-=-=-=-=-=-=-=builder := RSUMLClassBuilder new.classes := { 'Roassal3-Layouts'. 'Roassal3' }	flatCollect: [:pkgname | (RPackage organizer		packageNamed: pkgname) definedClasses ].builder classes: classes.builder renderer: RSTorchUMLClassRenderer new.builder build.builder canvas @ RSHierarchyPacker.builder canvas-=-=-=-=-=-=-=-=-=!!RSAbstractUMLPackageRenderer commentStamp: '' prior: 0!Abstract renderer for UML packages!!RSBasicUMLPackageRenderer commentStamp: '' prior: 0!A basic renderer for UML packages!!RSUMLAbstractModelDescriptor commentStamp: '' prior: 0!Abstract descriptor for UML artifacts!!RSUMLClassDescriptor commentStamp: '' prior: 0!I have information about how to accessing to one class in the Roassal Uml class builder!!RSUMLPackageDescriptor commentStamp: '' prior: 0!A package descriptor!!RSUMLCalypso commentStamp: '' prior: 0!I am an abstract browser for uml classes and packages in calypso!!RSUMLClassCalypso commentStamp: '' prior: 0!I am a basic uml class browser!!RSUMLPackageCalypso commentStamp: '' prior: 0!I am a basic uml package browser!!RSUMLAbstractBuilder commentStamp: '' prior: 0!An abstract builder for UML shapes based on a model description (like a class or package description)!!RSUMLClassBuilder commentStamp: '' prior: 0!I am a builder to create UML diagrams in Roassal3, see examples!!RSUMLPackageBuilder commentStamp: '' prior: 0!I am a builder to create UML package diagrams in Roassal3, see examples!!RSUMLCalypsoSettings class methodsFor: 'accessing'!darkThemeUMLClassColor	^ DarkThemeUMLClassColor ifNil: [ self defaultDarkThemeColorUMLClass ]! !!RSUMLCalypsoSettings class methodsFor: 'accessing'!darkThemeUMLClassColor: aColor	DarkThemeUMLClassColor := aColor! !!RSUMLCalypsoSettings class methodsFor: 'defaults'!defaultDarkThemeColorUMLClass	^Color colorFrom: '2C3E50'! !!RSUMLCalypsoSettings class methodsFor: 'defaults'!defaultLightThemeColorUMLClass	^Color colorFrom: 'ffffce'! !!RSUMLCalypsoSettings class methodsFor: 'accessing'!lightThemeUMLClassColor	^LightThemeUMLClassColor ifNil: [ self defaultLightThemeColorUMLClass ]! !!RSUMLCalypsoSettings class methodsFor: 'accessing'!lightThemeUMLClassColor: aColor	LightThemeUMLClassColor := aColor! !!RSUMLCalypsoSettings class methodsFor: 'accessing'!methodsLimitUML	^ methodsLimitUML ifNil: [ methodsLimitUML := 20 ].! !!RSUMLCalypsoSettings class methodsFor: 'accessing'!methodsLimitUML: aNumber	methodsLimitUML := aNumber! !!RSUMLCalypsoSettings class methodsFor: 'settings'!settingsForCalypsoUMLColorsOn: aBuilder 	<systemsettings>	(aBuilder group: #CalypsoUMLColors)		parent: #CalypsoUML;		label: 'UML Colors' ;  		description: 'All settings concerned with the look''n feel of your system';		with: [			(aBuilder setting: #lightThemeUMLClassColor)				target: self;				label: 'Light Theme UML Class color';				default: self defaultLightThemeColorUMLClass.						(aBuilder setting: #darkThemeUMLClassColor)				target: self;				label: 'Dark Theme UML Class color';				default: self defaultDarkThemeColorUMLClass	 ]! !!RSUMLCalypsoSettings class methodsFor: 'settings'!settingsForCalypsoUMLOn: aBuilder 	<systemsettings>	(aBuilder group: #CalypsoUMLValues)		parent: #CalypsoUML;		label: 'Capypso UML Methods' ;  		description: 'All settings concerned with the size of variables to show';		with: [			(aBuilder range: #methodsLimitUML)				target: self;				label: 'Limit for number of methods to show in UML class';				default: 30;				range: ( 0 to: 200). ]! !!RSUMLCalypsoSettings class methodsFor: 'settings'!settingsGroupOn: aBuilder	<systemsettings>	(aBuilder group: #CalypsoUML)		label: 'Calypso UML';		parent: #Calypso;		description: 'Settings related to the UML within Calypso browser'! !!RSAbstractUMLClassRenderer class methodsFor: 'testing'!isAbstract 	^self name = #RSAbstractUMLClassRenderer ! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!adjustBox: box on: shapes 	| rect |	rect := shapes encompassingRectangle.	box		extent: rect extent + self classBoxPadding;		position: rect floatCenter.! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!adjustTitle: title on: shapes 	title position: shapes encompassingRectangle floatCenter x @ title position y.! !!RSAbstractUMLClassRenderer methodsFor: 'layout'!applyLayoutOn: shapes	RSVerticalLineLayout new gapSize: 1.5; on: shapes.! !!RSAbstractUMLClassRenderer methodsFor: 'layout'!applyMLayoutOn: shapes	self applyLayoutOn: shapes! !!RSAbstractUMLClassRenderer methodsFor: 'layout'!applyVLayoutOn: shapes	self applyLayoutOn: shapes! !!RSAbstractUMLClassRenderer methodsFor: 'accessing'!classBoxPadding	^ padding ifNil: [ padding := self defaultClassBoxPadding ]! !!RSAbstractUMLClassRenderer methodsFor: 'accessing'!classBoxPadding: aPoint	padding := aPoint! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!classBoxShapeFor: aClass 	^ RSBox new		paint: self boxColor;		cornerRadius: 10;		border: self boxBorder;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!createEllipsisIfNecessaryOn: aGroup	| rect ellipsis |	self needsEllipsis ifFalse: [ ^ self ].		ellipsis := self ellipsisShape.	rect := aGroup encompassingRectangle.	ellipsis position: rect bottomCenter + (0@10).	aGroup add: ellipsis.	! !!RSAbstractUMLClassRenderer methodsFor: 'defaults'!defaultClassBoxPadding	^ 10@10! !!RSAbstractUMLClassRenderer methodsFor: 'defaults'!defaultEdgeBuilder	^ RSEdgeBuilder orthoVertical		attachPoint: (RSVerticalAttachPoint new startOffset: 11);		border: self border;		markerStart: self marker;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'defaults'!defaultLayout	| defaultLayout |	defaultLayout := RSLayoutBuilder new.	defaultLayout tree 		verticalGap: 50; 		horizontalGap: 50.	^ defaultLayout! !!RSAbstractUMLClassRenderer methodsFor: 'defaults'!defaultMarker	^ RSMarker new 		shape: (RSShapeFactory triangle			color: Color white;			border: self border;			size: 20;			yourself);		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'edges'!edgeBuilder	^ edgeBuilder ifNil: [ edgeBuilder := self defaultEdgeBuilder ]! !!RSAbstractUMLClassRenderer methodsFor: 'edges'!edgeBuilder: anEdgeBuilder	edgeBuilder := anEdgeBuilder! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!ellipsisShape	^ RSLabel new		text: '...';		color: self textColor;		addInteraction: (RSPopup text: 'This class has more methods.' )		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!groupFor: shapes	^ RSGroup streamContents: [ :stream |		shapes do: [ :s | s hasChildren ifTrue: [ stream << s ] ] ]. ! !!RSAbstractUMLClassRenderer methodsFor: 'accessing'!marker 	^ marker ifNil: [ marker := self defaultMarker ]! !!RSAbstractUMLClassRenderer methodsFor: 'accessing'!marker: aMarker	marker := aMarker.! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!methodFor: method	^ RSLabel new		model: method;		color: self textColor;		text: (modelDescriptor methodSelector rsValue: method);		popup;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!methodsFor: model	| shapes methods |	methods := currentClassMethods := modelDescriptor methods rsValue: model.	currentClassMethods size > modelDescriptor methodsLimit		ifTrue: [ methods := currentClassMethods 			copyFrom: 1 			to: modelDescriptor methodsLimit ].	shapes := methods collect: [ :met | self methodFor: met ].	self applyMLayoutOn: shapes.	^ RSComposite new		shapes: shapes;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'testing'!needsEllipsis 	^ currentClassMethods isNotNil 		and:  [ currentClassMethods size > modelDescriptor methodsLimit ]		! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!titleFor: model	| label |	label := RSLabel new		color: self textColor;		text: (modelDescriptor classname rsValue: model);		yourself.	label fontSize: label fontSize * 1.2.	^ { label } asGroup asShape padding: 0@ 5; yourself	! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!varFor: model	^ RSLabel new		model: model;		color: self textColor;		text: model;		yourself! !!RSAbstractUMLClassRenderer methodsFor: 'hooks'!varsFor: model	| vars shapes |	vars := modelDescriptor instVars rsValue: model.	shapes := vars collect: [ :m | self varFor: m ].	self applyVLayoutOn: shapes.	^ RSComposite new		shapes: shapes;		padding: (Margin left: 0 right: 0 top: 3  bottom: 8 );		yourself		! !!RSBasicUMLClassRenderer methodsFor: 'hooks'!addLines: group title: title 	| line rec |	line := self classInnerLine.	rec := group encompassingRectangle.	group size > 2 ifTrue: [ 		group add: (line copy			startPoint: rec origin x @ title height;			endPoint: rec corner x @ title height) ].	group size > 4 ifTrue: [ 		group add: (line copy			startPoint: rec origin x @ (title height + group third height);			endPoint: rec corner x @ (title height + group third height)) ].! !!RSBasicUMLClassRenderer methodsFor: 'accessing - shapes'!classInnerLine	^ classInnerLine ifNil: [		classInnerLine := RSLine new			border: self border;			yourself ]! !!RSBasicUMLClassRenderer methodsFor: 'accessing - shapes'!classInnerLine: aShape	classInnerLine := aShape! !!RSBasicUMLClassRenderer methodsFor: 'hooks'!shapeFor: aClass	| shapes box title vars methods |	title := self titleFor: aClass.	vars := self varsFor: aClass.		methods := self methodsFor: aClass.	shapes := self groupFor: { vars. methods }.	shapes addFirst: title.	box := self classBoxShapeFor: aClass.	self applyLayoutOn: shapes.	self adjustTitle: title on: shapes.		self createEllipsisIfNecessaryOn: shapes.	shapes addFirst: box.	self adjustBox: box on: shapes.	self addLines: shapes title: title.	^ RSComposite new		popup;		draggable;		model: aClass;		shapes: shapes;		yourself.! !!RSTorchUMLClassRenderer methodsFor: 'layout'!applyMLayoutOn: shapes	RSFlowLayout new 		gapSize: 2;		maxWidth: self currentMaxWidth;		on: shapes.! !!RSTorchUMLClassRenderer methodsFor: 'layout'!applyVLayoutOn: shapes	self applyMLayoutOn: shapes! !!RSTorchUMLClassRenderer methodsFor: 'hooks'!classBoxShapeFor: aClass	^ RSBox new		noPaint;		border: self boxBorder;		yourself! !!RSTorchUMLClassRenderer methodsFor: 'hooks'!classNameBoxFor: aClass 	^ RSBox new		color: self titleBoxColor;		yourself! !!RSTorchUMLClassRenderer methodsFor: 'accessing - shapes'!currentMaxWidth	^ currentTitleWidth max: self minMethodsWidth! !!RSTorchUMLClassRenderer methodsFor: 'defaults'!defaultClassBoxPadding	^ 10@0! !!RSTorchUMLClassRenderer methodsFor: 'defaults'!defaultLayout	^ super defaultLayout tree		verticalGap: 50;		horizontalGap: 10;		yourself! !!RSTorchUMLClassRenderer methodsFor: 'defaults'!defaultTitleBoxColor	^ Color colorFrom: 'AFD2EE'! !!RSTorchUMLClassRenderer methodsFor: 'hooks'!methodFor: aMethod	^ RSBox new		width: 20;		height: aMethod linesOfCode * 5 + 1;		popup;		yourself! !!RSTorchUMLClassRenderer methodsFor: 'hooks'!methodsFor: aClass	^ (super methodsFor: aClass)		padding: ( Margin 		 	left: 0			right: 0			top: 5			bottom: 5);		yourself! !!RSTorchUMLClassRenderer methodsFor: 'accessing - shapes'!minMethodsWidth	^ 200! !!RSTorchUMLClassRenderer methodsFor: 'hooks'!shapeFor: aClass	| shapes box title vars methods boxTitle |	title := self titleFor: aClass.	vars := self varsFor: aClass.	methods := self methodsFor: aClass.	shapes := self groupFor: { vars. methods }.	shapes addFirst: title.	box := self classBoxShapeFor: aClass.	boxTitle := self classNameBoxFor: aClass.	self applyLayoutOn: shapes.	self adjustTitle: title on: shapes.	shapes addFirst: boxTitle.	shapes addLast: box.	self adjustBox: box on: shapes. 	boxTitle 		position: box position x @ title position y ;		extent: (box width @ title height).	^ RSComposite new		popup;		draggable;		model: aClass;		shapes: shapes;		yourself.! !!RSTorchUMLClassRenderer methodsFor: 'accessing'!titleBoxColor	^ titleBoxColor ifNil: [ titleBoxColor := self defaultTitleBoxColor ]! !!RSTorchUMLClassRenderer methodsFor: 'accessing'!titleBoxColor: aColor	titleBoxColor := aColor! !!RSTorchUMLClassRenderer methodsFor: 'hooks'!titleFor: aClass	| s |	s := super titleFor: aClass.	currentTitleWidth := s children first textWidth.	^ s! !!RSTorchUMLClassRenderer methodsFor: 'hooks'!varFor: model	^ RSShapeFactory triangle		model: model;		popup;		size: 20;		yourself		! !!RSAbstractUMLPackageRenderer class methodsFor: 'testing'!isAbstract 	^self name = #RSAbstractUMLPackageRenderer! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks'!classBoxFor: aClass and: classNameShape	^ RSBox new		cornerRadius: 5;		color: self classColor;		border: self border;		extent: classNameShape extent + 10;		position: classNameShape position		yourself! !!RSAbstractUMLPackageRenderer methodsFor: 'accessing'!classColor	^ classColor ifNil: [ classColor := self defaultClassColor ]! !!RSAbstractUMLPackageRenderer methodsFor: 'accessing'!classColor: aColor	classColor := aColor! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks'!classFor: aClass	| box className |	className := self classNameFor: aClass.	box := self classBoxFor: aClass and: className.	^ RSComposite new		model: aClass;		shapes: { box. className };		popup;		browseable;		yourself.! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks'!classNameFor: aClass	^ RSLabel new		text: (modelDescriptor classname rsValue: aClass);		yourself! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks'!classesFor: aPackage	| classes shapes |	classes := modelDescriptor classes rsValue: aPackage.	shapes := classes collect: [ :cls | self classFor: cls ].	RSFlowLayout on: shapes.	^ RSComposite new		shapes: shapes;		yourself.! !!RSAbstractUMLPackageRenderer methodsFor: 'defaults'!defaultClassColor	^ Color colorFrom: 'DEEBF7'! !!RSAbstractUMLPackageRenderer methodsFor: 'accessing'!defaultLayout	| defaultLayout |	defaultLayout := RSLayoutBuilder new.	defaultLayout vertical 		verticalGap: 100; 		horizontalGap: 50.	^defaultLayout! !!RSAbstractUMLPackageRenderer methodsFor: 'defaults'!defaultPackageColor	^ Color colorFrom: '9ECAE1'! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks'!packageBoxFor: title and: classes	| boxTitle boxClasses rect cradius |	RSVerticalLineLayout new gapSize: 0; on: { title. classes }.	title translateBy: 10@ -5.	rect := classes encompassingRectangle.	cradius := RSCornerRadius new		radius: 5;		yourself.	boxTitle := RSBox new		position: title position; 		extent: title extent + 10;		cornerRadius: cradius;		border: self border;		color: self packageColor;		yourself.	boxClasses := RSBox new 		position: rect floatCenter;		extent: rect extent+10;		cornerRadius: cradius;		border: self border;		color: self packageColor;		yourself.	^ RSComposite new		addAll: { boxTitle. boxClasses };		yourself.! !!RSAbstractUMLPackageRenderer methodsFor: 'accessing'!packageColor	^ packageColor ifNil: [ packageColor := self defaultPackageColor ]! !!RSAbstractUMLPackageRenderer methodsFor: 'accessing'!packageColor: aColor	packageColor := aColor! !!RSAbstractUMLPackageRenderer methodsFor: 'hooks'!packageNameFor: aPackage	| shape |	shape := RSLabel new		bold;		text: (modelDescriptor packagename rsValue: aPackage);		yourself.	shape fontSize: shape fontSize * 1.2.	^ shape! !!RSBasicUMLPackageRenderer methodsFor: 'hooks'!shapeFor: aPackage	| title classes box |	title := self packageNameFor: aPackage.	classes := self classesFor: aPackage.	box := self packageBoxFor: title and: classes.	^ RSComposite new		model: aPackage;		shapes: { box. title. classes };		popup;		browseable;		draggable;		yourself! !!RSAbstractUMLRenderer class methodsFor: 'testing'!isAbstract 	^self name = #RSAbstractUMLRenderer! !!RSAbstractUMLRenderer methodsFor: 'accessing'!border	^ border ifNil: [ border := self defaultBorder ].! !!RSAbstractUMLRenderer methodsFor: 'accessing'!border: aBorder	border := aBorder! !!RSAbstractUMLRenderer methodsFor: 'accessing'!boxBorder	^ boxBorder ifNil: [ boxBorder := self defaultBoxBorder ]! !!RSAbstractUMLRenderer methodsFor: 'accessing'!boxBorder: aBorder	boxBorder := aBorder! !!RSAbstractUMLRenderer methodsFor: 'accessing'!boxColor 	^ boxColor ifNil: [ boxColor := self defaultBoxColor ]! !!RSAbstractUMLRenderer methodsFor: 'accessing'!boxColor: aColor	boxColor := aColor! !!RSAbstractUMLRenderer methodsFor: 'defaults'!defaultBorder	^ RSBorder new		color: self textColor;		yourself! !!RSAbstractUMLRenderer methodsFor: 'defaults'!defaultBoxBorder	^ RSBorder new		width: 5; 		joinMiter; 		color: '666EA0';		yourself ! !!RSAbstractUMLRenderer methodsFor: 'accessing'!defaultBoxColor	^ Color colorFrom: 'cfd9df'! !!RSAbstractUMLRenderer methodsFor: 'accessing'!defaultLayout	^ self subclassResponsibility! !!RSAbstractUMLRenderer methodsFor: 'defaults'!defaultTextColor	^ Color black! !!RSAbstractUMLRenderer methodsFor: 'accessing'!layout	^ layout ifNil: [ layout := self defaultLayout ]! !!RSAbstractUMLRenderer methodsFor: 'accessing'!modelDescriptor	^ modelDescriptor! !!RSAbstractUMLRenderer methodsFor: 'accessing'!modelDescriptor: aModelDescriptor	modelDescriptor := aModelDescriptor! !!RSAbstractUMLRenderer methodsFor: 'hooks'!setUpCanvas: aCanvas	"overridde me"! !!RSAbstractUMLRenderer methodsFor: 'hooks'!shapeFor: anObject	^ self subclassResponsibility! !!RSAbstractUMLRenderer methodsFor: 'accessing'!textColor	^ textColor ifNil: [ textColor := self defaultTextColor ]! !!RSAbstractUMLRenderer methodsFor: 'accessing'!textColor: aColor	textColor := aColor! !!RSUMLAbstractModelDescriptor class methodsFor: 'testing'!isAbstract 	^self name = #RSUMLAbstractModelDescriptor ! !!RSUMLAbstractModelDescriptor methodsFor: 'public'!forPharo	self subclassResponsibility ! !!RSUMLAbstractModelDescriptor methodsFor: 'initialization'!initialize	super initialize.	self forPharo.! !!RSUMLClassDescriptor methodsFor: 'accessing'!classname	^ classname! !!RSUMLClassDescriptor methodsFor: 'accessing'!classname: aSymbolOrBlock	"In classname N is because this method does not have relation with className method"	classname := aSymbolOrBlock! !!RSUMLClassDescriptor methodsFor: 'public'!forPharo	self		classname: #name;		instVars: [:cls | cls instVarNames sorted ];		methods: [ :cls | cls methods sorted: CompiledMethod sortBlock ];		superclass: #superclass;		methodSelector: #selector;		instVarSelector: #yourself;		methodsLimit: SmallInteger maxVal.		! !!RSUMLClassDescriptor methodsFor: 'accessing'!instVarSelector	^ instVarSelector! !!RSUMLClassDescriptor methodsFor: 'accessing'!instVarSelector: aSymbolOrBlock	instVarSelector := aSymbolOrBlock! !!RSUMLClassDescriptor methodsFor: 'accessing'!instVars	^ instVars! !!RSUMLClassDescriptor methodsFor: 'accessing'!instVars: aSymbolOrBlock	instVars := aSymbolOrBlock! !!RSUMLClassDescriptor methodsFor: 'accessing'!methodSelector	^ methodSelector! !!RSUMLClassDescriptor methodsFor: 'accessing'!methodSelector: aSymbolOrBlock	methodSelector := aSymbolOrBlock! !!RSUMLClassDescriptor methodsFor: 'accessing'!methods	^ methods! !!RSUMLClassDescriptor methodsFor: 'accessing'!methods: aSymbolOrBlock	methods := aSymbolOrBlock! !!RSUMLClassDescriptor methodsFor: 'accessing'!methodsLimit	^ methodsLimit! !!RSUMLClassDescriptor methodsFor: 'accessing'!methodsLimit: aNumber	self assert: aNumber >= 1 description: 'Cannot have a negative limit'.	methodsLimit := aNumber! !!RSUMLClassDescriptor methodsFor: 'accessing'!superclass	^ superclass! !!RSUMLClassDescriptor methodsFor: 'accessing'!superclass: aSymbolOrBlock	superclass := aSymbolOrBlock! !!RSUMLPackageDescriptor methodsFor: 'accessing'!classes	^ classes! !!RSUMLPackageDescriptor methodsFor: 'accessing'!classes: anObject	classes := anObject! !!RSUMLPackageDescriptor methodsFor: 'accessing'!classname	^ classname! !!RSUMLPackageDescriptor methodsFor: 'accessing'!classname: anObject	classname := anObject! !!RSUMLPackageDescriptor methodsFor: 'public'!forPharo	self		packagename: #name;		classes: [:pkg| pkg definedClasses sorted: Behavior sortBlock ];		classname: #name! !!RSUMLPackageDescriptor methodsFor: 'accessing'!packagename	^ packagename! !!RSUMLPackageDescriptor methodsFor: 'accessing'!packagename: anObject	packagename := anObject! !!UITheme methodsFor: '*Roassal3-UML'!classBoxBackgroundColor	^ RSUMLCalypsoSettings lightThemeUMLClassColor! !!UITheme methodsFor: '*Roassal3-UML'!methodsLimitUML	^ RSUMLCalypsoSettings methodsLimitUML! !!RSUMLCalypso methodsFor: 'initialization'!activationPriority	^0! !!RSUMLCalypso methodsFor: 'building'!applyTheme: builder	| theme renderer |	theme := Smalltalk ui theme.	builder canvas color: theme backgroundColor.	renderer := builder renderer.	renderer border color: theme textColor.	renderer marker shape color: theme backgroundColor.	renderer textColor: theme textColor.	renderer boxColor: theme classBoxBackgroundColor.	builder modelDescriptor methodsLimit: theme methodsLimitUML.! !!RSUMLCalypso methodsFor: 'building'!build	| builder morph controls |	builder := RSUMLClassBuilder new.	builder container: RSCanvas new.	controls := RSCanvasController new.	controls configuration 		useBasicZoom;		maxScale: 1.	self applyTheme: builder.	builder canvas addInteraction: controls.	builder classes: self classes.	builder build.	builder shapes do: #browseable.	builder canvas createMorph.	morph := builder canvas morph.	morph onAnnouncement: MorphDeleted 		do: [ self containerTab owner ifNotNil: [ self containerTab delete]].	builder canvas when: RSMouseClick do: [ morph takeKeyboardFocus].	self addMorph: morph fullFrame: LayoutFrame identity! !!RSUMLCalypso methodsFor: 'accessing'!classes	^ self subclassResponsibility! !!RSUMLCalypso methodsFor: 'initialization'!defaultIconName	^#hierarchy! !!RSUMLCalypso methodsFor: 'accessing'!limitedClasses: aCollection	| limit |	limit := 100.	^ aCollection size < limit 		ifTrue: [ aCollection ]		ifFalse: [ aCollection copyFrom: 1 to: limit ].! !!RSUMLCalypso methodsFor: 'initialization'!tabOrder	^ 200! !!RSUMLClassCalypso class methodsFor: 'activation'!classUmlTapActivation	<classAnnotation>	^ ClyTabActivationStrategy for: ClyClass asCalypsoItemContext! !!RSUMLClassCalypso methodsFor: 'accessing'!classes	| clazzes |	clazzes := targetClass withAllSuperAndSubclasses		copyWithoutAll: { Object. ProtoObject }.	^self limitedClasses: clazzes	! !!RSUMLClassCalypso methodsFor: 'initialization'!defaultTitle	^'UML-Class'! !!RSUMLClassCalypso methodsFor: 'initialization'!isSimilarTo: anotherBrowserTool	(super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].		^targetClass  = anotherBrowserTool targetClass! !!RSUMLClassCalypso methodsFor: 'initialization'!setUpModelFromContext	super setUpModelFromContext.	targetClass := context lastSelectedClass! !!RSUMLClassCalypso methodsFor: 'accessing'!targetClass	^ targetClass! !!RSUMLPackageCalypso class methodsFor: 'activation'!classUmlTapActivation	<classAnnotation>	^ ClyTabActivationStrategy for: ClyPackageContextOfFullBrowser! !!RSUMLPackageCalypso methodsFor: 'accessing'!classes	^ self limitedClasses: (packages flatCollect: #classes).! !!RSUMLPackageCalypso methodsFor: 'defaults'!defaultIconName	^#package! !!RSUMLPackageCalypso methodsFor: 'initialization'!defaultTitle	^'UML-Package'! !!RSUMLPackageCalypso methodsFor: 'accessing'!isSimilarTo: anotherBrowserTool	(super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].	^packages = anotherBrowserTool packages! !!RSUMLPackageCalypso methodsFor: 'accessing'!packages	^ packages ! !!RSUMLPackageCalypso methodsFor: 'initialization'!setUpModelFromContext	super setUpModelFromContext.	packages := context selectedPackages! !!RSUMLAbstractBuilder class methodsFor: 'testing'!isAbstract 	^self name = #RSUMLAbstractBuilder! !!RSUMLAbstractBuilder methodsFor: 'private'!defaultContainer	^ RSCanvas new 		addInteraction: RSCanvasController new;		yourself.! !!RSUMLAbstractBuilder methodsFor: 'accessing'!layout	^ renderer layout! !!RSUMLAbstractBuilder methodsFor: 'accessing'!modelDescriptor	^ modelDescriptor! !!RSUMLAbstractBuilder methodsFor: 'accessing'!modelDescriptor: aRSClassDescriptor	modelDescriptor := aRSClassDescriptor.	renderer ifNotNil: [ renderer modelDescriptor: modelDescriptor ].! !!RSUMLAbstractBuilder methodsFor: 'accessing'!renderer	^ renderer! !!RSUMLAbstractBuilder methodsFor: 'accessing'!renderer: aRSUMLRenderer	renderer := aRSUMLRenderer.	renderer modelDescriptor: modelDescriptor! !!RSUMLAbstractBuilder methodsFor: 'hooks'!shapeFor: anObject index: index	^ self renderer shapeFor: anObject! !!RSUMLClassBuilder methodsFor: 'accessing'!classes	^ classes! !!RSUMLClassBuilder methodsFor: 'accessing'!classes: aColletionOfClasses	classes := aColletionOfClasses ! !!RSUMLClassBuilder methodsFor: 'initialization'!initialize	super initialize.	self		modelDescriptor: RSUMLClassDescriptor new;		renderer: RSBasicUMLClassRenderer new! !!RSUMLClassBuilder methodsFor: 'hooks'!objects	^ classes! !!RSUMLClassBuilder methodsFor: 'hooks'!renderIn: aCanvas	super renderIn: aCanvas.	self renderer edgeBuilder		canvas: aCanvas;		shapes: shapes;		connectFrom: modelDescriptor superclass.	self layout on: shapes.	renderer setUpCanvas: aCanvas.! !!RSUMLPackageBuilder methodsFor: 'initialization'!initialize	super initialize.	self		modelDescriptor: RSUMLPackageDescriptor new;		renderer: RSBasicUMLPackageRenderer new! !!RSUMLPackageBuilder methodsFor: 'hooks'!objects	^ packages! !!RSUMLPackageBuilder methodsFor: 'accessing'!packages 	^packages ! !!RSUMLPackageBuilder methodsFor: 'accessing'!packages: aCollection	packages := aCollection! !!RSUMLPackageBuilder methodsFor: 'hooks'!renderIn: aCanvas	super renderIn: aCanvas.	self layout on: shapes.! !!PharoDarkTheme methodsFor: '*Roassal3-UML'!classBoxBackgroundColor	^ RSUMLCalypsoSettings darkThemeUMLClassColor! !!RSShape methodsFor: '*Roassal3-UML'!browseable	self when: RSMouseClick do: [ self model browse  ].! !"Roassal3-UML"!!RSDraggableForce commentStamp: '' prior: 0!I am a special case to drag elements with the draggable interaction and the RSForceBasedLayout!!RSAbstractElementHandling commentStamp: '' prior: 0!I am base class for RSAlignment and RSResize!!RSAlignment commentStamp: '' prior: 0!Define alignment of elements. For example, inspect the following:-=-=-=c := RSCanvas new.es := (1 to: 5) collect: [ :v | RSBox new size: v * 5 ] as: RSGroup.RSVerticalLineLayout on: es.align := RSAlignment new.align shapes: es.align right.c addAll: es.c-=-=-=!!RSResize commentStamp: '' prior: 0!Adjust the size of the Elements.[ [ [ 	values := #(35 26 5 18 17 60 36 13 16 28 29 3 8 0 3 2 14 12 13 17 1 9 3 3 4 1 1 1 2 1 1 61).	v := RSView new.	n := TSScale category20c.	shape := RSShapeBuilder box color: n; size: #yourself.	es := shape elementsOn: values.	v addAll: es.	RTResize new elements: es; sameSize.	RSHorizontalLineLayout new gapSize: 0; on: es.		v @ RSControlsView.	v open ] ] ]!!RSDummyNode commentStamp: '' prior: 0!A RODummyNode is used by the sugiyama layout!!RSIdentityMatrix commentStamp: '' prior: 0!TODO!!RSLayout commentStamp: '' prior: 0!TODO!!RSAbstractCircleLayout commentStamp: '' prior: 0!TODO!!RSCircleLayout commentStamp: '' prior: 0!TODO!!RSAbstractWeightedCircleLayout commentStamp: '' prior: 0!I am the abstract root class of weighted circle layout. Look at the class comments of my subclasses for more details.!!RSEquidistantCircleLayout commentStamp: '' prior: 0!RTEquidistantCircleLayout is a circle layout in which elements are equidistant from each other: the layout maintains the same distance between elements.Here is an example:-=-=-=-=-=-=-=-=-=-=-=-=v := RSView new.elements := (RSShapeBuilder circle size: 5; color: Color red; size: [:vv | vv * 4 ]) elementsOn: (1 to: 15).v addAll: elements.RSEquidistantCircleLayout on: elements.v @ RSControlsView.v open-=-=-=-=-=-=-=-=-=-=-=-=!!RSWeightedCircleLayout commentStamp: '' prior: 0!RTWeightedCircleLayout is a circle layout that gives more space to big elements and fewer space to small elements.Here is an example:-=-=-=-=-=-=-=-=-=-=-=-=v := RSView new.elements := (RSShapeBuilder circle size: 5; color: Color red; size: [:vv | vv * 4 ]) elementsOn: (1 to: 15).v addAll: elements.RSWeightedCircleLayout on: elements.v @ RSControlsView.v open-=-=-=-=-=-=-=-=-=-=-=-=!!RSAbstractFlowLayout commentStamp: '' prior: 0!TODO!!RSFlowLayout commentStamp: '' prior: 0!A RTFlowLayout arrange elements in a rectangle including space (gapSize) between them, ideally it give you a square if all elements have an equal height and width .!!RSHorizontalFlowLayout commentStamp: '' prior: 0!A RTHorizontalFlowLayout is a FlowLayout horizontaly arranged,  right queued at default.!!RSAbstractGridLayout commentStamp: '' prior: 0!A ROAbstractGridLayout is xxxxxxxxx.Instance Variables	gapSize:		<Object>	lineItemsCountBlock:		<Object>gapSize	- xxxxxlineItemsCountBlock	- xxxxx!!RSCellLayout commentStamp: '' prior: 0!A ROCellLayout is like ROGridLayout. Elements of each column are centered along the same vertical line. And elements of each row are centered along the same horizontal line.Instance Variables	inCellPosition:		<Object | Block>inCellPosition	- Object which computes position of each element inside a cell. The cell is the space allocated for an element. Its height is maximum of heights of elements on the row. Its width is maximum of widths of elements on the column. By default elements are in the middle of their cell.!!RSGridLayout commentStamp: '' prior: 0!A ROGridLayout places elements as a grid.!!RSAbstractLineLayout commentStamp: '' prior: 0!A ROAbstractLineLayout is the abstract superclass of the line layout.Instance Variables	alignment:		<Object>	gapSize:		<Object>	horizontalGap:		<Object>	horizontalOutGap:		<Object>	horizontallyStretchable:		<Object>	verticalGap:		<Object>	verticalOutGap:		<Object>	verticallyStretchable:		<Object>alignment	- xxxxxgapSize	- xxxxxhorizontalGap	- xxxxxhorizontalOutGap	- xxxxxhorizontallyStretchable	- xxxxxverticalGap	- xxxxxverticalOutGap	- xxxxxverticallyStretchable	- xxxxx!!RSHorizontalLineLayout commentStamp: '' prior: 0!A RTHorizontalLineLayout locates all the elements horizontally!!RSVerticalLineLayout commentStamp: '' prior: 0!A RTVerticalLineLayout locates all the elements vertically!!RSEdgeDrivenLayout commentStamp: '' prior: 0!TODO!!RSAbstractGraphLayout commentStamp: '' prior: 0!TODO!!RSAbstractCompactTree commentStamp: '' prior: 0!TODO!!RSRadialTreeLayout commentStamp: '' prior: 0!TODO!!RSAbstractRegularTreeLayout commentStamp: '' prior: 0!TODO!!RSAbstractHorizontalTreeLayout commentStamp: '' prior: 0!TODO!!RSHorizontalDominanceTreeLayout commentStamp: '' prior: 0!TODO!!RSHorizontalTreeLayout commentStamp: '' prior: 0!TODO!!RSAbstractVerticalTreeLayout commentStamp: '' prior: 0!TODO!!RSDominanceTreeLayout commentStamp: '' prior: 0!TODO!!RSTreeLayout commentStamp: '' prior: 0!TODO!!RSClusterLayout commentStamp: '' prior: 0!TODO!!RSSugiyamaLayout commentStamp: '' prior: 0!TODO!!RSForceBasedLayout commentStamp: '' prior: 0!I am a layout that uses forces in each elements, I have create a light representation of one element.For example:-=-=-=-=-=-=-=-=-=c := RSCanvas new.c addAll: ((1 to: 100) collect: [:i | RSEllipse new size: 10; model: i]).eb := RSEdgeBuilder line.eb canvas: c.eb connectFrom: [ :v | v // 2 ].RSForceBasedLayout on: c nodes.c-=-=-=-=-=-=-=-=-=!!RSRectangleForceLayout commentStamp: '' prior: 0!I am a specific kind of force based layout that has an enclosing rectangle for elements. On each step, I apply a repulsion force to elements that are close to the enclosing rectangle.!!RSNoLayout commentStamp: '' prior: 0!Here is an example:v := RTView new.es := (RTEllipse new color: Color blue trans; size: 20) elementsOn: (1 to: 30).v addAll: es.RTEdgeBuilder new	view: v;	elements: es;	connectFrom: [ :vv | vv // 2 ].v addMenu: 'Remember!!' callback: [ 	positions := es collect: #position.	 ].v addMenu: 'Recall!!' callback: [ 	positions with: es do: [ :p :e | e translateTo: p ].	v signalUpdate.	 ].v addMenu: 'Start layout!!' callback: [ 	force := RTForceBasedLayout new.	force initialLayout: RTNoLayout new.	animation := RTSpringLayoutStepping new.	animation layoutWithoutPreparing: force.	animation inView: v.].v addMenu: 'Stop layout!!' callback: [ 	animation stopAndRemove].v !!RSRectanglePackLayout commentStamp: '' prior: 0!A layout that packs elements according to their bounding box. Check #gap and #preferredAngle.Here is an example:-=-=-=-=-=-=-=-=-=numberOfBoxes := 900.r := Random seed: 42.shapes := RSGroup new.numberOfBoxes timesRepeat: [ 	shapes add: (RSBox new width: (r nextInt: 40); height: (r nextInt: 40)) ].c := RSCanvas new.c addAll: shapes.RSRectanglePackLayout new useProgressBar; on: shapes.c @ RSCanvasController-=-=-=-=-=-=-=-=-=!!RSLayoutBuilder commentStamp: '' prior: 0!RTLayoutBuilder is a higher abstract to manage layout. Most builder use it as it significantly shorten the use of layouts.!!RSLayoutTranslator commentStamp: '' prior: 0!TODO!!RSDirectLayoutTranslator commentStamp: '' prior: 0!TODO!!RSLocation commentStamp: '' prior: 0!<keyClass>`RSLocation` locates shapes with respect to other shapes. Shapes can be positioned in a sticky fashion or not. Being sticky means whether the base shapes "drag" the sitcky shapes when dragged. `RSLocation` iteratively builds constraint for moving and positioning a shape on top of another one.*Responsibility*: locate permanently or not some shapes with respect to other shapes.*Collaborators*: closely interact with `RSShape`, `RSExtentChangedEvent`, and `RSPositionChangedEvent`*Variables*:- `offset`: offset between the positioned shape and the base shape- `orientation`: a value that could be -1, 0, 1 indicating the orientation of the location- `direction`: a point indicating the direction of the lcoation*Example*:```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape, drag me').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	bottom;	outer;	right;	offset: 20;	stick: redShape on: baseShape."Try changing stick:on: by move:on. Replacing bottom by top"c```A more complex example:```Smalltalkv := RSCanvas new.classes := Collection withAllSubclasses.boxes := classes collect: [ :cls |	RSBox new		width: (cls instVarNames size * 5 max: 5);		height: (cls numberOfMethods max: 5);		model: cls] as: RSGroup.boxes @ RSDraggable.v addAll: boxes.RSEdgeBuilder orthoVertical	canvas: v;	attachPoint: RSVerticalAttachPoint new;	shapes: boxes;	connectFrom: #superclass.boxes do: [ :b |	| t |	t := RSLabel new height: 2; text: b model name.	v add: t.	RSLocation new		offset: 1;		above; center;		stick: t on: b.].RSTreeLayout on: boxes.v @ RSCanvasController.v open```!!RSMockEdge commentStamp: '' prior: 0!TODO!!RSMockElement commentStamp: '' prior: 0!TODO!!RSQuadTreeF commentStamp: '' prior: 0!TODO!!RSForceLayoutStepping commentStamp: '' prior: 0!Hi!!, I can control the RSForceBaseLayout step method, in order to use it only when it needs!!RSHierarchyPacker commentStamp: '' prior: 0!This interaction layouts the connected subgraphs of a view using a rectangle pack layout each time the view changes it's extent (e.g. a window resize).Adapt the layout based on the window size:-=-=-=-=-=-=-=-=-=numberOfBoxes := 50.r := Random seed: 42.shapes := RSGroup new.numberOfBoxes timesRepeat: [     shapes add: (RSBox new width: (r nextInt: 40); height: (r nextInt: 40)) ].c := RSCanvas new. c addAll: shapes.RSRectanglePackLayout new useProgressBar; on: shapes.c @ RSCanvasController @ RSHierarchyPacker.c open-=-=-=-=-=-=-=-=-=Another example:-=-=-=-=-=-=-=-=-="Try resizing the window. Note that it also works in the inspector"classes := { 'Roassal3-Layouts'. 'Roassal3' }	flatCollect: [:pkgname | (RPackage organizer		packageNamed: pkgname) definedClasses ].shapes := RSGroup new.classes do: [ :c | shapes add: (RSEllipse new model: c) ].c := RSCanvas new.c addAll: shapes.eb := RSEdgeBuilder orthoVertical.eb canvas: c.eb connectFrom: #superclass.RSNormalizer size	shapes: shapes;	normalize: [ :c | c numberOfMethods + 5 ].RSTreeLayout on: shapes.c @ RSCanvasController @ RSHierarchyPacker.c open-=-=-=-=-=-=-=-=-=Another example:-=-=-=-=-=-=-=-=-=builder := RSUMLClassBuilder new.classes := { 'Roassal3-Layouts'. 'Roassal3' }	flatCollect: [:pkgname | (RPackage organizer		packageNamed: pkgname) definedClasses ].builder classes: classes.builder renderer: RSTorchUMLClassRenderer new.builder build.builder canvas @ RSHierarchyPacker.builder canvas open-=-=-=-=-=-=-=-=-=!!RSSortBlock commentStamp: '' prior: 0!TODO!!RSDraggableForce methodsFor: 'hooks'!layout	^ layout! !!RSDraggableForce methodsFor: 'hooks'!layout: aForceLayout	layout := aForceLayout! !!RSDraggableForce methodsFor: 'hooks'!onShape: aShape	| mock |	aShape removeInteractionIfPresent: RSDraggable.	aShape 		when: RSMouseDragStart do: [ :evt | 			mock := layout mockElementAt: evt shape.			mock isFixed: true. ];		when: RSMouseDragging do: [ :evt |			| d |			d := evt shape parent camera distanceFromPixelToSpace: evt step.			evt shape translateBy: d.			mock fixPosition: evt shape position.			evt shape signalUpdate ];		when: RSMouseDragEnd do:[:evt | 			mock isFixed: false.			mock := nil ].! !!Rectangle methodsFor: '*Roassal3-Layouts'!areasOverlapingOutside: aRectangle 	"Answer an Array of maximized Rectangles comprising (overlaped by each other) the parts of the receiver not 	intersecting aRectangle."	"Make sure the intersection is non-empty"	| areas o c |	(self intersects: aRectangle) ifFalse: [ ^ Array with: self ].	areas := OrderedCollection new.	o := self topLeft.	c := self bottomRight.	aRectangle topLeft y > o y 		ifTrue: 			[ areas addLast: (o corner: c x @ aRectangle topLeft y) ].	aRectangle bottomRight y < c y 		ifTrue: 			[ areas addLast: (o x @ aRectangle bottomRight y corner: c) ].	aRectangle topLeft x > o x 		ifTrue: 			[ areas addLast: (o corner: aRectangle topLeft x @ c y) ].	aRectangle bottomRight x < c x 		ifTrue: 			[ areas addLast: (aRectangle bottomRight x @ o y corner: c) ].	^ areas! !!Rectangle methodsFor: '*Roassal3-Layouts'!halfPerimeter	^ self width + self height! !!RSAbstractElementHandling methodsFor: 'accessing'!fixedShape	^ fixedShape! !!RSAbstractElementHandling methodsFor: 'accessing'!fixedShape: aShape	"Designate a particular shape for which all the other will be aligned against"	fixedShape := aShape! !!RSAbstractElementHandling methodsFor: 'private - configuration'!ifNoFixedShapeThen: aBlock	fixedShape ifNil: [ aBlock value  ]! !!RSAbstractElementHandling methodsFor: 'accessing'!shapes	^ shapes! !!RSAbstractElementHandling methodsFor: 'accessing'!shapes: someShapes	shapes := someShapes asGroup! !!RSAlignment methodsFor: 'alignment'!alignFromBottomUsing: aShape	"The argument aShape is a fix point. It does not move"	| topY newY |	topY := aShape encompassingRectangle bottomCenter y.	shapes do: [ :s |		newY := topY - (s encompassingRectangle height / 2).		s translateTo: s position x @ newY	]! !!RSAlignment methodsFor: 'alignment'!alignFromCenterUsing: aShape	| topX |	topX := aShape position x.	shapes do: [ :s |		s translateTo: topX @ s position y	]! !!RSAlignment methodsFor: 'alignment'!alignFromLeftUsing: aShape	| topX newX |	topX := aShape encompassingRectangle topLeft x.	shapes do: [ :s |		newX := topX + (s encompassingRectangle width / 2).		s translateTo: newX @ s position y	]! !!RSAlignment methodsFor: 'alignment'!alignFromMiddleUsing: aShape	| topY |	topY := aShape position y.		shapes do: [ :s |			s translateTo: s position x @ topY	]! !!RSAlignment methodsFor: 'alignment'!alignFromRightUsing: aShape	| topX newX |	topX := aShape encompassingRectangle topRight x.	shapes do: [ :s |		newX := topX - (s encompassingRectangle width / 2).		s translateTo: newX @ s position y	]! !!RSAlignment methodsFor: 'alignment'!alignFromTopUsing: aShape	| topY newY |	topY := aShape encompassingRectangle topCenter y.	shapes do: [ :s |		newY := topY + (s encompassingRectangle height / 2).		s translateTo: s position x @ newY	]! !!RSAlignment methodsFor: 'public'!bottom"Align all the shapes on the bottoms of the shapes.-=-=-=-=-=-=-=-=c := RSCanvas new.es := (1 to: 5) collect: [ :v | RSBox new color: Color gray trans; size: v * 5 ] as: RSGroup.RSHorizontalLineLayout on: es.align := RSAlignment new.align shapes: es.align bottom.c addAll: es.c-=-=-=-="	self hasShape ifFalse: [ ^ self ].	self alignFromBottomUsing: self bottomMostShape ! !!RSAlignment methodsFor: 'accessing - computed'!bottomMostShape	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s | 			maxS encompassingRectangle top <= s encompassingRectangle top					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSAlignment methodsFor: 'public'!center"Center all the shapes along their X coordinate-=-=-=-c := RSCanvas new.es := (1 to: 5) collect: [ :v | RSBox new color: Color gray trans; size: v * 5 ] as: RSGroup.RSVerticalLineLayout on: es.align := RSAlignment new.align shapes: es.align center.c addAll: es.c-=-=-=-"	self hasShape ifFalse: [ ^ self ].	self alignFromCenterUsing: self centerMostShape! !!RSAlignment methodsFor: 'accessing - computed'!centerMostShape	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s | 			maxS encompassingRectangle floatCenter <= s encompassingRectangle floatCenter					ifTrue: [ s ] ifFalse: [ maxS ] ]! !!RSAlignment methodsFor: 'testing'!hasShape	"Return true if some shapes have been set"	^ (shapes isNil or: [ shapes isEmpty ]) not! !!RSAlignment methodsFor: 'public'!left	self hasShape ifFalse: [ ^ self ].	self alignFromLeftUsing: self leftMostShape ! !!RSAlignment methodsFor: 'accessing - computed'!leftMostShape	"Return the shape that is the located the most on the left hand side"	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s | 			maxS encompassingRectangle left >= s encompassingRectangle left					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSAlignment methodsFor: 'public'!middle"Center all the shapes along their Y coordinate-=-=-=-=-=-=c := RSCanvas new.es := (1 to: 5) collect: [ :v | RSBox new color: Color gray trans; size: v * 5 ] as: RSGroup.RSHorizontalLineLayout on: es.align := RSAlignment new.align shapes: es.align middle.c addAll: es.c-=-=-=-=-=-="	self hasShape ifFalse: [ ^ self ].	self alignFromMiddleUsing: self centerMostShape! !!RSAlignment methodsFor: 'public'!right	self hasShape ifFalse: [ ^ self ].	self alignFromRightUsing: self rightMostShape ! !!RSAlignment methodsFor: 'accessing - computed'!rightMostShape	"Return the shape that is the located the most on the right hand side"	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s | 			maxS encompassingRectangle right <= s encompassingRectangle right					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSAlignment methodsFor: 'public'!top	self hasShape ifFalse: [ ^ self ].	self alignFromTopUsing: self topMostShape ! !!RSAlignment methodsFor: 'accessing - computed'!topMostShape	fixedShape ifNotNil: [ ^ fixedShape ].	^ shapes inject: shapes first into: [ :maxS :s | 			maxS encompassingRectangle top >= s encompassingRectangle top					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSResize methodsFor: 'accessing - computed'!biggestExtent	fixedShape ifNotNil: [ ^ fixedShape extent ].	^ shapes inject: 0 @ 0 into: [ :maxExtent :e | 			maxExtent max: e extent ] ! !!RSResize methodsFor: 'accessing - computed'!biggestShape	^ shapes inject: shapes anyOne into: [ :biggestShape :e | 			biggestShape extent < e extent				ifTrue: [ e ] ifFalse: [ biggestShape ] ] ! !!RSResize methodsFor: 'accessing - computed'!highestShape	^ shapes inject: shapes anyOne into: [ :highestShape :e | 			highestShape extent y < e extent y				ifTrue: [ e ] ifFalse: [ highestShape ] ] ! !!RSResize methodsFor: 'public'!sameHeight	self ifNoFixedShapeThen: [ self useHighestShape ].	shapes do: [ :e | e height: self fixedShape height ]! !!RSResize methodsFor: 'public'!sameSize	self ifNoFixedShapeThen: [ self useBiggestShape ].	shapes do: [ :e | e extent: self fixedShape extent ]! !!RSResize methodsFor: 'public'!sameWidth	self ifNoFixedShapeThen: [ self useWidestShape ].	shapes do: [ :e | e width: self fixedShape width ]! !!RSResize methodsFor: 'public - configuration'!useBiggestShape	self fixedShape: self biggestShape! !!RSResize methodsFor: 'public - configuration'!useHighestShape	self fixedShape: self highestShape ! !!RSResize methodsFor: 'public - configuration'!useWidestShape	self fixedShape: self widestShape! !!RSResize methodsFor: 'accessing - computed'!widestShape	^ shapes inject: shapes anyOne into: [ :widestElement :e | 			widestElement extent x < e extent x				ifTrue: [ e ] ifFalse: [ widestElement ] ] ! !!RSDummyNode class methodsFor: 'instance creation'!on: anEdge slot: anIndex		^(self new)		edge: anEdge;		slot: anIndex;		yourself! !!RSDummyNode methodsFor: 'accessing'!edge	^ edge! !!RSDummyNode methodsFor: 'accessing'!edge: anEdge	edge := anEdge! !!RSDummyNode methodsFor: 'accessing'!extent	^ self height @ self width! !!RSDummyNode methodsFor: 'accessing'!height	^ 0! !!RSDummyNode methodsFor: 'accessing'!position	^ 0 @ 0! !!RSDummyNode methodsFor: 'accessing'!signalUpdate	"do nothing"! !!RSDummyNode methodsFor: 'accessing'!slot: anIndex	! !!RSDummyNode methodsFor: 'accessing'!translateBy: apoint	"do nothing"! !!RSDummyNode methodsFor: 'accessing'!translateTo: aPoint	"edge index: index point: aPoint"! !!RSDummyNode methodsFor: 'accessing'!width	^ 0! !!RSIdentityMatrix methodsFor: 'accessing'!at: u	| row |	row := rows		at: u		ifAbsentPut: [IdentityDictionary new].	^row keys! !!RSIdentityMatrix methodsFor: 'accessing'!at: u at: v	| row |	row := rows		at: u		ifAbsentPut: [IdentityDictionary new].	^row		at: v		ifAbsent: [false]! !!RSIdentityMatrix methodsFor: 'accessing'!at: u at: v put: aBoolean	| row |	"u -> v"	row := rows		at: u		ifAbsentPut: [IdentityDictionary new].	row at: v put: aBoolean.	"v -> u"	row := rows		at: v		ifAbsentPut: [IdentityDictionary new].	row at: u put: aBoolean! !!RSIdentityMatrix methodsFor: 'initialize-release'!initialize	rows := IdentityDictionary new! !!RSAbstractCircleLayout class methodsFor: 'public'!isAbstract	^ self name = #RSAbstractCircleLayout! !!RSAbstractCircleLayout methodsFor: 'hook'!computeIncrementalAngleFor: elements	"Return the value _in radian_ of the incremental angle"		^ initialIncrementalAngle = 0		ifTrue: [ 2 * Float pi / elements size ]		ifFalse: [ initialIncrementalAngle ]! !!RSAbstractCircleLayout methodsFor: 'hook'!computeRadiusFor: elements	"Return the radius of the circle. If none has been set (i.e., initialRadius = 0), then it is computed as the scale factor times the number of elements"	^ initialRadius = 0 		ifTrue: [ elements size * self scaleFactor ]		ifFalse: [ initialRadius ]! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngle	"Return the initial angle, in radian"	^ initialAngle! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngle: aFloat	"aFloat is an angle in Radian."	initialAngle := aFloat! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngleInDegree 	"Return the initial angle in degree"	^ self initialAngle * 180 / Float pi! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngleInDegree: aNumber	"Set the initial angle in radian"	self initialAngle: aNumber * Float pi / 180! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialIncrementalAngle	"Return the initial incremental angle"	^ initialIncrementalAngle! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialIncrementalAngle: aNumberInRadian	initialIncrementalAngle := aNumberInRadian! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialIncrementalAngleInDegree: aNumberInDegree	self initialIncrementalAngle: aNumberInDegree * Float pi / 180! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialRadius	"Return the radius in pixels of the circle"	^ initialRadius! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialRadius: aNumber	"Set the radius of the circle"	initialRadius := aNumber! !!RSAbstractCircleLayout methodsFor: 'initialize-release'!initialize	"Initialize a newly created instance. This method must answer the receiver."		super initialize.	self scaleBy: 11.		"Represent the initial angle to place the elements"	initialAngle := 0.		"Distance of the circle. If it is 0 when entering doExecute, then it is computed"	initialRadius := 0.		"0 means that it is computed, and not set by the user"	initialIncrementalAngle := 0.! !!RSAbstractCircleLayout methodsFor: 'accessing'!radius: aNumber	^ self initialRadius: aNumber! !!RSAbstractCircleLayout methodsFor: 'accessing'!scaleBy: aNumber	factor := aNumber! !!RSAbstractCircleLayout methodsFor: 'accessing'!scaleFactor	^ factor! !!RSAbstractWeightedCircleLayout methodsFor: 'hook'!doExecute: elements	"This method is used polymorphically"! !!RSAbstractWeightedCircleLayout methodsFor: 'hook'!weightSum: elements	"Computes the sum of all elements 'weight' or size"	| sum |	sum := 0.	elements		do: [ :each |			sum := sum + (each height)		].	^sum! !!RSEquidistantCircleLayout methodsFor: 'hook'!computeSeparationFor: elements"Compute the separation between each element, this separation will always be the same"	| sep |	sep := ((2 * Float pi * (self computeRadiusFor: elements)) - (self weightSum: elements))/	(elements size).	^sep! !!RSEquidistantCircleLayout methodsFor: 'hook'!doExecute: elements	| angle rad center angleIncrement |	rad := self computeRadiusFor: elements.	center := Point x: rad y: rad.	angle := self initialAngle.	elements		do: [ :each | 			| point |			"First, the angle is increased only by the angle given by the element radius (height/2),			then the point is set, and then it's increased by the rest of the total increment"			"This is to consider both last and next elements weights"			angle := angle + ((each height)/(2*rad)).			point := center + (Point r: rad theta: angle).			angleIncrement := (((each height)/2) + (self computeSeparationFor: elements))/rad.			angle := angle + angleIncrement.			translator translate: each to: point.		]! !!RSWeightedCircleLayout methodsFor: 'hook'!doExecute: elements	| angle rad center angleIncrement |	rad := self computeRadiusFor: elements.	center := Point x: rad y: rad.	angleIncrement := self computeIncrementalAngleFor: elements.	angle := self initialAngle.	elements		do: [ :each | 			| point fctr |			"The factor weighs the angleIncrement"			"The angle is increased by half of the total increment,			then the point is set, and then it's increased by the other half"			"This is to consider both last and next elements weights"			fctr := (elements size)*(each height)/(self weightSum: elements).			angle := angle + (angleIncrement*(fctr/2)).			point := center + (Point r: rad theta: angle).			angle := angle + (angleIncrement*(fctr/2)).			translator translate: each to: point. ]! !!RSCircleLayout class methodsFor: 'instance creation'!scaleBy: aNumber		^self new scaleBy: aNumber! !!RSCircleLayout methodsFor: 'hook'!doExecute: elements	| angleIncrement angle rad center |	rad := self computeRadiusFor: elements.	center := Point x: rad y: rad.	angleIncrement := self computeIncrementalAngleFor: elements.	angle := self initialAngle.	elements		do: [ :each | 			| point |			point := center + (Point r: rad theta: angle).			angle := angle + angleIncrement.			translator translateTopLeftOf: each to: point.			self step ]! !!RSAbstractFlowLayout class methodsFor: 'public'!isAbstract	^ self name = #RSAbstractFlowLayout! !!RSAbstractFlowLayout class methodsFor: 'instance creation'!withMaxWidth: anInteger		^(self new)		maxWidth: anInteger;		yourself! !!RSAbstractFlowLayout class methodsFor: 'instance creation'!withMaxWidth: anInteger withGap: anotherInteger		^(self new)		maxWidth: anInteger;		gapSize: anotherInteger;		yourself! !!RSAbstractFlowLayout methodsFor: 'alignment'!alignBottom	alignment := #bottom! !!RSAbstractFlowLayout methodsFor: 'alignment'!alignCenter	alignment := #center! !!RSAbstractFlowLayout methodsFor: 'alignment'!alignTop	alignment := #top! !!RSAbstractFlowLayout methodsFor: 'configuration'!defaultGapSize	^ 5! !!RSAbstractFlowLayout methodsFor: 'configuration'!defaultMaxWidth	^ [ :elements | 		(elements size < 4) ifTrue: [ (((elements collect: [ :each | each width * each height]) * 2) sum ) + (elements size * (gapSize squared)) ]			ifFalse: [			((((elements collect: [ :each | each width * each height]) * 2) sum) + (elements size * (gapSize squared))) sqrt ceiling truncated.			]		]! !!RSAbstractFlowLayout methodsFor: 'accessing'!gapSize	^ gapSize! !!RSAbstractFlowLayout methodsFor: 'accessing'!gapSize: aSizeInPixels	gapSize := aSizeInPixels! !!RSAbstractFlowLayout methodsFor: 'initialize-release'!initialize	super initialize.	maxWidth := self defaultMaxWidth.	gapSize := self defaultGapSize.! !!RSAbstractFlowLayout methodsFor: 'testing'!isAlignBottom	^ alignment = #bottom! !!RSAbstractFlowLayout methodsFor: 'testing'!isAlignCenter	^ alignment = #center! !!RSAbstractFlowLayout methodsFor: 'testing'!isAlignTop	^ alignment = #top! !!RSAbstractFlowLayout methodsFor: 'private'!maxWidth	^ maxWidth! !!RSAbstractFlowLayout methodsFor: 'accessing'!maxWidth: aSizeInPixels	maxWidth := aSizeInPixels! !!RSFlowLayout methodsFor: 'hook'!doExecute: elements 	| x y maxLastLineHeight maxNextLineHeight  nextElement |		x := self gapSize.	y := self gapSize.	maxLastLineHeight := 0.	maxNextLineHeight := 0.	nextElement := elements first.	 	elements do:		[ :anElement | 		(anElement = elements last) ifFalse:  [nextElement := (elements after: anElement)] ifTrue: [nextElement := anElement].			self isAlignBottom ifTrue: [ 			translator translateBottomLeftOf: anElement to: x @ y.			x := x + anElement width + (self gapSize).			((x > (self maxWidth rsValue: elements)) | ((x + nextElement width) > (self maxWidth rsValue: elements) )) ifTrue:				[ x := self gapSize.				maxNextLineHeight := self maxNextLineHeightFrom: nextElement for: elements.				y := y + (self gapSize) + maxNextLineHeight.				maxNextLineHeight := 0.				]			].				self isAlignCenter ifTrue: [ 			translator translateCenterLeftOf: anElement to: x @ y.								x := x + (anElement width) +(self gapSize).			maxLastLineHeight := maxLastLineHeight max: (anElement height).			((x > (self maxWidth rsValue: elements)) | ((x + nextElement width) > (self maxWidth rsValue: elements) )) ifTrue: 				[ x := self gapSize.				maxNextLineHeight := self maxNextLineHeightFrom: nextElement for: elements.				y := y + (self gapSize) + (maxNextLineHeight / 2) + (maxLastLineHeight / 2).				maxNextLineHeight := 0.				maxLastLineHeight := 0.				]			].				self isAlignTop ifTrue: [ 			translator translateTopLeftOf: anElement to: (x @ y).			x := x + anElement width + (self gapSize).			maxLastLineHeight := maxLastLineHeight max: (anElement height ).			( (x > (self maxWidth rsValue: elements)) | ((x + nextElement width) > (self maxWidth rsValue: elements) ))ifTrue: 				[ x := self gapSize.				y := y + (self gapSize) + maxLastLineHeight.				maxLastLineHeight := 0. 				]		] 	]! !!RSFlowLayout methodsFor: 'initialize-release'!initialize	super initialize.	self alignTop.! !!RSFlowLayout methodsFor: 'utility'!maxNextLineHeightFrom: ele for: elements	| nextLineX maxNextLineHeight anElement |	maxNextLineHeight := 0.	nextLineX := self gapSize.	anElement := ele.	[ nextLineX < (self maxWidth rsValue: elements) ] whileTrue: [		nextLineX := nextLineX + (self gapSize) + (anElement width).		maxNextLineHeight := maxNextLineHeight max: (anElement height).			(anElement = elements last) ifFalse:  [anElement := (elements after: anElement) ].		].	^ maxNextLineHeight				! !!RSHorizontalFlowLayout methodsFor: 'hook'!doExecute: elements 	| x y maxLastLineWidth nextElement maxNextLineWidth|	x := self gapSize.	y := self gapSize.	maxLastLineWidth := 0.	maxNextLineWidth := 0.		elements do:		[ :anElement | 				(anElement = elements last) ifFalse:  [nextElement := (elements after: anElement)] ifTrue: [nextElement := anElement].				self isAlignBottom ifTrue: [ 			translator translate: anElement to: ((x @ y) + ((anElement width / -2) @ (anElement height / 2))).				y := y + anElement height + (self gapSize).			((y > (self maxWidth rsValue: elements)) | ((y + nextElement height) > (self maxWidth rsValue: elements) ))ifTrue: 				[ y := self gapSize.				maxNextLineWidth := self maxNextLineWidthFrom: nextElement for: elements.				x := x + (1 * self gapSize) + maxNextLineWidth.				maxNextLineWidth := 0.				maxLastLineWidth := 0.				]		].		self isAlignCenter ifTrue: [ 		translator translate: anElement to: ((x @ y) + (0 @ (anElement width / 2))).			y := y + anElement height + (self gapSize).			maxLastLineWidth := maxLastLineWidth max: (anElement width).			((y > (self maxWidth rsValue: elements)) | ((y + nextElement height) > (self maxWidth rsValue: elements) ))ifTrue: 				[ y := self gapSize.				maxNextLineWidth := self maxNextLineWidthFrom: nextElement for: elements.				x := x + (self gapSize) + (maxNextLineWidth /2) + (maxLastLineWidth /2).				maxNextLineWidth := 0.				maxLastLineWidth := 0.				]			].						self isAlignTop ifTrue: [ 			translator translateTopLeftOf: anElement to: x @ y.			y := y + anElement height + (self gapSize).			maxLastLineWidth := maxLastLineWidth max: (anElement width ).			((y > (self maxWidth rsValue: elements)) | ((y + nextElement height) > (self maxWidth rsValue: elements) ))ifTrue: 				[ y := self gapSize.				x := x + (self gapSize) + maxLastLineWidth.				maxLastLineWidth := 0 ] 			].		].! !!RSHorizontalFlowLayout methodsFor: 'initialize-release'!initialize	super initialize.	self alignTop.! !!RSHorizontalFlowLayout methodsFor: 'utility'!maxNextLineWidthFrom: ele for: elements	| nextLineY maxNextLineWidth anElement |	anElement := ele.	maxNextLineWidth := 0.	nextLineY := self gapSize.	[ nextLineY < (self maxWidth rsValue: elements) ] whileTrue: [		nextLineY := nextLineY + (self gapSize) + (anElement height).		maxNextLineWidth := maxNextLineWidth max: (anElement width).			(anElement = elements last) ifFalse:  [anElement := (elements after: anElement)]		].	^ maxNextLineWidth! !!RSAbstractGridLayout class methodsFor: 'public'!isAbstract	^ self name = #RSAbstractGridLayout! !!RSAbstractGridLayout class methodsFor: 'public'!on: aCollectionOfElements withGap: anInteger withLineItemsCount: aBlock	"place the elements in a grid with (aBlock roValue: aCollectionOfElements) as the amount of elements horizontally"		| myLayout |	myLayout := self new gapSize: anInteger;  lineItemsCount: aBlock; yourself.	myLayout applyOn: aCollectionOfElements.	^ aCollectionOfElements! !!RSAbstractGridLayout class methodsFor: 'public'!on: aCollectionOfElements withLineItemsCount: aBlock	"place the elements in a grid with (aBlock roValue: aCollectionOfElements) as the amount of elements horizontally	For example:	self on: (ROElement forCollection: (1 to: 20)) withLineItemsCount: 5	=> place the 20 elements on a grid 5 x 4		self on: (ROElement forCollection: (1 to: 20)) withLineItemsCount: [ :elements | elements size // 3 ]	=> place the 20 elements on a grid 3 x 7	"			| myLayout |	myLayout := self new lineItemsCount: aBlock; yourself.	myLayout applyOn: aCollectionOfElements.	^ aCollectionOfElements! !!RSAbstractGridLayout class methodsFor: 'instance creation'!withGap: anInteger 	^ self new 			gapSize: anInteger; 			yourself! !!RSAbstractGridLayout class methodsFor: 'instance creation'!withGap: anInteger withLineItemsCount: aBlock		^self new		gapSize: anInteger;		lineItemsCount: aBlock;		yourself! !!RSAbstractGridLayout class methodsFor: 'instance creation'!withLineItemsCount: aBlock		^self new		lineItemsCount: aBlock;		yourself! !!RSAbstractGridLayout methodsFor: 'initialize-release'!defaultGapSize	^ 5! !!RSAbstractGridLayout methodsFor: 'accessing'!defaultLineItemsCount	^ [ :elements | 			| height width |			(elements size < 3 				ifTrue: [ (elements size max: 1) @ 1 ]				ifFalse: 					[ height := (elements size * 0.618034) sqrt ceiling truncated.					width := (elements size / height) ceiling truncated.					width @ height ]) x ]! !!RSAbstractGridLayout methodsFor: 'accessing'!gapSize	^ gapSize! !!RSAbstractGridLayout methodsFor: 'accessing'!gapSize: anInteger	gapSize := anInteger! !!RSAbstractGridLayout methodsFor: 'initialize-release'!initialize	super initialize.	gapSize := self defaultGapSize.	lineItemsCountBlock := self defaultLineItemsCount.! !!RSAbstractGridLayout methodsFor: 'accessing'!lineItemsCount: aNumberOrASymbolOrABlock	"The argument will be evaluated (using rtValue:) against the set of elements to perform the layout on. The result of this evaluation has to be a number, which indicates the number of elements per line"	lineItemsCountBlock := aNumberOrASymbolOrABlock! !!RSAbstractGridLayout methodsFor: 'accessing'!lineItemsCountBlock	^ lineItemsCountBlock! !!RSCellLayout methodsFor: 'accessing'!centered	align := #center.	translateElement := [ :aTranslator :anElement :newPos | translator translateCenterLeftOf: anElement to: newPos ].		self inCellPosition: [ :cell | cell extent x @ 0 ]! !!RSCellLayout methodsFor: 'hook'!doExecute: elements 	| lineItemSize pointer columnCount rowCount maxHeight columnsWidths rowHeights |	lineItemSize := self lineItemsCountBlock rsValue: elements.	"We compute the size of the grid"	columnCount := 1.	rowCount := 1.	maxHeight := 0.	columnsWidths := OrderedCollection new.	rowHeights := OrderedCollection new.	elements do: [ :e |		columnsWidths size < columnCount ifTrue: [ columnsWidths add: 0 ].		columnsWidths at: columnCount put: ((columnsWidths at: columnCount) max: e extent x).				maxHeight := maxHeight max: e extent y.		columnCount := columnCount + 1.				columnCount > lineItemSize			ifTrue: [ 				columnCount := 1. 				rowHeights add: maxHeight.				maxHeight := 0 ]	].	rowHeights add: maxHeight.	"We do the translation"	columnCount := 1.	rowCount := 1.	pointer := (((columnsWidths at: 1) / 2) @ ((rowHeights at: 1) / 2)).	elements do: [ :e | 		e translateTo: pointer.		pointer := pointer + (self gapSize * 2 @ 0) + (((columnsWidths at: columnCount) / 2) @ 0).		columnCount := columnCount + 1.		columnCount > lineItemSize			ifTrue: [ 				columnCount := 1.				pointer := (((columnsWidths at: 1) / 2) @ pointer y)  + (0 @ ((rowHeights at: rowCount) / 2)).				rowCount := rowCount + 1.				rowCount <= rowHeights size 					ifTrue: [ pointer := pointer + (0 @ ((rowHeights at: rowCount) / 2)) ].				 				 ]			ifFalse: [ pointer := pointer + (self gapSize * 2 @ 0) + (((columnsWidths at: columnCount ) / 2) @ 0) ].	]! !!RSCellLayout methodsFor: 'accessing'!inCellPosition: anObjectOrOneArgBlock	inCellPosition := anObjectOrOneArgBlock! !!RSCellLayout methodsFor: 'initialize-release'!initialize	super initialize.	self leftCentered! !!RSCellLayout methodsFor: 'accessing'!leftCentered	align := #left.	translateElement := [ :aTranslator :anElement :newPos | translator translateTopLeftOf: anElement to: newPos ].		"self inCellPosition: [ :cell | 0 @ ((cell extent y - cell element height) / 2) ]"	self inCellPosition: [ :cell | cell extent x @ 0 ]! !!RSGridLayout methodsFor: 'hook'!doExecute: elements	| pointer lineItemCount lineItemSize maxLastLineHeight originalGapLeft originalGapTop |	originalGapLeft := 0.	originalGapTop := 0.		pointer := originalGapLeft @ originalGapTop.	lineItemSize := self lineItemsCountBlock rsValue: elements.	lineItemCount := 0.	maxLastLineHeight := 0.	elements		do: [ :element | 			translator translateTopLeftOf: element to: pointer.			pointer := (pointer x + element width + self gapSize) @ pointer y.			lineItemCount := lineItemCount + 1.			maxLastLineHeight := maxLastLineHeight max: element height.			lineItemCount >= lineItemSize				ifTrue: [ 					pointer := originalGapLeft @ (pointer y + (self gapSize) + maxLastLineHeight).										maxLastLineHeight := 0.					lineItemCount := 0 ].			self step ].! !!RSAbstractLineLayout class methodsFor: 'testing'!isAbstract	^ self name = #RSAbstractLineLayout! !!RSAbstractLineLayout class methodsFor: 'instance creation'!withGap: anInteger		^(self new)		gapSize: anInteger;		yourself! !!RSAbstractLineLayout methodsFor: 'accessing'!alignBottom	alignment := #bottom! !!RSAbstractLineLayout methodsFor: 'accessing'!alignCenter	"Make the element centered"	alignment := #center! !!RSAbstractLineLayout methodsFor: 'accessing'!alignLeft	alignment := #left! !!RSAbstractLineLayout methodsFor: 'accessing'!alignRight	alignment := #right! !!RSAbstractLineLayout methodsFor: 'accessing'!alignTop	alignment := #top! !!RSAbstractLineLayout methodsFor: 'accessing'!alignment	^ alignment! !!RSAbstractLineLayout methodsFor: 'accessing'!alignment: anObject	alignment := anObject! !!RSAbstractLineLayout methodsFor: 'configuration'!center	self alignment: #center! !!RSAbstractLineLayout methodsFor: 'hook'!deltaFor: aNodeFigure	^ self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'hook'!doCenter: aGraph	self subclassResponsibility ! !!RSAbstractLineLayout methodsFor: 'hook'!doExecute: elements 	| pointer delta |	pointer := self positionOriginalPointer: elements.	elements do: [ :element |		delta := self deltaFor: element.		translator translateTopLeftOf: element to: pointer - delta.		pointer := self 			movePointer: pointer			accordingToFigure: element.		self step ].! !!RSAbstractLineLayout methodsFor: 'accessing'!gapSize	^ gapSize! !!RSAbstractLineLayout methodsFor: 'accessing'!gapSize: aNumber	gapSize := aNumber. " This value is never used actually "		verticalGap := 2 * aNumber.	horizontalGap := 2 * aNumber! !!RSAbstractLineLayout methodsFor: 'accessing'!horizontalGap	^ horizontalGap! !!RSAbstractLineLayout methodsFor: 'accessing'!horizontalGap: anInteger	horizontalGap := anInteger! !!RSAbstractLineLayout methodsFor: 'initialize-release'!initialize	super initialize.	verticalGap := 10.	horizontalGap := 10.! !!RSAbstractLineLayout methodsFor: 'hook'!movePointer: pointer accordingToFigure: aNodeFigure	self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'hook'!positionOriginalPointer: aGraph	^ self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'accessing'!verticalGap	^ verticalGap! !!RSAbstractLineLayout methodsFor: 'accessing'!verticalGap: anInteger	verticalGap := anInteger! !!RSHorizontalLineLayout methodsFor: 'hook'!deltaFor: aNodeFigure	| delta |	delta := 0.	self alignment == #bottom ifTrue: [delta := aNodeFigure height].	self alignment == #center ifTrue: [delta := aNodeFigure height / 2.0].	^0 @ delta! !!RSHorizontalLineLayout methodsFor: 'hook'!doCenter: elements  	| midTallest step |	midTallest := 0.	midTallest := elements nodes 		inject: 0		into: [ :m :el | m max: (el bounds height )].	midTallest := midTallest / 2.	elements nodes do: [ :node | 		step := 0 @ (midTallest - (node bounds height / 2)) asInteger.		node bounds origin: (node bounds origin + step).		node bounds corner: (node bounds corner + step).	] ! !!RSHorizontalLineLayout methodsFor: 'initialize-release'!initialize	super initialize.	self alignTop! !!RSHorizontalLineLayout methodsFor: 'hook'!movePointer: pointer accordingToFigure: element	^ (pointer x + element width + self horizontalGap) @ pointer y! !!RSHorizontalLineLayout methodsFor: 'hook'!positionOriginalPointer: elements 	| maxHeight delta |	delta := 0.	self alignment == #bottom ifTrue: 		[ maxHeight := elements maxValue: #height.		delta := maxHeight ].	self alignment == #center ifTrue: 		[ maxHeight := elements maxValue: #height.		delta := maxHeight / 2.0 ].	^ (0) @ ((0) + delta)! !!RSVerticalLineLayout methodsFor: 'hook'!deltaFor: aNodeFigure	| delta |	delta := 0.	self alignment == #right ifTrue: [delta := aNodeFigure width].	self alignment == #center ifTrue: [delta := aNodeFigure width / 2.0].	^delta @ 0! !!RSVerticalLineLayout methodsFor: 'hook'!doCenter: aGraph  	| midWidest step |	midWidest := aGraph nodes 		inject: 0		into: [ :m :el | m max: (el bounds width )].	midWidest := midWidest / 2.	aGraph nodes do: [ :node | 		step := (midWidest - (node bounds width /2)) asInteger @ 0.		node bounds origin: (node bounds origin + step).		node bounds corner: (node bounds corner + step).	] ! !!RSVerticalLineLayout methodsFor: 'initialize-release'!initialize	super initialize.	self alignLeft! !!RSVerticalLineLayout methodsFor: 'hook'!movePointer: pointer accordingToFigure: aNodeFigure	^ pointer x @ (pointer y + aNodeFigure height + self verticalGap)! !!RSVerticalLineLayout methodsFor: 'hook'!positionOriginalPointer: elements 	| maxWidth delta |	delta := 0.	self alignment == #right ifTrue: 		[ maxWidth := elements maxValue: #width.		delta := maxWidth ].	self alignment == #center ifTrue: 		[ maxWidth := elements maxValue: #width.		delta := maxWidth / 2.0 ].	^ ((0) + delta) @ (0)! !!RSAbstractCompactTree class methodsFor: 'testing'!horizontalGap: anInt	| new |		new := self new.	new horizontalGap: anInt.		^ new ! !!RSAbstractCompactTree class methodsFor: 'testing'!horizontalGap: anInt verticalGap: another	| new |		new := self new.	new horizontalGap: anInt.	new verticalGap: another.			^ new ! !!RSAbstractCompactTree class methodsFor: 'testing'!isAbstract	^ self name = #RSAbstractCompactTree! !!RSAbstractCompactTree class methodsFor: 'testing'!verticalGap: anInt	| new |		new := self new.	new verticalGap: anInt.		^ new ! !!RSAbstractCompactTree methodsFor: 'private'!childrenFor: aNode 	^ sonsDictionary isEmpty 		ifTrue: [ super childrenFor: aNode ] 		ifFalse: [ sonsDictionary at: aNode ifAbsent: [ ^ OrderedCollection new ] ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!compareContourOf: aNode with: another	"return the number of radians the subtree induced by aNode must be displaced to be separated by a predefined distance (horizontalGap) from the one induced by anotherNode"	self subclassResponsibility! !!RSAbstractCompactTree methodsFor: 'algorithm'!computePosition: aNode"compute the position of the given node and of his sons recursively"	self subclassResponsibility.! !!RSAbstractCompactTree methodsFor: 'algorithm'!followLeftContour: aNode toLayer: anInteger	"return the last node in the left contour begining at anode"		((self layerOf: aNode) = anInteger ) ifTrue: [^ aNode  ].	((self layerOf: aNode) > anInteger ) ifTrue: [^ nil  ].		(self leftContourOf: aNode) isNil ifTrue: [ (self pointerOf: aNode)  isNil ifTrue: [ ^ nil ] 														 ifFalse: [ ^ ( self followLeftContour: (self pointerOf: aNode) toLayer: anInteger ) ] ]				  				ifFalse: [ ^ (self followLeftContour: (self leftContourOf: aNode) toLayer: anInteger ) ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!followRightContour: aNode toLayer: anInteger	"return the node in the right contour begining at anode in layer anInteger"	((self layerOf: aNode) = anInteger ) ifTrue: [^ aNode  ].	((self layerOf: aNode) > anInteger ) ifTrue: [^ nil  ].	(self rightContourOf: aNode) isNil ifTrue: [ (self pointerOf: aNode) isNil ifTrue: [ ^ nil ] 														 ifFalse: [ ^ ( self followRightContour: (self pointerOf: aNode) toLayer: anInteger ) ] ]				  				ifFalse: [ ^ (self followRightContour: (self rightContourOf: aNode) toLayer: anInteger ) ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!getAbcissaOf: aNode inSubtreeFromLayer: anInteger	| node x |		(anInteger < 0) ifTrue: [^ self getAbcissaOf: aNode inSubtreeFromLayer: 0 ].		((self layerOf: aNode) = anInteger ) ifTrue: [ ^ self xOf: aNode ].	((self layerOf: aNode) < anInteger ) ifTrue: [ ^ nil ].		x := (self xOf: aNode) + (self modOf: aNode).		node := self fatherOf: aNode.		[(self layerOf: node) = anInteger  ] whileFalse: [ x := x + (self modOf: node).									node := self fatherOf: node ].									^ x! !!RSAbstractCompactTree methodsFor: 'initialize-release'!greedyCycleRemoval: aGraph! !!RSAbstractCompactTree methodsFor: 'initialize-release'!initialLayout: aLayout	initialLayout := aLayout ! !!RSAbstractCompactTree methodsFor: 'initialize-release'!initialize 	super initialize.	verticalGap := 20.	horizontalGap := 30.	margin := 40. 	sonsDictionary := Dictionary new! !!RSAbstractCompactTree methodsFor: 'initialize-release'!initialize: aNode whoseFatherIs: another 	self fatherOf: aNode put: another.		another isNil ifTrue: [ self layerOf: aNode put: 0 ] ifFalse: [ self layerOf: aNode put: (self layerOf: another) + 1 ] .		( self childrenFor: aNode ) do: [ :e | self initialize: e whoseFatherIs: aNode ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!leftSiblingOf: aNode	"return the left sibling of the given node "	| children |	(self fatherOf: aNode) isNil ifTrue: ["has no sibling" ^ nil]					    ifFalse: [ children := self childrenFor: (self fatherOf: aNode).								(children first) = aNode ifTrue: ["as no left sibling" ^ nil ]																    ifFalse: [^ children at: ((children indexOf: aNode) - 1) ] ]! !!RSAbstractCompactTree methodsFor: 'initialize-release'!root: aNode 	root := aNode ! !!RSRadialTreeLayout methodsFor: 'algorithm'!compareContourOf: aNode with: another	"return the number of radians the subtree induced by aNode must be displaced to be separated by a predefined distance (horizontalGap) from the one induced by anotherNode"	| difference max nodeA nodeB |	nodeB := aNode.	"the right one"	nodeA := another.	"the left one"	max := aNode = another		ifTrue: [ 0 ]		ifFalse: [ horizontalGap / (self layerOf: nodeB) / 2 - ((self xOf: nodeB) - (self getAbcissaOf: nodeA inSubtreeFromLayer: (self layerOf: aNode) - 1)) ].	nodeB := self followLeftContour: nodeB toLayer: (self layerOf: nodeB) + 1.	nodeA := self followRightContour: nodeA toLayer: (self layerOf: nodeA) + 1.	[ nodeB isNil not & nodeA isNil not ]		whileTrue: [ 			difference := horizontalGap / (self layerOf: nodeA)				-					((self getAbcissaOf: nodeB inSubtreeFromLayer: (self layerOf: aNode) - 1)						- (self getAbcissaOf: nodeA inSubtreeFromLayer: (self layerOf: aNode) - 1)).			max := max max: difference.			nodeB := self followLeftContour: nodeB toLayer: (self layerOf: nodeB) + 1.			nodeA := self followRightContour: nodeA toLayer: (self layerOf: nodeA) + 1 ].	^ max! !!RSRadialTreeLayout methodsFor: 'hook'!computeGap: aNode	" compute the vertical gap needed for drawing the radial tree "	| gap maxAbcissa i abc nodeL nodeR layer |		gap := 0.	maxAbcissa := 0.	layer := 1.		i := 1.	[ nodeL :=(self followLeftContour: aNode toLayer: i).	nodeR := (self followRightContour: aNode toLayer: i).	nodeL isNil not & nodeR isNil not ] whileTrue: [ abc := (((self getAbcissaOf: nodeR inSubtreeFromLayer: 0) - (self getAbcissaOf: nodeL inSubtreeFromLayer: 0 ) + (horizontalGap / layer/2)) / layer).																	(abc > maxAbcissa) ifTrue: [ maxAbcissa := abc. 																								layer := layer ].																	i := i + 1 ].		gap:= (maxAbcissa / 2 /Float pi ) floor +1.		((verticalGap isNil) or: [gap > verticalGap])  ifTrue: [ self verticalGap: gap ]! !!RSRadialTreeLayout methodsFor: 'algorithm'!computePosition: aNode	"compute the position of the given node and of his sons recursively"	| children neighbor nodeA |	children := self childrenFor: aNode.	neighbor := self leftSiblingOf: aNode.	children isEmpty ifTrue: [		 neighbor			ifNil: [ self xOf: aNode put: 0.				self modOf: aNode put: 0 ]			ifNotNil: [ self					xOf: aNode					put: (self xOf: neighbor) + (horizontalGap / (self layerOf: aNode) / 2).				self modOf: aNode put: (self modOf: neighbor).				self					pointerOf: aNode					put: (self followRightContour: neighbor toLayer: (self layerOf: aNode) + 1) ] ]	ifFalse: [ 		self leftContourOf: aNode put: children first.		self rightContourOf: aNode put: children last.		children do: [ :e | self computePosition: e ].		self			xOf: aNode			put:				((self xOf: (self leftContourOf: aNode))					+ (self xOf: (self rightContourOf: aNode))					+ (self modOf: (self rightContourOf: aNode))) / 2.		self modOf: aNode put: 0.		neighbor			ifNotNil:				[ self modOf: aNode put: (self compareContourOf: aNode with: neighbor).				nodeA := self					followLeftContour: (self fatherOf: aNode)					toLayer: (self layerOf: aNode).				[ (self					followLeftContour: nodeA					toLayer: (self layerOf: nodeA) + 1) isNil ]					whileFalse: [ nodeA := self							followLeftContour: nodeA							toLayer: (self layerOf: nodeA) + 1 ].				self					pointerOf: nodeA					put: (self followLeftContour: aNode toLayer: (self layerOf: nodeA) + 1).				nodeA := self					followRightContour: aNode					toLayer: (self layerOf: aNode) + 1.				nodeA ifNil: [ ^ self ].				[ (self					followRightContour: nodeA					toLayer: (self layerOf: nodeA) + 1) isNil ]					whileFalse: [ nodeA := self							followRightContour: nodeA							toLayer: (self layerOf: nodeA) + 1 ].				self					pointerOf: nodeA					put: (self followRightContour: neighbor toLayer: (self layerOf: nodeA) + 1) ] ]! !!RSRadialTreeLayout methodsFor: 'hook'!doExecute: nodeElements	| rootNodes xOffset maximumRadius | 	initialLayout isNil		ifFalse: [ initialLayout new executeOnElements: nodeElements ].	rootNodes := self rootNodesFor: nodeElements.	rootNodes		do: [ :e | self initialize: e whoseFatherIs: nil ];		do: [ :e | self computePosition: e. self step];		do: [ :e | self computeGap: e ];		do: [ :e | self toRadialTree: e withMod: 0 ].	xOffset := 0.	rootNodes		do: [ :e | 			maximumRadius := self radialDraw: e.			"Shifting all the subgroups"			self shiftTree: e by:  (maximumRadius+xOffset)@maximumRadius.			xOffset := xOffset + (2 * maximumRadius) + 10.  ].! !!RSRadialTreeLayout methodsFor: 'private'!gap	^ self verticalGap! !!RSRadialTreeLayout methodsFor: 'private'!layoutLayer: aCollection radius: oldRadius from: aFromAngle to: aToAngle	| delta childRadius maximumRadius myRadius fromAngle toAngle |	"Initialize with default value"	maximumRadius := oldRadius.	aCollection isEmpty		ifFalse:			[myRadius := oldRadius + self gap + (self maximumRadius: aCollection).			childRadius := oldRadius + self gap + (self maximumDiameter: aCollection).	"This is a purely optical tweak"			(aCollection size = 1 and: [aToAngle - aFromAngle = (2 * Float pi)])				ifTrue:					[delta := 0.4 * Float pi.					fromAngle := 0.8 * Float pi.					toAngle := fromAngle + delta]				ifFalse:					[delta := (aToAngle - aFromAngle) / aCollection size.					fromAngle := aFromAngle.					toAngle := aFromAngle + delta].			aCollection				do:					[:child | 					translator translateTopLeftOf: child to: (Point								r: myRadius								theta: toAngle - (delta / 2.0)).					"child						translateTo:							(Point								radius: myRadius								theta: toAngle - (delta / 2.0))."					maximumRadius := maximumRadius						max:							(self								layoutLayer: (self childrenFor: child)								radius: childRadius								from: fromAngle								to: toAngle).					fromAngle := toAngle.					toAngle := toAngle + delta]].	^maximumRadius! !!RSRadialTreeLayout methodsFor: 'private'!moveAllElementsToTopLeft: elements	| pos min |	pos := elements collect: #position.	min := pos inject: 0 @ 0 into: [ :minimum :p | minimum min: p ].	elements do: [ :e | e translateBy: min negated ] ! !!RSRadialTreeLayout methodsFor: 'algorithm'!radialDraw: aNode	"draw the subtree induced by the given node"	| children r max |	r := (self rOf: aNode).	translator translateTopLeftOf: aNode to: (Point r: r theta: (self thetaOf: aNode)).	"aNode translateTo: (Point radius: (aNode r) theta: (aNode theta))."	children := self childrenFor: aNode.	max := 0.	children do: [ :e | max := max max: (self radialDraw: e) ].	^ r + max.! !!RSRadialTreeLayout methodsFor: 'hook'!rotateSubtreeFrom: aNode by: aFloat	aNode theta: aNode theta + aFloat.	(self childrenFor: aNode) do: [ :e | 		self rotateSubtreeFrom: e by: aFloat ]! !!RSRadialTreeLayout methodsFor: 'algorithm'!toRadialTree: aNode withMod: aFloat	"compute polar coordinates of the subtree induced by anode from its cartesian coordinates "	| children |	self rOf: aNode put: ((self layerOf: aNode) * verticalGap ).	((self rOf: aNode) = 0) ifTrue: [ self thetaOf: aNode put: 0 ] 					ifFalse: [ self thetaOf: aNode put: ((self xOf: aNode)  + aFloat + (self modOf: aNode)) / verticalGap ].		children := self childrenFor: aNode.		children do: [ :e | self toRadialTree: e withMod: ( (self modOf: aNode) + aFloat) ]! !!RSAbstractGraphLayout class methodsFor: 'constants'!horizontalGap		^3.0! !!RSAbstractGraphLayout class methodsFor: 'testing'!isAbstract	^ self name = #RSAbstractGraphLayout! !!RSAbstractGraphLayout class methodsFor: 'public'!on: elements edges: edges	"Do the layout of the elements tacking into account the provided edges"	^ self new 		userDefinedEdges: edges;		applyOn: elements.! !!RSAbstractGraphLayout class methodsFor: 'constants'!verticalGap		^20.0! !!RSAbstractGraphLayout methodsFor: 'private'!cachedChildren	cachedChildren ifNil: [cachedChildren := IdentityDictionary new: 1000].	^ cachedChildren! !!RSAbstractGraphLayout methodsFor: 'private'!cachedParents	cachedParents ifNil: [cachedParents := IdentityDictionary new: 1000].	^ cachedParents! !!RSAbstractGraphLayout methodsFor: 'private'!cachedParentsWithHighestNestings	cachedParentsWithHighestNestings		ifNil: [cachedParentsWithHighestNestings := IdentityDictionary new: 1000].	^ cachedParentsWithHighestNestings! !!RSAbstractGraphLayout methodsFor: 'private'!childrenFor: aNode	^ self cachedChildren		at: aNode		ifAbsentPut:			[| nodes |			nodes := OrderedCollection new.			self edgesDo:					[:edge | 					(edge from == aNode and: [edge to ~= aNode])						ifTrue:							[(nodes includes: edge from) ifFalse: [nodes add: edge to]]].			nodes]! !!RSAbstractGraphLayout methodsFor: 'private'!childrenFor: aNode except: aNodeCollection	^ (self childrenFor: aNode) 		reject: [:each | aNodeCollection includes: each]		"we are explicitly not using the default Collection>>difference: behavior here because we want to preserve the order of the collection"! !!RSAbstractGraphLayout methodsFor: 'private'!childrenWithHighestNestingLevelFor: aNode	^ (self childrenFor: aNode)		select: [:eachChild | (self highestNestingParentFor: eachChild) == aNode]! !!RSAbstractGraphLayout methodsFor: 'private'!clear	cachedParents := nil.	cachedChildren := nil.	cachedParentsWithHighestNestings := nil! !!RSAbstractGraphLayout methodsFor: 'hook'!doInitialize: elements 	super doInitialize: elements.	self clear.	"self greedyCycleRemoval: elements"! !!RSAbstractGraphLayout methodsFor: 'battista'!greedyCycleRemoval: aCollection	"Di Battista Greedy-Cycle-Removal algorithm. Chapter 9.4, page 297. The last part is not like in the book. The original algorithm only takes	 local optimas into account. This will break ordinary trees sometimes. This version also takes global optimas into account."		| g sl sr s indeg outdeg degrees vertex | 	g := aCollection copy asOrderedCollection.	sl := OrderedCollection new.	sr := OrderedCollection new.	"While g contains a sink (aka leaf)"	g copy		do:			[:node | 			(self childrenFor: node) isEmpty				ifTrue:					[sr addFirst: node.					g remove: node]	"self edges detect: [:edge | edge fromFigure == node] ifNone: [sr addFirst: node. g remove: node]"].	"While g contains a source (aka root)"	g copy		do:			[:node | 			(self parentsFor: node) isEmpty				ifTrue:					[sl addLast: node.					g remove: node]	"self edges detect: [:edge | edge toFigure == node] ifNone: [sl addLast: node. g remove: node]"].	"Calculate deg for all remaining vertices"	degrees := IdentityDictionary new.	g		do:			[:node | 			indeg := (self parentsFor: node) size.			outdeg := (self childrenFor: node) size.	"indeg := self edges inject: 0 into: [:sum :edge | (edge toFigure == node) ifTrue: [sum + 1] ifFalse: [sum]].		outdeg := self edges inject: 0 into: [:sum :edge | (edge fromFigure == node) ifTrue: [sum + 1] ifFalse: [sum]]."			degrees				at: node				put: outdeg - indeg].	"While g not empty"	g := g asSortedCollection: [:a :b | (degrees at: a) >= (degrees at: b)].	[g isEmpty]		whileFalse:			[vertex := g				detect: [:v | (self parentsFor: v) anySatisfy: [:w | sl includes: w]]				ifNone: [g first].	"Corner case: Closed cycle with not root at all. Eg 1 -> 2 -> 3 -> 1"			sl addLast: vertex.			g remove: vertex].	"Remove all leftward edges"	s := sl , sr.	self edges notNil		ifTrue: 			[ self edges copy				do:					[:edge | 					(s indexOf: edge from) > (s indexOf: edge to)						ifTrue: [self edges remove: edge ] ] ].		"Reset the cache"	self clear! !!RSAbstractGraphLayout methodsFor: 'private'!highestNestingParentFor: aNodeFigure	| parents |	^self cachedParentsWithHighestNestings		at: aNodeFigure		ifAbsentPut:			[parents := self parentsFor: aNodeFigure.			parents isEmpty				ifTrue: [0]				ifFalse:					[parents detectMax: [:eachParent | self nestingLevelFor: eachParent]]]! !!RSAbstractGraphLayout methodsFor: 'accessing'!horizontalGap	"Return the horizontal space, in pixel, between two neighbors"	^ horizontalGap ifNil: [ self class horizontalGap ]! !!RSAbstractGraphLayout methodsFor: 'accessing'!horizontalGap: anInteger	"Set the horizontal space, in pixel, between two neighbors"	horizontalGap := anInteger! !!RSAbstractGraphLayout methodsFor: 'private'!maximumDiameter: aCollection	^ aCollection		inject: 0		into: [:max :node | max max: (node radius * 2) ] ! !!RSAbstractGraphLayout methodsFor: 'private'!maximumRadius: aCollection	^ aCollection		inject: 0		into: [:max :node | max max: node radius]! !!RSAbstractGraphLayout methodsFor: 'private'!nestingLevelFor: aNodeFigure	| parents parentsNesting |	parents := self parentsFor: aNodeFigure.	parentsNesting := parents		collect: [:eachParent | self nestingLevelFor: eachParent].	^parentsNesting isEmpty		ifTrue: [0]		ifFalse: [parentsNesting max + 1]! !!RSAbstractGraphLayout methodsFor: 'actions'!on: el edges: edgs	"Do the layout of the elements tacking into account the provided edges"	self userDefinedEdges ifNil: [ self userDefinedEdges: edgs ].	^ self applyOn: el.! !!RSAbstractGraphLayout methodsFor: 'private'!parentsFor: aNode	^ self cachedParents		at: aNode		ifAbsentPut:			[ | nodes |			nodes := OrderedCollection new.			self edgesDo:					[:edge | edge to == aNode ifTrue: [ nodes add: edge from ] ].			nodes ]! !!RSAbstractGraphLayout methodsFor: 'private'!rootNodesFor: aCollection	^ aCollection select: [:node | 		(self parentsFor: node) isEmpty ].	! !!RSAbstractGraphLayout methodsFor: 'private'!shiftTree: aNode by: aPoint	aNode translateBy: aPoint.	(self childrenFor: aNode) do: [:child | self shiftTree: child by: aPoint]! !!RSAbstractGraphLayout methodsFor: 'accessing'!verticalGap	"Return the vertical space, in pixel, between a layer and a children layer"	^ verticalGap ifNil: [ self class verticalGap ]! !!RSAbstractGraphLayout methodsFor: 'accessing'!verticalGap: anInteger	"Set the vertical space, in pixel, between a layer and a children layer"	verticalGap := anInteger! !!RSAbstractHorizontalTreeLayout class methodsFor: 'testing'!isAbstract	^ self = RSAbstractHorizontalTreeLayout! !!RSAbstractHorizontalTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	self subclassResponsibility! !!RSAbstractHorizontalTreeLayout methodsFor: 'initialize-release'!initialize	super initialize.	verticalGap := 3.	horizontalGap := 20! !!RSAbstractHorizontalTreeLayout methodsFor: 'hook-private'!layout: aNodeCollection atPoint: aPoint atLayer: aNumber	| treeSize childrenPosition x y middleOfTree |	aNodeCollection isEmpty ifTrue: [ ^ 0 ].	x := aPoint x.	y := aPoint y.	alreadyLayoutedNodes addAll: aNodeCollection.	self atLayer: aNumber add: aNodeCollection.	aNodeCollection do: [ :each | 		childrenPosition := x + each width + self horizontalGap.		treeSize := each height			max: (self layout: (self computeChildrenFor: each) atPoint: childrenPosition @ y atLayer: aNumber + 1).		middleOfTree := y + (treeSize / 2.0) - (each height / 2.0).		translator translateTopLeftOf: each to: (x @ middleOfTree).		y := y + treeSize + self verticalGap.		self step ].	^ y - aPoint y - self verticalGap! !!RSAbstractHorizontalTreeLayout methodsFor: 'private'!rearrangeByLayers: aGraph	| cursor layerDepthSize |	cursor := self leftGap.	nodesByLayer do: [ :eachSetOfNodes |		layerDepthSize := eachSetOfNodes inject: 0 into: [ :max :eachNode | 			translator translateTopLeftOf: eachNode to: (cursor @ eachNode encompassingRectangle top).			max max: eachNode width ].		cursor := cursor + layerDepthSize + self horizontalGap ]! !!RSHorizontalDominanceTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenWithHighestNestingLevelFor: aNode! !!RSHorizontalTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenFor: aNode except: alreadyLayoutedNodes! !!RSAbstractRegularTreeLayout class methodsFor: 'testing'!isAbstract	^ self = RSAbstractRegularTreeLayout! !!RSAbstractRegularTreeLayout methodsFor: 'private'!atLayer: aNumber add: aNodeCollection	| collection |	collection := nodesByLayer at: aNumber ifAbsentPut: [OrderedCollection new].	collection addAll: aNodeCollection! !!RSAbstractRegularTreeLayout methodsFor: 'hook'!doExecute: elements	| rootNodes |	alreadyLayoutedNodes := OrderedCollection new.	rootNodes := self rootNodesFor: elements.	nodesByLayer := OrderedCollection new.	self		layout: rootNodes		atPoint: self leftGap @ self topGap		atLayer: 1.	self isLayered ifTrue: [		self rearrangeByLayers: elements ]! !!RSAbstractRegularTreeLayout methodsFor: 'hook'!doInitialize: elements 	self clear! !!RSAbstractRegularTreeLayout methodsFor: 'hook'!doPost: elements	shouldBeHorizontallyReversed ifTrue: [ self horizontallyReverse: elements ].	shouldBeVerticallyReversed ifTrue: [ self verticallyReverse: elements ].! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!horizontallyReverse	shouldBeHorizontallyReversed := true! !!RSAbstractRegularTreeLayout methodsFor: 'reversing'!horizontallyReverse: elements	"Horizontally reverse the elements, as well as the attachpoints"	| g largeur |	g := elements asGroup.	largeur := g extent x.	elements		do: [ :el | el translateTo: (largeur - el position x) @ el position y ]! !!RSAbstractRegularTreeLayout methodsFor: 'initialize-release'!initialize	super initialize.	topGap := 5.	leftGap := 5.	isLayered := false.	shouldBeHorizontallyReversed := false.	shouldBeVerticallyReversed := false.! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!isLayered	"Is the layout layered"	^ isLayered! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!isLayered: boolean	"Is the layout layered"	isLayered := boolean! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!layered	self isLayered: true! !!RSAbstractRegularTreeLayout methodsFor: 'hook-private'!layout: aNodeCollection atPoint: aPoint atLayer: anObject	self subclassResponsibility! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!leftGap	^ leftGap! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!leftGap: anInteger	leftGap := anInteger! !!RSAbstractRegularTreeLayout methodsFor: 'private'!rearrangeByLayers: aGraph	self subclassResponsibility! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!shouldBeHorizontallyReversed	"Return if the layout is horizontally reversed"	^ shouldBeHorizontallyReversed ! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!shouldBeVerticallyReversed	"Return if the layout is vertically reversed"	^ shouldBeVerticallyReversed! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!topGap	^ topGap! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!topGap: anInteger	topGap := anInteger! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!verticallyReverse	"Reverse the edge extremities"	"Here is an example:| b |	b := RTMondrian new.b nodes: (1 to: 100).b edges connectFrom: [ :v | v // 2 ].b layout tree verticallyReverse.b"	shouldBeVerticallyReversed := true	! !!RSAbstractRegularTreeLayout methodsFor: 'reversing'!verticallyReverse: elements	"Vertically reverse the elements, as well as the attachpoints"	| g hauteur |	g := elements asGroup.	hauteur := g extent y.	elements		do: [ :el | el translateTo: el position x @ (hauteur - el position y) ]! !!RSAbstractVerticalTreeLayout class methodsFor: 'testing'!isAbstract	^ self = RSAbstractVerticalTreeLayout! !!RSAbstractVerticalTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	self subclassResponsibility! !!RSAbstractVerticalTreeLayout methodsFor: 'initialize-release'!initialize	super initialize.	verticalGap := 20.	horizontalGap := 3! !!RSAbstractVerticalTreeLayout methodsFor: 'hook-private'!layout: aNodeCollection atPoint: aPoint atLayer: aNumber	| treeSize childrenPosition x y middleOfTree |	aNodeCollection isEmpty ifTrue: [ ^ 0 ].	x := aPoint x.	y := aPoint y.	alreadyLayoutedNodes addAll: aNodeCollection.	self atLayer: aNumber add: aNodeCollection.	aNodeCollection do: [ :each |		| children |		childrenPosition := y + each height + self verticalGap.		children := self computeChildrenFor: each.		treeSize := self 			layout: children			atPoint: x @ childrenPosition			atLayer: aNumber + 1.		treeSize < each width ifTrue: [ 			self translate: children by: (each width - treeSize) / 2.0 @ 0.			treeSize := each width. ].				middleOfTree := x + (treeSize / 2.0) - (each width / 2.0).		translator translateTopLeftOf: each to: middleOfTree @ y.		x := x + treeSize + self horizontalGap.		self step ].	^ x - aPoint x - self horizontalGap! !!RSAbstractVerticalTreeLayout methodsFor: 'private'!rearrangeByLayers: aGraph	| cursor layerDepthSize |	cursor := self topGap.	nodesByLayer do: [:eachSetOfNodes |		layerDepthSize := eachSetOfNodes inject: 0 into: [ :max :eachNode | 			translator translateTopLeftOf: eachNode to: (eachNode position x @ cursor).			max max: eachNode height ].		cursor := cursor + layerDepthSize + self verticalGap ]! !!RSAbstractVerticalTreeLayout methodsFor: 'hook-private'!translate: aNodeCollection by: delta	aNodeCollection ifEmpty: [ ^ self ].	aNodeCollection do: [ :each | 		each translateBy: delta.		self translate: (self childrenFor: each) by: delta]! !!RSDominanceTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenWithHighestNestingLevelFor: aNode! !!RSTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenFor: aNode except: alreadyLayoutedNodes! !!RSClusterLayout methodsFor: 'algorithm'!computePosition: aNode	| children previous |	children := self childrenFor: aNode.	children do: [ :e | self computePosition: e ].	children isEmpty		ifTrue: [ externalLayer first = aNode				ifFalse: [ previous := externalLayer at: (externalLayer indexOf: aNode) - 1.					(self fatherOf: previous) = (self fatherOf: aNode)						ifTrue: [ self xOf: aNode put: (self xOf: previous) + (horizontalGap / 2) ]						ifFalse: [ self xOf: aNode put: (self xOf: previous) + horizontalGap ] ] ]		ifFalse: [ self				xOf: aNode				put:					((self xOf: (self leftContourOf: aNode))						+ (self xOf: (self rightContourOf: aNode))) / 2 ]! !!RSClusterLayout methodsFor: 'hook'!doExecute: nodeElements 	| rootNodes gap |	"Not much to do if there is only one element"	nodeElements size = 1 ifTrue: [ ^ self ].		rootNodes := self rootNodesFor: nodeElements .	rootNodes do: [ :e | self initializeNode: e ].	rootNodes do: [ :e | self computePosition: e ].		maxLayer := (rootNodes collect: [ :e | self layerOf: e ]) max.		(rootNodes size > 1) ifTrue: [ maxLayer := maxLayer + 1 ].		maxAbcissa := (self xOf: externalLayer last) + horizontalGap .		gap := maxAbcissa "+ horizontalGap "/ 2 / Float pi / maxLayer.		verticalGap := verticalGap max: gap.		rootNodes do: [ :e | self draw: e. self step ].		! !!RSClusterLayout methodsFor: 'drawing-general'!draw: aNode	(self childrenFor: aNode) do: [ :e | self draw: e ].	translator 		translateTopLeftOf: aNode 		to: (Point r: (maxLayer - (self layerOf: aNode)) * verticalGap theta: (maxAbcissa - (self xOf: aNode) / maxAbcissa) * 2 * Float pi )! !!RSClusterLayout methodsFor: 'initialize-release'!initialize 	super initialize.	verticalGap := 30.	horizontalGap := 20.	externalLayer := OrderedCollection new! !!RSClusterLayout methodsFor: 'initialize-release'!initializeNode: aNode	|children|	children := self childrenFor: aNode.		children do: [ :e | self initializeNode: e.						self fatherOf: e put: aNode ].		children isEmpty ifTrue: [ self layerOf: aNode put: 0.							externalLayer add: aNode ] 					ifFalse: [ self layerOf: aNode put: ((children collect: [ :e | (self layerOf: e) ]) max + 1).							self leftContourOf: aNode put: children first.							self rightContourOf: aNode put: children last ].					! !!RSSugiyamaLayout class methodsFor: 'utils'!sortBlock		^ RSSortBlock new! !!RSSugiyamaLayout methodsFor: 'private'!addDummyNodes	| layer layerNr |	connections := RSIdentityMatrix new.	self edgesDo:			[:edge | 			| a b span fromNode toNode |			"edge hints removeAll."			a := layerNrs at: edge from.			b := layerNrs at: edge to.			span := (a - b) abs.			span = 1				ifTrue:					[connections						at: edge from						at: edge to						put: true].	"Normal case where nodes are in adjacent layers"			fromNode := edge from.			[span > 1]				whileTrue:					[span := span - 1.					layerNr := b + span.					layer := layers at: layerNr.					toNode := RSDummyNode						on: edge						slot: a - span.					layer add: toNode.					layerNrs at: toNode put: layerNr.					connections at: fromNode at: toNode put: true.					fromNode := toNode].			(a - b) abs > 1				ifTrue:					[connections						at: fromNode						at: edge to						put: true]]! !!RSSugiyamaLayout methodsFor: 'private'!assignLabels: aNodeCollection 	"Initialize label dictionary"	| label vertices parentLabels |	labels := IdentityDictionary new.	label := 1.	"Assign labels to the roots"	(self rootNodesFor: aNodeCollection) do: 		[ :node | 		labels 			at: node			put: label.		label := label + 1 ].	"Assign labels to the rest"	[ labels keys size < aNodeCollection size ] whileTrue: 		[ vertices := SortedCollection sortBlock: self sortBlock.		aNodeCollection do: 			[ :node | 			(labels includesKey: node) ifFalse: 				[ parentLabels := ((self parentsFor: node) collect: 					[ :pn | 					labels 						at: pn						ifAbsent: [ self maxFloat ] ]) asSortedCollection.				parentLabels last ~= self maxFloat ifTrue: [ vertices add: node -> parentLabels ] ] ].		labels 			at: vertices first key			put: label.		label := label + 1 ]! !!RSSugiyamaLayout methodsFor: 'private'!buildLayers: g	| w layerNr u vertices vertex layer done |	w := self maxFloat.	u := OrderedCollection new.	layers := IdentityDictionary new.	layerNrs := IdentityDictionary new.	"Assign all nodes to layers"	[g isEmpty]		whileFalse:			[vertices := g				select:					[:e | (self childrenFor: e) allSatisfy: [:node | u includes: node]].			vertex := vertices detectMax: [:e | labels at: e].			done := false.			layerNr := 1.			[done]				whileFalse:					[layer := layers						at: layerNr						ifAbsentPut: [OrderedCollection new].					(layer size >= w						or:							[(self childrenFor: vertex) anySatisfy: [:n | (layerNrs at: n) >= layerNr]])						ifTrue: [layerNr := layerNr + 1]						ifFalse: [done := true]].			layer add: vertex.			layerNrs at: vertex put: layerNr.			u add: vertex.			g remove: vertex]! !!RSSugiyamaLayout methodsFor: 'private'!cl: layer u: u v: v	"Calculates cuv. Di Battista, chapter 9.2.2, page 283"	| partnersOfU partnersOfV c partnersOfUIndex partnersOfVIndex layerNr |	layerNr := layerNrs at: u.	":= layerNrs at: v"	partnersOfU := (connections at: u)		select: [:each | (layerNrs at: each) = (layerNr - 1)].	partnersOfV := (connections at: v)		select: [:each | (layerNrs at: each) = (layerNr - 1)].	c := 0.	partnersOfUIndex := partnersOfU collect: [:node | layer indexOf: node].	partnersOfVIndex := partnersOfV collect: [:node | layer indexOf: node].	partnersOfUIndex		do:			[:uIndex | partnersOfVIndex do: [:vIndex | vIndex < uIndex ifTrue: [c := c + 1]]].	^c! !!RSSugiyamaLayout methodsFor: 'hook'!doExecute: aNodeCollection 	"Coffman-Graham-Layering. Di Battista Book, page 275, chapter, 9.2.1"	self assignLabels: aNodeCollection.	self buildLayers: aNodeCollection copy.	self addDummyNodes.	self reduceCrossing.	self layoutAt: self verticalGap @ self horizontalGap! !!RSSugiyamaLayout methodsFor: 'private'!layoutAt: aPoint	| treeWidth layerKeys layer layerWidth horizontalPosition verticalPosition layerHeight |	treeWidth := layers values		inject: self maxFloat negated		into:			[:max :e | max max: (e sumNumbers: #width) + ((e size - 1) * self horizontalGap)].	verticalPosition := self horizontalGap.	"For visual reasons NOT: self class verticalGap"	layerKeys := layers keys asSortedCollection reverse.	layerKeys		do:			[:aKey | 			layer := layers at: aKey.			layerWidth := (layer sum: #width)				+ ((layer size - 1) * self horizontalGap).			layerHeight := (layer detectMax: #height) height.			horizontalPosition := treeWidth / 2.0 + aPoint x - (layerWidth / 2.0).			layer				do:					[:node | 					translator translateTopLeftOf: node to:  horizontalPosition @ verticalPosition.										horizontalPosition := horizontalPosition + node width						+ self horizontalGap ].			verticalPosition := verticalPosition + layerHeight + self verticalGap ]! !!RSSugiyamaLayout methodsFor: 'private'!maxFloat	^ 1e10! !!RSSugiyamaLayout methodsFor: 'private'!reduceCrossing	"Crossing reduction"	| layer2 u v c1 c2 layer1 done |	2		to: layers keys size		do:			[:index | 			layer1 := layers at: index - 1.			layer2 := layers at: index.			done := false.			[done]				whileFalse:					[done := true.					2						to: layer2 size						do:							[:i | 							u := layer2 at: i - 1.							v := layer2 at: i.							c1 := self cl: layer1 u: u v: v.							c2 := self cl: layer1 u: v v: u.							c1 > c2								ifTrue:									[layer2 rsSwapElement: u withElement: v.									done := false]]]]! !!RSSugiyamaLayout methodsFor: 'private'!sortBlock	sortBlock isNil ifTrue: [ sortBlock := self class sortBlock ].	^sortBlock! !!RSEdgeDrivenLayout class methodsFor: 'as yet unclassified'!isAbstract	^ self = RSEdgeDrivenLayout! !!RSEdgeDrivenLayout class methodsFor: 'public'!on: elements edges: edges	^ self new on: elements edges: edges! !!RSEdgeDrivenLayout class methodsFor: 'instance creation'!withEdges: aCollection		^self new initialize userDefinedEdges: aCollection! !!RSEdgeDrivenLayout methodsFor: 'hook'!doExecute: elements	self subclassResponsibility! !!RSEdgeDrivenLayout methodsFor: 'hook'!doIncrementallyExecute: anElementNode	"called by refreshLayoutEvery: ms. It is used to convey a feeling of incremental execution."	self doExecute: anElementNode! !!RSEdgeDrivenLayout methodsFor: 'private'!edges	^ edges! !!RSEdgeDrivenLayout methodsFor: 'accessing'!edges: aCollection	"Set the list of edges that should be considered for the layout.	If none is specified (i.e., if this method is not called), then the 	edges are infered."	edges := aCollection! !!RSEdgeDrivenLayout methodsFor: 'iterator'!edgesDo: aBlock	"Iterates over all the edges of the receiver."	edges ifNil: [ ^ self ].	edges do: aBlock! !!RSEdgeDrivenLayout methodsFor: 'hook'!executeOnElements: elements	"Execute the layout, myself, on the elements"	self userDefinedEdges		ifNil: [ self setEdgesFromElements: elements ]		ifNotNil: [ | flat |			flat := OrderedCollection new.			self userDefinedEdges				do: [ :each | 					each isCollection						ifTrue: [ flat addAll: each ]						ifFalse: [ flat add: each ] ].			self edges: flat ].	super executeOnElements: elements! !!RSEdgeDrivenLayout methodsFor: 'accessing'!fromPositions: anArray	fromPositions := anArray! !!RSEdgeDrivenLayout methodsFor: 'initialize-release'!initialize	"Initialization"	super initialize.	edges := nil.! !!RSEdgeDrivenLayout methodsFor: 'testing'!isEdgeDrivenLayout	^ true! !!RSEdgeDrivenLayout methodsFor: 'accessing'!setEdgesFromElements: elements	elements isEmpty ifTrue: [ ^ self ].		^ self edges:		((elements flatCollect: #incomingEdges)			select: [ :anEdge |elements includes: anEdge from])! !!RSEdgeDrivenLayout methodsFor: 'accessing'!toPositions: anArray	toPositions := anArray! !!RSEdgeDrivenLayout methodsFor: 'private'!userDefinedEdges	^ userDefinedEdges! !!RSEdgeDrivenLayout methodsFor: 'accessing'!userDefinedEdges: aCollectionOfEdges	"useful to tell to the layout which edges have to be used for the layout"	userDefinedEdges := aCollectionOfEdges.	! !!RSForceBasedLayout methodsFor: 'algorithm'!accumulate: aQuad 	| centerCharge |	centerCharge := 0@0.	aQuad charge: 0; centerOfCharge: 0@0.	aQuad isLeaf ifFalse: [		aQuad subQuadsDo: [ :aSubQuad |			self accumulate: aSubQuad.			aQuad charge: aQuad charge + aSubQuad charge.			centerCharge := centerCharge + (aSubQuad charge * aSubQuad centerOfCharge)] ].	aQuad soleChild ifNotNil: [ :soleChild |		| k |		aQuad isLeaf ifFalse: [			soleChild translateTo: soleChild position + (random next @ random next) - 0.5 ].		k := alpha * soleChild charge.		aQuad charge: aQuad charge + k.		centerCharge := centerCharge + (k * soleChild position) ].			aQuad charge = 0 ifTrue: [ ^ self ].			aQuad centerOfCharge: centerCharge / aQuad charge.		! !!RSForceBasedLayout methodsFor: 'adding'!addEdges: realEdges	| newMockEdges |	newMockEdges := realEdges collect: [ :e | self newMockEdgeFor: e ].	edges class = Array ifTrue: [ edges := OrderedCollection new ].	edges addAll: newMockEdges.! !!RSForceBasedLayout methodsFor: 'adding'!addNodes: realElements	| newMockElements |	newMockElements := (realElements collect: [ :e | self newMockElementFor: e ]).	nodes class = Array ifTrue: [ nodes := nodes asOrderedCollection ].	nodes addAll: newMockElements.	! !!RSForceBasedLayout methodsFor: 'accessing'!alpha	^ alpha! !!RSForceBasedLayout methodsFor: 'accessing'!alpha: aFloat	alpha := aFloat! !!RSForceBasedLayout methodsFor: 'accessing'!center	^ center! !!RSForceBasedLayout methodsFor: 'accessing'!center: aPoint	"gravity moves elements to that point"	center := aPoint.! !!RSForceBasedLayout methodsFor: 'accessing'!charge	^ charge! !!RSForceBasedLayout methodsFor: 'accessing'!charge: aFloat	"Typically a negative value. E.g., -300"	charge := aFloat! !!RSForceBasedLayout methodsFor: 'accessing'!currentQuadtree	^ quadtree! !!RSForceBasedLayout methodsFor: 'hook'!doExecute: nodeElements	self nodes: nodeElements.	self start.	self shouldUseProgressBar		ifTrue: [ self runLayoutInJob ]		ifFalse: [ self runLayoutSimply ].	alpha := 0.	nodes do: [ :e | translator translateTopLeftOf: e to: e position ]! !!RSForceBasedLayout methodsFor: 'public - configuration'!doNotUseProgressBar	shouldUseProgressBar := false! !!RSForceBasedLayout methodsFor: 'accessing'!friction	^ friction! !!RSForceBasedLayout methodsFor: 'accessing'!friction: aNumber	friction := aNumber! !!RSForceBasedLayout methodsFor: 'accessing'!gravity	^ gravity! !!RSForceBasedLayout methodsFor: 'accessing'!gravity: aNumber	gravity := aNumber! !!RSForceBasedLayout methodsFor: 'accessing'!initialLayout	^ initialLayout! !!RSForceBasedLayout methodsFor: 'accessing'!initialLayout: aLayout	initialLayout := aLayout! !!RSForceBasedLayout methodsFor: 'initialize-release'!initialize	super initialize.	random := Random new.	self		iterations: 0;		edges: #();		nodes: #();		initialLayout: RSGridLayout new;		gravity: 0.1;		friction: 0.9;		theta: 0.8;		strength: 1;		length: 20;		charge: -30;		center: 0@0;		useProgressBar.! !!RSForceBasedLayout methodsFor: 'accessing'!iterations: aNumber	iterations := aNumber! !!RSForceBasedLayout methodsFor: 'accessing'!length	^ length! !!RSForceBasedLayout methodsFor: 'accessing'!length: aFloat	"Specifiy the length of the edges. E.g., 50"	length := aFloat! !!RSForceBasedLayout methodsFor: 'accessing - model'!mockEdgeAt: anEdge	^ edges detect: [ :each | each realEdge == anEdge ]! !!RSForceBasedLayout methodsFor: 'accessing - model'!mockElementAt: realNode	^ nodes detect: [ :each | each realElement == realNode ]! !!RSForceBasedLayout methodsFor: 'private - initialization'!newMockEdgeFor: e	| from to |	from := self mockElementAt: e from.	to := self mockElementAt: e to.	from addWeight.	to addWeight.	^ RSMockEdge new		from: from;		to: to;		strength: strength;		length: length;		realEdge: e;		yourself! !!RSForceBasedLayout methodsFor: 'private - initialization'!newMockElementFor: e	^ RSMockElement new		realElement: e;		charge: charge;		weight: 0;		yourself! !!RSForceBasedLayout methodsFor: 'accessing - model'!nodes	^ nodes! !!RSForceBasedLayout methodsFor: 'accessing - model'!nodes: aCollection	nodes := aCollection! !!RSForceBasedLayout methodsFor: 'algorithm'!repulse: aNode from: aQuad		aQuad soleChild = aNode ifFalse: [		| d |		d := aQuad centerOfCharge - aNode position.		(d closeTo: 0@0) ifFalse: [			| dn p k |			dn := 1 / d r.			p := aNode oldPosition.			aQuad rectangle width * dn < theta				ifTrue: [					k := aQuad charge * dn * dn.					aNode oldPosition: p - (d * k).					^ self ].			(aQuad soleChild notNil and: [ dn < 1e9 ])				ifTrue: [					k := aQuad soleChild charge * dn * dn * alpha.					aNode oldPosition: p - (d * k).] ] ]. 	(aQuad charge closeTo: 0) ifFalse: [ 		aQuad subQuadsDo: [ :aSubQuad | self repulse: aNode from: aSubQuad ] ]! !!RSForceBasedLayout methodsFor: 'hook'!runLayoutIn: job	iterations isZero ifTrue: [ 		[alpha := alpha * 0.99.		alpha > 0.005 ] whileTrue: [ 			self step.			job currentValue: 1 - alpha ] ]	ifFalse: [ 		iterations timesRepeat: [ 			alpha := alpha * 0.99.			self step.		job currentValue: 1 - alpha ] ]! !!RSForceBasedLayout methodsFor: 'hook'!runLayoutInJob	[ :job | 		job			title: 'Laying out elements';			min: 1 - alpha;			max: 1.		self runLayoutIn: job ] asJob run! !!RSForceBasedLayout methodsFor: 'hook'!runLayoutSimply	iterations = 0 ifTrue: [ 		[ alpha := alpha * 0.99.		alpha > 0.005 ] whileTrue: [ self step ] ]	ifFalse: [ 		iterations timesRepeat: [ 			alpha := alpha * 0.99.			self step ] ]! !!RSForceBasedLayout methodsFor: 'testing'!shouldUseProgressBar	^ shouldUseProgressBar! !!RSForceBasedLayout methodsFor: 'hook'!start	"mandatory for animations"	initialLayout on: nodes.	nodes := nodes collect: [ :node | self newMockElementFor: node ].	edges := edges collect: [ :e | self newMockEdgeFor: e ].	alpha :=  0.1.! !!RSForceBasedLayout methodsFor: 'events'!step	nodes ifEmpty: [ ^ self ].	self stepEdgeForces.	self stepGravityForce.	self stepNodeRepulsion.	self stepFriction.	nodes do: #applyToRealElement! !!RSForceBasedLayout methodsFor: 'events'!stepEdgeForces	"Apply forces of edges."	edges do: [ :each | 		| from to fp tp len k pd |		from := each from.		to := each to.		fp := from position.		tp := to position.		pd := tp - fp.		len := tp dist: fp.		(len closeTo: 0) ifFalse: [			len := alpha * (each strength) * (len - (each length)) / len.			pd := pd * len.			k := from weight / (from weight + to weight).			to translateTo: tp - (pd * k).			k := 1 - k.			from translateTo: fp + (pd * k).]	].! !!RSForceBasedLayout methodsFor: 'events'!stepFriction	"Apply friction. This is the last to do in a step, after new positions have been defined."	nodes do: [ :each | 		| current new old |		current := each position.		old := each oldPosition.		new := current - ((old - current) * friction).		each translateTo: new.		each oldPosition: current ]! !!RSForceBasedLayout methodsFor: 'events'!stepGravityForce	"Apply gravity"	| k |	k := alpha * gravity.	(k closeTo: 0) ifTrue: [ ^ self ].	nodes do: [ :each | 		| pos |		pos := each position.		each translateTo: pos + (k * (center - pos)) ]! !!RSForceBasedLayout methodsFor: 'events'!stepNodeRepulsion	"Handle fixed nodes. Do this after all forces in a step were already applied."	quadtree := RSQuadTreeF withAll: nodes.	self accumulate: quadtree.	nodes		do: [ :each | 			each isFixed				ifTrue: [ each translateTo: each fixPosition ]				ifFalse: [ self repulse: each from: quadtree ] ]! !!RSForceBasedLayout methodsFor: 'accessing'!strength: aFloat	"Set the force of attraction for the edges. A high value results in having nodes together.	The default value is 1.0"	strength := aFloat! !!RSForceBasedLayout methodsFor: 'accessing'!theta	^ theta! !!RSForceBasedLayout methodsFor: 'accessing'!theta: aNumber	theta := aNumber! !!RSForceBasedLayout methodsFor: 'public - configuration'!useProgressBar	"Public method. Make the layout use a progress bar"	shouldUseProgressBar := true! !!RSRectangleForceLayout methodsFor: 'accessing'!enclosingForce	^ enclosingForce! !!RSRectangleForceLayout methodsFor: 'accessing'!enclosingForce: anObject	enclosingForce := anObject! !!RSRectangleForceLayout methodsFor: 'accessing'!enclosingRectangle	^ enclosingRectangle! !!RSRectangleForceLayout methodsFor: 'accessing'!enclosingRectangle: aRectangleInCanvasSpaceCoordinates	enclosingRectangle := aRectangleInCanvasSpaceCoordinates! !!RSRectangleForceLayout methodsFor: 'accessing'!enclosingThreshold	^ enclosingThreshold! !!RSRectangleForceLayout methodsFor: 'accessing'!enclosingThreshold: anObject	enclosingThreshold := anObject! !!RSRectangleForceLayout methodsFor: 'events'!initialize	super initialize.	enclosingThreshold := 50.	enclosingForce := 0.3.! !!RSRectangleForceLayout methodsFor: 'events'!step	self stepRectangleForces.	super step.! !!RSRectangleForceLayout methodsFor: 'events'!stepRectangleForces	"Apply a repulsion force to elements that are close to the enclosing rectangle."	| k |	k := enclosingForce * alpha.	(k closeTo: 0) ifTrue: [ ^self ].		nodes do: [ :each |		| eachRect diff |		eachRect := each encompassingRectangle.		"horizontal"		(diff := eachRect left - enclosingRectangle left) < enclosingThreshold ifTrue: [ 			each translateTo: each position + (k * (enclosingThreshold - diff)@0) ].		(diff := enclosingRectangle right - eachRect right) < enclosingThreshold ifTrue: [ 			each translateTo: each position - (k * (enclosingThreshold - diff)@0) ].		"vertical"		(diff := eachRect top - enclosingRectangle top) < enclosingThreshold ifTrue: [ 			each translateTo: each position + (0@(k * (enclosingThreshold - diff))) ].		(diff := enclosingRectangle bottom - eachRect bottom) < enclosingThreshold ifTrue: [ 			each translateTo: each position - (0@(k * (enclosingThreshold - diff))) ].		].! !!RSLayout class methodsFor: 'public'!isAbstract	^ self name = #RSLayout! !!RSLayout class methodsFor: 'public'!isNotAbstract	^ self isAbstract not! !!RSLayout class methodsFor: 'public'!on: aCollection	"main entry point of the class"		"If aCollection is empty, then there is not much to do"	aCollection isEmpty ifTrue: [ ^ aCollection ].	self new applyOn: aCollection.	^ aCollection! !!RSLayout class methodsFor: 'public'!on: elements edges: edges	"To make all the layout polymorphic"		^ self on: elements ! !!RSLayout class methodsFor: 'public'!onElement: aRoassalViewOrRoassalElement	^ self on: aRoassalViewOrRoassalElement elements! !!RSLayout class methodsFor: 'public'!onView: aRoassalView	^ self on: aRoassalView elements! !!RSLayout methodsFor: 'hook'!applyOn: elements	"Return quickly if there is nothing to do"	elements isEmpty ifTrue: [ ^ self ].	self executeOnElements: elements! !!RSLayout methodsFor: 'hook'!doExecute: elements	"Performs the layout"	self subclassResponsibility! !!RSLayout methodsFor: 'hook'!doInitialize: elements	"Method executed before beginning the layout. Useful when the graph to be ordered need to be prepared"	"self announce: (ROLayoutBegin new elements: elements)."! !!RSLayout methodsFor: 'hook'!doPost: elements	"Method executed after performing the layout"! !!RSLayout methodsFor: 'hook'!executeOnElements: elements 	"Execute the layout, myself, on the elements"			self doInitialize: elements.	self doExecute: elements asOrderedCollection.	self doPost: elements.! !!RSLayout methodsFor: 'utils'!fatherOf: aNode	^ aNode propertyAt: #father! !!RSLayout methodsFor: 'utils'!fatherOf: aNode put: aValue	aNode propertyAt: #father put: aValue! !!RSLayout methodsFor: 'initialize-release'!initialize	super initialize.	translator := RSLayoutTranslator default! !!RSLayout methodsFor: 'testing'!isEdgeDrivenLayout	^ false! !!RSLayout methodsFor: 'utils'!layerOf: aNode	^ aNode propertyAt: #layout! !!RSLayout methodsFor: 'utils'!layerOf: aNode put: aValue	aNode propertyAt: #layout put: aValue! !!RSLayout methodsFor: 'utils'!leftContourOf: aNode	^ aNode propertyAt: #leftContour! !!RSLayout methodsFor: 'utils'!leftContourOf: aNode put: aValue	aNode propertyAt: #leftContour put: aValue! !!RSLayout methodsFor: 'utils'!modOf: aNode	^ aNode propertyAt: #mod ifAbsent: [ 0 ]! !!RSLayout methodsFor: 'utils'!modOf: aNode put: aFloat	aNode propertyAt: #mod put: aFloat! !!RSLayout methodsFor: 'hook'!on: elements	self applyOn: elements! !!RSLayout methodsFor: 'hook'!on: elements edges: edges	self applyOn: elements! !!RSLayout methodsFor: 'utils'!pointerOf: aNode	^ aNode propertyAt: #pointer! !!RSLayout methodsFor: 'utils'!pointerOf: aNode put: aValue	^ aNode propertyAt: #pointer put: aValue! !!RSLayout methodsFor: 'utils'!rOf: aNode 	^ aNode propertyAt: #r ifAbsent: [ 0 ]	! !!RSLayout methodsFor: 'utils'!rOf: aNode put: aValue	^ aNode propertyAt: #r put: aValue! !!RSLayout methodsFor: 'utils'!rightContourOf: aNode	^ aNode propertyAt: #rightContour! !!RSLayout methodsFor: 'utils'!rightContourOf: aNode put: aValue	aNode propertyAt: #rightContour put: aValue! !!RSLayout methodsFor: 'events'!step! !!RSLayout methodsFor: 'utils'!thetaOf: aNode	^ aNode propertyAt: #theta ifAbsent: [ ^ 0 ]! !!RSLayout methodsFor: 'utils'!thetaOf: aNode put: aValue	^ aNode propertyAt: #theta put: aValue! !!RSLayout methodsFor: 'accessing'!translator	^ translator! !!RSLayout methodsFor: 'accessing'!translator: aTranslator	translator := aTranslator! !!RSLayout methodsFor: 'hook'!userDefinedEdges: edges	"Do nothing"! !!RSLayout methodsFor: 'utils'!xOf: aNode 	^ aNode propertyAt: #x ifAbsent: [ 0 ]! !!RSLayout methodsFor: 'utils'!xOf: aNode put: aValue	aNode propertyAt: #x put: aValue! !!RSNoLayout methodsFor: 'hook'!doExecute: elements	"Do nothing"! !!RSRectanglePackLayout methodsFor: 'space-calculation'!bestSpaceFor: anElement	| elementsPadedBox suitableSpaces |		elementsPadedBox := anElement encompassingRectangle extendBy: padding * 2.		suitableSpaces := freeSpace select: [ :space |		elementsPadedBox width <= space width and:			[ elementsPadedBox height <= space height ] ].		^ suitableSpaces		fold: [ :best :current |			| bestExt currentExt | 			((currentExt := self extentByInserting: elementsPadedBox into: current) <			(bestExt := self extentByInserting: elementsPadedBox into: best) or: [ 				currentExt = bestExt and: [					current halfPerimeter < best halfPerimeter ] ])						ifTrue: [ current ]						ifFalse: [ best ] ]! !!RSRectanglePackLayout methodsFor: 'accessing'!boundingBox	^ bounds! !!RSRectanglePackLayout methodsFor: 'hook'!doExecute: elements	| sortedElements maxSpace |	bounds := 0@0.		maxSpace := elements		inject: 0@0		into: [ :sum :el | sum + el extent ].			padding := maxSpace / elements size * gap / 2.	maxSpace :=(1 + gap) * maxSpace.		freeSpace := Set with: (0@0 corner: maxSpace).		sortedElements := SortedCollection sortBlock:  [ :larger :smaller |		larger  encompassingRectangle halfPerimeter >		smaller encompassingRectangle halfPerimeter ].	sortedElements addAll: elements.		sortedElements size <= 2 ifTrue: [		^ RSHorizontalLineLayout on: sortedElements ].	self shouldUseProgressBar		ifTrue: [			sortedElements				do: [ :element | self packIn: element ]				displayingProgress: 'Laying out elements' ]		ifFalse: [			sortedElements 				do: [ :element | self packIn: element ] ]! !!RSRectanglePackLayout methodsFor: 'public - configuration'!doNotUseProgressBar	shouldUseProgressBar := false! !!RSRectanglePackLayout methodsFor: 'space-calculation'!extentByInserting: aRectangle into: aSpace	| futureCorner preferredAngleInDegrees |	futureCorner := aSpace origin + aRectangle extent.	 	preferredAngleInDegrees := preferredAngle radiansToDegrees.		^ (((futureCorner max: bounds) degrees - preferredAngleInDegrees) abs / preferredAngleInDegrees + 1) ! !!RSRectanglePackLayout methodsFor: 'accessing'!gap	"Answer the gap between elements, defined as ''percentage'' of average size. For example, 0.2 means 20%."	^ gap! !!RSRectanglePackLayout methodsFor: 'accessing'!gap: aFloat	gap := aFloat! !!RSRectanglePackLayout methodsFor: 'initialize-release'!initialize	super initialize.	self doNotUseProgressBar.	gap := 0.2.	preferredAngle := Float pi / 4. "Squared"! !!RSRectanglePackLayout methodsFor: 'execution'!packIn: anElement	translator translateTopLeftOf: anElement to: (self bestSpaceFor: anElement) origin + padding.	bounds := bounds max: anElement encompassingRectangle bottomRight + padding.		self recalculateFreeSpacesWith: anElement! !!RSRectanglePackLayout methodsFor: 'accessing'!preferredAngle	"Answer the angle (in radians) that the pack algorithm will use to distribute (layout) the elements. For example, setting value of '(2@1) angle', the elements will tend to be distributed horizontally."	^ preferredAngle! !!RSRectanglePackLayout methodsFor: 'accessing'!preferredAngle: angleInRadians	preferredAngle := angleInRadians! !!RSRectanglePackLayout methodsFor: 'space-calculation'!recalculateFreeSpacesWith: anElement	| rectangle |	rectangle := anElement encompassingRectangle expandBy: padding.	freeSpace := freeSpace inject: Set new into: [ :set :space |		 set			addAll: (space areasOverlapingOutside: rectangle); 			yourself ].			"remove subspaces"	freeSpace := freeSpace reject: [ :subspace | 		freeSpace anySatisfy: [ :space |			space ~~ subspace and: [ 				space containsRect: subspace ] ] ]	! !!RSRectanglePackLayout methodsFor: 'testing'!shouldUseProgressBar	^ shouldUseProgressBar! !!RSRectanglePackLayout methodsFor: 'public - configuration'!useProgressBar	"Public method. Make the layout use a progress bar"	shouldUseProgressBar := true! !!RSLayoutBuilder methodsFor: 'public layout'!cell	^ layout := RSCellLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!circle	^ layout := RSCircleLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!cluster	^ layout := RSClusterLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!flow	^ layout := RSFlowLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!grid	^ layout := RSGridLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!horizontal	^ layout := RSHorizontalLineLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!horizontalTree	^ layout := RSHorizontalTreeLayout new.! !!RSLayoutBuilder methodsFor: 'initialization'!initialize	super initialize.	self flow.	! !!RSLayoutBuilder methodsFor: 'accessing'!layout	^ layout ! !!RSLayoutBuilder methodsFor: 'public layout'!none	layout := RSNoLayout new.	^ layout! !!RSLayoutBuilder methodsFor: 'public layout'!on: elements	layout on: elements! !!RSLayoutBuilder methodsFor: 'public layout'!radial	^ layout := RSRadialTreeLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!sugiyama	^ layout := RSSugiyamaLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!tree	^ layout := RSTreeLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!vertical	^ layout := RSVerticalLineLayout new.! !!RSDirectLayoutTranslator class methodsFor: 'testing'!isDefault	^ true! !!RSDirectLayoutTranslator methodsFor: 'hook'!translate: element to: newPosition	element translateTo: newPosition! !!RSLayoutTranslator class methodsFor: 'accessing'!default	"Return the default translator, the one used in the layouts"	defaultTranslator ifNotNil: [ ^ defaultTranslator ].	^ defaultTranslator := self defaultClass new! !!RSLayoutTranslator class methodsFor: 'accessing'!defaultClass	^ self allSubclasses detect: #isDefault! !!RSLayoutTranslator class methodsFor: 'as yet unclassified'!isDefault	^ false! !!RSLayoutTranslator methodsFor: 'hook'!translate: element by: deltaPosition	"Translate of the center of the element by a step"	self translate: element to: element position + deltaPosition! !!RSLayoutTranslator methodsFor: 'hook'!translate: element to: newPosition	"Translate of the center of the element"	self subclassResponsibility ! !!RSLayoutTranslator methodsFor: 'public - translating'!translate: element to: newPosition direction: aDirection	"Translate the bottom left corner of the element"	self translate: element to: newPosition + (element extent / 2 * aDirection)! !!RSLayoutTranslator methodsFor: 'public - translating'!translateBottomLeftOf: element to: newPosition	"Translate the bottom left corner of the element"	self translate: element to: newPosition direction: 1 @ -1.! !!RSLayoutTranslator methodsFor: 'public - translating'!translateCenterLeftOf: element to: newPosition	"Translate the left center of the element to newPosition"	self translate: element to: newPosition direction: 1 @ 0! !!RSLayoutTranslator methodsFor: 'public - translating'!translateTopLeftOf: element to: newPosition	"Translate the top right corner of the element"	self translate: element to: newPosition direction: 1 @ 1! !!RSLocation methodsFor: 'public - positioning shorcuts'!above 	self top; outer.! !!RSLocation methodsFor: 'public - positioning shorcuts'!below 	self bottom; outer! !!RSLocation methodsFor: 'public - modifiers'!border	orientation := 0! !!RSLocation methodsFor: 'public - positioning'!bottom	"Locate the shape at the bottom of the base shape.For example:```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	bottom;	outer;	right;	move: redShape on: baseShape.c```	"	fixedY := #bottom.	direction := direction x @ -1.! !!RSLocation methodsFor: 'public - positioning'!center	fixedX := [ :rec | rec floatCenter x ].	direction := 0 @ direction y! !!RSLocation methodsFor: 'private'!computePosition: movableShape on: fixedShape	^ movableShape extent / 2 * orientation * direction + (self parentPosition: fixedShape) + offset.! !!RSLocation methodsFor: 'initialization'!initialize	super initialize.	direction := 0 @ 0.	self		offset: 0;		inner;		middle;		center! !!RSLocation methodsFor: 'public - modifiers'!inner	orientation := 1! !!RSLocation methodsFor: 'public - positioning'!left	"Locate the shape on the left of the base shape.For example:```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	above;	left;	move: redShape on: baseShape.c```"	fixedX := #left.	direction := 1@ direction y! !!RSLocation methodsFor: 'public - positioning'!middle	"Locate the shape in the middle of the base shape.For example:```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	middle;	above;	move: redShape on: baseShape.c```	"	fixedY := [ :r | r floatCenter y ].	direction := direction x @ 0! !!RSLocation methodsFor: 'public - executing'!move: movableShape on: baseShape	movableShape translateTo: (self computePosition: movableShape on: baseShape).! !!RSLocation methodsFor: 'public - modifiers'!offset	^ offset! !!RSLocation methodsFor: 'public - modifiers'!offset: aNumber	"Let an offset between the positioned shape and the base shape.	For example```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	bottom;	outer;	right;	offset: 20;	move: redShape on: baseShape.c```"	offset := aNumber asPoint! !!RSLocation methodsFor: 'public - modifiers'!outer	orientation := -1! !!RSLocation methodsFor: 'private'!parentPosition: fixedShape	| rec |	rec := fixedShape.	rec isRectangle ifFalse:  [ rec := rec encompassingRectangle ] .	^ (fixedX value: rec)@ (fixedY value: rec).! !!RSLocation methodsFor: 'public - positioning'!right	"Locate the shape on the right of the base shape.For example:```Smalltalkc := RSCanvas new.g := RSGroup new.g add: (RSLabel new text: 'Base shape').baseShape := g asShape adjustToChildren.baseShape color: #lightBlue.baseShape @ RSDraggable.c add: baseShape.redShape := RSBox new extent: 60 @ 30; color: #red.c add: redShape.RSLocation new	above;	right;	move: redShape on: baseShape.c```"	fixedX := #right.	direction := -1 @ direction y.! !!RSLocation methodsFor: 'public - executing'!stick: movableShape on: baseShape	| block |	block := [ self move: movableShape on: baseShape ].	block value.	baseShape 		when: RSExtentChangedEvent do: block;		when: RSPositionChangedEvent do: block.! !!RSLocation methodsFor: 'public - positioning'!top	fixedY := #top.	direction := direction x @ 1! !!RSMockEdge methodsFor: 'accessing'!from	^ from! !!RSMockEdge methodsFor: 'accessing'!from: aMockElement	from := aMockElement! !!RSMockEdge methodsFor: 'accessing'!length	^ length! !!RSMockEdge methodsFor: 'accessing'!length: aNumber	length := aNumber! !!RSMockEdge methodsFor: 'accessing'!realEdge	^ realEdge! !!RSMockEdge methodsFor: 'accessing'!realEdge: anObject	realEdge := anObject! !!RSMockEdge methodsFor: 'accessing'!strength 	^ strength! !!RSMockEdge methodsFor: 'accessing'!strength: aNumber	strength := aNumber! !!RSMockEdge methodsFor: 'accessing'!to	^ to! !!RSMockEdge methodsFor: 'accessing'!to: aMockElement	to := aMockElement! !!RSMockElement methodsFor: 'actions'!addWeight	weight := weight + 1! !!RSMockElement methodsFor: 'actions'!applyToRealElement	isFixed ifTrue: [ ^ self ].	realElement translateTo: position ! !!RSMockElement methodsFor: 'accessing'!canvas	^ realElement canvas! !!RSMockElement methodsFor: 'accessing'!charge	^ charge! !!RSMockElement methodsFor: 'accessing'!charge: aNum	charge := aNum! !!RSMockElement methodsFor: 'accessing'!encompassingRectangle 	^ realElement encompassingRectangle! !!RSMockElement methodsFor: 'accessing'!extent	^ realElement extent! !!RSMockElement methodsFor: 'accessing'!fixPosition	^ fixPosition! !!RSMockElement methodsFor: 'accessing'!fixPosition: aPoint	fixPosition := aPoint! !!RSMockElement methodsFor: 'accessing'!height	^ realElement height! !!RSMockElement methodsFor: 'actions'!initialize	super initialize.	isFixed := false.! !!RSMockElement methodsFor: 'accessing'!isFixed	^ isFixed ! !!RSMockElement methodsFor: 'accessing'!isFixed: aBool	isFixed := aBool! !!RSMockElement methodsFor: 'accessing'!oldPosition	^ oldPosition! !!RSMockElement methodsFor: 'accessing'!oldPosition: aPoint	oldPosition := aPoint! !!RSMockElement methodsFor: 'accessing'!position	^ position! !!RSMockElement methodsFor: 'accessing'!realElement	^ realElement! !!RSMockElement methodsFor: 'accessing'!realElement: rtElement	realElement := rtElement.	position := rtElement position.	self oldPosition: position.! !!RSMockElement methodsFor: 'actions'!translateTo: aPosition	position := aPosition! !!RSMockElement methodsFor: 'accessing'!weight	^ weight! !!RSMockElement methodsFor: 'accessing'!weight: aNumber	weight := aNumber! !!RSMockElement methodsFor: 'accessing'!width	^ realElement width! !!RSQuadTreeF class methodsFor: 'public'!withAll: aNodeCollection	^ self		withAll: aNodeCollection		rectangle: (Rectangle encompassing: (aNodeCollection collect: #position))! !!RSQuadTreeF class methodsFor: 'public'!withAll: aNodeCollection rectangle: rectangle		| root extent |	extent := rectangle extent.	(extent x closeTo: extent y) ifTrue: [ 		root := self new.		root rectangle: rectangle.		aNodeCollection do: [ :e | root add: e ].		^ root ].		^ extent x > extent y		ifTrue: [ 			self 				withAll: aNodeCollection				rectangle: (rectangle origin corner: rectangle corner x @ (extent x + rectangle origin y)) ]		ifFalse: [			self 				withAll: aNodeCollection				rectangle: (rectangle origin corner: (extent y + rectangle origin x) @ rectangle corner y) ]! !!RSQuadTreeF methodsFor: 'adding'!add: aNode	leaf		ifTrue: [			soleChild isNil				ifTrue: [ soleChild := aNode ]				ifFalse: [					(soleChild position closeTo: aNode position)						ifTrue: [ self addChild: aNode ]						ifFalse: [							| firstChild |							firstChild := soleChild.							soleChild := nil.							self								addChild: aNode;								addChild: firstChild ] ] ]		ifFalse: [ self addChild: aNode ]! !!RSQuadTreeF methodsFor: 'adding'!addChild: aNode	| s origin corner |	leaf := false.	s := rectangle floatCenter.	origin := rectangle origin.	corner := rectangle corner.	aNode position x < s x		ifTrue: [			aNode position y < s y				ifTrue: [					northWestQuad ifNil: [ 						northWestQuad := RSQuadTreeF new							rectangle: (origin corner: s);							yourself ].					northWestQuad add: aNode ]				ifFalse: [					southWestQuad ifNil: [ 						southWestQuad := RSQuadTreeF new							rectangle: ((origin x @ s y ) corner: (s x @ corner y));							yourself ].					southWestQuad add: aNode ] ]		ifFalse: [			aNode position y < s y				ifTrue: [					northEastQuad ifNil: [						northEastQuad := RSQuadTreeF new							rectangle: ((s x @ origin y) corner: (corner x @ s y));							yourself ].					northEastQuad add: aNode ]				ifFalse: [					southEastQuad ifNil: [ 						southEastQuad := RSQuadTreeF new							rectangle: (s corner: corner);							yourself ].					southEastQuad add: aNode ] ]! !!RSQuadTreeF methodsFor: 'accessing'!centerOfCharge	^ centerOfCharge! !!RSQuadTreeF methodsFor: 'accessing'!centerOfCharge: aPoint	centerOfCharge := aPoint! !!RSQuadTreeF methodsFor: 'accessing'!charge	^ charge! !!RSQuadTreeF methodsFor: 'accessing'!charge: anObject	charge := anObject! !!RSQuadTreeF methodsFor: 'initialize-release'!initialize 	super initialize.		leaf := true.! !!RSQuadTreeF methodsFor: 'testing'!isLeaf	^ leaf! !!RSQuadTreeF methodsFor: 'accessing'!rectangle	^ rectangle! !!RSQuadTreeF methodsFor: 'accessing'!rectangle: aRectangle 	rectangle := aRectangle! !!RSQuadTreeF methodsFor: 'accessing'!soleChild	^ soleChild! !!RSQuadTreeF methodsFor: 'accessing'!subQuadsDo: aBlockClosure  northWestQuad ifNotNil: aBlockClosure.  northEastQuad ifNotNil: aBlockClosure.  southWestQuad ifNotNil: aBlockClosure.  southEastQuad ifNotNil: aBlockClosure.! !!Collection methodsFor: '*Roassal3-Layouts'!maxValue: aBlock	^ self inject: (aBlock value: self anyOne) into: [ :max :each | max max: (aBlock value: each) ]! !!RSForceLayoutStepping methodsFor: 'hooks'!addEventsTo: shape	| mock |	shape 		when: RSMouseDragStart do: [ :evt | 			mock := layout mockElementAt: evt shape.			mock isFixed: true.			self startForceAnimation: evt canvas ];		when: RSMouseDragging do: [ :evt |			mock fixPosition: evt shape position ];		when: RSMouseDragEnd do:[:evt | 			mock isFixed: false.			mock := nil.			self startSimpleAnimation: evt canvas ].! !!RSForceLayoutStepping methodsFor: 'accessing'!alphaRange	^ #(0 0.1)! !!RSForceLayoutStepping methodsFor: 'hooks'!configureLayoutOn: aCanvas	self hasDraggable ifTrue: [		aCanvas nodes @ (RSDraggableForce new layout: self layout)].	self layout		nodes: aCanvas nodes;		edges: aCanvas edges;		start.! !!RSForceLayoutStepping methodsFor: 'configuration'!draggable	hasDraggable := true! !!RSForceLayoutStepping methodsFor: 'testing'!hasDraggable	^ hasDraggable! !!RSForceLayoutStepping methodsFor: 'initialization'!initialize	super initialize.	self draggable.! !!RSForceLayoutStepping methodsFor: 'accessing'!layout	^ layout ifNil: [ layout := RSForceBasedLayout new ]! !!RSForceLayoutStepping methodsFor: 'accessing'!layout: aRSForceBasedLayout	layout := aRSForceBasedLayout! !!RSForceLayoutStepping methodsFor: 'configuration'!noDraggable	hasDraggable := false.! !!RSForceLayoutStepping methodsFor: 'hooks'!onShape: aCanvas	self configureLayoutOn: aCanvas.	aCanvas nodes do: [ :s | self addEventsTo: s ].	self startFirstAnimation: aCanvas.	aCanvas newAnimation onStepDo: [:t| aCanvas zoomToFit ].! !!RSForceLayoutStepping methodsFor: 'animation'!startFirstAnimation: aCanvas	| alpha |	animation ifNotNil: #stop.	alpha := 1.	animation := aCanvas newAnimation		repeat;		onStepDo: [ :t | layout alpha: alpha; step.			alpha := alpha * 0.99.			alpha < 0.005 ifTrue: [ animation stop ] ];		yourself! !!RSForceLayoutStepping methodsFor: 'animation'!startForceAnimation: aView	animation ifNotNil: #stop.	animation := aView animationFrom: {		"Start smoothly"		aView transitionAnimation			easing: RSEasing cubicOut;			duration: 500 milliSeconds;			range: self alphaRange;			onStepDo: [ :t | layout alpha: t; step ].		"Continue on max alpha undefinitely"		aView transitionAnimation			repeat;			onStepDo: [ :t | layout step ] }.! !!RSForceLayoutStepping methodsFor: 'animation'!startSimpleAnimation: aCanvas	animation ifNotNil: #stop.	animation := aCanvas newAnimation 		easing: RSEasing cubicInOut;		range: self alphaRange reversed;		duration: 2 seconds;		onStepDo: [ :t | layout alpha: t; step  ];		yourself! !!RSHierarchyPacker methodsFor: 'private'!fill: group with: aShape	group add: aShape.	aShape outgoingEdges do: [ :ed | 		self fill: group with: ed to ].! !!RSHierarchyPacker methodsFor: 'private'!initialize	super initialize.		rectanglePackLayout := RSRectanglePackLayout new		doNotUseProgressBar;		yourself.! !!RSHierarchyPacker methodsFor: 'private'!onShape: aCanvas	| layout connectedAsGroups connected isolated all |	layout := RSTreeLayout new		edges: aCanvas edges.	connectedAsGroups := aCanvas nodes.	connected := connectedAsGroups select: #hasEdges.	isolated := connectedAsGroups reject: #hasEdges.	connectedAsGroups := (layout rootNodesFor: connected) collect: [ :e | 		| group |		group :=  RSGroup new.		self fill: group with: e.		group ]. 		all := connectedAsGroups, isolated.	aCanvas when: RSExtentChangedEvent do: [		rectanglePackLayout			preferredAngle: aCanvas extent angle;			on: all.		aCanvas zoomToFit; signalUpdate ].! !!RSHierarchyPacker methodsFor: 'accessing'!rectanglePackLayout	^ rectanglePackLayout! !!RSHierarchyPacker methodsFor: 'accessing'!rectanglePackLayout: anObject	rectanglePackLayout := anObject! !!Point class methodsFor: '*Roassal3-Layouts'!r: radius theta: angle	^ (radius * angle cos) @ (radius * angle sin)! !!RSSortBlock methodsFor: 'accessing'!fixTemps! !!RSSortBlock methodsFor: 'accessing'!value: assocA value: assocB	"Return false if assocA is bigger than assocB.	Return true if assocA is smaller than assocB.	-> Inverted list with biggest elements first"		| a b offset |	offset := 0.	a := assocA value.	b := assocB value.	[(a size > offset)		and: [(b size > offset) and: [(a at: a size - offset) = (b at: b size - offset)]]]		whileTrue: [offset := offset + 1].	"Corner cases"	(a size = b size and: [b size = offset]) ifTrue: [ ^ true ].	"[3, 3], [3, 3]"	(a size > offset and: [b size = offset]) ifTrue: [ ^ true ].	"[3, 3, 6], [3, 3]"	(b size > offset and: [a size = offset]) ifTrue: [ ^ false ].	"[3, 3], [3, 3, 6]"	"Normal case"	^(a at: a size - offset) >= (b at: b size - offset)! !!SequenceableCollection methodsFor: '*Roassal3-Layouts'!rsSwapElement: u withElement: v	| index1 index2 |	index1 := self indexOf: u.	index2 := self indexOf: v.	self at: index2 put: u.	self at: index1 put: v.! !"Roassal3-Layouts"!!RSColorPalette commentStamp: '' prior: 0!Each ColorPalette is a set of beautiful color schemes in a context for a specific purpose.Each palette contains several color schemes. Each scheme can be selected in different numbers of colors: 3 or 5 or 11 (depends on each scheme).We have three palettes:- Qualitative: helps to distinguish different classes of data. - Sequential: useful for showing graduable data with a very light "low color" increasing darkness to "high color".- Diverging: it contains color scales with diverging colors on the extremes and transition colors from one extreme to the other. More detailed information is on it class comments.To see the palettes:RSShapeBasicExamples new example34PaletteVisualization open---Copyright:All colors, palettes and schemes are from www.ColorBrewer.org by Cynthia A. Brewer, Geography, Pennsylvania State University.Code by Cynthia is under the Apache License 2.0 (https://github.com/axismaps/colorbrewer/blob/master/LICENCE.txt)Roassal3 is distributed under the MIT License, which is compatible with Apache License 2.0 !!RSDivergingColorPalette commentStamp: '' prior: 0!Diverging schemes put equal emphasis on mid-range critical values and extremes at both ends of the data range. The critical class or break in the middle of the legend is emphasized with light colors and low and high extremes are emphasized with dark colors that have contrasting hues.Check it out by executing:RSShapeBasicExamples new example34PaletteVisualization openMore info:http://colorbrewer2.org/learnmore/schemes_full.html#diverging ---Copyright:All colors, palettes and schemes are from www.ColorBrewer.org by Cynthia A. Brewer, Geography, Pennsylvania State University.Code by Cynthia is under the Apache License 2.0 (https://github.com/axismaps/colorbrewer/blob/master/LICENCE.txt)Roassal3 is distributed under the MIT License, which is compatible with Apache License 2.0 !!RSQualitativeColorPalette commentStamp: '' prior: 0!Qualitative schemes do not imply magnitude differences between legend classes, and hues are used to create the primary visual differences between classes. Qualitative schemes are best suited to representing nominal or categorical data.More info: http://colorbrewer2.org/learnmore/schemes_full.html#qualitative---Copyright:All colors, palettes and schemes are from www.ColorBrewer.org by Cynthia A. Brewer, Geography, Pennsylvania State University.Code by Cynthia is under the Apache License 2.0 (https://github.com/axismaps/colorbrewer/blob/master/LICENCE.txt)Roassal3 is distributed under the MIT License, which is compatible with Apache License 2.0 FalutUI1 color scheme come from: http://flatuicolors.com/!!RSSequentialColorPalette commentStamp: '' prior: 0!Sequential schemes are suited to ordered data that progress from low to high. Lightness steps dominate the look of these schemes, with light colors for low data values to dark colors for high data values.More info: http://colorbrewer2.org/learnmore/schemes_full.html---Copyright:All colors, palettes and schemes are from www.ColorBrewer.org by Cynthia A. Brewer, Geography, Pennsylvania State University.Code by Cynthia is under the Apache License 2.0 (https://github.com/axismaps/colorbrewer/blob/master/LICENCE.txt)Roassal3 is distributed under the MIT License, which is compatible with Apache License 2.0 !!RSGradientPalette commentStamp: '' prior: 0!I have instances of linear gradient paintsI use the colors from this website https://webgradients.com/!!RSColorPalette class methodsFor: 'instance creation'!diverging	^ RSDivergingColorPalette new! !!RSColorPalette class methodsFor: 'as yet unclassified'!paletteName	^ self subclassResponsibility! !!RSColorPalette class methodsFor: 'instance creation'!qualitative	^ RSQualitativeColorPalette new! !!RSColorPalette class methodsFor: 'instance creation'!sequential	^ RSSequentialColorPalette new! !!RSColorPalette methodsFor: 'instance creation'!fromTriplet: array	^ NSScale ordinal		range: (array collect: [ :arr | 			Color				r: arr first				g: arr second				b: arr third				range: 255 ]);		yourself! !!RSDivergingColorPalette class methodsFor: 'as yet unclassified'!paletteName	^ #diverging! !!RSDivergingColorPalette methodsFor: 'palette'!brbg10	^ self fromTriplet: #(#(84 48 5) #(140 81 10) #(191 129 45) #(223 194 125) #(246 232 195) #(199 234 229) #(128 205 193) #(53 151 143) #(1 102 94) #(0 60 48))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg11	^ self fromTriplet: #(#(84 48 5) #(140 81 10) #(191 129 45) #(223 194 125) #(246 232 195) #(245 245 245) #(199 234 229) #(128 205 193) #(53 151 143) #(1 102 94) #(0 60 48))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg3	^ self fromTriplet: #(#(216 179 101) #(245 245 245) #(90 180 172))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg4	^ self fromTriplet: #(#(166 97 26) #(223 194 125) #(128 205 193) #(1 133 113))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg5	^ self fromTriplet: #(#(166 97 26) #(223 194 125) #(245 245 245) #(128 205 193) #(1 133 113))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg6	^ self fromTriplet: #(#(140 81 10) #(216 179 101) #(246 232 195) #(199 234 229) #(90 180 172) #(1 102 94))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg7	^ self fromTriplet: #(#(140 81 10) #(216 179 101) #(246 232 195) #(245 245 245) #(199 234 229) #(90 180 172) #(1 102 94))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg8	^ self fromTriplet: #(#(140 81 10) #(191 129 45) #(223 194 125) #(246 232 195) #(199 234 229) #(128 205 193) #(53 151 143) #(1 102 94))! !!RSDivergingColorPalette methodsFor: 'palette'!brbg9	^ self fromTriplet: #(#(140 81 10) #(191 129 45) #(223 194 125) #(246 232 195) #(245 245 245) #(199 234 229) #(128 205 193) #(53 151 143) #(1 102 94))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg10	^ self fromTriplet: #(#(142 1 82) #(197 27 125) #(222 119 174) #(241 182 218) #(253 224 239) #(230 245 208) #(184 225 134) #(127 188 65) #(77 146 33) #(39 100 25))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg11	^ self fromTriplet: #(#(142 1 82) #(197 27 125) #(222 119 174) #(241 182 218) #(253 224 239) #(247 247 247) #(230 245 208) #(184 225 134) #(127 188 65) #(77 146 33) #(39 100 25))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg3	^ self fromTriplet: #(#(233 163 201) #(247 247 247) #(161 215 106))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg4	^ self fromTriplet: #(#(208 28 139) #(241 182 218) #(184 225 134) #(77 172 38))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg5	^ self fromTriplet: #(#(208 28 139) #(241 182 218) #(247 247 247) #(184 225 134) #(77 172 38))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg6	^ self fromTriplet: #(#(197 27 125) #(233 163 201) #(253 224 239) #(230 245 208) #(161 215 106) #(77 146 33))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg7	^ self fromTriplet: #(#(197 27 125) #(233 163 201) #(253 224 239) #(247 247 247) #(230 245 208) #(161 215 106) #(77 146 33))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg8	^ self fromTriplet: #(#(197 27 125) #(222 119 174) #(241 182 218) #(253 224 239) #(230 245 208) #(184 225 134) #(127 188 65) #(77 146 33))! !!RSDivergingColorPalette methodsFor: 'palette'!piyg9	^ self fromTriplet: #(#(197 27 125) #(222 119 174) #(241 182 218) #(253 224 239) #(247 247 247) #(230 245 208) #(184 225 134) #(127 188 65) #(77 146 33))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn10	^ self fromTriplet: #(#(64 0 75) #(118 42 131) #(153 112 171) #(194 165 207) #(231 212 232) #(217 240 211) #(166 219 160) #(90 174 97) #(27 120 55) #(0 68 27))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn11	^ self fromTriplet: #(#(64 0 75) #(118 42 131) #(153 112 171) #(194 165 207) #(231 212 232) #(247 247 247) #(217 240 211) #(166 219 160) #(90 174 97) #(27 120 55) #(0 68 27))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn3	^ self fromTriplet: #(#(175 141 195) #(247 247 247) #(127 191 123))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn4	^ self fromTriplet: #(#(123 50 148) #(194 165 207) #(166 219 160) #(0 136 55))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn5	^ self fromTriplet: #(#(123 50 148) #(194 165 207) #(247 247 247) #(166 219 160) #(0 136 55))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn6	^ self fromTriplet: #(#(118 42 131) #(175 141 195) #(231 212 232) #(217 240 211) #(127 191 123) #(27 120 55))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn7	^ self fromTriplet: #(#(118 42 131) #(175 141 195) #(231 212 232) #(247 247 247) #(217 240 211) #(127 191 123) #(27 120 55))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn8	^ self fromTriplet: #(#(118 42 131) #(153 112 171) #(194 165 207) #(231 212 232) #(217 240 211) #(166 219 160) #(90 174 97) #(27 120 55))! !!RSDivergingColorPalette methodsFor: 'palette'!prgn9	^ self fromTriplet: #(#(118 42 131) #(153 112 171) #(194 165 207) #(231 212 232) #(247 247 247) #(217 240 211) #(166 219 160) #(90 174 97) #(27 120 55))! !!RSDivergingColorPalette methodsFor: 'palette'!puor10	^ self fromTriplet: #(#(127 59 8) #(179 88 6) #(224 130 20) #(253 184 99) #(254 224 182) #(216 218 235) #(178 171 210) #(128 115 172) #(84 39 136) #(45 0 75))! !!RSDivergingColorPalette methodsFor: 'palette'!puor11	^ self fromTriplet: #(#(127 59 8) #(179 88 6) #(224 130 20) #(253 184 99) #(254 224 182) #(247 247 247) #(216 218 235) #(178 171 210) #(128 115 172) #(84 39 136) #(45 0 75))! !!RSDivergingColorPalette methodsFor: 'palette'!puor3	^ self fromTriplet: #(#(241 163 64) #(247 247 247) #(153 142 195))! !!RSDivergingColorPalette methodsFor: 'palette'!puor4	^ self fromTriplet: #(#(230 97 1) #(253 184 99) #(178 171 210) #(94 60 153))! !!RSDivergingColorPalette methodsFor: 'palette'!puor5	^ self fromTriplet: #(#(230 97 1) #(253 184 99) #(247 247 247) #(178 171 210) #(94 60 153))! !!RSDivergingColorPalette methodsFor: 'palette'!puor6	^ self fromTriplet: #(#(179 88 6) #(241 163 64) #(254 224 182) #(216 218 235) #(153 142 195) #(84 39 136))! !!RSDivergingColorPalette methodsFor: 'palette'!puor7	^ self fromTriplet: #(#(179 88 6) #(241 163 64) #(254 224 182) #(247 247 247) #(216 218 235) #(153 142 195) #(84 39 136))! !!RSDivergingColorPalette methodsFor: 'palette'!puor8	^ self fromTriplet: #(#(179 88 6) #(224 130 20) #(253 184 99) #(254 224 182) #(216 218 235) #(178 171 210) #(128 115 172) #(84 39 136))! !!RSDivergingColorPalette methodsFor: 'palette'!puor9	^ self fromTriplet: #(#(179 88 6) #(224 130 20) #(253 184 99) #(254 224 182) #(247 247 247) #(216 218 235) #(178 171 210) #(128 115 172) #(84 39 136))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu10	^ self fromTriplet: #(#(103 0 31) #(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(209 229 240) #(146 197 222) #(67 147 195) #(33 102 172) #(5 48 97))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu11	^ self fromTriplet: #(#(103 0 31) #(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(247 247 247) #(209 229 240) #(146 197 222) #(67 147 195) #(33 102 172) #(5 48 97))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu3	^ self fromTriplet: #(#(239 138 98) #(247 247 247) #(103 169 207))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu4	^ self fromTriplet: #(#(202 0 32) #(244 165 130) #(146 197 222) #(5 113 176))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu5	^ self fromTriplet: #(#(202 0 32) #(244 165 130) #(247 247 247) #(146 197 222) #(5 113 176))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu6	^ self fromTriplet: #(#(178 24 43) #(239 138 98) #(253 219 199) #(209 229 240) #(103 169 207) #(33 102 172))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu7	^ self fromTriplet: #(#(178 24 43) #(239 138 98) #(253 219 199) #(247 247 247) #(209 229 240) #(103 169 207) #(33 102 172))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu8	^ self fromTriplet: #(#(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(209 229 240) #(146 197 222) #(67 147 195) #(33 102 172))! !!RSDivergingColorPalette methodsFor: 'palette'!rdbu9	^ self fromTriplet: #(#(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(247 247 247) #(209 229 240) #(146 197 222) #(67 147 195) #(33 102 172))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy10	^ self fromTriplet: #(#(103 0 31) #(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(224 224 224) #(186 186 186) #(135 135 135) #(77 77 77) #(26 26 26))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy11	^ self fromTriplet: #(#(103 0 31) #(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(255 255 255) #(224 224 224) #(186 186 186) #(135 135 135) #(77 77 77) #(26 26 26))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy3	^ self fromTriplet: #(#(239 138 98) #(255 255 255) #(153 153 153))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy4	^ self fromTriplet: #(#(202 0 32) #(244 165 130) #(186 186 186) #(64 64 64))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy5	^ self fromTriplet: #(#(202 0 32) #(244 165 130) #(255 255 255) #(186 186 186) #(64 64 64))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy6	^ self fromTriplet: #(#(178 24 43) #(239 138 98) #(253 219 199) #(224 224 224) #(153 153 153) #(77 77 77))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy7	^ self fromTriplet: #(#(178 24 43) #(239 138 98) #(253 219 199) #(255 255 255) #(224 224 224) #(153 153 153) #(77 77 77))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy8	^ self fromTriplet: #(#(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(224 224 224) #(186 186 186) #(135 135 135) #(77 77 77))! !!RSDivergingColorPalette methodsFor: 'palette'!rdgy9	^ self fromTriplet: #(#(178 24 43) #(214 96 77) #(244 165 130) #(253 219 199) #(255 255 255) #(224 224 224) #(186 186 186) #(135 135 135) #(77 77 77))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu10	^ self fromTriplet: #(#(165 0 38) #(215 48 39) #(244 109 67) #(253 174 97) #(254 224 144) #(224 243 248) #(171 217 233) #(116 173 209) #(69 117 180) #(49 54 149))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu11	^ self fromTriplet: #(#(165 0 38) #(215 48 39) #(244 109 67) #(253 174 97) #(254 224 144) #(255 255 191) #(224 243 248) #(171 217 233) #(116 173 209) #(69 117 180) #(49 54 149))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu3	^ self fromTriplet: #(#(252 141 89) #(255 255 191) #(145 191 219))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu4	^ self fromTriplet: #(#(215 25 28) #(253 174 97) #(171 217 233) #(44 123 182))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu5	^ self fromTriplet: #(#(215 25 28) #(253 174 97) #(255 255 191) #(171 217 233) #(44 123 182))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu6	^ self fromTriplet: #(#(215 48 39) #(252 141 89) #(254 224 144) #(224 243 248) #(145 191 219) #(69 117 180))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu7	^ self fromTriplet: #(#(215 48 39) #(252 141 89) #(254 224 144) #(255 255 191) #(224 243 248) #(145 191 219) #(69 117 180))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu8	^ self fromTriplet: #(#(215 48 39) #(244 109 67) #(253 174 97) #(254 224 144) #(224 243 248) #(171 217 233) #(116 173 209) #(69 117 180))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylbu9	^ self fromTriplet: #(#(215 48 39) #(244 109 67) #(253 174 97) #(254 224 144) #(255 255 191) #(224 243 248) #(171 217 233) #(116 173 209) #(69 117 180))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn10	^ self fromTriplet: #(#(165 0 38) #(215 48 39) #(244 109 67) #(253 174 97) #(254 224 139) #(217 239 139) #(166 217 106) #(102 189 99) #(26 152 80) #(0 104 55))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn11	^ self fromTriplet: #(#(165 0 38) #(215 48 39) #(244 109 67) #(253 174 97) #(254 224 139) #(255 255 191) #(217 239 139) #(166 217 106) #(102 189 99) #(26 152 80) #(0 104 55))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn3	^ self fromTriplet: #(#(252 141 89) #(255 255 191) #(145 207 96))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn4	^ self fromTriplet: #(#(215 25 28) #(253 174 97) #(166 217 106) #(26 150 65))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn5	^ self fromTriplet: #(#(215 25 28) #(253 174 97) #(255 255 191) #(166 217 106) #(26 150 65))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn6	^ self fromTriplet: #(#(215 48 39) #(252 141 89) #(254 224 139) #(217 239 139) #(145 207 96) #(26 152 80))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn7	^ self fromTriplet: #(#(215 48 39) #(252 141 89) #(254 224 139) #(255 255 191) #(217 239 139) #(145 207 96) #(26 152 80))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn8	^ self fromTriplet: #(#(215 48 39) #(244 109 67) #(253 174 97) #(254 224 139) #(217 239 139) #(166 217 106) #(102 189 99) #(26 152 80))! !!RSDivergingColorPalette methodsFor: 'palette'!rdylgn9	^ self fromTriplet: #(#(215 48 39) #(244 109 67) #(253 174 97) #(254 224 139) #(255 255 191) #(217 239 139) #(166 217 106) #(102 189 99) #(26 152 80))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral10	^ self fromTriplet: #(#(158 1 66) #(213 62 79) #(244 109 67) #(253 174 97) #(254 224 139) #(230 245 152) #(171 221 164) #(102 194 165) #(50 136 189) #(94 79 162))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral11	^ self fromTriplet: #(#(158 1 66) #(213 62 79) #(244 109 67) #(253 174 97) #(254 224 139) #(255 255 191) #(230 245 152) #(171 221 164) #(102 194 165) #(50 136 189) #(94 79 162))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral3	^ self fromTriplet: #(#(252 141 89) #(255 255 191) #(153 213 148))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral4	^ self fromTriplet: #(#(215 25 28) #(253 174 97) #(171 221 164) #(43 131 186))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral5	^ self fromTriplet: #(#(215 25 28) #(253 174 97) #(255 255 191) #(171 221 164) #(43 131 186))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral6	^ self fromTriplet: #(#(213 62 79) #(252 141 89) #(254 224 139) #(230 245 152) #(153 213 148) #(50 136 189))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral7	^ self fromTriplet: #(#(213 62 79) #(252 141 89) #(254 224 139) #(255 255 191) #(230 245 152) #(153 213 148) #(50 136 189))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral8	^ self fromTriplet: #(#(213 62 79) #(244 109 67) #(253 174 97) #(254 224 139) #(230 245 152) #(171 221 164) #(102 194 165) #(50 136 189))! !!RSDivergingColorPalette methodsFor: 'palette'!spectral9	^ self fromTriplet: #(#(213 62 79) #(244 109 67) #(253 174 97) #(254 224 139) #(255 255 191) #(230 245 152) #(171 221 164) #(102 194 165) #(50 136 189))! !!RSQualitativeColorPalette class methodsFor: 'as yet unclassified'!paletteName	^ #qualitative! !!RSQualitativeColorPalette methodsFor: 'palette'!accent3	^ self fromTriplet: #(#(127 201 127) #(190 174 212) #(253 192 134))! !!RSQualitativeColorPalette methodsFor: 'palette'!accent4	^ self fromTriplet: #(#(127 201 127) #(190 174 212) #(253 192 134) #(255 255 153))! !!RSQualitativeColorPalette methodsFor: 'palette'!accent5	^ self fromTriplet: #(#(127 201 127) #(190 174 212) #(253 192 134) #(255 255 153) #(56 108 176))! !!RSQualitativeColorPalette methodsFor: 'palette'!accent6	^ self fromTriplet: #(#(127 201 127) #(190 174 212) #(253 192 134) #(255 255 153) #(56 108 176) #(240 2 127))! !!RSQualitativeColorPalette methodsFor: 'palette'!accent7	^ self fromTriplet: #(#(127 201 127) #(190 174 212) #(253 192 134) #(255 255 153) #(56 108 176) #(240 2 127) #(191 91 23))! !!RSQualitativeColorPalette methodsFor: 'palette'!accent8	^ self fromTriplet: #(#(127 201 127) #(190 174 212) #(253 192 134) #(255 255 153) #(56 108 176) #(240 2 127) #(191 91 23) #(102 102 102))! !!RSQualitativeColorPalette methodsFor: 'palette'!dark23	^ self fromTriplet: #(#(27 158 119) #(217 95 2) #(117 112 179))! !!RSQualitativeColorPalette methodsFor: 'palette'!dark24	^ self fromTriplet: #(#(27 158 119) #(217 95 2) #(117 112 179) #(231 41 138))! !!RSQualitativeColorPalette methodsFor: 'palette'!dark25	^ self fromTriplet: #(#(27 158 119) #(217 95 2) #(117 112 179) #(231 41 138) #(102 166 30))! !!RSQualitativeColorPalette methodsFor: 'palette'!dark26	^ self fromTriplet: #(#(27 158 119) #(217 95 2) #(117 112 179) #(231 41 138) #(102 166 30) #(230 171 2))! !!RSQualitativeColorPalette methodsFor: 'palette'!dark27	^ self fromTriplet: #(#(27 158 119) #(217 95 2) #(117 112 179) #(231 41 138) #(102 166 30) #(230 171 2) #(166 118 29))! !!RSQualitativeColorPalette methodsFor: 'palette'!dark28	^ self fromTriplet: #(#(27 158 119) #(217 95 2) #(117 112 179) #(231 41 138) #(102 166 30) #(230 171 2) #(166 118 29) #(102 102 102))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui110	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui111	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui112	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui113	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui114	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60) #(236 240 241))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui115	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60) #(236 240 241) #(149 165 166))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui116	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60) #(236 240 241) #(149 165 166) #(243 156 18))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui117	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60) #(236 240 241) #(149 165 166) #(243 156 18) #(211 84 0))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui118	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60) #(236 240 241) #(149 165 166) #(243 156 18) #(211 84 0) #(192 57 43))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui119	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60) #(236 240 241) #(149 165 166) #(243 156 18) #(211 84 0) #(192 57 43) #(189 195 199))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui120	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173) #(44 62 80) #(241 196 15) #(230 126 34) #(231 76 60) #(236 240 241) #(149 165 166) #(243 156 18) #(211 84 0) #(192 57 43) #(189 195 199) #(127 140 141))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui13	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui14	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui15	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui16	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui17	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui18	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185))! !!RSQualitativeColorPalette methodsFor: 'palette'!flatui19	^ self fromTriplet: #(#(26 188 156) #(46 204 113) #(52 152 219) #(155 89 182) #(52 73 94) #(22 160 133) #(39 174 96) #(41 128 185) #(142 68 173))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired10	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111) #(255 127 0) #(202 178 214) #(106 61 154))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired11	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111) #(255 127 0) #(202 178 214) #(106 61 154) #(255 255 153))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired12	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111) #(255 127 0) #(202 178 214) #(106 61 154) #(255 255 153) #(177 89 40))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired3	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired4	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired5	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired6	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired7	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired8	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111) #(255 127 0))! !!RSQualitativeColorPalette methodsFor: 'palette'!paired9	^ self fromTriplet: #(#(166 206 227) #(31 120 180) #(178 223 138) #(51 160 44) #(251 154 153) #(227 26 28) #(253 191 111) #(255 127 0) #(202 178 214))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel13	^ self fromTriplet: #(#(251 180 174) #(179 205 227) #(204 235 197))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel14	^ self fromTriplet: #(#(251 180 174) #(179 205 227) #(204 235 197) #(222 203 228))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel15	^ self fromTriplet: #(#(251 180 174) #(179 205 227) #(204 235 197) #(222 203 228) #(254 217 166))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel16	^ self fromTriplet: #(#(251 180 174) #(179 205 227) #(204 235 197) #(222 203 228) #(254 217 166) #(255 255 204))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel17	^ self fromTriplet: #(#(251 180 174) #(179 205 227) #(204 235 197) #(222 203 228) #(254 217 166) #(255 255 204) #(229 216 189))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel18	^ self fromTriplet: #(#(251 180 174) #(179 205 227) #(204 235 197) #(222 203 228) #(254 217 166) #(255 255 204) #(229 216 189) #(253 218 236))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel19	^ self fromTriplet: #(#(251 180 174) #(179 205 227) #(204 235 197) #(222 203 228) #(254 217 166) #(255 255 204) #(229 216 189) #(253 218 236) #(242 242 242))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel23	^ self fromTriplet: #(#(179 226 205) #(253 205 172) #(203 213 232))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel24	^ self fromTriplet: #(#(179 226 205) #(253 205 172) #(203 213 232) #(244 202 228))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel25	^ self fromTriplet: #(#(179 226 205) #(253 205 172) #(203 213 232) #(244 202 228) #(230 245 201))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel26	^ self fromTriplet: #(#(179 226 205) #(253 205 172) #(203 213 232) #(244 202 228) #(230 245 201) #(255 242 174))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel27	^ self fromTriplet: #(#(179 226 205) #(253 205 172) #(203 213 232) #(244 202 228) #(230 245 201) #(255 242 174) #(241 226 204))! !!RSQualitativeColorPalette methodsFor: 'palette'!pastel28	^ self fromTriplet: #(#(179 226 205) #(253 205 172) #(203 213 232) #(244 202 228) #(230 245 201) #(255 242 174) #(241 226 204) #(204 204 204))! !!RSQualitativeColorPalette methodsFor: 'palette'!set13	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74))! !!RSQualitativeColorPalette methodsFor: 'palette'!set14	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74) #(152 78 163))! !!RSQualitativeColorPalette methodsFor: 'palette'!set15	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74) #(152 78 163) #(255 127 0))! !!RSQualitativeColorPalette methodsFor: 'palette'!set16	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74) #(152 78 163) #(255 127 0) #(255 255 51))! !!RSQualitativeColorPalette methodsFor: 'palette'!set17	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74) #(152 78 163) #(255 127 0) #(255 255 51) #(166 86 40))! !!RSQualitativeColorPalette methodsFor: 'palette'!set18	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74) #(152 78 163) #(255 127 0) #(255 255 51) #(166 86 40) #(247 129 191))! !!RSQualitativeColorPalette methodsFor: 'palette'!set19	^ self fromTriplet: #(#(228 26 28) #(55 126 184) #(77 175 74) #(152 78 163) #(255 127 0) #(255 255 51) #(166 86 40) #(247 129 191) #(153 153 153))! !!RSQualitativeColorPalette methodsFor: 'palette'!set23	^ self fromTriplet: #(#(102 194 165) #(252 141 98) #(141 160 203))! !!RSQualitativeColorPalette methodsFor: 'palette'!set24	^ self fromTriplet: #(#(102 194 165) #(252 141 98) #(141 160 203) #(231 138 195))! !!RSQualitativeColorPalette methodsFor: 'palette'!set25	^ self fromTriplet: #(#(102 194 165) #(252 141 98) #(141 160 203) #(231 138 195) #(166 216 84))! !!RSQualitativeColorPalette methodsFor: 'palette'!set26	^ self fromTriplet: #(#(102 194 165) #(252 141 98) #(141 160 203) #(231 138 195) #(166 216 84) #(255 217 47))! !!RSQualitativeColorPalette methodsFor: 'palette'!set27	^ self fromTriplet: #(#(102 194 165) #(252 141 98) #(141 160 203) #(231 138 195) #(166 216 84) #(255 217 47) #(229 196 148))! !!RSQualitativeColorPalette methodsFor: 'palette'!set28	^ self fromTriplet: #(#(102 194 165) #(252 141 98) #(141 160 203) #(231 138 195) #(166 216 84) #(255 217 47) #(229 196 148) #(179 179 179))! !!RSQualitativeColorPalette methodsFor: 'palette'!set310	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105) #(252 205 229) #(217 217 217) #(188 128 189))! !!RSQualitativeColorPalette methodsFor: 'palette'!set311	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105) #(252 205 229) #(217 217 217) #(188 128 189) #(204 235 197))! !!RSQualitativeColorPalette methodsFor: 'palette'!set312	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105) #(252 205 229) #(217 217 217) #(188 128 189) #(204 235 197) #(255 237 111))! !!RSQualitativeColorPalette methodsFor: 'palette'!set33	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218))! !!RSQualitativeColorPalette methodsFor: 'palette'!set34	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114))! !!RSQualitativeColorPalette methodsFor: 'palette'!set35	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211))! !!RSQualitativeColorPalette methodsFor: 'palette'!set36	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98))! !!RSQualitativeColorPalette methodsFor: 'palette'!set37	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105))! !!RSQualitativeColorPalette methodsFor: 'palette'!set38	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105) #(252 205 229))! !!RSQualitativeColorPalette methodsFor: 'palette'!set39	^ self fromTriplet: #(#(141 211 199) #(255 255 179) #(190 186 218) #(251 128 114) #(128 177 211) #(253 180 98) #(179 222 105) #(252 205 229) #(217 217 217))! !!RSSequentialColorPalette class methodsFor: 'as yet unclassified'!paletteName	^ #sequential! !!RSSequentialColorPalette methodsFor: 'palette'!blues3	^ self fromTriplet: #(#(222 235 247) #(158 202 225) #(49 130 189))! !!RSSequentialColorPalette methodsFor: 'palette'!blues4	^ self fromTriplet: #(#(239 243 255) #(189 215 231) #(107 174 214) #(33 113 181))! !!RSSequentialColorPalette methodsFor: 'palette'!blues5	^ self fromTriplet: #(#(239 243 255) #(189 215 231) #(107 174 214) #(49 130 189) #(8 81 156))! !!RSSequentialColorPalette methodsFor: 'palette'!blues6	^ self fromTriplet: #(#(239 243 255) #(198 219 239) #(158 202 225) #(107 174 214) #(49 130 189) #(8 81 156))! !!RSSequentialColorPalette methodsFor: 'palette'!blues7	^ self fromTriplet: #(#(239 243 255) #(198 219 239) #(158 202 225) #(107 174 214) #(66 146 198) #(33 113 181) #(8 69 148))! !!RSSequentialColorPalette methodsFor: 'palette'!blues8	^ self fromTriplet: #(#(247 251 255) #(222 235 247) #(198 219 239) #(158 202 225) #(107 174 214) #(66 146 198) #(33 113 181) #(8 69 148))! !!RSSequentialColorPalette methodsFor: 'palette'!blues9	^ self fromTriplet: #(#(247 251 255) #(222 235 247) #(198 219 239) #(158 202 225) #(107 174 214) #(66 146 198) #(33 113 181) #(8 81 156) #(8 48 107))! !!RSSequentialColorPalette methodsFor: 'palette'!bugn3	^ self fromTriplet: #(#(229 245 249) #(153 216 201) #(44 162 95))! !!RSSequentialColorPalette methodsFor: 'palette'!bugn4	^ self fromTriplet: #(#(237 248 251) #(178 226 226) #(102 194 164) #(35 139 69))! !!RSSequentialColorPalette methodsFor: 'palette'!bugn5	^ self fromTriplet: #(#(237 248 251) #(178 226 226) #(102 194 164) #(44 162 95) #(0 109 44))! !!RSSequentialColorPalette methodsFor: 'palette'!bugn6	^ self fromTriplet: #(#(237 248 251) #(204 236 230) #(153 216 201) #(102 194 164) #(44 162 95) #(0 109 44))! !!RSSequentialColorPalette methodsFor: 'palette'!bugn7	^ self fromTriplet: #(#(237 248 251) #(204 236 230) #(153 216 201) #(102 194 164) #(65 174 118) #(35 139 69) #(0 88 36))! !!RSSequentialColorPalette methodsFor: 'palette'!bugn8	^ self fromTriplet: #(#(247 252 253) #(229 245 249) #(204 236 230) #(153 216 201) #(102 194 164) #(65 174 118) #(35 139 69) #(0 88 36))! !!RSSequentialColorPalette methodsFor: 'palette'!bugn9	^ self fromTriplet: #(#(247 252 253) #(229 245 249) #(204 236 230) #(153 216 201) #(102 194 164) #(65 174 118) #(35 139 69) #(0 109 44) #(0 68 27))! !!RSSequentialColorPalette methodsFor: 'palette'!bupu3	^ self fromTriplet: #(#(224 236 244) #(158 188 218) #(136 86 167))! !!RSSequentialColorPalette methodsFor: 'palette'!bupu4	^ self fromTriplet: #(#(237 248 251) #(179 205 227) #(140 150 198) #(136 65 157))! !!RSSequentialColorPalette methodsFor: 'palette'!bupu5	^ self fromTriplet: #(#(237 248 251) #(179 205 227) #(140 150 198) #(136 86 167) #(129 15 124))! !!RSSequentialColorPalette methodsFor: 'palette'!bupu6	^ self fromTriplet: #(#(237 248 251) #(191 211 230) #(158 188 218) #(140 150 198) #(136 86 167) #(129 15 124))! !!RSSequentialColorPalette methodsFor: 'palette'!bupu7	^ self fromTriplet: #(#(237 248 251) #(191 211 230) #(158 188 218) #(140 150 198) #(140 107 177) #(136 65 157) #(110 1 107))! !!RSSequentialColorPalette methodsFor: 'palette'!bupu8	^ self fromTriplet: #(#(247 252 253) #(224 236 244) #(191 211 230) #(158 188 218) #(140 150 198) #(140 107 177) #(136 65 157) #(110 1 107))! !!RSSequentialColorPalette methodsFor: 'palette'!bupu9	^ self fromTriplet: #(#(247 252 253) #(224 236 244) #(191 211 230) #(158 188 218) #(140 150 198) #(140 107 177) #(136 65 157) #(129 15 124) #(77 0 75))! !!RSSequentialColorPalette methodsFor: 'palette'!gnbu3	^ self fromTriplet: #(#(224 243 219) #(168 221 181) #(67 162 202))! !!RSSequentialColorPalette methodsFor: 'palette'!gnbu4	^ self fromTriplet: #(#(240 249 232) #(186 228 188) #(123 204 196) #(43 140 190))! !!RSSequentialColorPalette methodsFor: 'palette'!gnbu5	^ self fromTriplet: #(#(240 249 232) #(186 228 188) #(123 204 196) #(67 162 202) #(8 104 172))! !!RSSequentialColorPalette methodsFor: 'palette'!gnbu6	^ self fromTriplet: #(#(240 249 232) #(204 235 197) #(168 221 181) #(123 204 196) #(67 162 202) #(8 104 172))! !!RSSequentialColorPalette methodsFor: 'palette'!gnbu7	^ self fromTriplet: #(#(240 249 232) #(204 235 197) #(168 221 181) #(123 204 196) #(78 179 211) #(43 140 190) #(8 88 158))! !!RSSequentialColorPalette methodsFor: 'palette'!gnbu8	^ self fromTriplet: #(#(247 252 240) #(224 243 219) #(204 235 197) #(168 221 181) #(123 204 196) #(78 179 211) #(43 140 190) #(8 88 158))! !!RSSequentialColorPalette methodsFor: 'palette'!gnbu9	^ self fromTriplet: #(#(247 252 240) #(224 243 219) #(204 235 197) #(168 221 181) #(123 204 196) #(78 179 211) #(43 140 190) #(8 104 172) #(8 64 129))! !!RSSequentialColorPalette methodsFor: 'palette'!greens3	^ self fromTriplet: #(#(229 245 224) #(161 217 155) #(49 163 84))! !!RSSequentialColorPalette methodsFor: 'palette'!greens4	^ self fromTriplet: #(#(237 248 233) #(186 228 179) #(116 196 118) #(35 139 69))! !!RSSequentialColorPalette methodsFor: 'palette'!greens5	^ self fromTriplet: #(#(237 248 233) #(186 228 179) #(116 196 118) #(49 163 84) #(0 109 44))! !!RSSequentialColorPalette methodsFor: 'palette'!greens6	^ self fromTriplet: #(#(237 248 233) #(199 233 192) #(161 217 155) #(116 196 118) #(49 163 84) #(0 109 44))! !!RSSequentialColorPalette methodsFor: 'palette'!greens7	^ self fromTriplet: #(#(237 248 233) #(199 233 192) #(161 217 155) #(116 196 118) #(65 171 93) #(35 139 69) #(0 90 50))! !!RSSequentialColorPalette methodsFor: 'palette'!greens8	^ self fromTriplet: #(#(247 252 245) #(229 245 224) #(199 233 192) #(161 217 155) #(116 196 118) #(65 171 93) #(35 139 69) #(0 90 50))! !!RSSequentialColorPalette methodsFor: 'palette'!greens9	^ self fromTriplet: #(#(247 252 245) #(229 245 224) #(199 233 192) #(161 217 155) #(116 196 118) #(65 171 93) #(35 139 69) #(0 109 44) #(0 68 27))! !!RSSequentialColorPalette methodsFor: 'palette'!greys3	^ self fromTriplet: #(#(240 240 240) #(189 189 189) #(99 99 99))! !!RSSequentialColorPalette methodsFor: 'palette'!greys4	^ self fromTriplet: #(#(247 247 247) #(204 204 204) #(150 150 150) #(82 82 82))! !!RSSequentialColorPalette methodsFor: 'palette'!greys5	^ self fromTriplet: #(#(247 247 247) #(204 204 204) #(150 150 150) #(99 99 99) #(37 37 37))! !!RSSequentialColorPalette methodsFor: 'palette'!greys6	^ self fromTriplet: #(#(247 247 247) #(217 217 217) #(189 189 189) #(150 150 150) #(99 99 99) #(37 37 37))! !!RSSequentialColorPalette methodsFor: 'palette'!greys7	^ self fromTriplet: #(#(247 247 247) #(217 217 217) #(189 189 189) #(150 150 150) #(115 115 115) #(82 82 82) #(37 37 37))! !!RSSequentialColorPalette methodsFor: 'palette'!greys8	^ self fromTriplet: #(#(255 255 255) #(240 240 240) #(217 217 217) #(189 189 189) #(150 150 150) #(115 115 115) #(82 82 82) #(37 37 37))! !!RSSequentialColorPalette methodsFor: 'palette'!greys9	^ self fromTriplet: #(#(255 255 255) #(240 240 240) #(217 217 217) #(189 189 189) #(150 150 150) #(115 115 115) #(82 82 82) #(37 37 37) #(0 0 0))! !!RSSequentialColorPalette methodsFor: 'palette'!oranges3	^ self fromTriplet: #(#(254 230 206) #(253 174 107) #(230 85 13))! !!RSSequentialColorPalette methodsFor: 'palette'!oranges4	^ self fromTriplet: #(#(254 237 222) #(253 190 133) #(253 141 60) #(217 71 1))! !!RSSequentialColorPalette methodsFor: 'palette'!oranges5	^ self fromTriplet: #(#(254 237 222) #(253 190 133) #(253 141 60) #(230 85 13) #(166 54 3))! !!RSSequentialColorPalette methodsFor: 'palette'!oranges6	^ self fromTriplet: #(#(254 237 222) #(253 208 162) #(253 174 107) #(253 141 60) #(230 85 13) #(166 54 3))! !!RSSequentialColorPalette methodsFor: 'palette'!oranges7	^ self fromTriplet: #(#(254 237 222) #(253 208 162) #(253 174 107) #(253 141 60) #(241 105 19) #(217 72 1) #(140 45 4))! !!RSSequentialColorPalette methodsFor: 'palette'!oranges8	^ self fromTriplet: #(#(255 245 235) #(254 230 206) #(253 208 162) #(253 174 107) #(253 141 60) #(241 105 19) #(217 72 1) #(140 45 4))! !!RSSequentialColorPalette methodsFor: 'palette'!oranges9	^ self fromTriplet: #(#(255 245 235) #(254 230 206) #(253 208 162) #(253 174 107) #(253 141 60) #(241 105 19) #(217 72 1) #(166 54 3) #(127 39 4))! !!RSSequentialColorPalette methodsFor: 'palette'!orrd3	^ self fromTriplet: #(#(254 232 200) #(253 187 132) #(227 74 51))! !!RSSequentialColorPalette methodsFor: 'palette'!orrd4	^ self fromTriplet: #(#(254 240 217) #(253 204 138) #(252 141 89) #(215 48 31))! !!RSSequentialColorPalette methodsFor: 'palette'!orrd5	^ self fromTriplet: #(#(254 240 217) #(253 204 138) #(252 141 89) #(227 74 51) #(179 0 0))! !!RSSequentialColorPalette methodsFor: 'palette'!orrd6	^ self fromTriplet: #(#(254 240 217) #(253 212 158) #(253 187 132) #(252 141 89) #(227 74 51) #(179 0 0))! !!RSSequentialColorPalette methodsFor: 'palette'!orrd7	^ self fromTriplet: #(#(254 240 217) #(253 212 158) #(253 187 132) #(252 141 89) #(239 101 72) #(215 48 31) #(153 0 0))! !!RSSequentialColorPalette methodsFor: 'palette'!orrd8	^ self fromTriplet: #(#(255 247 236) #(254 232 200) #(253 212 158) #(253 187 132) #(252 141 89) #(239 101 72) #(215 48 31) #(153 0 0))! !!RSSequentialColorPalette methodsFor: 'palette'!orrd9	^ self fromTriplet: #(#(255 247 236) #(254 232 200) #(253 212 158) #(253 187 132) #(252 141 89) #(239 101 72) #(215 48 31) #(179 0 0) #(127 0 0))! !!RSSequentialColorPalette methodsFor: 'palette'!pubu3	^ self fromTriplet: #(#(236 231 242) #(166 189 219) #(43 140 190))! !!RSSequentialColorPalette methodsFor: 'palette'!pubu4	^ self fromTriplet: #(#(241 238 246) #(189 201 225) #(116 169 207) #(5 112 176))! !!RSSequentialColorPalette methodsFor: 'palette'!pubu5	^ self fromTriplet: #(#(241 238 246) #(189 201 225) #(116 169 207) #(43 140 190) #(4 90 141))! !!RSSequentialColorPalette methodsFor: 'palette'!pubu6	^ self fromTriplet: #(#(241 238 246) #(208 209 230) #(166 189 219) #(116 169 207) #(43 140 190) #(4 90 141))! !!RSSequentialColorPalette methodsFor: 'palette'!pubu7	^ self fromTriplet: #(#(241 238 246) #(208 209 230) #(166 189 219) #(116 169 207) #(54 144 192) #(5 112 176) #(3 78 123))! !!RSSequentialColorPalette methodsFor: 'palette'!pubu8	^ self fromTriplet: #(#(255 247 251) #(236 231 242) #(208 209 230) #(166 189 219) #(116 169 207) #(54 144 192) #(5 112 176) #(3 78 123))! !!RSSequentialColorPalette methodsFor: 'palette'!pubu9	^ self fromTriplet: #(#(255 247 251) #(236 231 242) #(208 209 230) #(166 189 219) #(116 169 207) #(54 144 192) #(5 112 176) #(4 90 141) #(2 56 88))! !!RSSequentialColorPalette methodsFor: 'palette'!pubugn3	^ self fromTriplet: #(#(236 226 240) #(166 189 219) #(28 144 153))! !!RSSequentialColorPalette methodsFor: 'palette'!pubugn4	^ self fromTriplet: #(#(246 239 247) #(189 201 225) #(103 169 207) #(2 129 138))! !!RSSequentialColorPalette methodsFor: 'palette'!pubugn5	^ self fromTriplet: #(#(246 239 247) #(189 201 225) #(103 169 207) #(28 144 153) #(1 108 89))! !!RSSequentialColorPalette methodsFor: 'palette'!pubugn6	^ self fromTriplet: #(#(246 239 247) #(208 209 230) #(166 189 219) #(103 169 207) #(28 144 153) #(1 108 89))! !!RSSequentialColorPalette methodsFor: 'palette'!pubugn7	^ self fromTriplet: #(#(246 239 247) #(208 209 230) #(166 189 219) #(103 169 207) #(54 144 192) #(2 129 138) #(1 100 80))! !!RSSequentialColorPalette methodsFor: 'palette'!pubugn8	^ self fromTriplet: #(#(255 247 251) #(236 226 240) #(208 209 230) #(166 189 219) #(103 169 207) #(54 144 192) #(2 129 138) #(1 100 80))! !!RSSequentialColorPalette methodsFor: 'palette'!pubugn9	^ self fromTriplet: #(#(255 247 251) #(236 226 240) #(208 209 230) #(166 189 219) #(103 169 207) #(54 144 192) #(2 129 138) #(1 108 89) #(1 70 54))! !!RSSequentialColorPalette methodsFor: 'palette'!purd3	^ self fromTriplet: #(#(231 225 239) #(201 148 199) #(221 28 119))! !!RSSequentialColorPalette methodsFor: 'palette'!purd4	^ self fromTriplet: #(#(241 238 246) #(215 181 216) #(223 101 176) #(206 18 86))! !!RSSequentialColorPalette methodsFor: 'palette'!purd5	^ self fromTriplet: #(#(241 238 246) #(215 181 216) #(223 101 176) #(221 28 119) #(152 0 67))! !!RSSequentialColorPalette methodsFor: 'palette'!purd6	^ self fromTriplet: #(#(241 238 246) #(212 185 218) #(201 148 199) #(223 101 176) #(221 28 119) #(152 0 67))! !!RSSequentialColorPalette methodsFor: 'palette'!purd7	^ self fromTriplet: #(#(241 238 246) #(212 185 218) #(201 148 199) #(223 101 176) #(231 41 138) #(206 18 86) #(145 0 63))! !!RSSequentialColorPalette methodsFor: 'palette'!purd8	^ self fromTriplet: #(#(247 244 249) #(231 225 239) #(212 185 218) #(201 148 199) #(223 101 176) #(231 41 138) #(206 18 86) #(145 0 63))! !!RSSequentialColorPalette methodsFor: 'palette'!purd9	^ self fromTriplet: #(#(247 244 249) #(231 225 239) #(212 185 218) #(201 148 199) #(223 101 176) #(231 41 138) #(206 18 86) #(152 0 67) #(103 0 31))! !!RSSequentialColorPalette methodsFor: 'palette'!purples3	^ self fromTriplet: #(#(239 237 245) #(188 189 220) #(117 107 177))! !!RSSequentialColorPalette methodsFor: 'palette'!purples4	^ self fromTriplet: #(#(242 240 247) #(203 201 226) #(158 154 200) #(106 81 163))! !!RSSequentialColorPalette methodsFor: 'palette'!purples5	^ self fromTriplet: #(#(242 240 247) #(203 201 226) #(158 154 200) #(117 107 177) #(84 39 143))! !!RSSequentialColorPalette methodsFor: 'palette'!purples6	^ self fromTriplet: #(#(242 240 247) #(218 218 235) #(188 189 220) #(158 154 200) #(117 107 177) #(84 39 143))! !!RSSequentialColorPalette methodsFor: 'palette'!purples7	^ self fromTriplet: #(#(242 240 247) #(218 218 235) #(188 189 220) #(158 154 200) #(128 125 186) #(106 81 163) #(74 20 134))! !!RSSequentialColorPalette methodsFor: 'palette'!purples8	^ self fromTriplet: #(#(252 251 253) #(239 237 245) #(218 218 235) #(188 189 220) #(158 154 200) #(128 125 186) #(106 81 163) #(74 20 134))! !!RSSequentialColorPalette methodsFor: 'palette'!purples9	^ self fromTriplet: #(#(252 251 253) #(239 237 245) #(218 218 235) #(188 189 220) #(158 154 200) #(128 125 186) #(106 81 163) #(84 39 143) #(63 0 125))! !!RSSequentialColorPalette methodsFor: 'palette'!rdpu3	^ self fromTriplet: #(#(253 224 221) #(250 159 181) #(197 27 138))! !!RSSequentialColorPalette methodsFor: 'palette'!rdpu4	^ self fromTriplet: #(#(254 235 226) #(251 180 185) #(247 104 161) #(174 1 126))! !!RSSequentialColorPalette methodsFor: 'palette'!rdpu5	^ self fromTriplet: #(#(254 235 226) #(251 180 185) #(247 104 161) #(197 27 138) #(122 1 119))! !!RSSequentialColorPalette methodsFor: 'palette'!rdpu6	^ self fromTriplet: #(#(254 235 226) #(252 197 192) #(250 159 181) #(247 104 161) #(197 27 138) #(122 1 119))! !!RSSequentialColorPalette methodsFor: 'palette'!rdpu7	^ self fromTriplet: #(#(254 235 226) #(252 197 192) #(250 159 181) #(247 104 161) #(221 52 151) #(174 1 126) #(122 1 119))! !!RSSequentialColorPalette methodsFor: 'palette'!rdpu8	^ self fromTriplet: #(#(255 247 243) #(253 224 221) #(252 197 192) #(250 159 181) #(247 104 161) #(221 52 151) #(174 1 126) #(122 1 119))! !!RSSequentialColorPalette methodsFor: 'palette'!rdpu9	^ self fromTriplet: #(#(255 247 243) #(253 224 221) #(252 197 192) #(250 159 181) #(247 104 161) #(221 52 151) #(174 1 126) #(122 1 119) #(73 0 106))! !!RSSequentialColorPalette methodsFor: 'palette'!reds3	^ self fromTriplet: #(#(254 224 210) #(252 146 114) #(222 45 38))! !!RSSequentialColorPalette methodsFor: 'palette'!reds4	^ self fromTriplet: #(#(254 229 217) #(252 174 145) #(251 106 74) #(203 24 29))! !!RSSequentialColorPalette methodsFor: 'palette'!reds5	^ self fromTriplet: #(#(254 229 217) #(252 174 145) #(251 106 74) #(222 45 38) #(165 15 21))! !!RSSequentialColorPalette methodsFor: 'palette'!reds6	^ self fromTriplet: #(#(254 229 217) #(252 187 161) #(252 146 114) #(251 106 74) #(222 45 38) #(165 15 21))! !!RSSequentialColorPalette methodsFor: 'palette'!reds7	^ self fromTriplet: #(#(254 229 217) #(252 187 161) #(252 146 114) #(251 106 74) #(239 59 44) #(203 24 29) #(153 0 13))! !!RSSequentialColorPalette methodsFor: 'palette'!reds8	^ self fromTriplet: #(#(255 245 240) #(254 224 210) #(252 187 161) #(252 146 114) #(251 106 74) #(239 59 44) #(203 24 29) #(153 0 13))! !!RSSequentialColorPalette methodsFor: 'palette'!reds9	^ self fromTriplet: #(#(255 245 240) #(254 224 210) #(252 187 161) #(252 146 114) #(251 106 74) #(239 59 44) #(203 24 29) #(165 15 21) #(103 0 13))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgn3	^ self fromTriplet: #(#(247 252 185) #(173 221 142) #(49 163 84))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgn4	^ self fromTriplet: #(#(255 255 204) #(194 230 153) #(120 198 121) #(35 132 67))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgn5	^ self fromTriplet: #(#(255 255 204) #(194 230 153) #(120 198 121) #(49 163 84) #(0 104 55))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgn6	^ self fromTriplet: #(#(255 255 204) #(217 240 163) #(173 221 142) #(120 198 121) #(49 163 84) #(0 104 55))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgn7	^ self fromTriplet: #(#(255 255 204) #(217 240 163) #(173 221 142) #(120 198 121) #(65 171 93) #(35 132 67) #(0 90 50))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgn8	^ self fromTriplet: #(#(255 255 229) #(247 252 185) #(217 240 163) #(173 221 142) #(120 198 121) #(65 171 93) #(35 132 67) #(0 90 50))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgn9	^ self fromTriplet: #(#(255 255 229) #(247 252 185) #(217 240 163) #(173 221 142) #(120 198 121) #(65 171 93) #(35 132 67) #(0 104 55) #(0 69 41))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgnbu3	^ self fromTriplet: #(#(237 248 177) #(127 205 187) #(44 127 184))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgnbu4	^ self fromTriplet: #(#(255 255 204) #(161 218 180) #(65 182 196) #(34 94 168))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgnbu5	^ self fromTriplet: #(#(255 255 204) #(161 218 180) #(65 182 196) #(44 127 184) #(37 52 148))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgnbu6	^ self fromTriplet: #(#(255 255 204) #(199 233 180) #(127 205 187) #(65 182 196) #(44 127 184) #(37 52 148))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgnbu7	^ self fromTriplet: #(#(255 255 204) #(199 233 180) #(127 205 187) #(65 182 196) #(29 145 192) #(34 94 168) #(12 44 132))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgnbu8	^ self fromTriplet: #(#(255 255 217) #(237 248 177) #(199 233 180) #(127 205 187) #(65 182 196) #(29 145 192) #(34 94 168) #(12 44 132))! !!RSSequentialColorPalette methodsFor: 'palette'!ylgnbu9	^ self fromTriplet: #(#(255 255 217) #(237 248 177) #(199 233 180) #(127 205 187) #(65 182 196) #(29 145 192) #(34 94 168) #(37 52 148) #(8 29 88))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorbr3	^ self fromTriplet: #(#(255 247 188) #(254 196 79) #(217 95 14))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorbr4	^ self fromTriplet: #(#(255 255 212) #(254 217 142) #(254 153 41) #(204 76 2))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorbr5	^ self fromTriplet: #(#(255 255 212) #(254 217 142) #(254 153 41) #(217 95 14) #(153 52 4))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorbr6	^ self fromTriplet: #(#(255 255 212) #(254 227 145) #(254 196 79) #(254 153 41) #(217 95 14) #(153 52 4))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorbr7	^ self fromTriplet: #(#(255 255 212) #(254 227 145) #(254 196 79) #(254 153 41) #(236 112 20) #(204 76 2) #(140 45 4))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorbr8	^ self fromTriplet: #(#(255 255 229) #(255 247 188) #(254 227 145) #(254 196 79) #(254 153 41) #(236 112 20) #(204 76 2) #(140 45 4))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorbr9	^ self fromTriplet: #(#(255 255 229) #(255 247 188) #(254 227 145) #(254 196 79) #(254 153 41) #(236 112 20) #(204 76 2) #(153 52 4) #(102 37 6))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorrd3	^ self fromTriplet: #(#(255 237 160) #(254 178 76) #(240 59 32))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorrd4	^ self fromTriplet: #(#(255 255 178) #(254 204 92) #(253 141 60) #(227 26 28))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorrd5	^ self fromTriplet: #(#(255 255 178) #(254 204 92) #(253 141 60) #(240 59 32) #(189 0 38))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorrd6	^ self fromTriplet: #(#(255 255 178) #(254 217 118) #(254 178 76) #(253 141 60) #(240 59 32) #(189 0 38))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorrd7	^ self fromTriplet: #(#(255 255 178) #(254 217 118) #(254 178 76) #(253 141 60) #(252 78 42) #(227 26 28) #(177 0 38))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorrd8	^ self fromTriplet: #(#(255 255 204) #(255 237 160) #(254 217 118) #(254 178 76) #(253 141 60) #(252 78 42) #(227 26 28) #(177 0 38))! !!RSSequentialColorPalette methodsFor: 'palette'!ylorrd9	^ self fromTriplet: #(#(255 255 204) #(255 237 160) #(254 217 118) #(254 178 76) #(253 141 60) #(252 78 42) #(227 26 28) #(189 0 38) #(128 0 38))! !!RSGradientPalette class methodsFor: 'gradients'!burningSpring	^ LinearGradientPaint fromArray:		{0->'4fb576'. 		0.30->'44c489'.		0.46->'28a9ae'.		0.59->'28a2b7'.		0.71->'4c7788'.		0.86->'6c4f63'.		1->'432c39' }! !!RSGradientPalette class methodsFor: 'gradients'!cloudyKnoxville	^ LinearGradientPaint fromArray:		{0->'fdfbfb'. 		1->'ebedee' }! !!RSGradientPalette class methodsFor: 'gradients'!deepBlue	^ LinearGradientPaint fromArray:		{0->'e0c3fc'. 		1->'8ec5fc' }! !!RSGradientPalette class methodsFor: 'gradients'!dustyGrass	^ LinearGradientPaint fromArray:		{0->'d4fc79'. 		1->'96e6a1' }! !!RSGradientPalette class methodsFor: 'gradients'!fabledSunset	^ LinearGradientPaint fromArray:		{0->'231557'. 		0.29->'44107A'.		0.67->'FF1361'.		1->'FFF800' }! !!RSGradientPalette class methodsFor: 'palette'!gradient21	^ NSScale ordinal range:( 		#('warmFlame' 			'nightFade' 			'youngPassion' 			'sunnyMorning' 			'rainyAshville'			'winterNeva'			'dustyGrass'			'temptingAzure'			'heavyRain'			'deepBlue'			'cloudyKnoxville'			'malibuBeach'			'trueSunset'			'morpheusDen'			'nearMoon'			'happyFisher'			'sweetPeriod'			'burningSpring'			'redSalvation'			'northMiracle'			'fabledSunset') collect: [ :selector | self perform: selector asSymbol ] );		yourself! !!RSGradientPalette class methodsFor: 'gradients'!happyFisher	^ LinearGradientPaint fromArray:		{0->'89f7fe'. 		1->'66a6ff' }! !!RSGradientPalette class methodsFor: 'gradients'!heavyRain	^ LinearGradientPaint fromArray:		{0->'cfd9df'. 		1->'e2ebf0' }! !!RSGradientPalette class methodsFor: 'gradients'!malibuBeach	^ LinearGradientPaint fromArray:		{0->'4facfe'. 		1->'00f2fe' }! !!RSGradientPalette class methodsFor: 'gradients'!morpheusDen	^ LinearGradientPaint fromArray:		{0->'30cfd0'. 		1->'330867' }! !!RSGradientPalette class methodsFor: 'gradients'!nearMoon	^ LinearGradientPaint fromArray:		{0->'5ee7df'. 		1->'b490ca' }! !!RSGradientPalette class methodsFor: 'gradients'!nightFade	^ LinearGradientPaint fromArray:		{0->'a18cd1'. 		1->'fbc2eb' }! !!RSGradientPalette class methodsFor: 'gradients'!northMiracle	^ LinearGradientPaint fromArray:		{0->'00dbde'. 		1->'fc00ff' }! !!RSGradientPalette class methodsFor: 'gradients'!rainyAshville	^ LinearGradientPaint fromArray:		{0->'fbc2eb'. 		1->'a6c1ee' }! !!RSGradientPalette class methodsFor: 'gradients'!redSalvation	^ LinearGradientPaint fromArray:		{0->'f43b47'. 		1->'453a94' }! !!RSGradientPalette class methodsFor: 'gradients'!sunnyMorning	^ LinearGradientPaint fromArray:		{0->'f6d365'. 		1->'fda085' }! !!RSGradientPalette class methodsFor: 'gradients'!sweetPeriod	^ LinearGradientPaint fromArray:		{0->'3f51b1'. 		0.13->'5a55ae'.		0.25->'7b5fac'.		0.38->'8f6aae'.		0.50->'a86aa4'.		0.62->'cc6b8e'.		0.75->'f18271'.		0.87->'f3a469'.		1->'f7c978' }! !!RSGradientPalette class methodsFor: 'gradients'!temptingAzure	^ LinearGradientPaint fromArray:		{0->'84fab0'. 		1->'8fd3f4' }! !!RSGradientPalette class methodsFor: 'gradients'!trueSunset	^ LinearGradientPaint fromArray:		{0->'fa709a'. 		1->'fee140' }! !!RSGradientPalette class methodsFor: 'gradients'!warmFlame	^ LinearGradientPaint fromArray:		{0-> 'ff9a9e'. 		1->'fad0c4' }.	! !!RSGradientPalette class methodsFor: 'gradients'!winterNeva	^ LinearGradientPaint fromArray:		{0->'a1c4fd'. 		1->'c2e9fb' }! !!RSGradientPalette class methodsFor: 'gradients'!youngPassion	^ LinearGradientPaint fromArray:		{(0 -> 'ff867a').		(0.21 -> 'ff8c7f').		(0.52 -> 'f99185').		(0.78 -> 'cf556c').		(1 -> 'b12a5b')}! !!LinearGradientPaint methodsFor: '*Roassal3-Colors'!asScale 	| sc |	sc := NSScale linear.	sc domain: (colorRamp collect: #key).	sc range: (colorRamp collect: #value).	^ sc! !!Color methodsFor: '*Roassal3-Colors'!translucent	"Make the color transparent"	^ self alpha: 0.4! !"Roassal3-Colors"!!SpRoassalMorphicAdapter commentStamp: '' prior: 0!I am bridging RoassalPresenter and RTView!!SpRoassalPresenter commentStamp: '' prior: 0!I am a basic presenter for widgets in roassal with the Spec system!!SpRoassalMorphicAdapter methodsFor: 'initialization'!adapt: aComposableModel	super adapt: aComposableModel.	canvas := widget roassalCanvas.	widget		setProperty: #model toValue: self;		hResizing: #spaceFill;		vResizing: #spaceFill.	self basicApplyScript.! !!SpRoassalMorphicAdapter methodsFor: 'scripting actions'!applyScript	| extent |	extent := canvas extent.	self freeCanvas.	self basicApplyScript.	canvas extent: extent.	! !!SpRoassalMorphicAdapter methodsFor: 'scripting actions'!basicApplyScript	self model script value: canvas.	self model canvas: canvas.	self widgetDo: #startStepping.	canvas when: RSAbstractMouseEvent do: [ widget takeKeyboardFocus].! !!SpRoassalMorphicAdapter methodsFor: 'factory'!buildWidget	^ RSCanvas new createMorph! !!SpRoassalMorphicAdapter methodsFor: 'scripting actions'!freeCanvas	| temp |	temp := self buildWidget.	canvas := temp roassalCanvas.	widget canvas: canvas.	canvas morph: widget.! !!SpRoassalMorphicAdapter methodsFor: 'initialization'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!SpRoassalPresenter class methodsFor: 'specs'!adapterName	^ #SpRoassalMorphicAdapter! !!SpRoassalPresenter class methodsFor: 'instance creation'!open	<script>	^ self new openWithSpec! !!SpRoassalPresenter methodsFor: 'accessing'!canvas	^ currentCanvas! !!SpRoassalPresenter methodsFor: 'accessing'!canvas: aRSCanvas 	currentCanvas := aRSCanvas! !!SpRoassalPresenter methodsFor: 'initialization'!initialize	super initialize.	script := [ :v | ] asValueHolder.	script whenChangedDo: [ :s | self refresh ].! !!SpRoassalPresenter methodsFor: 'public'!refresh 	self changed: #applyScript with: #()! !!SpRoassalPresenter methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!SpRoassalPresenter methodsFor: 'accessing'!script	^ script value! !!SpRoassalPresenter methodsFor: 'accessing'!script: anObject	script value: anObject! !"Roassal3-Spec"!!RSSunburstAttachPoint commentStamp: '' prior: 0!I am an attach point to build edges!!RSSunburstFadeInteraction commentStamp: '' prior: 0!I define a new basic highlight interaction!!RSAbstractSunburstLayout commentStamp: '' prior: 0!I am the abstract class for sunburst visualizations in Roassal2, check my subclasses * RTSunburstConstanWidthLayout* RtSunburstExtentLayoutYou can use this layout in with RTLayoutBuilder or with RTSunburstBuilderand their examples to get more info!!RSSunburstConstantWidthStrategy commentStamp: '' prior: 0!I am a layout for sunburst visualization,I put the arcs in a constant delta separation, you can define the center width.!!RSSunburstExtentStrategy commentStamp: '' prior: 0!I am a layout for Sunburst Visualization, I use a radius to calculate the better distance of all arcs in the visualization.You can use radius to set the total radius of sunburstor use the selector extent:, that uses radius size!!RSSunburstBuilder commentStamp: '' prior: 0!I am a class to create visualizations about rings, center is the root of the tree and arcs are the sub trees.You can customize the angle of the arc, and play with the with radius and width of each arc.!!RSSunburstCPController commentStamp: '' prior: 0!I am prepared to sunburst arcs!!RSEdgeBuilder class methodsFor: '*Roassal3-Sunburst'!sunburstBezier	^ self bezier		controlPointsController: RSSunburstCPController new;		yourself.	! !!RSSunburstAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ anEdge to centroid: 0! !!RSSunburstAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ anEdge from centroid: 0! !!RSSunburstFadeInteraction methodsFor: 'accessing'!builder	^ builder! !!RSSunburstFadeInteraction methodsFor: 'accessing'!builder: aBuilder	builder := aBuilder! !!RSSunburstFadeInteraction methodsFor: 'initialization'!highlightShapesFor: shape	| parents |	parents := self pathFor: shape.	^ builder shapes 		reject: [ :s | parents includes: s].! !!RSSunburstFadeInteraction methodsFor: 'initialization'!initialize	super initialize.	self highlightColor: [ :shape | shape color alpha: 0.15 ].! !!RSSunburstFadeInteraction methodsFor: 'initialization'!onShape: aShape	aShape		when: RSMouseEnter do: [ :evt | 			still := true.			self doHighlight: evt shape.			evt signalUpdate ];		when: RSMouseLeave do: [ :evt | 			still := false.			evt canvas newAnimation				duration: 300 milliSeconds; 				onStepDo: [ :t | evt signalUpdate ];				when: RSAnimationLoopEvent do: [ :e | 					still ifFalse: [ self doUnhighlight: evt shape. ].					].			evt signalUpdate ]! !!RSSunburstFadeInteraction methodsFor: 'initialization'!pathFor: shape	| list current |	list := OrderedCollection new.	current := shape.	[ current notNil ] whileTrue: [		list add: current.		current := current sparent ].	^ list ! !!RSAbstractSunburstLayout methodsFor: 'accessing'!builder	^ builder! !!RSAbstractSunburstLayout methodsFor: 'accessing'!builder: aSunburstBuilder	builder := aSunburstBuilder! !!RSAbstractSunburstLayout methodsFor: 'hook'!doExecute: shapes	| virtual |	shapes isEmpty ifTrue: [ ^  self ].	firstNode := true.	shapes size = 1 ifTrue: [ 		^ self layoutSunburst: shapes first ].	virtual := RSPieSlice new.	virtual schildren: shapes.	shapes do: [ :shape | shape sparent: virtual ].	virtual sparent: nil.	virtual depth: 0.	self layoutSunburst: virtual.	shapes do: [ :shape | shape sparent: nil ].! !!RSAbstractSunburstLayout methodsFor: 'accessing'!hasCenter	^ hasCenter! !!RSAbstractSunburstLayout methodsFor: 'accessing'!hasCenter: aBool	hasCenter := aBool! !!RSAbstractSunburstLayout methodsFor: 'initialize-release'!initialize	super initialize.	self		hasCenter: true;		radialSpacing: 5.! !!RSAbstractSunburstLayout methodsFor: 'hook'!layoutSunburst: shape	self 		setRadius: shape;		setChildrenAngles: shape.! !!RSAbstractSunburstLayout methodsFor: 'accessing'!radialSpacing	^ radialSpacing ! !!RSAbstractSunburstLayout methodsFor: 'accessing'!radialSpacing: aNumber	radialSpacing := aNumber! !!RSAbstractSunburstLayout methodsFor: 'hook'!setCenterRadius: shape	self subclassResponsibility! !!RSAbstractSunburstLayout methodsFor: 'hook'!setChildrenAngles: shape	| children parentAngle angleOffset parentWeight |	children := shape schildren.	parentAngle := shape alphaAngle.	parentWeight := builder weightOf: shape.	angleOffset := (shape betaAngle - shape alphaAngle) / parentWeight.	children doWithIndex: [ :child :index |		| a b |		a := parentAngle.		b := angleOffset * (builder weightOf: child) + a.		child			alphaAngle: a;			betaAngle: b.		self layoutSunburst: child.		parentAngle := b. ].! !!RSAbstractSunburstLayout methodsFor: 'hook'!setNormalRadius: shape	self subclassResponsibility! !!RSAbstractSunburstLayout methodsFor: 'hook'!setRadius: shape	firstNode		ifTrue: [ 			self hasCenter 				ifTrue: [ self setCenterRadius: shape ].			shape betaAngle: 360. ]		ifFalse: [ self setNormalRadius: shape ].	firstNode := false.! !!RSSunburstConstantWidthStrategy methodsFor: 'accessing'!arcWidth	^ arcWidth! !!RSSunburstConstantWidthStrategy methodsFor: 'accessing'!arcWidth: aNumber	arcWidth := aNumber! !!RSSunburstConstantWidthStrategy methodsFor: 'accessing'!centerWidth	^ centerWidth! !!RSSunburstConstantWidthStrategy methodsFor: 'accessing'!centerWidth: anObject	centerWidth := anObject! !!RSSunburstConstantWidthStrategy methodsFor: 'initialize-release'!initialize	super initialize.	self arcWidth: 50.	self centerWidth: 50.! !!RSSunburstConstantWidthStrategy methodsFor: 'hook'!setCenterRadius: shape	shape externalRadius: self centerWidth.	! !!RSSunburstConstantWidthStrategy methodsFor: 'hook'!setNormalRadius: shape	| r1 r2 off depth |	depth := shape propertyAt: #depth.	off := self radialSpacing * (depth-1).	r1 := ((depth - 2) * arcWidth) + off.	r2 := ((depth -1 )* arcWidth ) + off.	shape		innerRadius: r1 + self centerWidth;		externalRadius: r2 + self centerWidth.! !!RSSunburstExtentStrategy methodsFor: 'accessing'!extent: aPoint	wside := aPoint x min: aPoint y! !!RSSunburstExtentStrategy methodsFor: 'initialize-release'!initialize	super initialize.	self extent: 500@500! !!RSSunburstExtentStrategy methodsFor: 'accessing'!radiusForDepth: depth	| w2 maxDepth |	w2 := wside/2.	maxDepth := builder maxLevel.	^ ((depth * w2 * w2) / (maxDepth + 1) ) sqrt! !!RSSunburstExtentStrategy methodsFor: 'hook'!setCenterRadius: shape	shape externalRadius: (self radiusForDepth: 1).	! !!RSSunburstExtentStrategy methodsFor: 'hook'!setNormalRadius: shape	| r1 r2 off depth |	depth := shape propertyAt: #depth.	off := self radialSpacing * (depth -1 ).	r1 := (self radiusForDepth: depth -1) + off.	r2 := (self radiusForDepth: depth) + off.	shape		innerRadius: r1;		externalRadius: r2.! !!RSSunburstBuilder methodsFor: 'public - shape'!color: aBlock	"an object"	color := aBlock! !!RSSunburstBuilder methodsFor: 'strategry'!constantWidthStrategy	self strategy: RSSunburstConstantWidthStrategy new.	^ strategy! !!RSSunburstBuilder methodsFor: 'strategry'!extentStrategy	self strategy: RSSunburstExtentStrategy new.	^ strategy! !!RSSunburstBuilder methodsFor: 'public - building'!from: objects nesting: block1 leaves: block2	| r |	r := super from: objects nesting: block1 leaves: block2.	r do: [ :e | e propertyAt: #parent put: nil].	^ r! !!RSSunburstBuilder methodsFor: 'public - building'!from: objects using: ablock	| r |	r := super from: objects using: ablock.	r do: [ :e | e propertyAt: #parent put: nil].	^ r! !!RSSunburstBuilder methodsFor: 'initialization'!initialize	super initialize. 	self extentStrategy extent: 500@500.	self leafWeight: 1.	self sliceColor: NSScale category20c.	sliceShape := RSPieSlice new.	maxLevel := 0.! !!RSSunburstBuilder methodsFor: 'accessing'!maxLevel	^ maxLevel! !!RSSunburstBuilder methodsFor: 'hooks'!renderIn: aCanvas	super renderIn: aCanvas.	self strategy on: self rootNodes! !!RSSunburstBuilder methodsFor: 'hooks'!shapeFor: anObject	| slice |	slice := self sliceShape copy		model: anObject;		popup;		draggable;		yourself.	slice color: (color rsValue: slice).	^ slice ! !!RSSunburstBuilder methodsFor: 'public - shape'!sliceColor: aBlock	"an object"	color := aBlock! !!RSSunburstBuilder methodsFor: 'accessing'!sliceShape	^ sliceShape! !!RSSunburstBuilder methodsFor: 'accessing'!strategy	^ strategy! !!RSSunburstBuilder methodsFor: 'accessing'!strategy: anStrategy	strategy := anStrategy.	strategy builder: self! !!RSSunburstCPController methodsFor: 'hooks'!controlPointsFor: anEdge	| cp1 cp2 cp3 cp4 from to width1 width2 |	from := anEdge from.	to := anEdge to.	width1 := (from externalRadius - from innerRadius)/2.	from innerRadius isZero ifTrue: [ width1 := 0 ].	cp1 := from centroid: width1 negated.	cp2 := from centroid: width1.		width2 := (to externalRadius - to innerRadius)/2.	cp3 := to centroid: (width1 * 2 + width2) negated.	cp4 := to centroid: width2 negated.	^ Array		with: cp1		with: cp2		with: cp3		with: cp4! !"Roassal3-Sunburst"!!RSAbstractContext commentStamp: '' prior: 0!A context is very usefull to describe de default interactions for a canvas.My subclasses should override interaction!!RSEmptyContext commentStamp: '' prior: 0!I do not register any interaction to the RSCanvas and its shapes!!RSInteractiveContext commentStamp: '' prior: 0!I put a default interaction for each shape in the canvas!!RSInspectable commentStamp: '' prior: 0!I allow to inspect another view or windows. It can be configurable to set the kind of view you want to inspect!!RSSelectionPresentation commentStamp: '' prior: 0!I am used on the inspector for Roassal3, when you select one element the view changes its shapes!!GLMMorphicRoassal3Renderer commentStamp: '' prior: 0!I am a basic Renderer for roassal3 presentation based on morphs!!GLMRoassal3Presentation commentStamp: '' prior: 0!I am a presentation for Roassal3!!RSAbstractAction commentStamp: '' prior: 0!Users can add actions to the inspector creating a new subclass of abstract action and defined their methods.!!RSSERAction commentStamp: '' prior: 0!This action show or hide the encompassing rectangles of shapes in the canvasSER = Show Encompassing Rectangles!!RSChessBackground commentStamp: '' prior: 0!I am a basici class!!NSInterpolator methodsFor: '*Roassal3-Inspector'!gtCanvasForInspector	| canvas theme boxes pos rect line cp label loc s | 	canvas := RSCanvas new.	theme := Smalltalk ui theme.	canvas color: theme backgroundColor.	s := NSScale linear domain: #(1 100); range: #(0 420).	boxes := (0 to: 99) collect: [ :i |		RSBox new			size: 40;			x: (s scale: (i / 10) asInteger) * 10 + 64;			y: (s scale: (i % 10) asInteger) * 10 + 64;			color: (theme caretColor alpha: 0.2);			resetBBox;			yourself ] as: RSGroup.	rect := boxes encompassingRectangle.	pos := NSScale linear		domain: { 0@0. 1@1 };		range: { 0 @ rect height. rect width@ 0 }.	line := RSPolyline new 		border: (RSBorder new 			width: 4;			paint: ((LinearGradientPaint fromArray: {"sweetPeriod"					0->'3f51b1'. 					0.13->'5a55ae'.					0.25->'7b5fac'.					0.38->'8f6aae'.					0.50->'a86aa4'.					0.62->'cc6b8e'.					0.75->'f18271'.					0.87->'f3a469'.					1->'f7c978'				})				start: rect bottomLeft;				stop: rect topRight;				yourself)).	canvas addShape: line.	cp := OrderedCollection new.	canvas newAnimation		duration: 5 seconds;		onStepDo: [ :t |			cp add: t.			line controlPoints: (cp collect: [:value | 				pos scale: value @ (self interpolate: value) ]).			canvas signalUpdate].	canvas addAll: boxes.	label := [ :text | 		RSLabel new			color: theme textColor;			size: 20;			text: text;			yourself ].	canvas addShape: (label value: '1').	loc := RSLocation new outer.	loc top; right;		move: canvas shapes last on: rect.	canvas addShape: (label value: '0').	loc bottom; left;		move: canvas shapes last on: rect.	canvas addShape: (label value: 'Y').	loc top; left;		move: canvas shapes last on: rect.	canvas addShape: (label value: 'X').	loc bottom; right;		move: canvas shapes last on: rect.	canvas @ RSCanvasController.	^ canvas! !!NSInterpolator methodsFor: '*Roassal3-Inspector'!gtInspectorCanvasIn: composite	<gtInspectorPresentationOrder: -10>	composite roassal3		title: ['Interpolator'];		initializeCanvas: [ self gtCanvasForInspector ]! !!RSAbstractContext methodsFor: 'initialization'!initialize	super initialize.	self propagateToChildren: true.! !!RSAbstractContext methodsFor: 'hooks'!interactionsToBeRegistered	^ self subclassResponsibility! !!RSAbstractContext methodsFor: 'hooks'!onShape: aShape	aShape removeInteractionIfPresent: self class.	self interactionsToBeRegistered 		do: [ :i | 			i presentation: self presentation.			aShape addInteraction: i].	self propagateToChildren ifFalse: [ ^ self ].	aShape children ifNil: [ ^ self ].		aShape children do: [ :child | child addInteraction: self ].	aShape		when: RSShapeAddedEvent		do: [ :evt | evt shape @ context ].! !!RSAbstractContext methodsFor: 'accessing'!presentation	^ presentation! !!RSAbstractContext methodsFor: 'accessing'!presentation: aGlamourPresentation	presentation := aGlamourPresentation! !!RSAbstractContext methodsFor: 'accessing'!propagateToChildren	^ propagateToChildren! !!RSAbstractContext methodsFor: 'accessing'!propagateToChildren: bool	propagateToChildren := bool! !!RSEmptyContext methodsFor: 'hooks'!interactionsToBeRegistered	^ #()! !!RSInteractiveContext methodsFor: 'initialization'!initialize	super initialize.	interactions := OrderedCollection new		add: (RSSelectionPresentation new);		yourself.! !!RSInteractiveContext methodsFor: 'hooks'!interactionsToBeRegistered	^ interactions! !!RSInspectable methodsFor: 'hooks'!deselectIfNecessary	"Nothing to unselect"	selectedShape ifNil: [ ^ self ].	highlightable doUnhighlight: selectedShape	! !!RSInspectable methodsFor: 'accessing'!highlightable	^ highlightable! !!RSInspectable methodsFor: 'accessing'!highlightable: anObject	highlightable := anObject! !!RSInspectable methodsFor: 'hooks'!initialize	super initialize.	highlightable := RSHighlightable new.! !!RSInspectable methodsFor: 'accessing'!inspectElementBlock	^ inspectShapeBlock! !!RSInspectable methodsFor: 'hooks'!inspectShape: aShape	| oldInspectorWindow canvasMorph |	self deselectIfNecessary.	selectedShape := aShape.	highlightable doHighlight: selectedShape.		oldInspectorWindow := inspectorWindow.	inspectorWindow := inspectShapeBlock rsValue: aShape model.	inspectorWindow setLabel: aShape model asString.	canvasMorph := aShape canvas morph.	canvasMorph root activate.	"If there is a previous inspector window, then we use the same position and extent"	oldInspectorWindow ifNil: [ ^ self ].	inspectorWindow 		position: oldInspectorWindow position;		extent: oldInspectorWindow extent.	oldInspectorWindow delete.	oldInspectorWindow := nil		! !!RSInspectable methodsFor: 'accessing'!inspectShapeBlock: oneArgBlock	"The block should return a window"	inspectShapeBlock := oneArgBlock! !!RSInspectable methodsFor: 'hooks'!onShape: aShape	aShape 		when: RSMouseLeftClick		do: [ :evt | self inspectShape: aShape ]! !!RSSelectionPresentation methodsFor: 'accessing'!key	^ self class name! !!RSSelectionPresentation methodsFor: 'hooks'!onShape: aShape	aShape model ifNil: [ ^ self ].	aShape when: RSMouseClick do: [ self selection: aShape ]! !!RSSelectionPresentation methodsFor: 'accessing'!presentation	^ presentation! !!RSSelectionPresentation methodsFor: 'accessing'!presentation: aRSRoassalPresentation	presentation := aRSRoassalPresentation! !!RSSelectionPresentation methodsFor: 'hooks'!putShadowOn: aShape	| shadow |	shadow := RSBox new		fromRectangle: (aShape encompassingRectangle expandBy: aShape extent * 0.05); 		paint: self shadowColor;		yourself.	aShape parent		addShape: shadow before: aShape.	aShape canvas 		propertyAt: self key		put: shadow! !!RSSelectionPresentation methodsFor: 'dependencies'!release	presentation := nil! !!RSSelectionPresentation methodsFor: 'hooks'!removeShadowOn: aShape	aShape canvas		propertyAt: self key		ifPresent: [ :shadow |shadow remove ].! !!RSSelectionPresentation methodsFor: 'hooks'!selection: aShape	self presentation selection: aShape model.	self		removeShadowOn: aShape;		putShadowOn: aShape.! !!RSSelectionPresentation methodsFor: 'accessing'!shadowColor	^ shadowColor ifNil: [ shadowColor := Color blue alpha: 0.3 ]! !!RSSelectionPresentation methodsFor: 'accessing'!shadowColor: aColor	shadowColor := aColor! !!GLMMorphicRenderer methodsFor: '*Roassal3-Inspector'!renderRoassal3Presentation: aPresentation	^ GLMMorphicRoassal3Renderer render: aPresentation from: self! !!RSGroup methodsFor: '*Roassal3-Inspector'!gtInspectorViewIn: composite	<gtInspectorPresentationOrder: 0>		composite roassal3		title: ['Canvas'];		initializeCanvas: [ | canvas |			canvas := RSCanvas new				addShape: (RSComposite new					shapes: self;					yourself).			canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].			canvas ]		! !!RSShape methodsFor: '*Roassal3-Inspector'!gtCanvasForInspector	| canvas copy |	canvas := RSCanvas new.	copy := self copy.	canvas addShape: copy.	canvas @ RSChessBackground.	^ canvas! !!RSShape methodsFor: '*Roassal3-Inspector'!gtInspectorCanvasIn: composite	<gtInspectorPresentationOrder: -10>	composite roassal3		title: ['Shape'];		initializeCanvas: [ self gtCanvasForInspector ]! !!GLMMorphicRoassal3Renderer methodsFor: 'rendering'!render: aRoassalPresentation	aRoassalPresentation 		setUpInteractions;		when: GLMPresentationUpdated send: #actOnPresentationUpdate: to: self.	myMorph :=aRoassalPresentation canvas createMorph.	myMorph takeKeyboardFocus.	aRoassalPresentation canvas when: RSMouseClick do: [ myMorph takeKeyboardFocus ].	^ myMorph! !!GLMPresentation methodsFor: '*Roassal3-Inspector'!roassal3	^ self custom: GLMRoassal3Presentation new! !!GLMRoassal3Presentation methodsFor: 'accessing'!canvas	^ canvas ifNil: [ canvas := newCanvasBlock value ].! !!GLMRoassal3Presentation methodsFor: 'initialization'!initialize	super initialize.			RSAbstractAction registerActionsOn: self.! !!GLMRoassal3Presentation methodsFor: 'initialization'!initializeCanvas: aZeroArgBlock	^ newCanvasBlock := aZeroArgBlock ! !!GLMRoassal3Presentation methodsFor: 'rendering'!renderGlamorouslyOn: aRenderer	self registerAnnouncements.	^ aRenderer renderRoassal3Presentation: self! !!GLMRoassal3Presentation methodsFor: 'initialization'!setUpInteractions	| context |	context := self canvas inspectorContext.	context presentation: self.		self canvas shapes @ context.	self canvas		when: RSShapeAddedEvent		do: [ :evt | evt shape @ context ].! !!RSCanvas methodsFor: '*Roassal3-Inspector'!gtInspectorShapesIn: composite	<gtInspectorPresentationOrder: 20>	composite table 		title: 'Shapes';		showOnly: 50;		display: [ :each | each shapes ];		children: #children;		column: 'Shape' evaluated: [ :each | each asString ];		column: 'Model' evaluated: [ :each | each model asString ];		column: 'Paint' evaluated: [ :each | each paint asString ];		column: 'Border' evaluated: [ :each | each border asString ].! !!RSCanvas methodsFor: '*Roassal3-Inspector'!gtInspectorViewIn: composite	<gtInspectorPresentationOrder: -10>	composite roassal3		title: ['Canvas'];		initializeCanvas: [ self ]		! !!RSCanvas methodsFor: '*Roassal3-Inspector'!inspectorContext	^ self		propertyAt: RSAbstractContext name asSymbol		ifAbsentPut: [ RSInteractiveContext new ]! !!RSCanvas methodsFor: '*Roassal3-Inspector'!inspectorContext: aRSContext	^ self		propertyAt: RSAbstractContext name asSymbol		put: aRSContext! !!RSAbstractAction class methodsFor: 'as yet unclassified'!registerActionsOn: presentation	| instances |	instances := self allSubclasses reject: #hasAbstractMethods.	instances := instances collect: #new.	instances := instances sort: [:a :b | a order < b order].	instances do: [ :inst | inst registerOn: presentation ].! !!RSAbstractAction methodsFor: 'hooks'!category 	^ nil! !!RSAbstractAction methodsFor: 'hooks'!execute	self subclassResponsibility! !!RSAbstractAction methodsFor: 'hooks'!executeOn: roassalPresentation	presentation := roassalPresentation.	self execute! !!RSAbstractAction methodsFor: 'hooks'!icon	^ nil! !!RSAbstractAction methodsFor: 'hooks'!order	^ 0! !!RSAbstractAction methodsFor: 'hooks'!registerOn: roassalPresentation	presentation := roassalPresentation.	roassalPresentation addAction: (GLMGenericAction new		action: [ :r | self executeOn: r ];		icon: self icon;		title: self title;		category: self category;		yourself)	! !!RSAbstractAction methodsFor: 'accessing'!roassalCanvas	^ presentation canvas! !!RSAbstractAction methodsFor: 'hooks'!title	^ nil! !!RSSERAction methodsFor: 'hooks'!execute	| canvas |	canvas := self roassalCanvas.	canvas showRectangles		ifTrue:[ canvas hideEncompassingRectangles]		ifFalse:[canvas showEncompassingRectangles ].	canvas signalUpdate! !!RSSERAction methodsFor: 'hooks'!icon	^ self iconNamed: #smallDebug ! !!RSSERAction methodsFor: 'hooks'!title	^ 'Show or hide encompassing rectangles'! !!RSChessBackground methodsFor: 'hooks'!onShape: aCanvas	| boxes theme color |	theme := Smalltalk ui theme.	aCanvas color: theme backgroundColor.	color := theme caretColor alpha: 0.2.	boxes := nil.	aCanvas when: RSExtentChangedEvent do: [ 		| extent side counter even camera |		boxes ifNotNil: [ boxes do: #remove ].		extent := aCanvas extent.		camera := aCanvas camera.				aCanvas zoomToFit.		side := 20.		boxes := RSGroup new.		counter := 0.		(side / 2) to: extent x by: 20 do: [ :j |			even := counter even.			(side / 2) to: extent y by: 20 do: [ :k |				| box |				even ifTrue: [ 					box := RSBox new						color: color;						size: side / camera scale;						position: (camera fromPixelToSpace: j@k).					boxes add: box.					aCanvas addShape: box.				 ].				even := even not.			].			counter := counter + 1 ].		boxes pushBack.		aCanvas signalUpdate ].	! !!RSObjectWithProperty methodsFor: '*Roassal3-Inspector'!gtInspectorProperties: composite	<gtInspectorPresentationOrder: 25>	self hasProperties ifFalse: [ ^ self ].	self properties gtInspectorItemsIn: composite! !"Roassal3-Inspector"!!RSWorldMenu commentStamp: '' prior: 0!I am have the menu items for the menu Roassal3 on Tools!!RSWorldMenu class methodsFor: 'icons'!discord	^ discord ifNil: [ discord := PNGReadWriter formFromStream: self discordPNGByteArray readStream ]! !!RSWorldMenu class methodsFor: 'streams'!discordPNGByteArray	^ #[137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 16 0 0 0 16 8 6 0 0 0 31 243 255 97 0 0 0 4 103 65 77 65 0 0 177 143 11 252 97 5 0 0 0 32 99 72 82 77 0 0 122 38 0 0 128 132 0 0 250 0 0 0 128 232 0 0 117 48 0 0 234 96 0 0 58 152 0 0 23 112 156 186 81 60 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 1 203 105 84 88 116 88 77 76 58 99 111 109 46 97 100 111 98 101 46 120 109 112 0 0 0 0 0 60 120 58 120 109 112 109 101 116 97 32 120 109 108 110 115 58 120 61 34 97 100 111 98 101 58 110 115 58 109 101 116 97 47 34 32 120 58 120 109 112 116 107 61 34 88 77 80 32 67 111 114 101 32 53 46 52 46 48 34 62 10 32 32 32 60 114 100 102 58 82 68 70 32 120 109 108 110 115 58 114 100 102 61 34 104 116 116 112 58 47 47 119 119 119 46 119 51 46 111 114 103 47 49 57 57 57 47 48 50 47 50 50 45 114 100 102 45 115 121 110 116 97 120 45 110 115 35 34 62 10 32 32 32 32 32 32 60 114 100 102 58 68 101 115 99 114 105 112 116 105 111 110 32 114 100 102 58 97 98 111 117 116 61 34 34 10 32 32 32 32 32 32 32 32 32 32 32 32 120 109 108 110 115 58 116 105 102 102 61 34 104 116 116 112 58 47 47 110 115 46 97 100 111 98 101 46 99 111 109 47 116 105 102 102 47 49 46 48 47 34 10 32 32 32 32 32 32 32 32 32 32 32 32 120 109 108 110 115 58 120 109 112 61 34 104 116 116 112 58 47 47 110 115 46 97 100 111 98 101 46 99 111 109 47 120 97 112 47 49 46 48 47 34 62 10 32 32 32 32 32 32 32 32 32 60 116 105 102 102 58 79 114 105 101 110 116 97 116 105 111 110 62 49 60 47 116 105 102 102 58 79 114 105 101 110 116 97 116 105 111 110 62 10 32 32 32 32 32 32 32 32 32 60 120 109 112 58 67 114 101 97 116 111 114 84 111 111 108 62 65 100 111 98 101 32 73 109 97 103 101 82 101 97 100 121 60 47 120 109 112 58 67 114 101 97 116 111 114 84 111 111 108 62 10 32 32 32 32 32 32 60 47 114 100 102 58 68 101 115 99 114 105 112 116 105 111 110 62 10 32 32 32 60 47 114 100 102 58 82 68 70 62 10 60 47 120 58 120 109 112 109 101 116 97 62 10 178 35 126 241 0 0 2 168 73 68 65 84 56 17 109 83 75 107 83 65 20 254 230 113 147 38 49 125 102 97 17 90 95 180 40 162 32 74 74 235 198 62 246 174 10 130 85 112 43 40 198 141 127 194 138 27 23 46 4 173 32 22 23 238 107 91 186 104 177 186 113 161 139 46 164 166 130 45 86 105 154 54 105 110 238 220 25 207 153 52 88 197 3 147 156 185 231 245 205 119 206 17 216 151 233 105 167 198 199 69 204 215 135 207 220 104 108 49 18 4 232 225 123 20 97 77 73 204 222 189 33 222 242 253 160 175 56 248 225 209 148 27 148 2 147 16 200 171 0 112 150 173 128 144 64 28 145 226 176 108 29 10 119 38 196 82 51 137 104 42 15 158 186 107 58 192 84 68 24 76 29 86 74 88 66 225 11 144 238 40 153 212 9 200 64 145 61 194 196 189 155 226 5 199 122 7 174 76 153 23 235 117 224 88 183 49 29 173 177 222 248 165 25 186 23 122 10 14 119 25 108 149 149 89 93 215 58 145 0 8 233 16 35 209 13 23 15 27 99 249 170 233 106 55 154 161 159 237 223 67 160 29 161 166 138 70 96 175 38 33 4 244 201 30 101 22 62 102 56 110 146 206 128 120 252 202 141 238 86 48 115 162 59 178 99 67 59 50 138 4 148 116 176 206 131 219 207 207 21 29 98 43 124 210 153 165 172 253 178 30 200 67 25 140 201 168 102 71 36 229 235 59 26 146 153 120 162 146 76 154 86 92 187 33 172 83 245 134 141 254 251 122 67 203 49 81 136 97 25 11 217 147 77 1 185 14 35 76 76 24 9 246 218 247 36 86 86 91 40 136 3 157 215 215 214 147 222 198 62 185 78 35 56 134 248 238 149 53 34 46 215 6 164 146 214 87 136 201 97 246 125 26 175 231 211 8 235 210 31 214 249 27 219 24 97 170 197 34 215 14 112 172 222 169 96 173 147 18 40 5 199 189 102 226 46 158 174 161 82 149 72 4 141 103 140 156 15 145 73 91 111 139 136 80 26 42 215 217 10 16 119 69 93 220 194 108 75 16 223 215 218 202 221 138 166 138 2 231 78 85 185 77 96 103 150 75 23 118 97 169 51 229 93 229 185 72 167 98 73 49 248 186 165 230 188 199 243 55 238 221 229 124 156 111 207 108 155 159 37 173 75 101 133 36 85 103 168 44 220 194 144 186 211 158 141 153 43 83 170 180 233 249 101 181 124 253 138 24 240 115 240 185 136 194 102 73 45 246 247 180 234 227 71 106 102 99 51 208 75 159 18 200 166 125 60 202 85 96 232 76 157 147 154 133 15 173 122 229 155 194 143 109 20 216 250 215 40 215 45 166 252 240 198 176 201 4 161 62 48 202 97 29 18 138 14 209 146 144 255 140 114 115 31 158 188 140 6 195 88 55 150 137 176 241 187 89 104 23 16 27 82 104 153 164 50 133 91 87 131 63 203 228 61 232 167 153 132 239 188 206 180 27 195 90 163 151 239 198 160 24 8 204 221 254 207 58 255 6 33 135 81 38 156 4 58 218 0 0 0 0 73 69 78 68 174 66 96 130]! !!RSWorldMenu class methodsFor: 'menu'!menu00RoassalOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3)		parent: #Tools;		label: 'Roassal';		icon: self roassalIcon;		help: 'A visualization engine';		order: 777! !!RSWorldMenu class methodsFor: 'menu'!menu01ReportABugOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Bug)		parent: #Roassal3;		order: 1;		label: 'Report a Bug';		icon: (self iconNamed: 'smallDebug');		action: [ WebBrowser openOn: 'https://github.com/ObjectProfile/Roassal3/issues/new' ]! !!RSWorldMenu class methodsFor: 'menu'!menu02GithubOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Git)		parent: #Roassal3;		order: 2;		label: 'Github';		icon: (self iconNamed: 'github');		action: [ WebBrowser openOn: 'https://github.com/ObjectProfile/Roassal3/' ]! !!RSWorldMenu class methodsFor: 'menu'!menu03DiscordOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Chat)		parent: #Roassal3;		order: 3;		label: 'Chat with us';		icon: self discord;		action: [ WebBrowser openOn: 'https://discord.gg/YTEaAu6' ]! !!RSWorldMenu class methodsFor: 'menu'!menu04DocumentationOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Documentation)		parent: #Roassal3;		order: 4;		label: 'Online documentation';		icon: (self iconNamed: #smallHelp);		action: [ WebBrowser openOn: 'http://AgileVisualization.com' ]! !!RSWorldMenu class methodsFor: 'menu'!menu05ExamplesOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Examples)		parent: #Roassal3;		order: 5;		label: 'Examples';		icon: self roassalIcon;		action: [ (RPackageOrganizer default packageNamed: 'Roassal3-Examples') browse ]! !!RSWorldMenu class methodsFor: 'menu'!menu06PluginsOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Plugins)		parent: #Roassal3;		order: 6;		label: 'Plugins';		icon: self roassalIcon;		action: [ self inform: 'TODO' ]! !!RSWorldMenu class methodsFor: 'menu'!menu11SelfOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Self)		parent: #Roassal3;		order: 11;		label: 'This menu';		icon: (self iconNamed: 'smallExport');		action: [ self browse ]! !!RSWorldMenu class methodsFor: 'icons'!roassalIcon	^ roassalIcon ifNil: [ roassalIcon := Form fromBinaryStream: self roassalIconStream base64Decoded readStream ]! !!RSWorldMenu class methodsFor: 'streams'!roassalIconStream	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABMUlEQVQ4T2NkoBAwgvS/sAr5D6LNi6MZ/v39z/D3LwPD3z8MEPrvf4b3ycFgddgAwoD/DF8ljq/hkV217v/jsCC4BsG5a/+DDPuUjt0QDJPRDQDZyjdz7f9/fxkYvmRhGkKUASBDeKat/U/QAPm1ayX//WV8huwFmL8JGqC0cT3Yr8iB+DIWEhZEeQFkwD3/QEZYGIgvXvf/4vRlDJrJkeAYIRiIIAP+/f2//u8fhsC//xi+/f3NwAUyAAQkjq3BH40wf8qvBRsCjv9nkUGML6zDKjWTwtsIpgPkBIItHVBuAO9fdoawsF8wi17ahAb+//d/HchrRKUDUCwgByIs6WMY8NIq5Pd/BgYW9ECDRSMkf0DzSkkI2HIUFyCbjC3jcE5e++R7brAMshzO6CE2lwMAVKG/Eb0e33UAAAAASUVORK5CYII='! !"Roassal3-Menu"!!RSAbstractExamples commentStamp: '' prior: 0!I am the root class of all the examples of Roassal3. Examples contained in a subclass of myself are automatically run by the the test: TSExamplesTest>>testExamplesThe goal is to make the examples part of the tests.If you wish to add examples to Roassal3, then you need to subclass me.!!RSAnimationExamples commentStamp: '' prior: 0!I have examples for animation!!RSBasicAnimationExamples commentStamp: '' prior: 0!I have basic animation examples!!RSBasicShapeExamples commentStamp: '' prior: 0!I have the basic examples for shapes!!RSHighlightableExamples commentStamp: '' prior: 0!Basic examples about highlighting!!RSInspectableExample commentStamp: '' prior: 0!I have examples of different ways to inspect views an objects in roassal3!!RSLayoutExamples commentStamp: '' prior: 0!I use the RSShapeBuilder!!RSShapeExamples commentStamp: '' prior: 0!I use the RSShapeBuilder!!RSExpandingBoxes commentStamp: '' prior: 0!This is a simple example suggested by Nicolas Anquetil!!RSAbstractExamples methodsFor: 'accessing'!label	^ self className! !!RSAnimationExamples methodsFor: 'examples'!example01BoxWindmill	<script: 'self new example01BoxWindmill open'>	| canvas shapes extent points frameCount border |	canvas := RSCanvas new.	canvas color: Color black.	extent := 1920@1080.	points := (0 to: extent x by: 50) flatCollect: [ :x |		(0 to: extent y by: 50) collect: [ :y | (x@y)- (extent/2) ] ].	border := RSBorder new		color: (Color gray alpha: 0.5);		yourself.			shapes := points collect: [ :p | 		RSBox new			extent: 140@40;			model: p;			color: Color white;			border: border;			yourself  ].	canvas addAll: shapes.	frameCount := 0.	canvas newAnimation repeat;		onStepDo: [ :t |			shapes do: [ :s | 				s matrix 					loadIdentity;					translateBy: s model;					rotateByRadians: (s model x + s model y + frameCount) degreesToRadians * 1.95  ].			frameCount := frameCount + 1. ].	canvas @ RSGraphCanvasMonitor.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example02BoxesLineCircles	<script: 'self new example02BoxesLineCircles open'>	| c extent r shapes position alpha update updateLine lineX line |	c := RSCanvas new.	r := Random new.	shapes := (1 to: 12) collect: [ :i | 		RSBox new			model: r next;			noPaint;			border: (RSBorder new width: 4);			yourself].	c addAll: shapes.	RSNormalizer size		from: 30;		to: 100;		shapes: shapes;		normalize: #yourself.	lineX := 0.	line := RSLine new		color: Color red;		width: 8;		yourself;		startPoint: 1@0;		endPoint: 0@0;		yourself.	c add: line. 	position := nil.	updateLine := [		line 			startPoint: lineX@position from y;			endPoint: lineX@position to y. ].	c when: RSMouseMove do: [ :ev | 		lineX := ev position x.		updateLine value ].	update := [ 		extent := c extent.		position := NSScale linear			range: { extent / 2 negated. extent /2 }.		updateLine value.		shapes do: [ :e | e translateTo: (position scale: r next@ r next) ].	].	update value.	c when: RSExtentChangedEvent do: update.		"shadow"	alpha := NSScale linear domain: #(1 4); range: #(0.4 0.05).	shapes do: [ :e | | ant |		ant := e.		1 to: 4 do: [:i | | s |			s := RSBox new 				noPaint;				position: e position;				extent: e extent;				border: (RSBorder new					width: 6;					color: (e border color alpha: (alpha scale: i)));				yourself.			ant when: RSPositionChangedEvent do: [ :evt | 				s translateTo: evt oldPosition ].			ant := s.			c add: s			] ] .	c newAnimation repeat; 		onStepDo: [ :t | 			shapes do: [ :e |				| delta newX |				delta := e propertyAt: #delta ifAbsentPut: [ 5 ].				newX := e position x + delta.				(newX 					between: position from x 					and: position to x) ifFalse: [ 					delta := delta negated.					newX := e position x + delta.					 ].				e translateTo: newX@e position y.				e propertyAt: #delta put: delta				].			c nodes copy do: [ :e | | cls |				cls := e position x > lineX 					ifTrue: [ RSEllipse ]					ifFalse: [ RSBox ].				e replaceWith: cls new.				 ].	].	^ c! !!RSAnimationExamples methodsFor: 'examples'!example03Atom	<script: 'self new example03Atom open'>	| shapes canvas border extent speed frame |	canvas := RSCanvas new.	border := RSBorder new width: 4.	extent := 450@110.		shapes := { 40@40. extent. extent. extent. extent} collectWithIndex: [ :m :index | 		| ellipse |		ellipse := RSEllipse new			border: border;			extent: m;			noPaint;			yourself.		ellipse matrix			rotateByRadians: index * Float pi / 4.		index = 1 ifTrue: [ ellipse color: Color black ].		ellipse		 ].	canvas addAll: shapes.	shapes := (1 to: 4) collect: [ :m |		RSEllipse new			border: border;			color: Color black;			extent: 20 asPoint;			yourself ].	canvas addAll: shapes.		frame := 0.		canvas newAnimation repeat onStepDo: [ :t |		frame := frame +1.		speed := frame/50.		shapes doWithIndex: [ :shape :index | | ang |			ang := speed + (index * 90).			shape matrix				loadIdentity;				rotateByRadians: index * Float pi /4;				translateBy: (extent/2)* (ang cos @ ang sin)			 ]	].	canvas when: RSExtentChangedEvent do: [ :evt | 		canvas zoomToFit ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example05ElasticEllipses	<script: 'self new example05ElasticEllipses open'>	| canvas random mouseClick |	canvas := RSCanvas new.	random := Random new.		mouseClick := [ | c1 c2 color  |		canvas nodes copy do: #remove.		c1 := Color r: random next g: random next b: random next.		c2 := Color r: random next g: random next b: random next.		color := NSScale linear range: { c1. c2 }.		1 to: 10000 do: [ :i | | shape radius ang overlapped |			shape := RSEllipse new.			shape radius: random next * 30 + 2.			radius := random next * 250.			ang := random next * Float pi * 2.			shape position: radius * (ang cos @ ang sin).			overlapped := canvas nodes anySatisfy: [ :other |				(other position dist: shape position) < 					((shape radius + other radius) * 1.4)  ].			overlapped ifFalse: [ 				canvas add: shape.				shape propertyAt: #radius put: shape radius.				shape color: (color scale: (shape position dist: 0@0)/250 ) ].		].		canvas newAnimation			easing: RSEasing elasticOut;			onStepDo: [ :t |				canvas nodes do: [ :shape | | scale |					scale := NSScale linear range: { 1. shape propertyAt: #radius }.					shape radius: (scale scale: t)					 ].				]	].	mouseClick value.		canvas 		when: RSExtentChangedEvent do: [ :evt | canvas zoomToFit ];		when: RSMouseClick do: mouseClick.	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example06LinePatterns	<script: 'self new example06LinePatterns open'>	| canvas step frame border dot bar radius data update ap |	canvas := RSCanvas new.	step := 0.	frame := 0.	bar := 200.	radius := 150.	data := (1 to: 360 by: 3) collect: #degreesToRadians.	canvas add: (RSBox new noPaint; size: 640; yourself).	border := RSBorder new		color: (Color colorFrom: '00004A');		width: 2.	dot := [ RSBox new		size: 5;		border: border; 		yourself ].	ap := RSCenteredAttachPoint new.	update := [ 		canvas nodes copy do: #remove.		canvas addAll: (data collect: [ :radian | | matrix line d1 d2 |			"edges do not handle matrix"			matrix := AthensAffineTransform new.			matrix translateBy: radius * (radian cos @ radian sin);				rotateByRadians: radian + (radian * step * 5) + (frame *0.02).			d1 := dot value.			d2 := dot value.			d1 position: (matrix transform: bar/2@0).			d2 position: (matrix transform: bar/ -2 * radian cos @ 0 ).			d2 size: 6* radian cos.			canvas add: d1; add: d2.			line := RSLine new.			line border: border.			line from: d1.			line to: d2.			line attachPoint: ap.			line ]).	].	canvas newAnimation repeat onStepDo: [ :t | 		frame := frame + 1.		update value.	].	canvas 		when: RSExtentChangedEvent do: [ :evt | canvas zoomToFit ];		when: RSMouseClick do: [ 			step := step +1.			step > 20 ifTrue: [ step := 0 ] ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example07CircleParty	<script: 'self new example07CircleParty open'>	| canvas x x2 speed speed2 random shape color |	canvas := RSCanvas new.	x := 1. x2 := 2.	speed := 5. speed2 := 10.	random := Random new.	color := NSScale ordinal rangeFrom: { 		(Color colorFrom: 'B4FA05') alpha: 0.7. 		'FF7C7C'.		(Color colorFrom: 'EA323E') alpha: 0.5.		'BDEA5C'.		(Color colorFrom: 'CB1D34') alpha: 0.3.		'E0CC14'}.	canvas color: Color black.	shape := [ :m | 		RSEllipse new			border: (RSBorder new 				width: 25;				color: (Color					r: (random rsNext: 0 and: 40)					g: (random rsNext: 100 and: 200)					b: (random rsNext: 100 and: 255));				yourself);			color: (color scale: m);			position: m key;			size: m value;			yourself		].	canvas newAnimation repeat onStepDo: [:t | 		canvas nodes copy do: #remove.		color dictionary keysAndValuesRemove: [:a :b| true ].		(x between: 0 and: 1000) ifFalse: [ speed := speed negated ].		x2 >= x ifTrue: [ 			speed2 := speed2 negated.			x2 > 20 ifTrue: [ x2 := x2 - 20 ] ].		x2 <= 0 ifTrue: [ speed2 := speed2 negated ].		x := x + speed.		x2 := x2 + speed2.		canvas add: (shape value: 0@0 -> x).		canvas add: (shape value: 0@0 -> x2).		canvas add: (shape value: -300 asPoint -> x).		canvas add: (shape value: -300 asPoint -> x2).		canvas add: (shape value: 300 asPoint -> x).		canvas add: (shape value: 300 asPoint -> x2).		].	canvas camera scale: 0.5.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example08ArcTree	<script: 'self new example08ArcTree open'>	| canvas newArc alpha beta |	canvas := RSCanvas new.		newArc := nil.	newArc := [ :point :size :iteration | | arc |		arc := RSPieSlice new			color: Color black;			index: iteration;			innerRadius: size * 0.9;			externalRadius: size;			yourself.		arc position: point.		canvas add: arc.		iteration > 1 ifTrue: [ 			newArc 				value: point + (0 - size@ (size/2 - (size* 0.01) ) ) 				value: size/2				value: iteration - 1.			newArc 				value: point + (size@ (size/2 - (size* 0.01) ) ) 				value: size/2				value: iteration - 1.			 ]		].	newArc value: 0@0 value: 100 value: 5.	alpha := NSScale linear range: #(90 0).	beta := NSScale linear range: #(90 180).	canvas showEncompassingRectangles.	canvas animationFrom: ((1 to: 5) reverse collect: [ :i| | shapes |		shapes := canvas nodes select: [ :e | e index = i ].		canvas transitionAnimation 			duration: 1 seconds;			easing: RSEasing bounceOut;			onStepDo: [ :t |			shapes do: [ :e |				e 					alphaAngle: (alpha scale: t);					betaAngle: (beta scale: t);					resetPath.				 ]			 ]		 ]).	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit; signalUpdate ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example09PerlinParticles	<script: 'self new example09PerlinParticles  open setLabel: ''Particles!!!!!! :V'''>	| canvas label particle random frame perlin color |	canvas := RSCanvas new.	random := Random new.	frame := 0.	perlin := NSPerlinNoise new.		label := RSLabel new		color: Color black;		text: 'Drag to draw. type ''c'' to clear the view'.	canvas addShape: label.		canvas newAnimation delay: 2 seconds;		from: Color black; 		to: Color transparent; 		on: label set: #color:;		when: RSAnimationEndEvent do: [ 			canvas clearBackground: false.			label remove. ].	color := RSGradientPalette fabledSunset asScale.	color domain: color domain reverse.	particle := [ :m | 		| ang vel att lifeSpan decay passedLife weightRange update shape |		shape := RSEllipse new			withBorder;			position: m key;			yourself.		att := shape properties.					ang := random next * Float pi * 2.		vel := random next * 5 * (ang cos @ ang sin).		lifeSpan := random rsNext: 30 and: 90.				decay := random rsNext: 0.75 and: 0.9.		passedLife := 0.		weightRange := random rsNext: 3 and: 50.		att at: #dead put: false.		"in this case use a class"		update := [ | radius rn acc mag pos dir rand alpha |			att at: #dead put: (passedLife >= lifeSpan).			passedLife := passedLife + 1.			acc := (lifeSpan - passedLife)/lifeSpan.			alpha := acc max: 0.4.			shape border color: (Color black alpha: alpha).			shape color: (color scale: acc asFloat).			radius := acc * weightRange.			pos := shape position.			rn := 4*Float pi*((perlin 				noise: 0.02				and:0.02) - 0.5).			mag := (perlin noise: (pos y + frame) * 0.01 and: (pos x + frame)* 0.01) abs.			dir := rn cos @ rn sin.			ang :=  random next * Float pi * 2.			rand := (ang cos @ ang sin) * 0.5.			acc := (dir * mag) + rand.			vel := (vel + acc)* decay.			vel := vel normalized * 3.				shape size: radius.			shape translateBy: vel.			].			att at: #update put: update.			shape ].	canvas newAnimation repeat; onStepDo: [ :t| 		frame := frame + 30.		canvas nodes copy do: [ :e| 			(e propertyAt: #update) value.			(e propertyAt: #dead) ifTrue: [ e remove ] ].		canvas signalUpdate ].		canvas when: RSMouseDragging do: [ :evt | 		1 to: 10 do: [ :i | | p |			p := (particle value: evt position->(i+canvas nodes size)).			canvas add: p ].		canvas signalUpdate ];		when: RSKeyUp do: [:evt | 			evt keyValue = 8 ifTrue: [ 				canvas clearBackground: true.				canvas nodes copy do: #remove.				canvas signalUpdate.				canvas newAnimation duration: 200 milliSeconds;				when: RSAnimationEndEvent do: [ canvas clearBackground: false ] ] ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example09b	<script: 'self new example09b  open setLabel: ''Particles!!!!!! :V'''>	| canvas label particle random frame perlin changeHue hIndex hExtent h |	canvas := RSCanvas new.	canvas color: Color black.	random := Random new.	frame := 0.	perlin := NSPerlinNoise new.		label := RSLabel new		color: Color white;		text: 'Drag to draw. type ''c'' to clear the view.'.	canvas addShape: label.		canvas newAnimation delay: 2 seconds;		from: Color black; 		to: Color transparent; 		on: label set: #color:;		when: RSAnimationEndEvent do: [ 			canvas clearBackground: false.			label remove. ].			hIndex := 4.	changeHue := [		hIndex := hIndex + 1.		hIndex > 4 ifTrue: [ hIndex := 0 ].		hExtent := NSScale linear			domain: #(0 1 2 3 4);			range: { 220@100. 55@0. 100@20. 180@110. 255@150 };			scale: hIndex.		hExtent := hExtent * 360 / 255.		h := hExtent y ].	changeHue value.	particle := [ :m |  		| ang vel att lifeSpan decay passedLife update sizeMult shape |		shape := RSEllipse new			position: m key;			yourself.		att := shape properties.				ang := random next * Float pi * 2.		vel := random next * 5 * (ang cos @ ang sin).		lifeSpan := random rsNext: 30 and: 90.				decay := random rsNext: 0.75 and: 0.9.		passedLife := 0.		h := h + 0.5.		h > hExtent x ifTrue: [ h := hExtent y + h - hExtent x ].		shape color: ((Color h: h s: 1 v: 1) alpha: 0.2).		sizeMult := ((frame * 0.02) sin max: 0.05) min: 0.5.		att at: #dead put: false.		"in this case use a class"		update := [ | radius rn acc mag pos dir rand |			att at: #dead put: (passedLife >= lifeSpan).			passedLife := passedLife + 1.			acc := lifeSpan - passedLife.						radius := acc * sizeMult.			pos := shape position.			rn := 4*Float pi*((perlin 				noise: 0.02				and:0.02) - 0.5).			mag := (perlin noise: (pos y + frame) * 0.01 and: (pos x + frame)* 0.01) abs.			dir := rn cos @ rn sin.			ang :=  random next * Float pi * 2.			rand := (ang cos @ ang sin) * 0.5.			acc := (dir * mag) + rand.			vel := (vel + acc)* decay.			vel := vel normalized * 3.				shape size: radius.			shape translateBy: vel.		].		att at: #update put: update.		shape	].		canvas newAnimation repeat; onStepDo: [ :t| 		frame := frame + 30.		canvas nodes copy do: [ :e| 			(e propertyAt: #update) value.			(e propertyAt: #dead) ifTrue: [ e remove ] ].		canvas signalUpdate ].		canvas when: RSMouseDragging do: [ :evt | 		1 to: 10 do: [ :i | | p |			p := (particle value: evt position-> (i+canvas nodes size) ).			canvas add: p ].		canvas signalUpdate ];		when: RSKeyUp do: [:evt | 			evt keyValue = 8 ifTrue: [ 				canvas clearBackground: true.				canvas nodes copy do: #remove.				canvas signalUpdate.				canvas newAnimation duration: 200 milliSeconds;				when: RSAnimationEndEvent do: [ canvas clearBackground: false ] ]			ifFalse: changeHue ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example10Arcs	<script: 'self new example10Arcs open setLabel: ''Arc animation'''>	| canvas beta shapes theta step size |	theta := 0.	step := 12.	size := 21.	canvas := RSCanvas new.	canvas color: Color black.	beta := NSScale linear		domain: #(-1 1);		range: #(180 360).	shapes := (1 to: size) collect: [ :m | 		RSPieSlice new			model: m;			innerRadius: m * step;			externalRadius: m * step + 5;			alphaAngle: 180;			yourself ].			canvas addAll: shapes.	canvas newAnimation repeat onStepDo: [ :t |		theta := theta + 0.0523.		shapes do: [ :shape | | m offset |			m := shape model.			offset := Float pi * 2 / size * m.			shape 				color: (Color h: theta * 2 + (m * 10) s: 1 l: 0.5);				betaAngle: (beta scale: (theta + offset) sin)			 ] ].	canvas when: RSExtentChangedEvent do: [ | s sc e |		s := (size * step + 5) * 2.		e := canvas extent.		sc := e x / s.		canvas camera			scale: sc.		canvas newAnimation 			from: 0@0; 			to: 0@ (e y/sc)/2;			on: canvas camera set: #translateTo:.  ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example11C	<script: 'self new example11C open setLabel: ''C!!!!!!'''>	| canvas shapes step theta |	canvas := RSCanvas new.	canvas color: Color black.	step := 15.	theta := 0.	shapes := (1 to: 16) collect: [ :m |		RSPieSlice new			model: m;			innerRadius: m * step + 7;			externalRadius: m * step + 10;			yourself		 ].	canvas addAll: shapes.	canvas newAnimation repeat onStepDo: [ :t |		theta := theta + 0.4.		shapes do: [ :shape | | m |			m := shape model.			shape				alphaAngle: 30 + (theta * m);				betaAngle: 300 + (theta * m);				color: (Color h: theta * m s: 1 l: 0.5) ] ].	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example12Sky	<script: 'self new example12Sky open setLabel: ''Star trails'''>	<noTest>	| canvas client image ext dots random frame box colors |	canvas := RSCanvas new.	random := Random new.	ext := 2200 @ 2200.	box := RSBox new		extent: ext;		position: 0 @ ext y / 2 negated;		paint:			(LinearGradientPaint new				colorRamp:					{(0 -> Color black).					(1 -> Color blue muchDarker)};				start: ext / 2 negated;				stop: ext / 2).	canvas addShape: box.	colors := NSScale linear		domain: #(5 15);		range: {'6A6569' . 'white'}.	dots := (1 to: 800) collect: [ :n | 		| e |		e := RSEllipse new			propertyAt: #a put: (random rsNext: 0 and: 350);			propertyAt: #r put: (random rsNext: 3500 and: 6000);			size: (random rsNext: 5 and: 15);			yourself. 		e color: ((colors scale: e width) alpha: (random rsNext: 0.1 and: 0.8)).		e ].	canvas addAll: dots.	frame := 0.	canvas clearBackground: false.	(canvas newAnimation duration: 5 seconds;onStepDo: [ :t| ])		when: RSAnimationEndEvent do: [ box remove ].	canvas newAnimation repeat		onStepDo: [ :t | 			frame := frame + 0.1.			dots				do: [ :e | 					| ang radius |					ang := ((e propertyAt: #a) + frame) degreesToRadians.					radius := e propertyAt: #r.					e position: ang cos @ ang sin negated * radius + (2500 @ 3000) ] ].	(client := ZnEasy client)		url:			'http://www.transparentpng.com/download/mountain/68IzPF-mountain-clipart-png-photos.png';		accept: ZnMimeType imagePng;		signalProgress: true;		get.	image := ImageReadWriter formFromStream: client entity readStream.	canvas addShape: (RSBitmap new form: image).	canvas		when: RSExtentChangedEvent		do: [ | e s |			e := canvas extent.			s := e x / 2200.			"2200 x 800 = image extent"			canvas camera				scale: s;				translateTo: 0 @ (e y / s - 800) / 2 negated ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example13ArcNoise	<script: 'self new example13ArcNoise open setLabel: ''Arcs with Perlin noise'''>	| frame canvas perlin radius line points yscale |	frame := 0.	canvas := RSCanvas new.	canvas color: Color black.	perlin := NSPerlinNoise new.	radius := NSScale linear domain: #(1 20); range: #(50 250).	canvas addAll: ((1 to: 20) collect: [:n |		| r |		r := radius scale: n.		RSPieSlice new			color: Color white;			externalRadius: r;			alphaAngle: 0;			innerRadius: r - 5;			yourself. ]).	canvas addShape: (RSBox new 		color: (Color white alpha: 0.4);		cornerRadius: 7;		extent: 140@80;		position: 70@40;		isFixed: true ).			points := OrderedCollection new.	yscale := NSScale linear domain: #(0 360); range: #(80 5).		line := RSPolyline new		border: (RSBorder new  			width: 2;			paint: ((LinearGradientPaint fromArray:				{0 -> 'red'.				0.5 -> 'yellow'.				1 -> 'green'})				start: 0@0;				stop: 0@80;				yourself);			yourself);		isFixed: true;		yourself.	canvas addShape: line.			canvas newAnimation repeat; onStepDo: [ :t|		| last temp | 		frame := frame + 0.2.		canvas nodes do: [ :arc | 			temp := (frame * 0.025) + (arc externalRadius * 0.0005).			arc betaAngle: 360 * (perlin noise: temp and: 0.01) abs.			arc color: (Color h: arc betaAngle s: 0.5 v: 1).			 ].		last := canvas nodes last.		points add: (yscale scale: last betaAngle).		points size > 140 ifTrue: [ points removeFirst ].		line controlPoints: (points collectWithIndex: [:y :x | x@ y]).		 ].		canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example14Retina	<script: 'self new example14Retina open setLabel: ''Retina (~o.o)~'''>	| random canvas perlin side angle circleSize ringSize label minR updateValues offset rad val radius |	canvas := RSCanvas new.	canvas color: Color black.	minR := 0.08.	side := 900.	perlin := NSPerlinNoise new.	circleSize := ringSize := 100.	random := Random new.	angle := NSScale linear domain: { 1. circleSize }; range: {0. 360}.	label := RSLabel new 		fontName: 'Source Sans Pro'; 		text: 'Now begin!!'; 		color: Color white;		fontSize: 40.	canvas addShape: label.	(canvas newAnimation 		delay: 2 seconds; 		from: 40; 		to: 12; 		on: label set:#fontSize: ).	(canvas newAnimation 		delay: 2 seconds;		from: Color white; to: Color transparent;		on: label set: #color:) when: RSAnimationEndEvent do: [			label remove.			canvas clearBackground: false].	updateValues := [ 		offset := random rsNext: 90.		rad := random rsNext: minR*side and: 1/ 2 sqrt*side.		val := rad / side * 100.		radius := ((rad / (side /2))-minR)*((perlin noise: val and: 0) abs) * side / 6.	].	updateValues value.		canvas addAll: ((1 to: circleSize) collect: [:m |		RSEllipse new			noPaint;			withBorder;			yourself ]).	canvas newAnimation 		delay: 4 seconds;		loops: ringSize; 		duration: 200 milliSeconds; 	 	when: RSAnimationLoopEvent do: [ :evt | 			updateValues value.			canvas nodes doWithIndex: [ :e :index | 				| theta |				theta := angle scale: index.				e border color: (Color h: theta + offset s: 1 v: 1 alpha: 0.7).				theta := theta degreesToRadians.				e size: radius.				e position: (theta cos @ theta sin) * rad.				 ].		].	canvas when: RSExtentChangedEvent do: [ 		canvas camera zoomToFit: canvas extent extent: side@side ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example15SpaceDandy	<script: 'self new example15SpaceDandy open setLabel: ''Space :D'''>	| random extent diagonal rotation init drawDist canvas shapes |	random := Random new.	extent := 800@600.	diagonal := ((extent x * extent x)+ (extent y* extent y)) sqrt / 2.	rotation := 0.	init := [ :e | | n |		e properties 			at: #l put: 1;			at: #n put: (n := random rsNext: 1 and: extent x/2);			at: #r put: (random rsNext: Float pi * 2);			at: #off put: (random rsNext: 90);			at: #o put: (random rsNext: 1 and: (random rsNext: 1 and: extent x / n ))  ].	drawDist := [ :att | | n o |		n := att at: #n.		o := att at: #o.		(n / o) arcTan * extent x / (Float pi / 2) ].	canvas := RSCanvas new.	canvas color: Color black.	shapes := (1 to: 500) collect: [ :m |		RSEllipse new			color: Color white;			yourself ].	shapes do: [ :e | init value: e ].	canvas addAll: shapes.		canvas addShape: (RSLabel new 		paint: ((LinearGradientPaint fromArray:				{0 -> 'yellow'.				0.35 -> 'orange'.				0.25 -> Color white darker.				0.35 -> 'orange'.				1 -> 'white'})			start: 0@ -150;			stop: 0@130;			yourself);		fontSize: 150;		fontName: 'Brushcrazy DEMO';		withBorder;		bold;		text: 'Pharo';		yourself).	canvas newAnimation 		repeat;		duration: 5 seconds; 		when: RSAnimationLoopEvent do: [ :e| canvas clearBackground: e animation currentLoop odd  ].	canvas newAnimation repeat onStepDo: [ :t|		rotation := rotation - 0.002.		shapes do: [ :e | | l o r d off | 			l := (e propertyAt: #l)+1.			e propertyAt: #l put: l.			r := (e propertyAt: #r) + rotation.			o := e propertyAt: #o.			off := e propertyAt: #off.			d := drawDist value: e properties.						e color: ((Color h: (e properties at: #r) radiansToDegrees+off s: 1 v: 0.5) 				alpha: d / diagonal).			e size: extent x/o/8.			e position: (r cos @ r sin) * d.			e propertyAt: #o put: o - 0.07.			(drawDist value: e properties) > diagonal ifTrue: [ init value: e ].			].		 ].	canvas when: RSExtentChangedEvent do: [ 		canvas camera			zoomToFit: canvas extent 			extent: extent ].	^ canvas.! !!RSAnimationExamples methodsFor: 'examples'!example16Gris	<script: 'self new example16Gris open setLabel: ''Roassal :V'''>	| c label shape border r mini animation g|	c := RSCanvas new.	r := Random new.	border := RSBorder new.	label := RSLabel new		fontName: 'Marker Felt';		text: 'Roassal';		noPaint;		border: border;		fontSize: 30.	c addShape: label.		c addAll: ({0.6. 0.64. 1.05. 1.20. 1.7} collectWithIndex: [ :m :i | | s |		s := RSEllipse new			noPaint;			radius: m * label width;			border: border;			yourself.		i = 5 ifTrue: [ s border: (RSBorder new width: 1.5) ].		i = 4 ifTrue: [ s border: (RSBorder new dashArray: #(4)) ].		s ] ).		c newAnimation repeat from: 0; to: 8; duration: 200 milliSeconds;		on: c nodes fourth border set: #dashOffset:.			mini := [ :m | | s |		s := RSEllipse new			noPaint;			radius: m * 5;			border: (RSBorder new width: 0.5);			yourself.		m = 1 ifTrue: [ s paint: Color black ].		m = 2 ifTrue: [ s radius: m * 6 ].		s ].	animation := [ :s :seconds :target :dir | |  ang |		ang := r next * Float pi * 2.		c newAnimation repeat duration: seconds asSeconds;				from: ang; to: ang + (Float pi * 2* dir);				onStepDo: [ :t | s translateTo: (t cos@t sin) * target radius ] ].				c addAll: ({3-> 3. 4->2} collect: [ :m | | s |		s := RSComposite new			shapes: ((1 to: m value) collect: [ :k | mini value: k ]);			yourself.		animation value: s value: m key * 6 value: (c nodes at: m key) value: 1.		s ] ).	g := (1 to: 4) collect: [ :m | mini value: m ] as: RSGroup.	g first radius: 10.	g second radius: 15.	g third radius: 18.	g fourth radius: 25.	g add: ((mini value: 1) radius: 3).	shape := RSComposite new		shapes: g;		yourself.	c add: shape.	animation value: shape value: 30 value: c nodes fifth value: -1.	animation value: shape shapes fifth value: 10 value: shape shapes fourth value: 1.	c when: RSExtentChangedEvent do: [ c zoomToFit ].	^ c	! !!RSAnimationExamples methodsFor: 'examples'!example17Flor	<script: 'self new example17Flor open setLabel: ''Animation test'''>	| c frame angleSp alphaS hueS dia1 dia2 |	c := RSCanvas new.	frame := 0.	angleSp := 0.	hueS := NSScale linear domain: #(50 200); range: #(250 360).	alphaS := NSScale linear domain: #(50 200); range: #(0.3 1).	dia1 := NSScale linear domain: #(50 180); range: #(90 1).	dia2 := NSScale linear domain: #(-1 1); range: #(5 20).	(0 to: 350 by: 60) do: [ :i | 		(50 to: 170 by: 10) do: [ :m |  | color |			color := Color 				h: (hueS scale: m)				s: 0.8 				v: 1 				alpha: (alphaS scale: m).			c addShape: (RSEllipse new				color: color;				model: i -> m;				yourself).			 ].		 ].	c newAnimation repeat onStepDo: [ :t | 		frame := frame + 1.		angleSp := frame / 250.0 * (Float pi * 2).		c shapes do: [ :s | 			| angle i m dist diameter |			i := s model key.			m := s model value.			angle := (i + (angleSp sin * m)) degreesToRadians.			s position: m * (angle cos @ angle sin).			dist := s position dist: 0@0.			diameter := dia2 scale: (dia1 scale: dist) sin.			s extent: diameter asPoint.	 	].		c signalUpdate.		].	c when: RSExtentChangedEvent do: [ 		c camera zoomToFit: c extent extent: 500 asPoint ].	^ c	! !!RSAnimationExamples methodsFor: 'perlin'!example18Rainbow	<script: 'self new example18Rainbow open setLabel: ''Worms'''>	| canvas random shape mode color frame border |	canvas := RSCanvas new.	canvas clearBackground: false.	canvas color: Color black.	random := Random new.		border := RSBorder new		width: 0.5;		yourself. 	shape := [ | e att xs ys  |		e := RSEllipse new.		e border: border.		att := e properties.		xs := random rsNext: -3 and: 3.		ys := (xs between: -1 and: 1)			ifTrue: [ random next > 0.5				ifTrue: [ random rsNext: 1 and: 3 ]				ifFalse: [ random rsNext: -3 and: -1 ] ]			ifFalse: [ random rsNext: 3 and: -3 ].		att			at: #s put: 0;			at: #t put: 0;			at: #degX put: random next;			at: #degY put: random next;			at: #xs put: xs;			at: #ys put: ys;			at: #hue put: random next * 360;			at: #hue2 put: 4.		e].	mode := 1.	frame := 0.	color := NSScale ordinal		domain: #(0 1 2);		range:			{[ Color black ].			[ :e | Color h: (e propertyAt: #hue) s: 0.7 v: 1 ].			[ :e | 			frame even				ifTrue: [ Color black ]				ifFalse: [ Color h: (e propertyAt: #hue) s: 1 v: 1 ] ]}.	canvas newAnimation repeat		onStepDo: [ :k | 			| shapes |			canvas add: shape value.			frame := frame + 1.			shapes := canvas shapes copy.			shapes do: [ :e | | att t s degX degY xs ys hue hue2|				att := e properties.				t := att at: #t.				s := att at: #s.				degX := att at: #degX.				degY := att at: #degY.				xs := att at: #xs.				ys := att at: #ys.				hue := att at: #hue.				hue2 := att at: #hue2.								e color: ((color scale: mode) rsValue: e).				e border color: (Color h: 360 - (att at: #hue) s: 1 v: 1).				e size: s.								t := t + 0.02.				s := s + 0.2.				e translateBy: ((xs @ ys )+(degX cos@ degY cos)) * t.				degX := degX +  (random rsNext: 0.1 and: 0.8).				degY := degY + (random rsNext: 0.1 and: 0.8).				hue := hue + hue2.				(hue > 360 or: [hue < 0])					ifTrue: [ hue2 := hue2 negated ].				att					at: #t put: t;					at: #s put: s;					at: #degX put: degX;					at: #degY put: degY;					at: #hue put: hue;					at: #hue2 put: hue2.				((Rectangle center: 0@0 extent: canvas extent + 200) 					containsPoint: e position)					ifFalse: [ e remove ]  ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: canvas extent ];		when: RSMouseClick do: [ 			mode := mode +1.			mode > 2 ifTrue: [mode := 0] ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example19Stars	<script: 'self new example19Stars open setLabel: ''Stars'''>	| canvas color random stars |	canvas := RSCanvas new.	random := Random new.	color := NSScale linear domain: #(0 10); range: #('black' 'blue').	canvas addAll: ((1 to: 100) collect: [:m | 		RSBox new			size: 39;			color: (color scale: m-1 // 10);			yourself ]).	RSGridLayout new lineItemsCount: 10; gapSize: 1; on: canvas nodes. 	stars := (1 to: 5) collect: [:m | 		RSShapeFactory star			withBorder;			size: (random rsNext: 10 and: 100);			position:  (random rsNext: 50 and: 300)@ (random rsNext: 50 and: 300);			color: Color white;			yourself ].	canvas addAll: stars.	canvas newAnimation repeat to: 360; onStepDo: [ :t |		stars do: [ :star | | position |			position := star position.			star matrix loadIdentity.			star translateTo: position.			star rotateByDegrees: t ] ].	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example20CircleWaves	<script: 'self new example20CircleWaves open setLabel: ''Waves'''>	| canvas shapes frame |	canvas := RSCanvas new.	frame := 0.			shapes := #('15c108' '8d0402' '0002ab') collect: [:m |		RSPolygon new			noPaint;			border: (RSBorder new				color: ((Color colorFrom: m) alpha: 0.5);				width: 10;				yourself);			yourself ].	canvas addAll: shapes.		canvas newAnimation repeat onStepDo: [ :transition | 		frame := frame + 0.02.		shapes doWithIndex: [ :poly :index | 			| points |			points := RSPolygon				generateUnitNgonPoints: 150				rotation: 0 				angle: [ :a :i | a ]				radius: [ :a :i | | t |					t := frame.					200 + (((a * 8) - ((index * 2 * Float pi) / 3) + t ) cos * 				(((1 + (a - t) cos) / 2) raisedTo: 3) * 32 ) ].			poly 				privatePoints: points;				resetPath			 ] ].	canvas 		when: RSExtentChangedEvent 		do: [ canvas camera zoomToFit: canvas extent extent: 500@500 ].	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example21Lines	<script: 'self new example21Lines open setLabel: ''.=.= Lines =.=.'''>	| canvas frame radius hueOffset angleSp shapes soffset size mult shape |	canvas := RSCanvas new.	canvas color: Color black.	frame := 0.	radius := 200.	hueOffset := 0.	angleSp := 0.	"<globals>"	soffset := nil. size := nil. mult := 0.	"</globals>"	shape := [ :array |		array collect: [ :m | | com ang a line |			com := RSComposite new.			com model: m + soffset.			ang := m degreesToRadians.			a := Float halfPi + ang.			com propertyAt: #offset put: a * size.			line := RSLine new				width: 1.5;				yourself.							com add: line.			com translateTo: ang cos @ ang sin * radius * mult.			com matrix rotateByRadians: a.			com ] ].		soffset := 0. size := 12. mult := 1.	shapes := shape value: (0 to: 359 by: 12).	canvas addAll: shapes.		soffset := 180. size := 8. mult := 0.5.	shapes := shape value: (0 to: 359 by: 5).	canvas addAll: shapes.		soffset := 120. size := 4. mult := 0.5@0.75.	shapes := shape value: (0 to: 359 by: 5).	canvas addAll: shapes."		"soffset := 240. size := 4. mult := 0.75@0.5.	shapes := shape value: (0 to: 359 by: 5).	canvas addAll: shapes.	shapes := canvas nodes.	canvas addShape: (RSLabel new 		text: 'Roassal';		fontSize: 30;		border: (RSBorder new color: Color white);		color: nil).	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1. 		angleSp := frame / 300 * Float twoPi.		hueOffset := hueOffset + 1.		shapes do: [ :s | | pos line |			pos := (angleSp negated + (s propertyAt: #offset)) cos * 30.			line := s shapes first.			line color: (Color h: s model + hueOffset s: 0.6 v: 1).			line endPoint: 0@ pos ].		 ].	canvas when: RSExtentChangedEvent do: [ canvas camera zoomToFit: canvas extent extent: 500 asPoint ].	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example22Lines	<script: 'self new example22Lines open setLabel: ''Line patterns'''>	| canvas radius bar step frame label border |	canvas := RSCanvas new.	canvas color: (Color colorFrom: 'EEEEEE').	radius := 200.	bar := 180.	step := 1.	frame := 0.	border := RSBorder new		color: Color lightGray;		yourself.	canvas addAll: ((0 to: 360 by: 0.5) collect: [ :i |		RSComposite new			model: i;			add: (RSLine new				border: border;				startPoint: bar negated /2 @0;				endPoint: bar / 2 @ 0;				yourself);			yourself ] ).	canvas newAnimation repeat onStepDo: [ :t | 		frame := frame + 4.		canvas nodes do: [ :s | | radian |			radian := s model degreesToRadians.			s matrix 				loadIdentity;				translation: radius * (radian cos@radian sin);				rotateByRadians: radian + (frame * (radian * step * 0.5) sin * 0.05) ]		].	label := RSLabel new 		text: 'Pharo';		fontName: 'Brushcrazy DEMO';		fontSize: 50;		noPaint;		bold;		border: (RSBorder new paint: Color black; dashArray: #(4)).	canvas addShape: label.	canvas newAnimation repeat from: 0; to: 8; on: label border set: #dashOffset:.		canvas when: RSMouseClick do: [		step := step + 0.5.		step > 11 ifTrue: [ step := 1 ] ].	canvas when: RSExtentChangedEvent do: [ canvas camera zoomToFit: canvas extent extent: 640@640 ].	^ canvas	! !!RSAnimationExamples methodsFor: 'perlin'!example23PerlinNoise	<script: 'self new example23PerlinNoise open setLabel: ''Perlin Noise'''>	"inpired by wangyasai Twitter: @yasai_wang"	| canvas random c1 c2 c3 size perlin noiseScale rec |	canvas := RSCanvas new.	rec := Rectangle floatCenter: 0@0 extent: self currentWorld extent.	random := Random new.	size := 200.	noiseScale := 300.	canvas clearBackground: false.	perlin := NSPerlinNoise2 new.	canvas color: (Color colorFrom: '150832').	c1 := '45217C'. c2 := '0799F2'. c3 := 'white'.		canvas addAll: ((1 to: size) collect: [ :i |		| newcircle |		newcircle := [ :col | RSEllipse new			position: (random next* rec width)@(random next * rec height) + rec origin;			size: 0.1 + (i/size);			color: ((Color colorFrom: col) alpha: i*(250 / 255)/ size);			yourself ].		RSComposite new			model: i;			add: (newcircle value: c1);			add: (newcircle value: c2);			add: (newcircle value: c3);			yourself.			 ] ).	canvas newAnimation repeat onStepDo: [ :t | | speed |		speed := 0.4.		canvas nodes do: [ :c |			c shapes do: [ :e |				| angle p dir vel pval |				p := e position.				pval := perlin 					noise: p x / noiseScale					and: p y / noiseScale.				pval := (pval + 1) / 2.				angle := Float twoPi * noiseScale * pval.				dir := angle cos @ angle sin.				vel := dir * speed.				p := p + vel.				(rec containsPoint: p) ifFalse: [ 					p := (random next * rec width )@(random next * rec height) + rec origin ].				e translateTo: p.				].			].		].	^ canvas	! !!RSAnimationExamples methodsFor: 'perlin'!example24RoassalPerlinNoise	<script: 'self new example24RoassalPerlinNoise open extent: 800@500; setLabel: ''Roassal'''>	| canvas density rect maxLife size perlin r color noiseScale sc1 sc2 |	canvas := RSCanvas new.	canvas color: Color black.	canvas clearBackground: false.	r := Random new.	perlin := NSPerlinNoise2 new.	density := 800. maxLife := 10. noiseScale := 800.	rect := Rectangle floatCenter: 0@0 extent: self currentWorld extent.	size := rect width * rect height / density.	color := NSScale ordinal rangeFrom: { '6E39CC'. '0799F2'. 'white'}.	sc1 := NSScale linear domain: {1. size}; range: #(5 1).	sc2 := NSScale linear domain: {1. size}; range: #(1 2).	canvas addAll: ((1 to: size) collect: [:i |		RSEllipse new			size: (sc2 scale: i);			model: i;			propertyAt: #flip put: (r next* 2) asInteger * 2 - 1;			propertyAt: #life put: r next * maxLife;			propertyAt: #color put: (color scale: (r next * 3) asInteger);			position: (r next * rect width)@ (r next * rect height )+ rect origin;			yourself.		]).	canvas newAnimation repeat onStepDo: [ :t |		canvas nodes do: [ :e | 			| life att p flip iterations respawn case fadeRatio colorCase c |			att := e properties.			flip := att at: #flip.			life := att at: #life.			c := att at: #color.			life := life - 0.06667.			respawn := [				e position: (r next * rect width)@ (r next * rect height )+ rect origin.				life := maxLife. ].			life < 0 ifTrue: respawn.			att at: #life put: life.			p := e position-rect origin.			iterations := sc1 scale: e model.			1 to: iterations do: [ :i| | angle dir |				angle := Float twoPi * noiseScale * flip * (perlin 					snoise: p x / noiseScale  					and: p y / noiseScale).				dir := angle cos @ angle sin * 1.2.				p := p + dir.				].			case := p / rect extent.			case := ((case x + case y)/2 *3 )asInteger.			p := p + rect origin.			e position: p.			(rect containsPoint: p) ifFalse: respawn.			fadeRatio := (life * 5) min: 1.			fadeRatio := fadeRatio min: (maxLife - life)*5 / maxLife .			colorCase := NSScale ordinal domain: #(0 1 2); range: { 				[ Color gray: life / maxLife ].				[ c ].				[ (Color 					r: (c blue * 255) + 10					g: (c green * 255)- 20					b: (c red * 255) - 5 range: 255) ]			}.			c := (colorCase scale: case) value.			e color: (c alpha: fadeRatio).			 ]. ].	canvas 		when: RSExtentChangedEvent 		do: [ canvas camera zoomToFit: canvas extent rectangle: rect ].	^ canvas	"morph := v canvas morph.	morph extent: 800@500.	v2 := RSView new.	v2 color: Color black.		v2 addShape: (TSLabel new		text: 'Roassal3';		fontName: 'Impact';		fontSize: 150;		border: (TSBorder new color: Color white trans)).		v2 animation repeat onStepDo: [ :t| | paint |		morph drawOnMockCanvas.		paint := AthensCairoPatternSurfacePaint createForSurface: morph surface.		paint origin: ( -100@ -300) .		v2 shapes first paint: paint.		v2 signalUpdate ].	v2 when: TSExtentChangedEvent do: [ v zoomToFit ].	v2 open extent: 800@500; setLabel: 'Roassal'.	"! !!RSAnimationExamples methodsFor: 'examples'!example25AnimationCircle	<script: 'self new example25AnimationCircle open setLabel: ''Animation Test'''>	| canvas radius  shapes update points lines sc1 sc2 |	canvas := RSCanvas new.	radius := 50.	lines := 1.	canvas addShape: (RSEllipse new		color: Color black;		radius: radius).	shapes := (1 to: 10) collect: [:i | | e |		e := RSEllipse new			model: i; 			index: i;			size: 5;			color: Color white;			yourself.		i = 1 ifTrue: [ e color: Color red ].		i = 2 ifTrue: [ e color: Color green ].		e ].		points := [ :r :i |		| a b slice |		slice := Float twoPi / (lines * 2).		a := (i-1) * slice + Float halfPi.		b := a + Float pi.		a := (a cos @ a sin ) * r.		b := (b cos @ b sin) * r.		a -> b ].	update := [ 		lines := lines + 1.		lines > 10 ifTrue: [ lines := 2 ].		canvas nodes copy do: #remove.		canvas edges copy do: #remove.		shapes do: [ :e | e model: (e index - 1) / (lines*2) ].		1 to: lines do: [ :i| | ab |			ab := points value: radius value: i.			canvas add: (				RSLine new					width: 0.1;					color: Color white;					startPoint: ab key;					endPoint: ab value;					yourself).			canvas add: (shapes at: i).		].	].	update value.	sc1 := NSScale linear range: {0. Float twoPi}.	sc2 := NSScale linear domain: #(-1 1).	shapes do: [ :e | | animation |		animation := canvas newAnimation repeat 			"easing: TSEasing bounceOut;"			duration: 2 seconds; onStepDo: [ :t | 			| val |			val := (e model + t)%1.			val := (sc1 scale: val) cos.			canvas edges size >= e index ifTrue: [ | ab |				ab := points value: radius - 2.5 value: e index.				e position: (sc2 range: { ab key. ab value. };					scale: val).			] ].		e index = 1 ifTrue:[ animation when: RSAnimationLoopEvent do: update ] ].		canvas @ RSCanvasController.	^ canvas	! !!RSAnimationExamples methodsFor: 'lines'!example26Bezier	<script: 'self new example26Bezier open setLabel: ''Bezier Test'''>	| canvas size theta sc borderWhite cpController |	canvas := RSCanvas new.	size := 50.	theta := 0.	canvas color: Color black.	sc := NSScale linear domain: #(-1 1); range: #(0 80).	cpController := RSBlockCPController new		block: [ :line | 			| x1 |			x1 := sc scale: (theta + (line model * 5)) sin.			Array				with: x1 @ 0				with: 100 @ -100				with: 100 @ 50				with: 200 @ -120 ];		yourself.	borderWhite := RSBorder new		color: Color white;		yourself.	canvas addAll: ((1 to: size) collectWithIndex: [ :m :index | 		| com offset edge |		com := RSComposite new.		offset := Float twoPi / size * index.		com matrix rotateByRadians: offset.		edge := RSBezier new			color: Color white;			model: offset;			width: 2;			controlPointsController: cpController;			paint: (Color h: 360 / size * index s: 1 v: 1 alpha: 0.5);			yourself.		edge 			markerEnd: ((RSShapeFactory triangle					extent: 10@20;					color: edge paint;					border: borderWhite;					yourself) asMarker 				offset: -10;				yourself).		com add: edge.		com ]).	canvas newAnimation repeat onStepDo: [ :t | 		theta := theta + 0.0523.		canvas nodes do: [ :com | com shapes first update ] ].	canvas		when: RSExtentChangedEvent		do: [ canvas camera zoomToFit: canvas extent extent: 500 @ 500 ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example27RSLocate	<script: 'self new example27RSLocate open setLabel: ''RSLocation methods'''>	| canvas newBox updateText fixedElement movableElement buttons labeled locate label grad1 grad2 color |	canvas := RSCanvas new.	locate := RSLocation new.	color := RSColorPalette qualitative paired3.	newBox := [ :m | RSBox new			size: 200;			color: (color scale: m);			yourself. ].	label := RSLabel new.	updateText := [ 		label text: 'Offset:', 			(locate offset x printShowingDecimalPlaces: 1),'@',			(locate offset y printShowingDecimalPlaces: 1) ].	updateText value.	fixedElement := newBox value: 1.	movableElement := newBox value: 2.	movableElement size: 40.	movableElement when: RSMouseClick do: [ 		canvas newAnimation			scale: (NSScale linear 				domain: #(0 0.5 1); 				range: { 0@0. 20@20. 0@0});			onStepDo: [ :t | 				locate offset: t.				locate move: movableElement on: fixedElement.				updateText value.				label signalUpdate.				 ]  ].		canvas add: fixedElement; add: movableElement; add: label.	grad2 := (LinearGradientPaint fromArray: 		{0->'white'.		0.25->'black'.		1 ->'lightGray'})		start: 0@ -15;		stop: 0@ 15.	grad1 := (LinearGradientPaint fromArray:		{0->'lightGray'.		0.25->'black'.		1 ->'gray'})		start: 0@ -15;		stop: 0@ 15.	labeled := RSLabeled new.	labeled shapeBuilder: [ :m | RSLabel new text: m asString; color: Color white ].	labeled location middle.	buttons :=  #(outer border inner left center right top middle bottom) collect: [ :t |		RSBox new			border: (RSBorder new color: Color lightGray);			cornerRadius: 5;			extent: 60@30;			paint: grad1;			model: t;			addInteraction: labeled;			when: RSMouseEnter do: [:evt | evt shape paint: grad2; signalUpdate ]; 			when: RSMouseLeave do: [:evt | evt shape paint: grad1; signalUpdate ];			when: RSMouseClick do: [:evt | | p |				evt shape model value: locate.				p := movableElement position.				locate move: movableElement on: fixedElement.				canvas newAnimation					from: p;					duration: 500 milliSeconds;					to: movableElement position;					on: movableElement shape set: #position: ]			] as: RSGroup.	RSGridLayout new lineItemsCount: 3; on: buttons.	RSVerticalLineLayout new center; gapSize: 30; on: (RSGroup with: canvas nodes with: buttons).	canvas addAll: buttons.	canvas when: RSExtentChangedEvent do: [ 		canvas camera zoomToFit: canvas extent * 0.7.		canvas signalUpdate ].		^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example28AlteredWorld	"base on Gerard Ferrandez source code"	"https://codepen.io/ge1doot/details/GQobbq/"	<script:	'self new example28AlteredWorld open setLabel: ''Altered World :V'''>	| canvas extent px perlin r period length |	canvas := RSCanvas new.	r := Random new.	extent := 500 @ 500.	period := 0.01.	length := 400.	canvas clearBackground: false.	canvas color: Color black.	px := 0.	perlin := NSPerlinNoise3 new octaves: 5.	canvas addAll: ((1 to: extent y / 6) collect: [ :m | 			 RSPolyline new				 width: 0.5;				 yourself ]).	canvas newAnimation		loops: extent x;		duration: 50 milliSeconds;		when: RSAnimationLoopEvent do: [ 			canvas edges do: [ :e | 					| x y n points m |					x := px.					y := extent y * r next.					n := perlin noise: x * period and: y * period.					e color:							((Color h: -210 + (n * 600) s: 1 l: 8 * n * n * n) alpha: 0.05).					points := OrderedCollection new.					points add: x @ y.					m := 0.					[ m < length and: [ y between: 0 and: extent y ] ] whileTrue: [ 							n := perlin noise: x * period and: y * period.							x := x + (n * 14) cos.							y := y + (n * 14) sin.							points add: x @ y.							m := m + 1 ].					e shape controlPoints: points ].			canvas signalUpdate.			px := px + 1 ].	canvas when: RSExtentChangedEvent do: [ 		canvas camera			zoomToFit: canvas extent			rectangle: (Rectangle floatCenter: extent / 2 extent: extent) ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example29Tick	<script: 'self new example29Tick open setLabel: ''Can you hear it?'''>	| c slice animation ios g |	c := RSCanvas new.	c color: Color black.	slice := Float twoPi / 16.		ios := (1 to: 16) collect: [:i | 		i even			ifTrue: [ 'I' ]			ifFalse: [ 'O' ] ].	g := ios collect: [ :m | RSLabel new		color: Color gray;		text: m;		yourself ].	g doWithIndex: [ :s :i  | | ang | 		ang := i * slice.		s matrix rotateByRadians: ang + Float halfPi.		s position: (ang cos @ ang sin) * 30.		 ].	c add: (RSComposite new		shapes: g;		yourself).		c addAll: ('TICK' asArray collectWithIndex: [:m :i | | s |		s := RSLabel new			color: Color white;			text: m asString;			yourself.		s position: 0@ ( -60 + (i * 15)).		s]).	(c nodes at: 3) remove.	animation := [:a :b :k | c transitionAnimation 		duration: 700 milliSeconds;		easing: RSEasing bounceOut;		from: a;		to: b;		onStepDo: [ :t | | s |			c nodes first matrix				loadIdentity;				rotateByRadians: t.			s := c nodes first shapes.			(s at: k key) color: Color lightGray.			(s at: k value) color: Color white. ]].	(c animationFrom: { 		(animation value: 0 value: slice value: 10->11).		(animation value: slice value: slice * 2 value: 11->10)}) repeat.		c when: RSExtentChangedEvent do: [ c camera zoomToFit: c extent extent: 120 asPoint ].	^ c	! !!RSAnimationExamples methodsFor: 'perlin'!example30Perlin	<script: 'self new example30Perlin open setLabel: ''Perlin :V'''>	| canvas random frame scIterations scRadius rect extent maxLife perlin noiseScale respawnTop |	random := Random new.	canvas := RSCanvas new.	canvas clearBackground: false.	extent := 500@500.	rect := Rectangle floatCenter: extent/2 extent: extent.	maxLife := 10.	perlin := NSPerlinNoise3 new octaves: 3.	noiseScale := 80.	canvas color: Color black.	scIterations := NSScale linear domain: #(0 100); range: #(5 1).	scRadius := NSScale linear domain: #(0 100); range: #(1 3).		frame := 0.	respawnTop := [ :e | 		e 			propertyAt: #life put: random next* maxLife;			position: random next @ 0 * extent ].			canvas addAll: ((1 to: 100) collect: [:n | | e c1 c2 |		c1 := c2 :=  Color white.		(random next * 3) asInteger = 1 ifTrue: [ 			c1 := Color purple.			c2 := Color cyan ].		e := RSEllipse new.		e size: (scRadius scale: n).		e properties			at: #c1 put: c1;			at: #c2 put: c2;			at: #iterations put: (scIterations scale: n).		respawnTop value: e.		e ]).	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1.				canvas nodes do: [ :e |			| life p heading vel color alpha |			life := e propertyAt: #life.			e propertyAt: #life put: (life := life - 0.01666).			life < 0 ifTrue: [ respawnTop value: e ].			p := e position.			vel := 0@0.			1 to: (e propertyAt: #iterations) do: [ :k | 				| transition angle |				transition := p x / extent x.				angle := (perlin					noise: p x / noiseScale					and: p y / noiseScale) * transition * Float twoPi * noiseScale.				vel := angle cos @ angle sin * 0.2.				p := p + vel. ].			(rect containsPoint: p) ifFalse: [respawnTop value: e].			e position: p.									heading := vel angle / Float twoPi.			heading < 0 ifTrue: [ heading := heading negated ].			color := NSScale linear 				range: { e propertyAt: #c1. e propertyAt: #c2 }; scale: heading.			alpha := life * 5 / maxLife min: 1.			alpha := (maxLife - life * 5 )/ maxLife min: alpha.			e color: (color alpha: alpha).			 ]. ].	canvas when: RSExtentChangedEvent do: [ canvas camera 		zoomToFit: canvas extent		rectangle: rect ].	^ canvas	! !!RSAnimationExamples methodsFor: 'examples'!example31RoundRectagles	"example inspired in paper.js"	<script: 'self new example31RoundRectagles open setLabel: ''Round Rectangles'''>	| canvas mouse extent frame scale color |	canvas := RSCanvas new.	extent := 500@500.	mouse := 0@0.	scale := [ :i | (1- (i / 25)) * 10 ].	color := RSColorPalette sequential blues9.	canvas addAll:  ((1 to: 25) collect: [ :n |		RSBox new			size: 25 * (scale value: n);			cornerRadius: 6 * (scale value: n);			color: (color scale: n);			yourself  ] ).	canvas when: RSExtentChangedEvent do: [ 		canvas camera zoomToFit: canvas extent extent: extent ].	canvas when: RSMouseMove do: [ :evt | mouse := evt position. ].	frame := 0.	canvas newAnimation repeat onStepDo: [ :t |		frame := frame + 1.		canvas nodes doWithIndex: [ :e :index | | pos angle |			pos := e position + ((mouse - e position) / (index + 5)).			angle := e propertyAt: #angle ifAbsentPut: [ 0 ].			angle := angle +(((frame + index) / 10) sin * 7).			e propertyAt: #angle put: angle.			e matrix 				loadIdentity;				translation: pos;				rotateByDegrees: angle.			]].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example32SimpleClock	<script: 'self new example32SimpleClock open setLabel: ''4 gradient corners'''>	| canvas extent half linear color label roassal clock location |	canvas := RSCanvas new.	extent := 800 @ 600.	half := extent / 2.	linear := [ :val :a :b | 	(LinearGradientPaint fromArray: val)		start: a * half;		stop: b * half ].	color := NSScale ordinal range:		{(linear value: {0 -> '7D66E9'. 1 -> 'E664AC'} value: -1 @ 1 value: 1 @ -1).		(linear value: {0 -> '71C1E2'. 0.9 -> Color transparent} value: -1 @ -1 value: 0 @ 1).		(linear value: {0 -> 'EDB259'. 0.9 -> Color transparent} value: 1 @ 1 value: 0 @ -1)}.	canvas addAll: ((1 to: 3) collect: [:i | 		RSBox new			draggable;			extent: extent;			color: (color scale: i);			yourself		]).	label := [:t | RSLabel new		fontSize: 40;		color: Color white;		text: t;		yourself 	].	roassal := label value: 'Roassal3 2019'.	clock := label value: Time now print24.	clock fontSize: 100.	canvas add: roassal.	canvas add: clock.	canvas newAnimation		duration: 500 milliSeconds;		repeat;		when: RSAnimationLoopEvent do: [ clock text: Time now print24 ].	location := RSLocation new		inner;		bottom;		offset: 0 @ -15.	location move: roassal on: canvas nodes.	canvas		addShape: (RSBitmap new form: PolymorphSystemSettings pharoLogoForm).	location		top;		offset: 0 @ 15.	location move: canvas shapes last on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example33AnimatedLayout	<script: 'self new example33AnimatedLayout open setLabel: ''Layouts'''>	| c objects layout update labels shapes color |	c := RSCanvas new.	objects := 1 to: 100.		color := RSColorPalette sequential ylorrd9.	shapes := objects collect: [ :m |		RSBox new			border: RSBorder new;			color: (color scale: m);			size: 10;			model: m;		yourself ].	c addAll: shapes.	RSEdgeBuilder line 		canvas: c;		objects: objects;		connectFrom: [ :value | value //2 ] to: #yourself.	layout := RSLayoutBuilder new.	update := [ :sel | 		layout perform: sel asSymbol.		layout on: shapes.		 ].	update value: #tree.	RSZoomToFitCanvas new animatedZoomToFit: c.	labels := #('grid' 'tree' 'cell' 'horizontalTree' 'cluster' 'circle' 'radial' 'sugiyama').	labels := labels collect: [ :sel |		RSLabel new			isFixed: true;			text: sel capitalized;			when: RSMouseLeave do: [ :evt | evt shape 				color: Color black; 				normal;				signalUpdate ];			when: RSMouseEnter do: [ :evt | evt shape 				color: Color blue; 				underline;				signalUpdate ];			when: RSMouseClick do: [ :evt | | pos1 pos2 |				pos1 := shapes collect: #position.				update value: sel.				pos2 := shapes collect: #position.				c newAnimation onStepDo: [ :t |					shapes doWithIndex: [ :e :i |						e translateTo: ((pos1 at: i) 							interpolateTo: (pos2 at: i) at: t) ].					c zoomToFit ] ] ].	c addAll: labels.	RSHorizontalLineLayout on: labels.	^ c	! !!RSAnimationExamples methodsFor: 'examples'!example34ForceLayout	<script: 'self new example34ForceLayout open'>	| c classes layout |	c := RSCanvas new.	classes := Collection withAllSubclasses collect: [ :cls | | e |		e := RSEllipse new			draggable;			model: cls;			color: Color purple translucent;			size: 10;			yourself.		cls = Collection ifTrue: [ e color: Color red ].		e		 ].	RSEdgeBuilder line		canvas: c;		shapes: classes;		color: (Color purple alpha: 0.2);		connectFrom: #superclass to: #yourself.	c addAll: classes.	layout := RSForceBasedLayout new 		nodes: classes;		edges: c edges;		start;		yourself.	c newAnimation repeat onStepDo: [ :t | 		layout step ].	^ c	! !!RSAnimationExamples methodsFor: 'examples'!example35Roassal	<script: 'self new example35Roassal open'>	| canvas points paint fscale timeSize text |	canvas := RSCanvas new.	text := 'Roassal3'.	points := RSPolygon 		generateUnitNgonPoints: 3		rotation: Float pi.		canvas addShape: (RSPolygon new		cornerRadii: 5;		color: Color red;		points: points;		size: 300;		position: 0@0).	canvas addShape: (RSPolygon new		cornerRadii: 5;		border: (RSBorder new color: Color white; width: 5);		noPaint;		points: points;		position: 0@ -3;		size: 280).		timeSize := 500.	fscale := NSScale linear range: #(130 80).	paint := LinearGradientPaint new 		colorRamp: {0 -> Color white};		start: 0@ -100;		stop: 0@100.	text doWithIndex: [ :char :index | |lbl |		lbl := RSLabel new			text: char;			bold;			fontName: 'Marker Felt';			position: 0@ -40;			border: (RSBorder new color: Color white; width: 3);			paint: paint;			fontSize: 130.		canvas newAnimation			duration: timeSize milliSeconds;			delay: ((index - 1) * timeSize) milliSeconds;			onStepDo: [ :t |				lbl isInACanvas ifFalse: [ canvas addShape: lbl].				lbl fontSize: (fscale scale: t).				paint colorRamp: 					{ 0 -> Color white. 					t -> Color white.					t+0.001->Color transparent.					1 -> Color transparent } ];			when: RSAnimationEndEvent do: [ lbl remove ].		 ].	canvas newAnimation duration: (timeSize * text size) milliSeconds ; when: RSAnimationEndEvent do: [		canvas addShape: (RSLabel new		text:  text;		bold;		position: 5@ -50;		fontName: 'Marker Felt';		color: Color white;		fontSize: 30).		canvas newAnimation			easing: RSEasing elasticOut;			from: -1; to: 0; onStepDo: [ :t |			canvas shapes last matrix shy: t ] ]. 	canvas when: RSExtentChangedEvent do: [ canvas camera zoomToFit: canvas extent * 0.8 extent: 300@300 ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example36Title	<script: 'self new example36Title open setLabel: ''Basic Animation'''>	| c t1 t2 s line1 line2 line3 line4 title desc r1 r2 pad mid marker sum lineAnime p lblbase |	c := RSCanvas new.	t1 := 'Roassal3'.	t2 := 'It is a new agile visualization enginefor Pharo 7 and Pharo 8.'.	lblbase := RSLabel new		color: Color white;		fontSize: 30;		fontName: 'Marker Felt';		withBorder;		yourself.	s := [ :m | lblbase copy text: m ].	desc := t2 lines collect: [:m | s value: m ] as: RSGroup.	RSVerticalLineLayout new		gapSize: 0;		on: desc.	desc := desc asShape.	lblbase fontSize: 25.	title := s value: t1.	RSLocation new 		outer; right; top;		offset: title width / -2 @ -20;		move: title on: desc.		r1 := title encompassingRectangle.	r2 := desc encompassingRectangle.	pad := 15.	mid := (r2 origin + r1 corner)/2. 	marker := RSPieSlice new 		color: Color black;		externalRadius: 5;		alphaAngle: -90;		betaAngle: -90.	line1 := RSPolyline new		cornerRadii: 30;		markerEnd: marker;		controlPoints: {			mid.			(r1 corner x + (pad * 2) ) @ mid y.			r1 topRight + ((pad *2) @ pad negated ).			r1 origin - pad asPoint }.	line2 := RSPolyline new 		markerEnd: marker;		cornerRadii: 50;		controlPoints: { 			mid.			(r2 origin x - (pad*2)) @ mid y.			r2 bottomLeft + ( pad negated * 2 @ pad). 			(r1 corner x @ r2 corner y)  + (pad@pad)}.	line3 := RSPolyline new		cornerRadii: 30;		controlPoints: { 			r1 rightCenter  + ( pad * 3 @ 0).			r1 topRight + (3@ -2 * pad).			r1 topCenter + (0 @ -2 * pad) } .	line4 := RSPolyline new		cornerRadii: 50;		controlPoints: {			r2 leftCenter + (-3 @ 0 * pad).			r2 bottomLeft + (-3 @ 2 * pad).			r2 bottomCenter + (0 @ 2 * pad).		}.	c addShape: line1.	c addShape: line2.	c addShape: line3.	c addShape: line4.	c camera 		zoomToFit: c extent * 0.8 		rectangle: c encompassingRectangle.	sum := [ :line | |cp|		cp := line controlPoints.		(cp first x - cp second x) abs + 		(cp second y - cp third y) abs + 		(cp third x - cp fourth x) abs  ].	lineAnime := [ :line :lbl :pscale :array |		line border dashArray: array.		c newAnimation 			from: 0;			to: (sum value: line);			onStepDo: [ :t | array at: 1 put: t ].		c newAnimation 			duration: 1 second; 			when: RSAnimationEndEvent do: [ c add: lbl ].		c newAnimation			delay: 1 second;			duration: 1 second;			from: 0.05;			to: 1;			onStepDo: [ :t |				lbl matrix loadIdentity;					translation: (pscale scale: t );					scaleBy: t @ 1.  ].	 	].	p := title position.	lineAnime 		value: line1 		value: title		value: (NSScale linear range: {(p x + (title width/2))@ p y. p })		value: { 0. 1000 }.	p := desc position.	lineAnime 		value: line2		value: desc 		value: (NSScale linear range: {(p x - (desc width/2))@ p y. p })		value: { 0. 1000 }.	c newAnimation		delay: 2 seconds;		duration: 1 second;		from: 0; to: 360;		onStepDo: [ :t | marker betaAngle: t - 90.].	^ c.	"TODO add animation to line3 and line4, hide and remove with animation these elements"! !!RSAnimationExamples methodsFor: 'examples'!example37RectangleForceLayout	<script: 'self new example37RectangleForceLayout open'>	| canvas classes layout color |	canvas := RSCanvas new.	color := NSScale category20.	classes := Collection withAllSubclasses collect: [ :cls |		RSBox new			model: cls;			color: (color scale: cls);			size: 10;			yourself ] as: RSGroup.	RSEdgeBuilder line		canvas: canvas;		shapes: classes;		color: (Color blue alpha: 0.5);		connectFrom: #superclass to: #yourself.	canvas addAll: classes.		layout := RSRectangleForceLayout new		nodes: classes;		edges: canvas edges;		start;		yourself.	canvas @ RSSimpleCanvasMonitor.	canvas newAnimation repeat onStepDo: [ :t | layout step. ].	"Apply forces from the window borders to the elements."	canvas when: RSExtentChangedEvent do: [ :evt |		| camera origin corner |		camera := canvas canvas camera.		origin := camera fromPixelToSpace: 0@0.		corner := camera fromPixelToSpace: canvas canvas extent.		layout enclosingRectangle: (origin corner: corner).	].	classes @ (RSDraggableForce new layout: layout).	canvas camera scale: 2.	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example38PerlinRose	<script: 'self new example38PerlinRose open extent: 800@600; setLabel: ''Rose'''>	| canvas offset offsetInc inc m s tau perlin border |	canvas := RSCanvas new.	offset:= 0@0.			"Perlin offset"	offsetInc := 0.006.	"Perlin offset increment"	inc := 1. 				"Perlin increment"	m := 1.005.				"size multiplier"	s := 1.					"Start size of perlin ring"	tau := 6.2831855.		"It is the circle constant relating the circumference of a circle to its linear dimension"	canvas color: Color black.	perlin := NSPerlinNoise3 new. 	perlin octaves: 3.	canvas clearBackground: false.	border := RSBorder new		color: (Color blue alpha: 0.1);		yourself.	canvas addAll: ((1 to: 10) collect: [ :i | 		RSPolygon new 			noPaint			border: border;			yourself]).	canvas newAnimation 		loops: 1000;		duration: 50 milliSeconds;		when: RSAnimationLoopEvent do: [ :evt | 			"Create a series of perlin rings from big to small"			s < 2000 ifTrue: [ 				canvas nodes do: [ :e | | nPoints points |					nPoints := 2* Float pi * s.					nPoints := nPoints min: 500.					points := (1 to: nPoints) collect: [ :i | 						|a p n |						a := i / nPoints * tau.						p := a cos @ a sin.						n := (perlin 							noise: offset x + (p x * inc)							and: offset y + (p y * inc )) * s.						p * n ].					e points: points.					offset := offset + offsetInc.					s := s * m				]			] ifFalse: [evt animation stop].			canvas signalUpdate. ].	^ canvas! !!RSAnimationExamples methodsFor: 'perlin'!example39Duna	<script: 'self new example39Duna  open extent: 1000@700; position: World center - (1000@700 / 2)'>	| canvas extent num color noiseScale perlin c particles |	canvas := RSCanvas new.	extent := 1000@700.	canvas clearBackground: false.	num := 1000.	color := Color purple.	noiseScale := 400. "<<<-- change this"	perlin := NSPerlinNoise3 new. 	perlin octaves: 2."<<<-- also this :D"	c := NSScale linear 		domain: { 0. num/2 };		range: { color alpha: 0.8. color alpha: 0 }.	particles := (1 to: num) collect: [ :n | 		RSEllipse new			size: 1;			isFixed: true;			position: n @ extent y;			color: (c scale: (n - (num / 2)) abs);			yourself ].	canvas addAll: particles.	canvas newAnimation repeat; onStepDo: [ :t | 		particles do: [ :particle | 			| p dir vel  |			p := particle position.			dir := Float twoPi * (perlin 				noise: p x / noiseScale 				and: p y / noiseScale).			vel := dir sin @ dir cos * 0.5.			particle translateBy: vel.			 ].		 ].	^ canvas! !!RSAnimationExamples methodsFor: 'examples'!example40Circles	<script: 'self new example40Circles open'>	| canvas max min gscale alpha scale circleSize vertexSize updateMouse center getSize color frameCount |	canvas := RSCanvas new.	canvas color: Color black.	max := 2500.	min := 100.	gscale := NSScale linear		range: { max@20. min@3 }.	alpha := NSScale linear		domain: { min. max };		range: { 0.6. 0.12 }.	scale := 300.	updateMouse := [ :pos | | offset size |		offset := pos abs.		gscale domain: { 0@0. canvas extent/2 }.		size := gscale scale: offset.		circleSize := size x.		vertexSize := size y.		 ].	center := [ :theta :time | 		| dir distance |		dir := theta cos @ theta sin.		distance := 0.6 + (0.2 * (theta * 6 + (theta * 8 + time) cos ) cos ).		dir * distance * scale. ].	getSize := [ :theta :time | 		| offset |		offset := 0.2 + (0.12 * (theta * 9 - (time * 2) ) cos).		scale * offset		].	color := [ :theta :time |		| th |		th := 8*theta + (time * 2).		Color 			r: 0.6 + (0.4 * th cos)		 	g: 0.6 + (0.4 * (th - (Float pi / 3) ) cos  )			b: 0.6 + (0.4 * (th - (Float pi * 2 / 3) ) cos )			alpha: (alpha scale: circleSize) ].	canvas 		when: RSMouseMove 		do: [ :evt | updateMouse value: evt position ].	updateMouse value: 0@0.	frameCount := 0.	canvas newAnimation		repeat;		onStepDo: [ :t |			frameCount := frameCount + 1.			canvas shapes copy do: #remove.			1 to: circleSize do: [ :ci | 				| time thetaC c circleCenter cSize points |				time := frameCount / 20.				thetaC := ci * Float twoPi / circleSize.				circleCenter := center value: thetaC value: time.				cSize := getSize value: thetaC value: time.				c := color value: thetaC value: time.				points := (1 to: vertexSize) collect: [:vi | 					| thetaV |					thetaV := vi * Float twoPi / vertexSize. 				 	(thetaV cos @ thetaV sin) * cSize + circleCenter 					].									canvas add: (RSPolygon new 					noPaint;					border: (RSBorder new color: c);					points: points;					yourself).				 ].		].	^ canvas ! !!RSAnimationExamples methodsFor: 'perlin'!example41River	<script: 'self new example41River open setLabel: ''River''; extent: 900@200.'>	| extent half c r back rect perlin cScale alphaS inc setParticles |	extent := 900@ 200.	half := extent / 2.	c := RSCanvas new.	c clearBackground: false.	c color: Color black.	r := Random new.	back := RSBox new		color: Color black translucent;		extent: extent;		yourself.	rect := back encompassingRectangle.	perlin := NSPerlinNoise3 new octaves: 3.	cScale := NSScale linear		domain: { half negated y. half y};		range: #(255 0).	alphaS := NSScale linear		domain: { half negated x. half x};		range: #(0.05 0.4).	inc := 0.	setParticles := [ 		c nodes copy do: #remove.		c add: back.		c addAll: ((1 to: 3000) collect: [:i | 			| box |			box := RSBox new				size: 1;				position: (r next @ r next) * extent - half.						box 				color: (Color 					r: 40					g: (cScale scale: box position y)					b: 255					range: 255);				propertyAt: #update put: [ | theta p |					p := box position.					theta := (perlin 						noise: p x * 0.006 + inc						and: p y * 0.004 + inc) * Float twoPi.					p := p + (theta cos @ theta sin * 2).					p x < rect origin x ifTrue: [ p := rect corner x @ p y ].					p x > rect corner x ifTrue: [ p := rect origin x @ p y ].					p y < rect origin y ifTrue: [ p := p x @ rect corner y ].					p y > rect corner y ifTrue: [ p := p x @ rect origin y ].					box translateTo: p				 ].			box 			])  ].	setParticles value.	c		when: RSMouseClick do: setParticles;		when: RSMouseMove do: [ :evt | | alpha |			alpha := alphaS scale: evt position x.			back color: (Color black alpha: alpha) ].	c newAnimation repeat onStepDo: [ :t | 		inc := inc + 0.008. 		c shapes do: [ :node | (node propertyAt: #update) value ]		].	^ c! !!RSAnimationExamples methodsFor: 'lines'!example42OneLine	<script: 'self new example42OneLine open extent: 1112@834; setLabel: ''One line'''>	| canvas line ang1 ang2 radio x1 y1 x2 y2 |	canvas := RSCanvas new clearBackground: false.	canvas color: Color black.	canvas add: (line := RSLine new).	ang1 := 0. ang2 := 0.radio := 200. 	canvas newAnimation repeat onStepDo: [ :t | | nx ny |		line color: (Color h: ang2 radiansToDegrees s: 1 v: 1 alpha: 0.1).		nx := ang2 sin * radio.		ny := ang2 cos * radio.		x1 := nx - (ang1 sin * radio).		y1 := ny - (ang1 cos * radio).		x2 := nx + (ang1 sin * radio).		y2 := ny + (ang1 cos * radio).		line startPoint: x1@y1; endPoint: x2@y2.		ang1 := ang1 + (Float pi / 33).		ang1 > Float twoPi ifTrue: [ ang1 := 0 ].		ang2 := ang2 + (Float pi / 360).		ang2 > Float twoPi ifTrue: [ ang2 := 0 ].		].	^ canvas! !!RSAnimationExamples methodsFor: 'lines'!example43Waves	<script: 'self new example43Waves open		position: 0@20;		color: Color transparent;		setLabel: ''Waves'';		extent: 1600@1000'>	| canvas frame size extent perlin paint height points |	canvas := RSCanvas new.	canvas color: Color transparent.	frame := 0.	size := 100.	extent := 1600@1000.	perlin := NSPerlinNoise2 new.	paint := NSScale linear domain: { 0. size }.	height := NSScale linear range: { extent y* 0.3. extent y* 0.6}.	canvas newAnimation repeat		onStepDo: [ :t |			canvas edges copy do: #remove.			0 to: size do: [ :i | | color |				color := paint scale: i.				color := Color gray: color.				points := (-10 to: extent x + 11 by: 20) collect: [ :x | | y n |					n := perlin noise: x*0.004 y: i * 0.03 z: frame * 0.05.					n := (n + 1) / 2.					y := height scale: n.					x @ y. ].				canvas add: (RSPolyline new					isFixed: true;					width: 2;					borderColor: color;					controlPoints: points;					yourself)				].			frame := frame + 1. ].	^ canvas! !!RSBasicAnimationExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| c b |	c := RSCanvas new.	b := RSBox new		extent: 100@100;		withBorder.	c addShape: b.		c newAnimation 		easing: RSEasing bounce;		from: -100@ -100;		to: 100@100;		on: b set: #position:.	c newAnimation 		from: Color red;		to: Color blue;		on: b set: #color:.	c newAnimation 		from: 0;		to: 10;		on: b border set: 'width:'.	c 		when:RSMouseClick		do: [ c animations do: #pause ];		when: RSMouseDoubleClick 		do: [ c animations do: #continue ].	c clearBackground: false.	^ c! !!RSBasicAnimationExamples methodsFor: 'examples'!example02Sequential	<script: 'self new example02Sequential open'>	| c b animation |	c := RSCanvas new.	b := RSBox new		extent: 100@100;		withBorder.	c addShape: b.		animation := c animationFrom: { 		(c transitionAnimation			from: -100@ -200;			to: 100@130;			on: b set: #position:).		(c transitionAnimation			from: Color red;			to: Color blue;			on: b set: #color:).		(c transitionAnimation 			from: 0;			to: 10;			on: b border set: 'width:')	}.	animation		loops: 2.		c 		when:RSMouseClick		do: [ c animations do: #pause ];		when: RSMouseDoubleClick 		do: [ c animations do: #continue ].	^ c! !!RSBasicAnimationExamples methodsFor: 'examples'!example03Ramp	<script: 'self new example03Ramp open'>	| c b |	c := RSCanvas new.	b := RSBox new		extent: 100@100;		withBorder.	c addShape: b.		c newAnimation		ramp: { 		 	0 -> (0@0).			0.25 -> (200@180).			0.75 -> (-200@ -80).			1 -> (200@0)};		on: b set: #position:.		c 		when:RSMouseClick		do: [ c animations do: #pause ];		when: RSMouseDoubleClick 		do: [ c animations do: #continue ].	^ c! !!RSBasicAnimationExamples methodsFor: 'lines'!example04DashAnimation	<script: 'self new example04DashAnimation open'>	| c box paint form border animation |	c := RSCanvas new.	form := self iconNamed: #eyedropper.	paint := (AthensCairoPatternSurfacePaint 		createForSurface: (AthensCairoSurface 			fromForm: form)).	paint origin: (form extent / 2) negated.	border := RSBorder new		color: Color purple;		dashArray: #(4).	box := RSBox new		paint: paint;		extent: form extent;		border: border;		scaleBy: 3.		c addShape: box.		animation := c newAnimation		repeat;		from: 0;		to: 8;		on: border set: #dashOffset:.	box when: RSMouseClick do: [ :a |		animation isPaused 			ifTrue: [ animation continue ]			ifFalse: [ animation pause ] ].	^ c! !!RSBasicAnimationExamples methodsFor: 'lines'!example05LoopEvent	<script: 'self new example05LoopEvent open'>	| canvas box |	canvas := RSCanvas new.	canvas clearBackground: false.	box := RSComposite new		add: (RSLabel new text: '0');		adjustToChildren;		yourself.	(canvas animationFrom: { 		canvas transitionAnimation })		loops: 3;		when: RSAnimationLoopEvent do: [ :evt | 			box children first text: evt currentLoop.			box position: 0 @ evt currentLoop * 50.			canvas signalUpdate].	canvas add: box.	^ canvas! !!RSBasicAnimationExamples methodsFor: 'lines'!example06Parallel	<script: 'self new example06Parallel open'>	| canvas box1 box2 animation updateWithAngle |	canvas := RSCanvas new.	canvas clearBackground: false.	box1 := RSBox new size: 50; color: (Color red alpha: 0.02).	box2 := RSBox new size: 50; color: (Color blue alpha: 0.02).	updateWithAngle := [ :ang :box | | p |		p := ang degreesToRadians.		p := p cos @ p sin negated * 100.		box position: p.		].	animation := canvas parallelAnimation.	animation addAll: { 		canvas transitionAnimation			from: 90;			to: -90;			onStepDo: updateWithAngle with: box1.		canvas transitionAnimation			from: 90;			to: 270;			onStepDo: updateWithAngle with: box2.		}.	(canvas animationFrom: { 		canvas transitionAnimation			from: 0@100;			to: 0@ -100;			onStepDo: [ :p | box1 position: p. box2 position: p].		animation	}) loops: 2.	canvas add: box1; add: box2.	canvas when: RSMouseClick do: [ :evt | canvas animations do: #toggle ].	^ canvas! !!RSBasicAnimationExamples methodsFor: 'lines'!example07CornerRadius	<script: 'self new example07CornerRadius open'>	| c paint b from to |	c := RSCanvas new.	paint := LinearGradientPaint fromArray: 		{ 0->Color red.		1->Color black }.	paint start: -100 asPoint; stop: 100 asPoint.	b := RSBox new		size: 200;		paint: paint;		cornerRadius: 0;		border: (RSBorder new width: 3).	c add: b.	from := RSCornerRadius new topLeft: 200; bottomRight: 200.	to := RSCornerRadius new topRight: 200; bottomLeft: 200.	c newAnimation		repeat;		duration: 4 seconds;		scale: (NSScale linear 			domain: #(0 0.5 1);			range: #(0 1 0));		onStepDo: [:t | 			b cornerRadius: (from interpolateTo: to at: t).			c signalUpdate.			].	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example01BasicBoxes	<script: 'self new example01BasicBoxes open'>	| c |	c := RSCanvas new.	c addShape: (RSBox new		extent: 100@100;		yourself).	c addShape: (RSBox new		position: 100@100;		color: Color red;		extent: 100@100;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example02BasicEllipses	<script: 'self new example02BasicEllipses open'>	| c |	c := RSCanvas new.	c addShape: (RSEllipse new		extent: 100@100;		yourself).	c addShape: (RSEllipse new		position: 100@100;		color: Color red;		extent: 100@100;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'composite'!example03BasicComposite	<script: 'self new example03BasicComposite open'>	| c com |	c := RSCanvas new.	com := RSComposite new.	com add: (RSBox new		color: (Color gray alpha: 0.4);		extent: 100@100;		yourself).	com add: (RSBox new		position: 100@100;		color: (Color red alpha: 0.4);		extent: 100@100;		yourself).			c addShape: com.		c addShape: (RSEllipse new		color: (Color gray alpha: 0.4);		extent: 100@100;		yourself).	c addShape: (RSEllipse new		position: 100@100;		color: (Color red alpha: 0.4);		extent: 100@100;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'composite'!example04BasicComposite	<script: 'self new example04BasicComposite open'>	| c com |	c := RSCanvas new.	com := RSComposite new.	com add: (RSBox new		color: (Color yellow alpha: 0.5);		position: -50 @ 0;		extent: 50@100;		yourself).	com add: (RSBox new		position: 0 @ 0;		color: (Color red alpha: 0.5);		extent: 50@100;		yourself).			com position: 100@100.		c addShape: com.		c addShape: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 100@100;		yourself).	c addShape: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 20@20;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example05BasicGroup	<script: 'self new example05BasicGroup inspect'>	| g |	g := RSGroup new.	g add: (RSBox new		color: (Color yellow alpha: 0.5);		position: -50 @ 0;		extent: 50@100;		yourself).	g add: (RSBox new		position: 0 @ 0;		color: (Color red alpha: 0.5);		extent: 50@100;		yourself).	g add: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 100@100;		yourself).	g add: (RSEllipse new		color: (Color gray alpha: 0.5);		extent: 20@20;		yourself).	^ g! !!RSBasicShapeExamples methodsFor: 'labels'!example06BasicLabels	<script: 'self new example06BasicLabels open'>	| c label |	c := RSCanvas new.	1 to: 12 do: [ :m | 		| angle theta p|		angle := (m * 360 / 12) degreesToRadians.		theta := angle cos @ angle sin.		p := theta * 100.		label := RSLabel new			color: (Color purple alpha: 0.5);			fontName: 'Source Sans Pro';			fontSize: 20;			text: (Month nameOfMonth: m);			yourself.		angle := angle radiansToDegrees.		angle := angle + ((angle between: 90 and: 270) 			ifTrue: [ 180 ]			ifFalse: [ 0 ] ).				label rotateByDegrees: angle.		label position: p + ((label textWidth/2) * theta).		m even			ifTrue: [ label bold ]			ifFalse: [ label italic ].		c addShape: label.		].	c addShape: (RSEllipse new		color: nil;		withBorder;		radius: 90).	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example07EventsMouseMoveDrag	<script: 'self new example07EventsMouseMoveDrag open'>	| c ellipse update |	c := RSCanvas new.	ellipse := RSEllipse new		radius: 40;		withBorder.	c addShape: ellipse.	update := [ :evt :color |		ellipse 			color: color;			position: evt position;			signalUpdate].	c		when: RSMouseDragging do: [ :evt | 			update value: evt value: (Color colorFrom: '12A288')];		when: RSMouseMove do: [ :evt | 			update value: evt value: (Color colorFrom: 'AB2567') ].	c clearBackground: false.	^ c	! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example08EllipseBorder	<script: 'self new example08EllipseBorder open'>	| c y r |	c := RSCanvas new.	r := Random new.	c color: (Color colorFrom: '325A64').	1 to: 500 do: [ :x|		y := 255 + (x sin * 255).		c addShape: (RSEllipse new			color: Color transparent;			border: (RSBorder new				width: x/ 50;				color: (Color 					r: r next * 255 					g: r next * 200					b: 255					range: y) );			position: (x*2@y)-250;			extent: (y/10)@( x * 75/ 499 ) ).		 ].	"m := c morph.	PolymorphSystemSettings setDesktopLogoWith: m.	m position: 0@World menubar height.	m extent: World extent- (0@World menubar height)."	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example09MouseStep	<script: 'self new example09MouseStep open'>	|  c e prev dif |	c := RSCanvas new.	c color: Color black.	e := RSEllipse new		border: (RSBorder new color: Color white);		radius: 0.	c addShape: e.	prev := 0.	c when: RSMouseMove do: [ :evt | 		dif := (evt position x - prev) abs.		prev := evt position x.		e 			color: (Color r: 0 g: dif b: 0 range: 255);			position: evt position;			size: dif.		c signalUpdate.		 ].	c clearBackground: false.	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example10EllipseMouseMove	<script: 'self new example10EllipseMouseMove open'>	| c border circleResolution angle a b radius p |	c := RSCanvas new.	c color: Color white.	border := RSBorder new color: (Color colorFrom: '002800').	b := 1.	radius := 200.	c when: RSMouseMove do: [ :evt | 		circleResolution := b.		circleResolution isZero ifTrue: [ circleResolution := 0.1 ].		angle := Float twoPi / circleResolution.		p := evt position abs.		a := 175 * p x / c extent x.		b := 200 * p y / c extent y.		c shapes copy do: #remove.		0 to: circleResolution do: [ :i |			c addShape: (RSEllipse new 				color: Color transparent;				rotateByDegrees: 45;				border: border;				extent: ((angle * i) cos @ (angle * i) sin) * radius + a			)].				c signalUpdate.		 ].	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example11ScaleMouseDistance	<script: 'self new example11ScaleMouseDistance open'>	| c easing canvasExtent boxSize zindex maxDist scale border |	c := RSCanvas new.	c color: Color white.	easing := 0@0.	boxSize := 50.	canvasExtent := 500 asPoint.	maxDist := 0@0 dist: canvasExtent.	scale := NSScale linear 		domain: { 0. maxDist}; 		rangeRound: #(80 0).	border := RSBorder new.	c when: RSExtentChangedEvent do: [ 		c shapes copy do: #remove.		canvasExtent := c extent.		maxDist := 0@0 dist: canvasExtent.		scale := NSScale linear 			domain: { 0. maxDist}; 			rangeRound: #(80 0).		0 to: canvasExtent y/boxSize do: [ :y|			0 to: canvasExtent x/boxSize do: [ :x| 				c addShape: (RSBox new 					color: Color white;					position: ((x@y)*boxSize) - (canvasExtent/2);					extent: 10@10;					border: border )				] ]		].	c when: RSMouseMove do: [ :evt | 		easing := easing + ((evt position - easing)* 1).		c shapes copy do: [ :s |			zindex := scale scale: (easing dist: s position).			s extent: boxSize * (zindex /100) asPoint ].		c signalUpdate.	].	c clearBackground: false.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example12BasicLine	<script: 'self new example12BasicLine open'>	| c rotate size angle |	c := RSCanvas new.	angle := 0.	size := 0.	rotate := [ :point | | cos sin p |		cos := angle cos.		sin := angle sin.		"origin"		p := point - ((size @ size)/2).		"rotated"		((p x * cos) - (p y * sin))@((p y * cos) + (p x * sin))	].	c when: RSMouseMove do: [ :evt | 		size := evt position distanceTo: 0@0.		angle := evt position angle + 135 degreesToRadians.		c shapes copy do: #remove.		size := size asInteger.		(0 to: size by: 3) do: [ :k |			| a b |			a := rotate value: k @ 0.			b := rotate value: 0 @ (size - k).			c addShape: (RSLine new				startPoint: a;				endPoint: b;				yourself).		 ].		c signalUpdate.	].		^ c! !!RSBasicShapeExamples methodsFor: 'bitmap'!example14BasicBitmap	<script: 'self new example14BasicBitmap open'>	| c |	c := RSCanvas new.	c addShape: (RSBitmap new		form: (self iconNamed: #eyedropper);		extent: 200@350).			^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example15BasicRoundBoxes	<script: 'self new example15BasicRoundBoxes open'>	| c |	c := RSCanvas new.	c addShape: (RSBox new		cornerRadius: 5;		extent: 100@50).			c addShape: (RSBox new		cornerRadius: (RSCornerRadius new top: 20);		position: 100@100;		extent: 100@50;		withBorder).			^ c! !!RSBasicShapeExamples methodsFor: 'border'!example17Borders	<script: 'self new example17Borders open'>	| c |	c := RSCanvas new.	c addShape: (RSLine new		startPoint: -100@ -100;		endPoint: 100@ -100;		width: 50;		capRound;		yourself).	c addShape: (RSLine new		startPoint: -100@ 0;		endPoint: 100@ 0;		width: 50;		capButt;		yourself).	c addShape: (RSLine new		startPoint: -100@ 100;		endPoint: 100@ 100;		width: 50;		capSquare;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example18BasicPieSlice	<script: 'self new example18BasicPieSlice open'>	| c |	c := RSCanvas new.	"empty"	c addShape: RSPieSlice new.	"circle"	c addShape: (RSPieSlice new		innerRadius: 0;		externalRadius: 100;		alphaAngle: 0;		betaAngle: 360).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example19PieSlice	<script: 'self new example19PieSlice open'>	| c |	c := RSCanvas new.	"slice"	c addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 30;		betaAngle: 90;		segmentSpacing: 5).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example20Donut	<script: 'self new example20Donut open'>	| c |	c := RSCanvas new.	"donut"	c addShape: (RSPieSlice new		withBorder;		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 360).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example21CornerRadii	<script: 'self new example21CornerRadii open'>	| c |	c := RSCanvas new.	"corner radii"	c addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 90;		cornerRadii: 20).	^ c! !!RSBasicShapeExamples methodsFor: 'arcs'!example22BasicPieSlice	<script: 'self new example22BasicPieSlice open'>	| c |	c := RSCanvas new.	"slice"	c addShape: (RSPieSlice new		externalRadius: 100;		alphaAngle: 30;		betaAngle: 90).	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example23FixedShape	<script: 'self new example23FixedShape open'>	| c box |	c := RSCanvas new.	box := RSBox new		extent: 100@100;		position: 200 asPoint;		color: Color blue;		yourself.	box isFixed: true.	c addShape: box.		box := RSBox new		extent: 100@100;		yourself.	c addShape: box.	box setAsFixed.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example24Polyline	<script: 'self new example24Polyline open'>	| c |	c := RSCanvas new.	c addShape: (RSPolyline new		width: 30;		joinRound;"joinBevel; joinMiter"		color: Color blue;		controlPoints: { 50@300. 150@300. 150@200. 250@200. 250@100. 350@100};		basicTranslateBy: -150 @ -150;		yourself).	^ c! !!RSBasicShapeExamples methodsFor: 'labels'!example25LabelWithBorder	<script: 'self new example25LabelWithBorder open'>	| c |	c := RSCanvas new.	c addShape: (RSLabel new		fontSize: 60;		fontName: 'Source Sans Pro';		"fontName: 'Brushcrazy DEMO';"		border: (RSBorder new 			color: Color red;			dashArray: #(4) );		text: 'Roassal Pharo').	^ c! !!RSBasicShapeExamples methodsFor: 'polygons'!example26Polygon	<script: 'self new example26Polygon open'>	| c |	c := RSCanvas new.	c addShape: (RSPolygon new		points: { 100@10. 40@198. 190@78. 10@78. 160@198 };		yourself).	c shapes first translateTo: 0@0.	c showEncompassingRectangles.	c shapes first when: RSMouseDragging do: [:evt |		evt shape translateBy: evt step; signalUpdate].	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example27Markers	<script: 'self new example27Markers open'>	| c arrow axes circle dataLine |	c := RSCanvas new.	arrow := RSPolygon new 		points: { -10@0. 0@ -10. 10@0 };		color: Color black;		size: 10.	circle := RSEllipse new		radius: 2.5;		color: Color red.	axes := RSPolyline new		controlPoints: { 10@10. 10@90. 90@90 }.	dataLine := RSPolyline new 		controlPoints: { 15@80. 29@50. 43@60. 57@30. 71@40. 85@15 }.	axes markerEnd: (axes markerStart: arrow).	dataLine marker: circle.	c addShape: axes.	c addShape: dataLine.	c camera zoomToFit: 250@250.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example29PolylineRadius	<script: 'self new example29PolylineRadius open '>	| c |	c := RSCanvas new.	c addShape: (RSPolyline new		border: (RSBorder new width: 10);		cornerRadii: 50;		controlPoints: { 5@30. 15@30. 15@20. 25@20. 25@10. 35@10} * 50).	c zoomToFit.	^ c! !!RSBasicShapeExamples methodsFor: 'polygons'!example30PolygonWithRadius	<script: 'self new example30PolygonWithRadius open'>	| c |	c := RSCanvas new.	c addShape: (RSPolygon new		cornerRadii: 10;		points: { 100@10. 40@198. 190@78. 10@78. 160@198 };		yourself).	c shapes first translateTo: 0@0.	c showEncompassingRectangles.	c shapes first when: RSMouseDragging do: [:evt |		evt shape translateBy: evt step; signalUpdate].	^ c! !!RSBasicShapeExamples methodsFor: 'boxes and ellipses'!example31BorderAttachPointWithOffset	<script: 'self new example31BorderAttachPointWithOffset open'>	| c s1 s2|	c := RSCanvas new.	s1 := RSEllipse new		size: 30;		yourself.	s2 := RSBox new		size: 50;		yourself.	s2 translateTo: 200@200.	c add: s1; add: s2.	c add: (RSLine new		attachPoint: (RSBorderAttachPoint new			startOffset: 5;			endOffset: 10;			yourself);		from: s1;		to: s2;		yourself).	c nodes @ RSDraggable.	c @ RSCanvasController.	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example32RotateShapeByMouse	<script: 'self new example32RotateShapeByMouse open'>	| c s |	c := RSCanvas new.	s := RSLabel new		text: 'Dehaka';		draggable;		yourself.	c add: s.	s @ RSRotated.	^ c! !!RSBasicShapeExamples methodsFor: 'lines'!example33EdgesBetweenChildren	<script: 'self new example33EdgesBetweenChildren open'>	| c b1 b2 e1 com1 com2 |	c := RSCanvas new.	com1 := RSComposite new.	com1 paint: Color blue translucent.	b1 := RSBox new size: 10.	com1 add: b1.	com1 adjustToChildren.	b1 position: 20@20.	com1 position: 200@0.		com2 := RSComposite new.	com2 paint: Color blue translucent.	b2 := RSBox new size: 10.	com2 add: b2.	com2 adjustToChildren.	b2 position: 50@0.	com2 position: -100@0.		com1 draggable.	com2 draggable.		e1 := RSLine new from: b1; to: b2.	c addAll: { com1. com2. e1 }.	^ c! !!RSBasicShapeExamples methodsFor: 'composite'!example34PaletteVisualization	<script: 'self new example34PaletteVisualization open'>	| c colors shapes compo label composites paletteObject |	"Try 		RSColorPalette qualitative		RSColorPalette sequential	"	paletteObject := RSColorPalette diverging.		c := RSCanvas new.	composites := OrderedCollection new.	paletteObject class selectors do: [ :selector |		colors := paletteObject perform: selector.				shapes := RSGroup new.		shapes addAll: (colors range collect: [ :aColor | RSBox new size: 20; color: aColor ]).				RSHorizontalLineLayout on: shapes.				compo := RSComposite new.		compo shapes: shapes.		c add: compo.		composites add: compo.				label := RSLabel new text: selector.		c add: label.		RSLocation new			left; outer; stick: label on: compo.	].	RSVerticalLineLayout on: composites.	c @ RSCanvasController.	^ c! !!RSBasicShapeExamples methodsFor: 'events'!example35KeyEvents	<script: 'self new example35KeyEvents open setLabel: ''Use the keyboard'''>	| c print down up |	c := RSCanvas new.	down := RSLabel new model: 'DOWN'; text: ''.	up := RSLabel new model: 'UP'; text: ''; position: 0@ 30.	c addAll: { down. up }.	print := [ :evt :s | 		s text: (s model, ': ' , evt keyName,', value: ', evt keyValue asString).		evt signalUpdate  ].	c 		when: RSKeyDown do: [ :evt | print value: evt value: down ];		when: RSKeyUp do: [ :evt | print value: evt value: up ].	^ c! !!RSBasicShapeExamples methodsFor: 'polygons'!example36PolygonAndCanvas	<script: 'self new example36PolygonAndCanvas open setLabel: ''Zoom in or Zoom out'''>	| coords canvas int |	coords := {(13.3540698 @ 52.5346676).	(13.3531445 @ 52.5339734).	(13.347075 @ 52.530959).	(13.343642 @ 52.531777).	(13.3392352 @ 52.5329414).	(13.33869 @ 52.531065).	(13.337552 @ 52.526725).	(13.3278908 @ 52.5276262).	(13.327312 @ 52.524392).	(13.3268118 @ 52.5234332).	(13.326025 @ 52.523974).	(13.31646 @ 52.499445).	(13.330889 @ 52.500452).	(13.331878 @ 52.500556).	(13.33527 @ 52.499405).	(13.334371 @ 52.498542).	(13.335189 @ 52.498098).	(13.33451 @ 52.497572).	(13.33469 @ 52.495098).	(13.336883 @ 52.494522).	(13.33899 @ 52.494246).	(13.345728 @ 52.494409).	(13.345127 @ 52.492168).	(13.3453118 @ 52.4866845).	(13.3497232 @ 52.4870749).	(13.3507406 @ 52.4862916).	(13.3527267 @ 52.4846656).	(13.3529346 @ 52.4841626).	(13.381439 @ 52.4848815).	(13.3846565 @ 52.4848903).	(13.3860099 @ 52.4846622).	(13.386044 @ 52.483165).	(13.386408 @ 52.483036).	(13.386736 @ 52.483048).	(13.386892 @ 52.483063).	(13.3540698 @ 52.5346676)}.	canvas := RSCanvas new.	canvas addShape: (RSPolygon new		points: coords;		color: Color black).	int := RSCanvasController new.	int configuration		minScale: 1000;		maxScale: 10000.	canvas @ int.	^ canvas! !!RSBasicShapeExamples methodsFor: 'polygons'!example37AngleDirection	<script: 'self new example37AngleDirection open setLabel: ''Angle direction in RSPieSlice'''>	| canvas slice magic |	canvas := RSCanvas new.	slice := RSPieSlice new.	slice 		innerRadius: 100;		externalRadius: 150;		alphaAngle: 15;		betaAngle: 180.	canvas add: slice.	canvas add: (RSLine new		startPoint: 0@ -200;		endPoint: 0 @ 200;		dashed;		markerStartEnd: (RSShapeFactory arrow			size: 10);		yourself).	canvas add: (RSLine new		startPoint: -200@ 0;		endPoint: 200 @ 0;		dashed;		markerStartEnd: (RSShapeFactory arrow			size: 10);		yourself).	canvas add: (RSLabel new		text: '0@0';		position: 20@10;		yourself).	magic := 160*0.551784.	canvas add: (RSBezier new		width: 3;		dashed;		markerEnd: (RSShapeFactory arrow			size: 20;			color: Color black);		controlPoints: 			{160@0. 			160@ magic negated. 			magic@ -160. 			0@ -160  };		yourself		).	canvas add: (RSLabel new		text: 'Angle direction';		color: 'blue';		position: 180@ -130;		yourself).	^ canvas! !!RSBasicShapeExamples methodsFor: 'shapes'!example38Interaction	<script: 'self new example38Interaction open'>	| c1 c2 com canvas |	c1 := RSEllipse new		extent: 100 @ 50;		withBorder;		model: 'Click to remove';		popup;		color: Color red translucent;		yourself.	c2 := RSEllipse new		extent: 50 @ 100;		withBorder;		color: Color blue translucent;		yourself.	com := RSComposite new		addAll:			{c1.			c2};		adjustToChildren;		model: 'Draggable';		popup;		draggable;		padding: 10;		color: Color gray translucent;		yourself.	c1		when: RSMouseClick		do: [ :evt | 			c1 remove.			com removeInteractionIfPresent: RSDraggable.			com model: 'Not draggable anymore'.			evt signalUpdate ].	canvas := RSCanvas new.	canvas		add:			(RSEllipse new				color: Color red;				model: 'Reference';				popup;				size: 10;				yourself).	canvas add: com.	canvas @ RSCanvasController.	^ canvas! !!RSBasicShapeExamples methodsFor: 'shapes'!example39YikigeiAnimated	<script: 'self new example39YikigeiAnimated open'>	| c size circles posOffset negOffset |	c := RSCanvas new.	size := 200.	c addAll: (circles := #(magenta yellow red cyan) collect: [ :sel | 	    c add: (RSEllipse new	        size: size;	        color: ((Color perform: sel) alpha: 0.4 );	        yourself).	    ]).	c when: RSMouseMove do: [ :evt | 	    posOffset := (evt position distanceTo: 0@0).	    negOffset := posOffset negated.	    circles first position: posOffset @ 0.	    circles second position: 0 @ posOffset.	    circles third position: negOffset @ 0.	    circles fourth position: 0@negOffset.	    c signalUpdate.	     ].	^ c! !!RSHighlightableExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| canvas shapes color |	canvas := RSCanvas new.		color := RSColorPalette sequential bupu3.	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: 10;			model: m;			draggable;			withBorder;			color: (color scale: m);			yourself.		 ].	RSEdgeBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas edges do: #withBorder.	canvas addAll: shapes.	canvas shapes @ RSHighlightable defaultRed.	RSClusterLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example02ElementEdges	<script: 'self new example02ElementEdges open'>	| canvas shapes interaction color |	canvas := RSCanvas new.	interaction := RSHighlightable defaultRed		withEdges;		yourself.	color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSEdgeBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	canvas edges do: #withBorder.	canvas edges @ RSHighlightable defaultRed.	canvas nodes @ interaction.	RSClusterLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples - animated'!example03Interactive	<script: 'self new example03Interactive open'>	| canvas shapes interaction update color |	canvas := RSCanvas new.		color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSEdgeBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas edges do: #withBorder.	canvas addAll: shapes.	RSClusterLayout on: shapes.		interaction := RSHighlightable defaultRed.	interaction withEdges.	update := [ interaction doHighlight: shapes atRandom ].	update value.	canvas newAnimation repeat when: RSAnimationLoopEvent do: update.		canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples - animated'!example04Interactive	<script: 'self new example04Interactive open'>	| canvas shapes interaction bool update color |	canvas := RSCanvas new.		color := RSColorPalette qualitative accent8.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			popup;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSEdgeBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	RSClusterLayout on: shapes.		interaction := RSHighlightable defaultRed.	bool := true.	update := [		interaction doHighlightShapes: (shapes select: [ :e | bool = e model even ]).		bool := bool not ].	update value.	canvas newAnimation repeat when: RSAnimationLoopEvent do: update.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example05Border	<script: 'self new example05Border open'>	| canvas shapes interaction color |	canvas := RSCanvas new.		color := RSColorPalette sequential blues9.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			popup;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSEdgeBuilder line		shapes: shapes;		canvas: canvas;		connectFrom: [ :n | n // 2 ].	interaction := RSHighlightable new.	interaction highlightBorder: (RSBorder new width: 2).	canvas addAll: shapes.	canvas nodes @ interaction.	RSClusterLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example06IterateNext	<script: 'self new example06IterateNext open'>	| canvas numbers edges layout legendBuilder highlightableForBoxes highlightableForLabels selectedNumber highlightBlock unhighlightAllBlock |	canvas := RSCanvas new.	legendBuilder := RSLegend new container: canvas. 	"Create the view with numbers as elements."	numbers := (1 to: 10) collect: [ :i |		RSBox new			model: i;			size: 30;			labeled;			yourself ] as: RSGroup.	edges := RSEdgeBuilder line		shapes: numbers;		connectFrom: [ :i | i // 2 ].	canvas		addAll: edges;		addAll: numbers.	layout := RSForceBasedLayout new		length: 80;		charge: -300;		nodes: numbers;		edges: edges;		start;		yourself.	canvas newAnimation repeat onStepDo: [ :t | layout step ].	numbers @ (RSDraggableForce new layout: layout).	"Set up highlighting interactions"	highlightableForBoxes := RSHighlightable defaultRed.	highlightableForLabels := RSHighlightable new		propertyKey: #exampleKey;		when: RSHighlightEvent do: [ :evt | evt shape bold ];		when: RSUnHighlightEvent do: [ :evt | evt shape normal ].	highlightBlock := [ :model |		highlightableForBoxes doHighlight: (canvas shapeFromModel: model).		highlightableForLabels doHighlight: (legendBuilder shapes shapeFromModel: model).		selectedNumber := model ].	unhighlightAllBlock := [		highlightableForBoxes unhighlightRecordedShapes: canvas.		highlightableForLabels unhighlightRecordedShapes: canvas ].	"Build a legend with all the numbers"	legendBuilder leyendDo: [ :l |l withBorder; padding: 5 ].	legendBuilder location 		outer; right; offset: 70@ -200.	numbers do: [ :e | 		(legendBuilder text: e model) model: e model  ].	numbers, legendBuilder shapes when: RSMouseClick do: [ :evt | highlightBlock value: evt shape model ].	legendBuilder build.	"Unhighlight all when clicking on background."	canvas when: RSMouseClick do: unhighlightAllBlock.	"Highlight next number when N key is pressed. Initial is nothing"	selectedNumber := 0.	canvas when: RSKeyUp do: [ :evt |		evt keyName = #N ifTrue: [			selectedNumber := (selectedNumber \\ numbers size) + 1.			highlightBlock value: selectedNumber ] ].	^ canvas! !!RSHighlightableExamples methodsFor: 'examples'!example07HighlightButtons	<script: 'self new example07HighlightButtons open'>	| canvas mouseOver selectedButton |	canvas := RSCanvas new.	selectedButton := RSHighlightable defaultRed.	mouseOver:= RSHighlightable new.	mouseOver highlightColor: [ :shape | 		shape model > 5			ifTrue: [ Color purple ]			ifFalse: [ Color blue ] ].	"usefull to combine 2 instances of RSHighlightable"	selectedButton propertyKey: #buttons.	mouseOver highlightShapesButKeep: selectedButton.			canvas addAll: ((1 to: 10) collect: [ :i |		RSBox new			model: i;			@ mouseOver; 			extent: 120@30;			cornerRadius: 3;			when: RSMouseClick do: [ :evt |				mouseOver doUnhighlight: evt shape.				selectedButton doHighlight: evt shape.				evt signalUpdate ];			yourself ] ).	selectedButton doHighlight: canvas nodes first.	RSVerticalLineLayout on: canvas nodes.	canvas @ RSCanvasController.	^ canvas	! !!RSHighlightableExamples methodsFor: 'examples'!example08DependendMethods	<script: 'self new example08DependendMethods open'>	| packagesRegExp packages canvas popup label padding high arrow allClasses allMethods |	packagesRegExp := { 'Roassal3-Shapes'}.	    	packages := packagesRegExp flatCollect: [ :regExp | 		RPackageOrganizer default packages 			select: [ :p | regExp match: p packageName ] ].	canvas := RSCanvas new.	popup := RSPopup new.	label := RSLabeled new highlightable.	padding := 10 asMargin.	high := RSHighlightable new.	arrow := RSShapeFactory arrowedLine		withBorderAttachPoint;		color: Color blue.	packages := packages collect: [ :p | 		| classes pkg |		classes := p definedClasses collect: [ :cls | | methods |			methods := cls methods collect: [ :met |				RSEllipse new					extent: 5 @ met linesOfCode;					@ popup;					@ high;					model: met;					yourself					 ].			RSGridLayout on: methods.			RSComposite new				model: cls;				@ label;				@ popup;				paint: Color white;				children: methods;				padding: padding;				yourself ] as: RSGroup.		pkg := RSComposite new			children: classes;			paint: Color blue translucent;			model: p;			@ popup;			draggable;			yourself.		RSEdgeBuilder orthoVertical 			withVerticalAttachPoint;			canvas: pkg;			shapes: pkg nodes;			connectFrom: #superclass.		RSTreeLayout on: pkg nodes edges: pkg edges.		pkg adjustToChildren;			padding: padding.		pkg ].	canvas addAll: packages.	RSGridLayout on: canvas shapes.	allClasses := canvas shapes flatCollect: #nodes.	allMethods := allClasses flatCollect: #nodes.	high 		when: RSHighlightEvent do: [ :evt | | methods |			methods := allClasses flatCollect: [ :class | 				(class model 					thoroughWhichMethodsReferTo: 						evt shape model selector) 							collect: [ :method | method ] ].			methods := methods collect: [ :met | 				arrow copy					from: evt shape;					to:(allMethods shapeFromModel: met)					 ].			canvas addAll: methods.			canvas propertyAt: #methods put: methods.			 ];		when: RSUnHighlightEvent do: [ :evt | 			(canvas propertyAt: #methods ifAbsent: [ #() ]) do:#remove ].	canvas @ RSCanvasController.	^  canvas ! !!RSHighlightableExamples methodsFor: 'examples'!example09ArrowedLines	<script: 'self new example09ArrowedLines open'>	| canvas interaction color shapes |	canvas := RSCanvas new.	interaction := RSHighlightable new		highlightBorder: (RSBorder new			width: 2;			yourself);		withEdges;		yourself.	color := RSColorPalette diverging rdylbu3.	shapes := (1 to: 20) collect: [ :i |		RSBox new			size: 10;			model: i;			draggable;			withBorder;			color: (color scale: i) ;			yourself ].	RSEdgeBuilder arrowedLine		withBorderAttachPoint;		canvas: canvas;		shapes: shapes;		connectFrom: [ :n | n // 2 ].	canvas addAll: shapes.	canvas nodes @ interaction.	RSClusterLayout on: shapes.	canvas zoomToFit.	^ canvas! !!RSInspectableExample methodsFor: 'examples'!example01SimpleExample	<script: 'self new example01SimpleExample open'>	| canvas boxes inspectable highligtable |	canvas := RSCanvas new.	boxes := Collection withAllSubclasses collect: [ :cls | 		RSBox new			model: cls;			width: (cls instVarNames size * 5 max: 5);			height: (cls numberOfMethods max: 5);			yourself] as: RSGroup.	canvas addAll: boxes.	RSEdgeBuilder line		canvas: canvas;		shapes: boxes;		withVerticalAttachPoint;		connectFrom: #superclass.	RSTreeLayout on: boxes.	RSInspectable reset.	inspectable := RSInspectable new.	highligtable := inspectable highlightable.	highligtable highlightColor: Color green.	inspectable inspectShapeBlock: [ :cls | 		| builder |		builder := RSUMLClassBuilder new.		builder classes: {cls}.		builder build.		builder canvas open ].	"inspectable inspectElementBlock: [ :cls | GTInspector openOn: cls ]."	boxes @ inspectable.	canvas @ RSCanvasController.	^ canvas! !!RSInspectableExample methodsFor: 'examples'!example02Inspect	<script: 'self new example02Inspect inspect'>		| canvas animation lastSize box color |	canvas := RSCanvas new.	color := NSScale category20c.	box := [ :model |		RSBox new			model: model;			color: (color scale: model);			size: 20;		yourself ].		canvas add: (box value: Collection).	lastSize := 0.	animation := nil.	animation := canvas animationFrom: { 		canvas transitionAnimation repeat		easing: RSEasing backOut;		onStepDo: [ :t |			canvas nodes do: [ :shape |				| att a b |				att := shape properties.				a := att at: #old ifAbsentPut: [ shape position ].				b := att at: #new ifAbsentPut: [ shape position ].				shape translateTo: (a interpolateTo: b at: t ) ].			canvas zoomToFit.		];		when: RSAnimationLoopEvent do: [ 			canvas nodes size = lastSize ifTrue: [ 				animation stop.				self inform: 'Done :V!!!!!!' ].			lastSize := canvas nodes size.			canvas nodes do: [ :shape |				shape outgoingEdges ifEmpty: [ | children |					children := shape model subclasses collect: [:cls | box value: cls ].					children do: [ :child | child position: shape position ].					canvas addAll: children ]. ].						canvas edges copy do: #remove.			canvas nodes do: [:shape | shape propertyAt: #old put: shape position ].			RSEdgeBuilder arrowedLine 				canvas: canvas;				connectFrom: #superclass.			canvas nodes do: #updateEdgesOFF.			RSClusterLayout on: canvas nodes.			canvas nodes do: #updateEdgesON.			canvas nodes do: [:shape | shape propertyAt: #new put: shape position. ].		 ]}.	canvas @ RSCanvasController.	^ canvas! !!RSInspectableExample methodsFor: 'examples'!example03Easing	<script: 'self new example03Easing inspect'>	^ RSEasing bounceOut! !!RSLayoutExamples methodsFor: 'layouts'!example01LayoutBasic	<script: 'self new example01LayoutBasic open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := (1 to: 20) collect: [ :m | 		RSBox new			size: m;			position: (1 to: m) sum asPoint -150;			draggable;			color: (m even				ifTrue: Color red				ifFalse: Color blue);			yourself ].	shapes do: [ :s | s color: (s color alpha: 0.5) ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example02Grid	<script: 'self new example02Grid open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		RSBox new			size: cls numberOfMethods;			draggable;			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example03LayoutColorFadingBasic	<script: 'self new example03LayoutColorFadingBasic open'>	| canvas shapes color |	canvas := RSCanvas new.	color := NSScale linear		domain: #(1 20);		range: {Color red. Color green}.			shapes := (1 to: 20) collect: [ :m |		RSBox new			size: m;			position: (1 to: m) sum asPoint -150;			draggable;			color: (color scale: m);			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example04LayoutColorFadingBasic2	<script: 'self new example04LayoutColorFadingBasic2 open'>	| canvas shapes color |	canvas := RSCanvas new.	color := NSScale linear		domain: #(1 10 20);		range: { Color red. Color green. Color blue }";		interpolate: TSColorHSVAInterpolator".			shapes := (1 to: 20) collect: [ :m |		RSBox new			size: m;			position: (1 to: m) sum asPoint -150;			draggable;			color: (color scale: m);			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example05LayoutBasicWithColorFading	<script: 'self new example05LayoutBasicWithColorFading open'>	| canvas shapes minAndMax color |	canvas := RSCanvas new.	minAndMax := Collection withAllSubclasses inject: { 10000 . 0 } into: [ :res :cls | {res first min: cls numberOfMethods . res second max: cls numberOfMethods}].	color := NSScale linear		domain: minAndMax;		range: { Color green . Color red }.	shapes := Collection withAllSubclasses collect: [ :cls |		RSBox new			size: cls numberOfMethods;			draggable;			color: (color scale: cls numberOfMethods);			yourself ].	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas @ RSDraggableCanvas .	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example06TreeLayout	<script: 'self new example06TreeLayout open'>	| c shapes eb |	c := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		RSEllipse new			model: cls;			draggable;			size: 5;			yourself		 ].		c addAll: shapes.	RSNormalizer color		from: (Color gray alpha: 0.5);		to: (Color red alpha: 0.5);		shapes: shapes;		normalize: #numberOfMethods.	RSNormalizer size		shapes: shapes;		normalize: #numberOfMethods.	eb := RSEdgeBuilder line.	eb canvas: c.	eb connectFrom: #superclass.	RSTreeLayout on: shapes.	shapes do: [ :e | e translateBy: 0 @ 0 ].	c @ RSCanvasController.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example07ForceBasedLayout	<script: 'self new example07ForceBasedLayout open'>	| c shapes eb |	c := RSCanvas new.	shapes := RSShape withAllSubclasses collect: [ :cls |		RSEllipse new 			popup;			draggable;			model: cls;			size: 5;			yourself ].	c addAll: shapes.	RSNormalizer size		shapes: c nodes;		normalize: #numberOfMethods.	RSNormalizer color		from: (Color green alpha: 0.5);		to: (Color red alpha: 0.5);		shapes: c nodes;		normalize: #numberOfMethods.	eb := RSEdgeBuilder line.	eb		canvas: c;		moveBehind;		connectFrom: #superclass.	RSForceBasedLayout new		doNotUseProgressBar; 		charge: -350;		on: c nodes.	c @ RSCanvasController.	c zoomToFit.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example08HorizontalTree	<script: 'self new example08HorizontalTree open setLabel: ''Horizontal Tree'''>	| c shapes |	c := RSCanvas new.		shapes := String withAllSubclasses collect: [ :cls | | box lbl |		lbl := RSLabel new			text: cls;			yourself.		box := RSBox new			withBorder;			cornerRadius: (RSCornerRadius new right: 10);			extent: lbl extent + 10.		RSComposite new			draggable;			model: cls;			shapes: (RSGroup with: box with: lbl );			yourself ].	c addAll: shapes.	c @ RSCanvasController.	RSEdgeBuilder orthoHorizontal		markerEnd: (RSMarker new 			offset: 2;			shape: (RSShapeFactory triangle 				color: Color black;				size: 5;				yourself));		attachPoint: RSHorizontalAttachPoint new; 		canvas: c;		shapes: c nodes;		connectFrom: #superclass.	RSHorizontalTreeLayout new on: c nodes.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example09BorderAttachPoint	<script: 'self new example09BorderAttachPoint open setLabel: ''TSShape withAllSubclasses'''>	| c shapes |	c := RSCanvas new.	shapes := RSShape withAllSubclasses collect: [ :cls | 		RSShapeFactory square size: 30; draggable; model: cls; yourself ].	c addAll: shapes.	RSEdgeBuilder arrowedLine 		withBorderAttachPoint;		canvas: c;		connectFrom: #superclass.	RSForceBasedLayout new 		charge: -500; 		on: c nodes.	c @ RSCanvasController.	^ c! !!RSLayoutExamples methodsFor: 'lines'!example10Locate	<script: 'self new example10Locate open'>	| canvas newshape e1 e2 color |	canvas := RSCanvas new.	color := RSColorPalette sequential blues3.	newshape := [ :m |		RSBox new			draggable;			color: (color scale: m) ;			size: 100;			yourself].	e1 := newshape value: 1.	e2 := newshape value: 2.	e2 size: 20.	RSLocation new		offset: 1@ -1;		inner;		bottom;		left;		stick: e2 on: e1.	canvas addAll:{e1. e2}.	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'lines'!example11PaddingInComposite	<script: 'self new example11PaddingInComposite open'>	| canvas shapes |	canvas := RSCanvas new.		shapes := Collection withAllSubclasses collect: [ :cls | | methods |		methods := cls methods collect: [:met | RSBox new color: Color black; size: 5; yourself ].		RSGridLayout on: methods.		RSComposite new			model: cls;			popup;			shapes: methods;			padding: (Margin				left: 50				right: 5				top: 20				bottom: 5);			color: Color blue translucent;			yourself  ].	RSGridLayout on: shapes.	canvas addAll: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'animations'!example12AnimatedForceBasedLayout 	<script: 'self new example12AnimatedForceBasedLayout open'>	| c |	c := RSCanvas new.	c addAll: ((1 to: 100) collect: [:i | RSEllipse new size: 10; model: i]).	RSEdgeBuilder line		canvas: c;		connectFrom: [ :v | v // 2 ].	c @ RSForceLayoutStepping.	^ c! !!RSLayoutExamples methodsFor: 'animations'!example13VisualizeQuatree	<script: 'self new example13VisualizeQuatree open'>	| canvas shapes stepping edges newBox boxes createBoxes colors newLabel |	canvas := RSCanvas new.	shapes := (1 to: 50) collect: [:n | 		RSBox new			size: 30;			labeled;			model: n;			yourself].	edges := RSEdgeBuilder line		shapes: shapes;		connectFrom: [ :i | i // 2 ].	canvas		addAll: edges;		addAll: shapes.	stepping := RSForceLayoutStepping new.	stepping layout		length: 80;		charge: -300.	canvas @ RSCanvasController.	canvas @ stepping.	colors := RSColorPalette sequential pubu9.	newBox := [ :quad :index |		RSBox new			border: (RSBorder new color: Color lightGray translucent; width: 0.5);			extent: quad rectangle extent;			position: quad rectangle floatCenter;			color: ((colors scale: index) alpha: 0.5 );			yourself			 ]. 	newLabel := [ :quad :index |		RSLabel new			text: (quad charge printShowingDecimalPlaces: 1);			position: quad rectangle floatCenter;			yourself.		 ].	boxes := #().	createBoxes := nil.	createBoxes := [ :quad :lvl | | box label |		box := newBox value: quad value: lvl.		label := newLabel value: quad value: lvl.		quad subQuadsDo: [ :subQuad | createBoxes value: subQuad value: lvl + 1 ].		boxes add: box.		boxes add: label.		].	canvas newAnimation		repeat;		duration: 500 milliSeconds;		when: RSAnimationLoopEvent do: [ :v | 			boxes do: #remove.			boxes := RSGroup new.			createBoxes value: stepping layout currentQuadtree value: 0.			canvas addAll: boxes.			boxes pushBack ].	^ canvas! !!RSLayoutExamples methodsFor: 'lines'!example15SimpleClassHierarchy	<script: 'self new example15SimpleClassHierarchy open'>	| c methods |	c := RSCanvas new.	GoferOperation withAllSubclassesDo: [ :cls |		| composite label |		methods := cls methods collect: [ :m | RSBox new color: Color red; size: 5; model: m; yourself ] as: RSGroup.		methods @ (RSPopup text: #selector).				RSGridLayout on: methods.		composite := RSComposite new.		label := RSLabel new text: cls name.		RSLocation new above; move: label on: methods.		composite shapes:  methods, { label }.				composite color: Color gray.		composite model: cls.		composite @ RSAnimatedPopup @ RSDraggable.		composite padding: 10.		c add: composite ].	RSEdgeBuilder line		canvas: c;		withVerticalAttachPoint;		color: Color blue;		connectFrom: #superclass.	RSTreeLayout on: c nodes.	"Making sure we have zooming"	c @ RSCanvasController.	^ c ! !!RSLayoutExamples methodsFor: 'lines'!example16SimpleClassHierarchy	<script: 'self new example16SimpleClassHierarchy open'>	| c |	c := RSCanvas new.	Collection withAllSubclassesDo: [ :cls |		| box |		box := RSBox new.		box model: cls.		box height: (cls numberOfMethods max: 5).		box width: ((cls instVarNames size * 4) max: 5).		box @ RSPopup @ RSDraggable.		c add: box.		 ].	RSEdgeBuilder line		canvas: c;		withVerticalAttachPoint;		color: Color blue;		connectFrom: #superclass.	RSTreeLayout on: c nodes.	c @ RSCanvasController.	^ c ! !!RSLayoutExamples methodsFor: 'animations'!example17ForceBasedLayout	<script: 'self new example17ForceBasedLayout open'>	| canvas shapes stepping edges  layout |	canvas := RSCanvas new.	shapes := (1 to: 10) collect: [ :m | 		RSBox new 			size: 30;			draggable;			labeled;			model: m;			yourself ].	edges := RSEdgeBuilder line		shapes: shapes;		connectFrom: [ :i | i // 2 ].	canvas		addAll: edges;		addAll: shapes.	stepping := RSForceLayoutStepping new.		(layout := stepping layout)		length: 80;		charge: -300.	canvas @ stepping.	canvas edges do: [ :edge | 		(layout mockEdgeAt: edge) 			length: (edge model key + edge model value) * 10 ].	canvas @ RSCanvasController.		^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example18Cluster	<script: 'self new example18Cluster open'>	| canvas shapes |	canvas := RSCanvas new.	canvas addAll: (#(linear sqrt log) collect: [ :scale | 		| group |		group := RSGroup new.		shapes :=  GLMBrickedMorph withAllSubclasses collect: [ :cls |			RSEllipse new 				size: 5;				draggable;				color: Color red;				model: cls;				yourself ].		group addAll: shapes.		RSEdgeBuilder line			color: Color blue translucent;			canvas: group;			shapes: shapes;			connectFrom: #superclass.				RSNormalizer size			scale: (NSScale perform: scale);			from: 1;			to: 30;			shapes: shapes;			normalize: #numberOfMethods.		RSNormalizer color			scale: (NSScale perform: scale);			from: Color blue;			to: Color red;			shapes: shapes;			normalize: #numberOfMethods.		RSClusterLayout on: shapes.		RSComposite new			color: Color veryLightGray translucent;			model: scale;			labeled;			draggable;			shapes: group;			yourself.		]).	RSGridLayout new gapSize: 20; on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSLayoutExamples methodsFor: 'layouts'!example19AutomaticLayoutWhenWindowIsResized	<script: 'self new example19AutomaticLayoutWhenWindowIsResized open'>	| classes shapes c eb |	classes := { 'Roassal3-Layouts'. 'Roassal3' }		flatCollect: [:pkgname | (RPackage organizer			packageNamed: pkgname) definedClasses ].	shapes := RSGroup new.	classes do: [ :cls | shapes add: (RSEllipse new model: cls) ].	c := RSCanvas new.	c addAll: shapes.	eb := RSEdgeBuilder orthoVertical.	eb canvas: c.	eb connectFrom: #superclass.	RSNormalizer size		shapes: shapes;		normalize: [ :cls | cls numberOfMethods + 5 ].	RSTreeLayout on: shapes.	^ c @ RSCanvasController @ RSHierarchyPacker! !!RSShapeExamples methodsFor: 'shapes'!example01BasicShape	<script: 'self new example01BasicShape open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := (1 to: 20) collect: [ :m |		RSBox new			size: m;			position: (1 to: m) sum asPoint - 150;			color: (m even				ifTrue: Color red				ifFalse: Color blue);			yourself		 ].	canvas addAll: shapes.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example02BasicEdge	<script: 'self new example02BasicEdge open'>	| canvas box |	canvas := RSCanvas new.		box := RSBox new		size: 100;		draggable;		position: -100@150;		yourself.	canvas add: box.	canvas add: (		RSLine new			from: box;			to: 0@0;			color: Color red;			yourself).	canvas add: (		RSLine new			startPoint: 100@100;			endPoint: 150@150;			yourself).	^ canvas	! !!RSShapeExamples methodsFor: 'lines'!example04LineDashes	<script: 'self new example04LineDashes open'>	| canvas dashes |	canvas := RSCanvas new.		dashes := #(		#()			"no dashes no gaps"		#(4) 			"Dashes and gaps of the same size"		#(4 1)		"Dashes and gaps of different sizes"		#(4 1 2) 	"Dashes and gaps of various sizes with an odd number of values"		#(4 1 2 3)	"Dashes and gaps of various sizes with an even number of values"		) doWithIndex: [ :array :k |		canvas add: (RSLine new			dashArray: array;			from: -15@ (k*2);			to: 15 @(k*2);			yourself) ] .	canvas camera 		scale: 10;		position: 0@5.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example05CapStyles	<script: 'self new example05CapStyles open'>	| canvas dot styles ann |	canvas := RSCanvas new.	dot := [ :position | 		RSEllipse new			color: Color darkGray;			position: position;			radius: 5;			yourself	].	styles := #('capButt' 'capRound' 'capSquare').	styles doWithIndex: [ :style :i| 		| d1 d2 line |		d1 := dot value: -100@(i*30).		d2 := dot value: 100@(i*30).		line := RSLine new			width: 20;			color: Color lightGray;			from: d1;			to: d2;			yourself.		line perform: style asSymbol.		canvas add: line; add: d1; add: d2.		 ].	canvas nodes first @ RSDraggable.	ann := canvas nodes first announcer.	canvas nodes do: [ :s | s announcer: ann ].	^ canvas	! !!RSShapeExamples methodsFor: 'normalizer'!example07NormalizeColor	<script: 'self new example07NormalizeColor open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls |		RSBox new			model: cls;			draggable;			"size: cls numberOfMethods;"			popup;			yourself ].	RSNormalizer color		shapes: shapes;		normalize: #numberOfMethods.	RSNormalizer size		scale: NSScale sqrt;		shapes: shapes;		normalize: #numberOfMethods.	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas camera position: canvas shapes encompassingRectangle center.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit; signalUpdate ].	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example08Labels	<script: 'self new example08Labels open'>	| canvas shapes random |	canvas := RSCanvas new.	random := Random new.		shapes := Collection withAllSubclasses collect: [ :cls |		RSLabel new			draggable;			text: cls;			model: cls;			translateTo: (random rsNext: 300) @ (random rsNext: 300);			yourself ].	canvas addAll: shapes.	RSNormalizer fontSize		shapes: shapes;		to: 30;		normalize: #numberOfMethods.	RSNormalizer color		shapes: shapes;		normalize: #numberOfMethods.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example09Polyline	<script: 'self new example09Polyline open'>	| canvas box box1 line box2 |	canvas := RSCanvas new.	box := [ RSBox new 		size: 100;		draggable;		yourself ].	box1 := box value.	box1 translateBy: 150@150.	box2 := box value.	box2 translateBy: -200@200.	canvas add: box1; add: box2.	line := RSPolyline new		color: Color red;		controlPointsController: (			RSCustomCPController new				models: { 					box1. 					0@0. 					[ box1 position x@ box2 position y ].					box2 };				yourself).	canvas add: line.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example10Donut	<script: 'self new example10Donut open'>	| data radius color canvas border |	"1800 ellipses"	data := 0 to: 358 by: 2.	canvas := RSCanvas new.	radius := NSScale linear		domain: #(1 10);		range: #(180 240).	color := NSScale linear		domain: #(1 7 10);		range: #('brown' '4682b4' 'brown').	border := RSBorder new.	1 to: 10 do: [ :i |		canvas addAll: (data collect: [ :a | 			| d |			d := a degreesToRadians.			RSEllipse new				radius: 4.5;				color: (color scale: i);				border: border;				position: (radius scale: i) * (d cos @ d sin);				yourself ]).		 ].	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example11ClassTree	<script: 'self new example11ClassTree open setLabel: ''Collection withAllSubclasses'''>	| canvas shapes |	canvas := RSCanvas new.	"canvas showEncompassingRectangles."	shapes := Collection withAllSubclasses collect: [ :cls |		| group label s methods|		group := RSGroup new.		methods := cls methods collect: [ :met|			RSBox new				model: met;				popupText: #selector;				size: met linesOfCode;				yourself ].		RSGridLayout on: methods.		s := RSComposite new			color: (Color lightGray alpha: 0.4);			shapes: methods;			yourself.		s extent: s extent + 10.		label := RSLabel new			text: cls;			yourself.		group add: label; add: s.		RSVerticalLineLayout new alignCenter on: group.		RSComposite new			shapes: group;			model: cls;			draggable;			popup;			yourself  ].	canvas addAll: shapes.	RSEdgeBuilder line		canvas: canvas;		objects: Collection withAllSubclasses;		connectFrom: #superclass.	canvas edges pushBack.	RSTreeLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example12Polygons	<script: 'self new example12Polygons open setLabel: ''Polygon shapes'''>	| canvas color border |	canvas := RSCanvas new.	color:= RSGradientPalette gradient21.	border := RSBorder new paint: Color black; width: 2.	#('diamond' 'square' 'heptagon' 'hexagon' 	'octagon' 'pentagon' 'rhomboid' 'star'	'triangle' 'vee' 'plus' 'arrow'	"not polygons" 'box' 'circle') do: [ :selector| 		| shape gradient |		gradient := color scale: selector.		gradient			start: -50 asPoint;			stop: 50 asPoint.		shape := (RSShapeFactory perform: selector asSymbol)			size: 100;			model: selector;			popup;			color: gradient;			border: border.		canvas add: shape		 ].	RSGridLayout new gapSize: 50; on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example13Arrow	<script: 'self new example13Arrow open setLabel: ''You can do it'''>	| canvas polygon labels paint |	canvas := RSCanvas new.	paint := (LinearGradientPaint fromArray:			{0 -> 'CC2A49'.			0.25 -> 'F99E4C'.			0.50 -> 'F36F38'.			0.75 -> 'EF4648'.			1 -> '582841'})		start: -125 asPoint;		stop: 125 asPoint.		polygon := RSPolygon new		points: 			{100@0. 200@100. 			160@100. 160@ 250.			40@ 250. 40@100.			0@ 100			};		cornerRadii: 7.77;		paint: paint;		yourself.	canvas add: polygon.		labels := #('Keep' 'calm' 'and' 'roassal' 'on') collectWithIndex: [ :t :index |		RSLabel new			fontSize: (index = 3 ifTrue: 10 ifFalse: [ 20 ]);			bold;			color: Color white;			text: t asUppercase;			yourself		].	canvas addAll: labels.	RSVerticalLineLayout new alignCenter on: labels.	labels asGroup translateBy: 50@50.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example14Marker	<script: 'self new example14Marker open'>	| canvas  shapes line arrow |	canvas := RSCanvas new.	shapes := (1 to: 2) collect: [ :n |		RSEllipse new			model: n;			draggable;			size: 100;			yourself ].	arrow := RSShapeFactory triangle 		color: Color white;		border: (RSBorder new color: Color red; width: 3);		size: 20;		yourself.	line := RSLine new		markerEnd: (RSMarker new 			shape: arrow; 			offsetRatio: 0.5; 			offset: 10;			yourself); 		from: shapes first;		to: shapes second;		yourself.	canvas addAll: shapes.	canvas add: line.	RSFlowLayout on: shapes.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example16Bezier	<script: 'self new example16Bezier open'>	| canvas box1 box2 line |	canvas := RSCanvas new.	canvas addShape: (RSBezier new		color: Color red;		controlPoints:			{(0 @ 0).			(100 @ 100).			(200 @ 0).			(300 @ 100)};		yourself).	box1 := RSBox new 		draggable; 		size: 100; 		color: Color blue;		translateTo: 100@ -200; 		yourself.	box2 := RSBox new		draggable;		size: 100;		yourself.	canvas		add: box1;		add: box2.			line := RSBezier new		withVerticalAttachPoint;		from: box1;		controlPointsController: RSVerticalCPAPController new;		to: box2;		yourself.	canvas add: line.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example17Labeled	<script: 'self new example17Labeled open'>	| canvas e1 e2 s line label |	canvas := RSCanvas new.	s := [ :m | 		RSEllipse new			border: RSBorder new; 			draggable;			labeled;			size: 20;			model: m;			yourself].	e1 := s value: 'hello'.	e2 := s value: 'world'.	e2 translateTo: 60@80.		label := RSLabeled new.	label location inner; middle.	label shapeBuilder textBlock: 'lining up!!'.	line := RSShapeFactory arrowedLine		addInteraction: label;		color: Color red;		from: e1;		to: e2;		yourself.	canvas add: e1; add: e2; add: line.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example19Bitmap	<script: 'self new example19Bitmap open'>	| canvas shapes icons |	icons := Smalltalk ui icons icons associations sorted: [:a :b | a key < b key].	canvas := RSCanvas new.	shapes := icons collect: [ :icon|		RSBitmap new			form: icon value;			model: icon;			popupText: #key;			when: RSMouseClick do: [ :evt |				Clipboard clipboardText: evt shape model key.				self inform: 'Copied icon name' ].  ].	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example20Highlightable	<script: 'self new example20Highlightable open'>	| canvas shapes labeled |	canvas := RSCanvas new.	labeled := RSLabeled new.	labeled highlightable.	shapes := #('Hello' 'World') collect: [ :m | 		RSEllipse new			color: Color blue;			draggable; 			addInteraction: labeled;			size: 20;			model: m;			yourself ].	canvas addAll: shapes.	RSHorizontalLineLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example21MenuActivableOnElement	<script: 'self new example21MenuActivableOnElement open'>	| canvas boxes |	canvas := RSCanvas new.	boxes := (1 to: 100) collect: [ :n |		RSComposite new			color: Color blue translucent;			shapes: { RSLabel new text: n; yourself };			size: 30;			yourself ] as: RSGroup.	canvas addAll: boxes.	boxes @ RSHighlightable defaultRed.	RSGridLayout on: boxes.	boxes @ (RSMenuActivable new		menuDo: [ :menu :box | 			menu 				add: 'Inspect'				target: box				selector: #inspect				argument: #() ]).	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'lines'!example22ScaleEvents	<script: 'self new example22ScaleEvents open setLabel: ''Horizontal Tree'''>	"Zooming preserve the size of the red arrow"	| canvas |	canvas := RSCanvas new.	canvas addAll: (ArrayedCollection withAllSubclasses collect: [:cls |		| label box | 		label := RSLabel new			text: cls;			yourself.		box := RSBox new			withBorder;			cornerRadius: (RSCornerRadius new right: 10);			extent: label extent + 5.		RSComposite new			draggable;			model: cls;			shapes: {box. label};			yourself]).		canvas @ RSCanvasController.	RSEdgeBuilder orthoHorizontal		markerEnd: (RSMarker new 			offset: 6;			shape: (RSShapeFactory triangle 				color: Color red;				size: 10;				yourself));		attachPoint: RSHorizontalAttachPoint new; 		border: (RSBorder new);		canvas: canvas;		shapes: canvas nodes;		connectFrom: #superclass.	canvas edges first @ RSKeepBorderWidthRatio. 	canvas edges first @ RSKeepMarkersSizeRatio.	RSHorizontalTreeLayout new on: canvas nodes.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example24Highlightable	<script: 'self new example24Highlightable open'>	| canvas shapes interaction |	canvas := RSCanvas new.	interaction := RSLabeled new.	interaction shapeBuilder: [:str | 		| g title box |		title := RSLabel new text: str; yourself.		box := RSBox new			withBorder;			extent: title textWidth @ 3;			yourself.		g := { title. box }.		RSVerticalLineLayout new alignCenter; gapSize: 0; on: g.		g asGroup asShape].	interaction highlightable.	interaction target: [ :e | e shapes first ].	shapes := #('Hello' 'World') collect: [:str | 		RSEllipse new			color: Color blue;			model: str;			addInteraction: interaction;			draggable;			size: 20;			yourself ].	canvas addAll: shapes.	RSHorizontalLineLayout on: shapes.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example26AnimatedPopup	<script: 'self new example26AnimatedPopup open'>	| canvas interaction s box |	canvas := RSCanvas new.	interaction := RSAnimatedPopup new.			s := [:model |		RSBox new			size: 100;			model: model;			addInteraction: interaction;			translateTo: 100 asPoint;			isFixed: true;			yourself.		].	box := s value: 'Fixed'.	canvas add: box.		box := s value: 'Not Fixed'.	box color: Color red.	box isFixed: false.	canvas add: box.		^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example27MultilineLabelBasic	<script: 'self new example27MultilineLabelBasic open'>	| canvas shapeBuilder |	canvas := RSCanvas new.	shapeBuilder := RSMultilineLabelBuilder new.	shapeBuilder labelShape		font: 20;		italic.	canvas add:(shapeBuilder shapeFor: '"tu est loin, très loin de tous ces regards vicieux qui s''alimentent de ta lumière"').	canvas nodes when: RSMouseClick do: [ :evt | canvas nodes last inspect ].	canvas showEncompassingRectangles.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example28MultilineLabel	<script: 'self new example28MultilineLabel open'>	| canvas shapes |	canvas := RSCanvas new.	shapes := RSShape withAllSubclasses collect: [ :cls | 		| methods |		methods := cls methods collect: [ :met | 			RSBox new				model: met;				size: 20;				popup;				when: RSMouseClick do: [ :evt | evt shape inspect ];				yourself			 ].		RSGridLayout on: methods.		RSComposite new			model: cls;			shapes: methods;			padding: 10;			color: (Color purple alpha: 0.3 );			draggable; 			popup;			yourself ].	RSEdgeBuilder orthoVertical		withVerticalAttachPoint;		canvas: canvas;		shapes: shapes;		connectFrom: #superclass.	canvas addAll: shapes.	RSTreeLayout on: shapes.	canvas @ RSCanvasController.	^ canvas.! !!RSShapeExamples methodsFor: 'shapes'!example29AntAnimation	<script: 'self new example29AntAnimation open setLabel: ''Move mouse on one box'''>	| canvas shapes labelInt highInt popupMethod |	canvas := RSCanvas new.	labelInt := RSLabeled new.	labelInt shapeBuilder: [ :model |		 RSLabel new 			color: Color white; 			text: model;			yourself ].	highInt := RSHighlightable new setupAntAnimation yourself.	popupMethod := RSPopup text: #selector.	shapes := String withAllSubclasses collect: [ :cls | | methods |		methods := cls methods collect: [ :met |			RSBox new				color: Color green;				model: met;				addInteraction: popupMethod;				size: met linesOfCode ].		RSGridLayout on: methods.		RSComposite new			color: Color white translucent;			model: cls;			shapes: methods;			padding: 10;			popup;			draggable;			addInteraction: labelInt;			addInteraction: highInt;			yourself ].	canvas color: PharoDarkTheme new backgroundColor.		canvas addAll: shapes.		RSEdgeBuilder line		color: Color white;		withVerticalAttachPoint;		canvas: canvas;		connectFrom: #superclass.	canvas edges pushBack.	RSTreeLayout new 		verticalGap: 100;		on: shapes.	canvas @ RSCanvasController.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example30EdgesToChildren	<script: 'self new example30EdgesToChildren open'>		| canvas color shape parent1 parent2 edge |	canvas := RSCanvas new.	color := NSScale category20b.	shape := [ :model | 		RSComposite new			color: (color scale: model);			shapes: { 				RSEllipse new					color: (color scale: model + 2);					size: 20;					yourself };			draggable;			padding: (Margin 				left: 100				right: 10				top: 100				bottom: 10);			yourself. ].	parent1 := shape value: 1.	parent2 := shape value: 2.	parent1 translateTo: 100@100.	edge := RSLine new		width: 2;		color: Color red;		from: parent1 shapes first;		to: parent2 shapes first;		yourself.	canvas newAnimation		repeat;		from: 0;		to: 360;		onStepDo: [:t | | p |			p := parent1 position.			parent1 matrix				loadIdentity;				rotateByDegrees: t.			parent1 translateTo: p].	canvas add: parent1; add: parent2; add: edge.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example31BasicGrapher	<script: 'self new example31BasicGrapher open'>	| classes canvas line shapes color |	classes := Collection withAllSubclasses.		canvas := RSCanvas new.	line := RSPolyline new 		width: 2;		controlPoints: { 0@ -600. 0@0. 600@0 };		markerStartEnd: (RSShapeFactory triangle			size: 20;			color: Color black;			yourself);		yourself.		color := RSColorPalette sequential orrd9.	shapes := classes collect: [ :cls |		RSEllipse new			model: cls;			popup;			browseable;			withBorder;			color: (color scale: cls);			yourself ].	canvas addAll: shapes.	canvas add: line.	RSNormalizer size		from: 5;		to: 20;		shapes: shapes;		normalize: [ :cls | cls instVarNames size ].		RSNormalizer position		from: 0@0;		to: 600@ -600;		shapes: shapes;		normalize: [ :cls | cls numberOfMethods @ cls linesOfCode ].	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example32RSLabeledOnComposite	<script: 'self new example32RSLabeledOnComposite open'>	| canvas shapes labeled |	canvas := RSCanvas new.	labeled := RSLabeled new.	labeled location middle.	shapes := (1 to: 20) collect: [:n| 		RSBox new			withBorder;			model: n;			@ labeled;			popup; draggable;			size: 50;			yourself		] as: RSGroup.	RSGridLayout on: shapes.	canvas add: shapes asShape.	shapes translateBy: 0@0.	canvas nodes first		scaleBy: 0.5@ 1;		rotateByDegrees: 45.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: 'shapes'!example33ColorScaling	<script: 'self new example33ColorScaling open'>	| c classes scale numberOfMethods |	c := RSCanvas new.	classes := RSObject withAllSubclasses.	numberOfMethods := classes collect: #numberOfMethods.	scale := NSScale linear		domain: { numberOfMethods min. numberOfMethods max};		range: { 'red'. 'blue' }.	c addAll: (classes collect: [ :cls |		| b |		b := RSEllipse new.		b size: cls linesOfCode sqrt.		b color: (scale scale: cls numberOfMethods).		b model: cls.		b @ RSPopup.		b ]).	RSFlowLayout on: c shapes.	c @ RSCanvasController.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example34MorphicPopup	<script: 'self new example34MorphicPopup open'>	| c |	c := RSCanvas new.	Collection withAllSubclassesDo: [ :cls |		c add: (RSBox new			model: cls;			size: 10;			yourself) ].	RSGridLayout on: c nodes.	c @ RSCanvasController.	c nodes @ (RSMorphicPopup new		morphBuilder: [:model | ('Class: ', model asString) asTextMorph ]) .	^ c! !!RSShapeExamples methodsFor: 'lines'!example35Lines	<script: 'self new example35Lines open'>	| c circle box dragMeLabel |	c := RSCanvas new.	circle := RSEllipse new		color: Color green;		size: 10.	box := RSBox new		color: Color red;		size: 10.	c		add: circle;		add: box.	dragMeLabel := RSLabel new text: 'Drag me'.	c add: dragMeLabel.	RSLocation new		above;		center;		stick: dragMeLabel on: box.	c		add:			(RSLine new				color: Color veryVeryLightGray;				from: 0 @ -1000;				to: 0 @ 1000).	c		add:			(RSLine new				color: Color veryVeryLightGray;				from: -1000 @ 0;				to: 1000 @ 0).	box translateBy: 50 @ 50.	box @ RSDraggable.	c		add:			(RSLine new				color: Color blue;				from: box;				to: circle).	^ c! !!RSShapeExamples methodsFor: 'shapes'!example36ShapePosition	<script: 'self new example36ShapePosition open'>	| c circle box labelBox dragMeLabel |	c := RSCanvas new.	circle := RSEllipse new size: 10.	box := RSBox new		color: Color red;		size: 10.	c		add: circle;		add: box.	c		add:			(RSLine new				color: Color veryVeryLightGray;				from: 0 @ -1000;				to: 0 @ 1000).	c		add:			(RSLine new				color: Color veryVeryLightGray;				from: -1000 @ 0;				to: 1000 @ 0).	labelBox := RSLabel new text: 'Box'.	c add: labelBox.	labelBox setAsFixed.	labelBox translateBy: 100 @ 50.	box @ RSDraggable.	box		when: RSMouseDragging		do: [ :evt | 			labelBox				text: 'Box position = ' , evt position asIntegerPoint asString ].				dragMeLabel := RSLabel new text: 'Drag me'.	c add: dragMeLabel.	RSLocation new		above; center;		stick: dragMeLabel on: box.	box translateTo: 50 @ 50.	^ c! !!RSShapeExamples methodsFor: 'shapes'!example37PunchCard	<script: 'self new example37PunchCard open'>	| card |	card := RSPunchCardBuilder new.	card objects: String withAllSubclasses.	card addMetric: [:cls | cls numberOfMethods] name: 'NOM'.	card addMetric: [:cls | cls linesOfCode ] name: 'NLC'.	card addMetric: [:cls | cls numberOfVariables] name: 'NOV'.	^ card build! !!RSShapeExamples methodsFor: 'shapes'!example38Transformable	<script: 'self new example38Transformable open'>	| c |	c := RSCanvas new.	c add: (RSBox new		size: 200;		withBorder).	c add: (RSBox new		size: 100;		cornerRadius: 20;		withBorder).		c add: (RSEllipse new		extent: 200@60;		withBorder).	c add: (RSLabel new		fontSize: 100;		text: 'Kaguya Sama';		yourself).	c add: (RSBitmap new		form: (self iconNamed: 'pharoBig');				yourself).	c add: (RSShapeFactory star		size: 200;		color: 'purple').	c add: (self example31BasicGrapher asShape		rotateByDegrees: 15;		color: Color lightGray translucent).		c add: (RSBox new		size: 50;		color: Color black).		c add: (RSLine new		withBorderAttachPoint;		from: c nodes first;		to: c nodes last).	RSGridLayout new		gapSize: 50;		on: c nodes.	c nodes do: [ :s | s model: s ].	c nodes @ RSDraggable; @ (RSPopup text: [ :m | m class name ] ).		c nodes allButLast @ RSTransformable.		c @ RSCanvasController. 	^ c ! !!RSShapeExamples methodsFor: 'shapes'!example39RoassalPackages	<script: 'self new example39RoassalPackages open'>	| packagesRegExp packages canvas color labeled boxes stepping |	packagesRegExp := { 'Roassal3*' }.	    	packages := packagesRegExp flatCollect: [ :regExp | 	    RPackageOrganizer default packages 	        select: [ :p | regExp match: p packageName ] ].	    	canvas := RSCanvas new.	color := NSScale category20c.	labeled := RSLabeled new.	labeled shapeBuilder textBlock: #name.	boxes := packages collect: [ :pkg |	    RSBox new	        model: pkg;	        color: (color scale: pkg);	        @labeled;	        size: pkg linesOfCode sqrt;	        yourself  ].	canvas addAll: boxes.	canvas nodes @ (RSPopup text: #name).	RSEdgeBuilder arrowedLine	    withBorderAttachPoint;	    canvas: canvas;	    connectFrom: #yourself toAll: #dependentPackages.	stepping := RSForceLayoutStepping new.	stepping layout	    length: 300;	    charge: -300.	canvas @ stepping.	canvas @ RSCanvasController.	^ canvas! !!RSExpandingBoxes methodsFor: 'as yet unclassified'!close: shape	shape children copy do: #remove.	self update.! !!RSExpandingBoxes methodsFor: 'initialization'!initialize	super initialize.	canvas := RSCanvas new.	color := NSScale category20b.	base := RSComposite new.	base popup.	base when: RSMouseClick do: [ :evt | self processEvent: evt ].	border := RSBorder new.! !!RSExpandingBoxes methodsFor: 'helpers'!nodeFor: cls	| com |	com := base copy.	com model: cls.	cls subclasses ifNotEmpty: [ com border: border ].	com announcer: base announcer.	com color: (color scale: cls) translucent.	^ com! !!RSExpandingBoxes methodsFor: 'as yet unclassified'!open: shape	| children |	children := shape model subclasses 		collect: [ :cls | self nodeFor: cls ].	shape addAll: children.	self update.! !!RSExpandingBoxes methodsFor: 'as yet unclassified'!processEvent: evt	| shape |	shape := evt shape.	shape children		ifEmpty: [ self open: shape]		ifNotEmpty: [ self close: shape ].! !!RSExpandingBoxes methodsFor: 'updating'!relayout: shape	shape propertyAt: #original put: shape encompassingRectangle.		shape shapes do: [ :s | self relayout: s ].	RSGridLayout on: shape shapes.	shape adjustToChildren.	shape padding: 10.! !!RSExpandingBoxes methodsFor: 'running'!run	<script: 'self new run'>	canvas add: (self nodeFor: Collection).	self update.	canvas open! !!RSExpandingBoxes methodsFor: 'updating'!saveCurrent: shape	shape children do: [ :s | self saveCurrent: s ].	shape propertyAt: #current put: shape encompassingRectangle.! !!RSExpandingBoxes methodsFor: 'updating'!scale: shape at: t	| rect1 rect2 |	shape children do: [ :s | self scale: s at: t ].	rect1 := shape propertyAt: #original ifAbsent: [ ^ self].		rect2 := shape propertyAt: #current.				shape translateTo: (rect1 floatCenter interpolateTo: rect2 floatCenter at: t).		shape extent: (rect1 extent interpolateTo: rect2 extent at: t)! !!RSExpandingBoxes methodsFor: 'updating'!update	| first |	first := canvas shapes first.	self relayout: first.	self saveCurrent: first.	canvas newAnimation		onStepDo: [ :t |			self scale: first at: t.			self zoomCanvans.			canvas signalUpdate. 			 ].! !!RSExpandingBoxes methodsFor: 'updating'!zoomCanvans	canvas zoomToFit	canvas camera scale: 1.! !!RPackage methodsFor: '*Roassal3-Examples'!dependentPackagesWithOccurences	"	Return the list of packages that I depend on. The result may includes several times the same packages. This reflects the number of dependencies.		(RPackageOrganizer default packageNamed: 'Athens-Cairo') dependentPackagesWithOccurences	"	^ (self definedClasses flatCollect: #dependentClassesWithOccurences as: Bag) collect: #package! !!RPackage methodsFor: '*Roassal3-Examples'!numberOfDependenciesToward: anotherPackage	"	Return the number of dependencies between mysefl and the package provided as argument		(RPackageOrganizer default packageNamed: 'Athens-Cairo') numberOfDependenciesToward: (RPackageOrganizer default packageNamed: 'Text-Core') 	"	^ (self dependentPackagesWithOccurences select: [ :p | p == anotherPackage ]) size! !"Roassal3-Examples"!!RSLegendExamples commentStamp: '' prior: 0!I have basic examples of legend builder!!RSLegendExamples methodsFor: 'examples'!example01Basic 	<script: 'self new example01Basic open'>	| b |	b := RSLegend new.	b text: 'Circle = classes, size = number of methods; gray links = inheritance;'.	b text: 'Blue links = dependencies; layout = force based layout on the inheritance links'.	b build.	self assert: b shapes size = 2.	self assert: b container shapes size = 1.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example02Border	<script: 'self new example02Border open'>	| b |	b := RSLegend new.	b text: 'Circle = classes, size = number of methods; gray links = inheritance;'.	b text: 'Blue links = dependencies; layout = force based layout on the inheritance links'.	b leyendDo: [ :l | 		l 			withBorder;			padding: 50 ].	b build.	b canvas @ RSCanvasController.	^ b canvas.! !!RSLegendExamples methodsFor: 'examples'!example03Vertical	<script: 'self new example03Vertical open'>	| b |	b := RSLegend new.	b 		title: 'Mid Heros';		text: 'Invoker';		text: 'Shadow Fiend';		text: 'Tinker';		text: 'Meepo'.	b layout vertical gapSize: 20.	b leyendDo: [ :l | 		l 			withBorder;			padding: (Margin left: 50 right: 10 top: 10  bottom: 50) ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example04Horizontal	<script: 'self new example04Horizontal open'>	| b |	b := RSLegend new.	b 		text: 'Invoker';		text: 'Shadow Fiend';		text: 'Tinker';		text: 'Meepo'.	b leyendDo: [ :l | 		l			withBorder;			padding: 10 ].	b layout horizontal gapSize: 20.	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example05Colors	<script: 'self new example05Colors open'>	| b color |	b := RSLegend new.		color := NSScale category20.	b 		title: 'Mid Heros';		text: 'Invoker' withCircleColor: color;		text: 'Shadow Fiend' withCircleColor: color;		text: 'Tinker' withCircleColor: color;		text: 'Meepo' withCircleColor: Color black.	b leyendDo: [ :l |		l			withBorder;			padding: 20 ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example06BoxColors	<script: 'self new example06BoxColors open'>	| b color |	b := RSLegend new.	color := NSScale category20.	b 		text: 'Invoker' withBoxColor: color;		text: 'Shadow Fiend' withBoxColor: color;		text: 'Tinker' withBoxColor: color;		text: 'Meepo' withBoxColor: color.	b leyendDo: [ :l | 		l			withBorder;			padding: 20 ].	b layout horizontal gapSize: 30.	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example07BoxFading	<script: 'self new example07BoxFading open'>	| b |	b := RSLegend new.	b title: 'Legend'.	b text: 'Number of lines of code' withFadingRamp: {0->'black'. 1->'red'}.	b leyendDo: [:l | l withBorder; padding: 10 ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example08Polygons	<script: 'self new example08Polygons open'>	| b |	b := RSLegend new.	b title: 'Polygons'.	#(diamond triangle star pentagon octagon) do: [ :selector | 		b text: selector withShape: ((RSShapeFactory perform: selector) size: 15) ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example09Lines	<script: 'self new example09Lines open'>	| b |	b := RSLegend new.	b title: 'Line with markers'.	#(diamond triangle star pentagon octagon arrow) do: [ :selector |		| line marker |		marker := (RSShapeFactory perform: selector) size: 10.		line := RSLine new markerEnd: marker; 			startPoint: 0@0; 			endPoint: 20@0;			yourself.		b text: selector withShape: line.		 ].	b build.	b canvas @ RSCanvasController.	^ b canvas! !!RSLegendExamples methodsFor: 'examples'!example10Location	<script: 'self new example10Location open setLabel: ''TSShape withAllSubclasses'''>	| canvas classes b |	canvas := RSCanvas new.	classes := RSShape withAllSubclasses collect: [ :cls | 		RSBox new			draggable;			popup;			model: cls;			height: cls numberOfMethods;			width: (cls instVarNames size + 1) * 5 ] as: RSGroup.	canvas addAll: classes.	RSEdgeBuilder line		withVerticalAttachPoint;		width: 0.1;		canvas: canvas;		shapes: classes;		connectFrom: #superclass.	RSNormalizer color		from: Color black;		to: Color red;		shapes: classes;		normalize: #numberOfMethods.	RSTreeLayout on: classes.	b := RSLegend new.	b container: canvas.	b title: 'System complexity view'.	b text: 'Number of lines of code' withFadingRamp: { 0->'black'. 1->'red'}.	b 		polymetricWidth: 'number of methods' 			height: 'lines of code'			box: 'a Pharo class'.	b leyendDo: [ :s | 		s			draggable;			border:(RSBorder new				color: Color red;				dashArray: #(4));			scaleBy: 0.5;			padding: 15 ].	b location right middle.	b build.	canvas @ RSCanvasController.	^ canvas.	! !!RSLegendExamples methodsFor: 'examples'!example11OnDemand	<script: 'self new example11OnDemand open setLabel: ''TSShape withAllSubclasses'''>	| canvas classes b |	canvas := RSCanvas new.	classes := RSShape withAllSubclasses collect: [ :cls | 		RSBox new			draggable;			popup;			model: cls;			height: cls numberOfMethods;			width: (cls instVarNames size + 1) * 5 ] as: RSGroup.	canvas addAll: classes.	RSEdgeBuilder line		withVerticalAttachPoint;		width: 0.1;		canvas: canvas;		shapes: classes;		connectFrom: #superclass.	RSNormalizer color		from: Color black;		to: Color red;		shapes: classes;		normalize: #numberOfMethods.	RSTreeLayout on: classes.	b := RSLegend new.	b container: canvas.	b title: 'System complexity view'.	b text: 'Number of lines of code' withFadingRamp: { 0->'black'. 1->'red'}.	b 		polymetricWidth: 'number of methods' 			height: 'lines of code'			box: 'a Pharo class'.	b leyendDo: [ :s | 		s			draggable;			border:(RSBorder new				color: Color red;				dashArray: #(4));			scaleBy: 0.5;			padding: 15 ].	b location right middle.	b onDemand; build.	canvas @ RSCanvasController.	^ canvas.	! !"Roassal3-Legend-Examples"!!RSChartExample commentStamp: '' prior: 0!I have basic examples for RSChart and some of their decorators!!RSChartExample methodsFor: 'examples'!example01Markers	<script: 'self new example01Markers open'>	| x c p |	x := -3.14 to: 3.14 by: 0.01.	c := RSChart new.	p := RSLinePlot new.	p x: x y: x sin * 0.22 + 0.5.	c addPlot: p.	c addDecoration: RSHorizontalTick new.	c addDecoration: RSVerticalTick new asFloat.	c addDecoration: RSYMarkerDecoration new average.	c addDecoration: RSYMarkerDecoration new min.	c addDecoration: RSYMarkerDecoration new max.	c addDecoration: RSXMarkerDecoration new max.	c addDecoration: RSXMarkerDecoration new min.	c addDecoration: (RSXMarkerDecoration new value: 0).	^ c! !!RSChartExample methodsFor: 'examples'!example02ScatterPlot	<script: 'self new example02ScatterPlot show'>	| classes c p |	classes := Collection withAllSubclasses.	c := RSChart new.	p := RSScatterPlot new x: (classes collect: #numberOfMethods) y: (classes collect: #linesOfCode).	c addPlot: p.		c xlabel: 'X Axis'.	c ylabel: 'Y Axis'.	c title: 'Hello World'.	^ c! !!RSChartExample methodsFor: 'examples'!example03Plot	<script: 'self new example03Plot show'>	| plt p x |	x := 0.0 to: 2 count: 100.	plt := RSChart new.	p := RSLinePlot new x: x y: (x raisedTo: 2).	plt addPlot: p.	p := RSLinePlot new x: x y: (x raisedTo: 3).	plt addPlot: p.	p := RSLinePlot new x: x y: (x raisedTo: 4).	plt addPlot: p.	plt xlabel: 'X Axis'.	plt ylabel: 'Y Axis'.	plt title: 'Hello World'.	^ plt! !!RSChartExample methodsFor: 'examples'!example04WithTick	<script: 'self new example04WithTick show'>	| x |	x := -10.0 to: 20.0 count: 100.	^ RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		addPlot: (RSLinePlot new x: x y: (x raisedTo: 2));		addDecoration: RSHorizontalTick new integer;		addDecoration: RSVerticalTick new integer;		yourself! !!RSChartExample methodsFor: 'examples'!example05WithTick	<script: 'self new example05WithTick show'>	| x c |	x := 0.0 to: 14 count: 100.	c := RSChart new.	1 to: 7 do: [ :i |		c addPlot: (RSLinePlot new x: x y: (i * 0.3 + x) sin * (7 - i))	].	c addDecoration: RSVerticalTick new integer.	c addDecoration: RSHorizontalTick new integer.	^ c! !!RSChartExample methodsFor: 'examples'!example06CustomNumberOfTicks	<script: 'self new example06CustomNumberOfTicks show'>	| x |	x := -10.0 to: 20.0 count: 100.	^ RSChart new		addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));		addPlot: (RSLinePlot new x: x y: (x raisedTo: 2));		addDecoration: (RSHorizontalTick new 			numberOfTicks: 20;			integer);		addDecoration: (RSVerticalTick new integer 			numberOfTicks: 2;			doNotUseNiceLabel);		yourself	! !!RSChartExample methodsFor: 'examples'!example07AdjustingFontSize	<script: 'self new example07AdjustingFontSize open'>	| x y c |	x := -3.14 to: 3.14 by: 0.1.	y := x sin.	c := RSChart new.	c addPlot: (RSLinePlot new x: x y: y).	c addDecoration: (RSChartTitleDecoration new title: 'hello'; fontSize: 20).	c addDecoration: (RSXLabelDecoration new title: 'My X Axis'; fontSize: 12).	c addDecoration: (RSYLabelDecoration new title: 'My Y Axis'; fontSize: 15; horizontal).	^ c! !!RSChartExample methodsFor: 'examples'!example08TwoCharts	<script: 'self new example08TwoCharts open'>	| c g1 c1 g2 c2 |	c := RSCanvas new.	g1 := RSGroup new.	c1 := RSChart new.	c1 container: g1.	c1 addPlot: (RSLinePlot new x: (1 to: 10) y: (1 to: 10) sqrt).	c1 title: 'squared root'.	c1 xlabel: 'X'.	c1 ylabel: 'Y'.	c1 build.	g2 := RSGroup new.	c2 := RSChart new.	c2 container: g2.	c2 addPlot: (RSLinePlot new x: (1 to: 10) y: (1 to: 10) squared).	c2 title: '^ 2'.	c2 xlabel: 'X'.	c2 ylabel: 'Y'.	c2 build.	c add: g1 asShape; add: g2 asShape.	RSHorizontalLineLayout on: c shapes.	c @ RSCanvasController.	^ c ! !!RSChartExample methodsFor: 'examples'!example09LinearSqrtSymlog	<script: 'self new example09LinearSqrtSymlog open'>	| c x y |	c := RSCanvas new @ RSCanvasController.	x := (-5 to: 500 by: 0.1).	y := x.	#(yLinear ySqrt yLog) do: [ :sel | 		| chart g |		g := RSGroup new.		chart := RSChart new.		chart container: g.		chart addPlot: (RSLinePlot new x: x y: y).		chart addDecoration: (RSVerticalTick new asFloat).		chart perform: sel.		chart title: sel.		chart build.		c add: g asShape ].	RSHorizontalLineLayout on: c shapes.	^ c! !!RSChartExample methodsFor: 'examples'!example10BarPlot	<script: 'self new example10BarPlot open'>	| c p x y |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	p := RSBarPlot new x: x y: y.	self flag: 'TODO'.	c addPlot: p.	c xlabel: 'X Axis'.	"c addDecoration: (RSHorizontalTick new 		numberOfTicks: 20;		asFloat)."	c addDecoration: (RSVerticalTick new 		numberOfTicks: 10;		asFloat).	c ylabel: 'Y Axis'.	c title: 'Histogram'.	^ c! !!RSChartExample methodsFor: 'examples'!example11BarplotCombinedWithLine	<script: 'self new example11BarplotCombinedWithLine open'>	| c x y |	x := 0.0 to: 2 count: 10.	y := (x raisedTo: 2) - 2.	c := RSChart new.	c addPlot: (RSBarPlot new x: x y: y).	self flag: 'TODO'.	"c addPlot: (RSLinePlot new x: x y: y; color: Color red)."	"c addDecoration: (RSHorizontalTick new  asFloat)."	c addDecoration: (RSVerticalTick new 		numberOfTicks: 10;		asFloat).	c xlabel: 'X Axis'.	c ylabel: 'Y Axis'.	c title: 'Bar char'.	^ c! !!RSChartExample methodsFor: 'examples'!example12ScatterPlotAndNormalizer	<script: 'self new example12ScatterPlotAndNormalizer open'>	| x y z r c p |	x := OrderedCollection new.	y := OrderedCollection new.	z := OrderedCollection new.	r := Random seed: 42.	1 to: 100 do: [ :i |		x add: i + (r nextInt: 10).		y add: i + (r nextInt: 10).		z add: i + (r nextInt: 10).	].	c := RSChart new.	p := RSScatterPlot new x: x y: y.	p color: Color blue translucent.	p processBlock: [ :shapes | 			shapes models: z.			RSNormalizer size				shapes: shapes;				from: 2;				to: 10;				normalize: #yourself.			RSNormalizer color				shapes: shapes;				normalize: #yourself.			shapes translucent.				 ].	c addPlot: p.	 	c addDecoration: (RSHorizontalTick new doNotUseNiceLabel asFloat: 3).	c addDecoration: RSVerticalTick new.	^ c! !!RSChartExample methodsFor: 'examples'!example18Animation	<script: 'self new example18Animation inspect'>	| c canvas line points current lineAnimation area paint afterline yticks xticks |	c := self example17CLPvsUSD.	c build.	canvas := c canvas.		"line"	line := canvas shapes detect: [ :s | s class = RSPolyline ].	points := line controlPoints.	current := OrderedCollection new.	current add: points first; add: points second.	line controlPoints: current.	lineAnimation := (2 to: points size) collect: [ :i |		canvas transitionAnimation			duration: 100 milliSeconds;			from: (points at: i - 1);			to: (points at: i);			onStepDo: [ :t |				current removeLast; add: t.				line controlPoints: current.				 ];			when: RSAnimationEndEvent do: [current add: (points at: i) ].	] as: OrderedCollection.	"area"	area := canvas shapes detect: [ :s | s class = RSSVGPath ].	paint := area paint.	area noPaint.	afterline := canvas parallelAnimation.	afterline add: (canvas transitionAnimation		onStepDo: [ :t |			area paint: (Color transparent interpolateTo: paint at: t).		]).	lineAnimation add: afterline.	canvas animationFrom: lineAnimation.		"ticks"	yticks := canvas shapes select: [ :s | s class = RSLabel ].	yticks do: [ :s |  s bold. ].	yticks := yticks groupedBy: [ :s | s matrix sy ].	xticks := yticks values first.	yticks := yticks values second.	xticks doWithIndex: [ :s :index | 		canvas newAnimation			delay: ((index-1) * 100) milliSeconds;			duration: 200 milliSeconds;			from: Color transparent;			to: s color;			on: s set: #color:.		s color: Color transparent ].	yticks doWithIndex: [ :s :index |		s noPaint.		afterline add: (canvas transitionAnimation			delay: (index * 300) milliSeconds;			duration: 2 second;			easing: RSEasing elasticOut;			from: -100@ s position y;			to: s position;			onStepDo: [:p | 				s color: Color black.				s position: p]).		].	^ canvas! !!RSChartExample methodsFor: 'examples'!example19PositiveNetagiveBarPlots	<script: 'self new example19PositiveNetagiveBarPlots open'>	| c d d2 |		c := RSChart new.	d := RSBarPlot new.	d color: Color green darker darker darker translucent.	d y: #(4 10 5 9).	c addPlot: d.	d2 := RSBarPlot new.	d2 color: Color red darker darker darker translucent.	d2 y: #(-5 -6 -3 -3).	c addPlot: d2.	c addDecoration: (RSVerticalTick new integer).	c addDecoration: (RSHorizontalTick new).	c addDecoration: (RSYLabelDecoration new title: 'Difference'; rotationAngle: -90; offset: -25 @ 0).	c addDecoration: (RSXLabelDecoration new title: 'Evolution').	^ c ! !"Roassal3-Chart-Examples"!!RSPieExamples commentStamp: '' prior: 0!I have examples for RSPieBuilder load the package Roassal3-Pie!!RSPieExamples methodsFor: 'data'!esportPrizepool	"source https://www.esportsearnings.com/games"	| arr data |	arr := {		{'Dota' . 2013 . 2874380}.		{'Dota' . 2014 . 10931105}.		{'Dota' . 2015 . 18429613}.		{'Dota' . 2016 . 20770460}.		{'Dota' . 2017 . 24787916}.		{'SC2' . 2013 . 250000}.		{'SC2' . 2014 . 250000}.		{'SC2' . 2015 . 250000}.		{'SC2' . 2016 . 500000}.		{'SC2' . 2017 . 700000}.		{'LOL' . 2013 . 246575}.		{'LOL' . 2014 . 2130000}.		{'LOL' . 2015 . 2130000}.		{'LOL' . 2016 . 5070000}.		{'LOL' . 2017 . 4946969}}.	data := Dictionary new.	arr do: [ :d | 		| list |		list := data at: d first ifAbsentPut: [ OrderedCollection new ].		list add: d second -> d third ].	^ data	! !!RSPieExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| classes pie |	classes :={Dictionary. OrderedCollection. String. Set. Array}.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.	pie build.	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example02Emphasize	<script: 'self new example02Emphasize open'>	| classes pie |	classes :={Dictionary. OrderedCollection. String. Set. Array}.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.	pie build.	pie shapes 		select: [ :s | s model numberOfMethods > 100 ]		thenDo: [ :s | s emphasizeWith: 20 ].	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example03BasicColors	<script: 'self new example03BasicColors open'>	| classes pie |	classes :={Dictionary. OrderedCollection. String. Set. Array}.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.			pie sliceShape		segmentSpacing: 5;		externalRadius: 120.	pie 		sliceColor: NSScale category10;		build.	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example04SegmentSpacingAnimation	<script: 'self new example04SegmentSpacingAnimation open'>	| pie |	pie := RSPie new		objects: #(3 3 2 2 5 8 14);		yourself.	pie sliceShape		segmentSpacing: 5;		innerRadius: 50;		externalRadius: 200;		withBorder.	pie		sliceColor: NSScale google20;		build.	pie canvas newAnimation 		repeat;		easing: RSEasing sinIn;		duration: 5 seconds;		from: 0; 		to: 180;		onStepDo: [ :t | 			pie canvas nodes do: [ :s | | op |				op := 125 - (t degreesToRadians sin abs * 125).				s segmentSpacing: op. ] ].	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example05Smash	<script: 'self new example05Smash open'>	| pie r |	r := Random new.	pie := RSPie new		objects: ((1 to: 10) collect: [:e | r next]) sort;		yourself.	pie sliceShape		border: (RSBorder new width: 1.5);		innerRadius: 0;		externalRadius: 200.	pie		sliceColor: NSScale category10;		build.	pie shapes doWithIndex: [ :shape :index | | a b |		a := shape alphaAngle.		b := shape betaAngle.		pie canvas animationFrom: { 			(pie canvas transitionAnimation 				duration: 2 seconds;				easing: RSEasing bounceOut;				onStepDo: [ :t |					shape 						alphaAngle: a * t;						betaAngle: b * t ]).			(pie canvas transitionAnimation 				delay: (50 * index) milliSeconds;				duration: 750 milliSecond;				easing: RSEasing elasticOut;				from: 0;				to: 120;				on: shape shape set: #innerRadius: ) }. ].	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example06SmashHSL	<script: 'self new example06SmashHSL open'>	| pie |	pie := RSPie new		objects: (1 to: 360);		yourself.	pie sliceShape		innerRadius: 0;		externalRadius: 200.	pie		sliceColor: [ :shape |  Color h: shape index s: 1 l: 0.5 ];		build.	pie shapes doWithIndex: [ :shape :index | | a b |		shape			alphaAngle: (a := shape model - 1);			betaAngle: (b := shape model + 1).		pie canvas animationFrom: { 			(pie canvas transitionAnimation 				duration: 2 seconds;				easing: RSEasing bounceOut;				onStepDo: [ :t |					shape 						alphaAngle: a * t;						betaAngle: b * t ]).			(pie canvas transitionAnimation 				delay: (10 * index) milliSeconds;				duration: 2 seconds;				easing: (RSEasing elasticOut period: 0.30; amplitude: 0.8) ;				from: 0;				to: 120;				on: shape shape set: #innerRadius: ) }. ].		pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example07Dendi	<script: 'self new example07Dendi open'>	| pie r |	r := Random new.	pie := RSPie new		objects: ((1 to: 10) collect: [:e | r next]) sort;		yourself.	pie sliceShape		border: (RSBorder new width: 1.5);		externalRadius: 200.	pie		sliceColor: NSScale category20b;		build.	pie shapes do: [ :shape | | a b |		a := shape alphaAngle.		b := shape betaAngle.		pie canvas animationFrom: { 			(pie canvas transitionAnimation 				easing: RSEasing bounce;				onStepDo: [ :t |					shape 						alphaAngle: a * t;						betaAngle: b * t ]).			(pie canvas transitionAnimation 				delay: 3 seconds;				easing: RSEasing  bounce;				onStepDo: [:t | 					shape						alphaAngle: a + ((360 - a) * t);						betaAngle: b + ((360 - b) * t) ] ) }. ].		^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example08CornerRadii	<script: 'self new example08CornerRadii open'>	| pie |	pie := RSPie new		objects: #(1 1 2 3 4 8 14 21);		yourself.	pie sliceShape		border: (RSBorder new width: 1.5);		externalRadius: 220;		innerRadius: 220/3;		cornerRadii: 30.	pie		sliceColor: NSScale category20c;		build.		^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example09TickAnimation	<script: 'self new example09TickAnimation open'>	| pie |	pie := RSPie new.	pie objects: (0 to: 360).	pie sliceShape		externalRadius: 200;		innerRadius: 150.	pie build.	pie shapes do: [ :s | s 		alphaAngle: s model;		betaAngle: s model + 2 ].	pie canvas newAnimation 		repeat; 		from: 0; 		to: 500;		easing: RSEasing elasticOut;		onStepDo: [ :t |			pie shapes do: [ :s |				s color: (Color h: s model  + t s: 1 l: 0.5) ] ].		^ pie canvas.! !!RSPieExamples methodsFor: 'examples'!example10CornerRadiiAnimation	<script: 'self new example10CornerRadiiAnimation open'>	| pie |	pie := RSPie new.	pie objects: #(1 1 2 3 4 8 14 21).		pie sliceShape		segmentSpacing: 1;		border: (RSBorder new width: 1.5; color: Color gray);		externalRadius: 220;		innerRadius: 70.	pie 		sliceColor: nil;		build.	pie		sliceColor: NSScale paired12;		build.	pie canvas newAnimation repeat		onStepDo: [ :k |			pie shapes do: [ :shape | 				| t |				t := 1 - ((k - 0.5) abs * 2).				shape cornerRadii: (220-70)/2 * t ]			 ].		^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example11OpenningAnimation	<script: 'self new example11OpenningAnimation open'>	| pie bounce inout outin reset colors |	pie := RSPie new.	pie objects: #(1 1 2 3 4 8 14 21) reverse.	pie sliceShape		segmentSpacing: 1;		border: (RSBorder new width: 1.5; color: Color gray);		externalRadius: 220;		innerRadius: 70.	colors := NSScale category20.	pie		sliceColor: [:slice | colors scale: slice model ];		build.	reset := [ pie shapes do: #remove. pie build. pie canvas signalUpdate ].		bounce := pie canvas transitionAnimation from: 0; to: 360; 		easing: RSEasing bounceOut;		onStepDo: [ :t | 		pie shapes do: [ :shape | | beta |			beta := shape propertyAt: #beta.			(t between: shape alphaAngle and: beta)				ifTrue: [ shape betaAngle: t ].			t >= beta ifTrue: [ shape betaAngle: beta ].			t < shape alphaAngle ifTrue: [ shape betaAngle: shape alphaAngle ]			 ] ].	bounce when: RSAnimationStartEvent do: [ 		pie shapes do: [ :shape |			shape propertyAt: #beta put: shape betaAngle.			shape betaAngle: shape alphaAngle.			 ] ].	bounce when: RSAnimationEndEvent do: reset.		inout := pie canvas transitionAnimation 		delay: 1 second;		easing: RSEasing backOut;		onStepDo: [ :t |			pie shapes do: [ :shape |				shape innerRadius: 70 * t.				shape externalRadius: 220 * t ]			 ].	inout when: RSAnimationEndEvent do: reset.		outin := pie canvas transitionAnimation		delay: 1 second;		easing: RSEasing elasticOut;		onStepDo: [ :t |			pie shapes do: [ :shape | | p a b att |				att := shape properties.				p := att at: #position ifAbsentPut: [ 					| angle |					angle := (shape alphaAngle + shape betaAngle)/2 + 180.					angle := angle degreesToRadians.					NSScale linear range: {300*(angle cos@angle sin negated). 0@0 } ].				a := att at: #alpha ifAbsentPut: [ 					NSScale linear range: { shape alphaAngle + 180. shape alphaAngle } ].				b := att at: #beta ifAbsentPut: [ 					NSScale linear from: shape betaAngle + 180; to: shape betaAngle; yourself ].				shape position: (p scale: t).				shape alphaAngle: (a scale: t).				shape betaAngle: (b scale: t).				 ] ].	"It is not necessary rebuild all the arc, you can reuse them	but I did not try this animation event, for that reason I use it"	outin when: RSAnimationEndEvent do: reset.	(pie canvas animationFrom: { bounce. inout. outin }) repeat.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example12RainbowPie	<script: 'self new example12RainbowPie open setLabel: ''Roassal3 :V'' '>	| pie frame n d update |	n := 48.	d := 100.	frame := 0.	pie := RSPie new		objects: (1 to: n);		slice: [:v | 1 ].	pie sliceShape		innerRadius: 75;		segmentSpacing: 1.	pie		sliceColor: [ :slice | | f r g b i |			i := slice model.			f := (i / n) * Float pi * 2.			r := (f + 0) sin * 127 + 128.			g := (f + 2) sin * 127 + 128.			b := (f + 4) sin * 127 + 128.			Color r: r g: g b: b range: 256 ];		build.	update := [ :tran | 		frame := frame + 1.		pie shapes do:[ :shape | | t |			t := frame / 50.0.			shape externalRadius: 300 + ( (t +  ((shape model /n) * Float pi * 4)) sin * d ).			shape arcRadiusAuto.			] ].	update value: 0.	pie canvas newAnimation repeat onStepDo: update.	pie canvas when: RSExtentChangedEvent do: [ :evt | pie canvas zoomToFit ].	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example13BasicColorNormalize	<script: 'self new example13BasicColorNormalize open'>	| classes pie  |	classes :=RSEvent withAllSubclasses.	pie := RSPie new		objects: classes;		slice: #numberOfMethods;		yourself.	pie sliceShape		segmentSpacing: 1;		innerRadius: 30;		externalRadius: 120.	pie build.	RSNormalizer color		from: Color cyan;		to: Color red;		shapes: pie shapes;		normalize: #numberOfMethods.	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example14Pyramid	<script: 'self new example14Pyramid open setLabel: ''Pyramid'''>	| b data |	data := {	{ 0.7. 'Sky'. Color lightBlue }.	{0.2. 'Sunny side of pyramid'. Color yellow darker }.	{ 0.05. 'Shady side of pyramid'. Color yellow muchDarker} }.	b := RSPie new.	b		objects: data;		slice: #first.	b sliceShape externalRadius: 200.	b sliceColor: [:slice | slice model third];		build.	b shapes @ (RSPopup text: #second).	b shapes do: [ :shape | shape shiftAngles: -40 ].		^ b canvas! !!RSPieExamples methodsFor: 'examples'!example15Clockwise	<script: 'self new example15Clockwise open'>	| b r  |	b := RSPie new.	r := Random new.	b objects: ((1 to: 10) collect: [:e | r next]) sort.	b sliceShape externalRadius: 200.	b		sliceColor: NSScale sky8;		build.	b shapes do: [ :shape | 		shape			alphaAngle: (b betaAngleFor: shape) negated + 90;			betaAngle: (b alphaAngleFor: shape) negated + 90.		 ].	^ b canvas! !!RSPieExamples methodsFor: 'examples'!example16MyDay	<script: 'self new example16MyDay open'>	| pie data color canvas pieLabel pieTitle |	data := { 		{ 'sleep'. 'I dream with my gf 8hrs'. 8 }.		{ 'eat'. 'Sometimes I cook for 4hrs'. 3 }.		{ 'work with smalltalk'. 'with Roassal & Carlone 8hrs'. 8 }.		{ 'draw and play dota'. 'I draw with manga style and play dota in leyend level 4hrs'. 5} }.	color := NSScale ordinal		rangeFrom: { 'ae579c'. 'f28d1b'. 'e21454'. '4cbcec' }.	canvas := RSCanvas new.	pie := RSPie new		container: canvas;		objects: data;		slice: #third.	canvas color: '1a1b3a'.	pie sliceShape		externalRadius: 200;		innerRadius: 140;		segmentSpacing: 1.	pie sliceColor: color.			pieLabel := RSPieLabeled new.	pieLabel labelShape		fontSize: 16;		fontName: 'Source Code Pro'.	pieLabel		labelColor: color;		labelText: [ :obj | (obj third * 100 / pie totalSum) rounded asString, '%' ];		rotated;		offset: 60.	pieTitle := RSPieTitle new.	pieTitle labelShape		fontSize: 30;		color: Color white.	pieTitle labelText: 'Milton''s', String cr, 'Day'.	pie build.		pie shapes @ (RSPopup text: [ :obj |		obj first capitalized, '. ', obj third asString, ' hrs' ] ).	pie shapes @ pieLabel.	pie canvas @ pieTitle.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example17PieLabels	<script: 'self new example17PieLabels open setLabel: ''Bolivia population by age'''>	| data pie pieLabel |	"source https://www.indexmundi.com/bolivia/age_structure.html"	data := { 		'<=14'->3547498.		'15-24'->2168047. 		'25-54'->4174931. 		'55-64'->657007. 		'>=65'->590751}.	pie := RSPie new 		objects: data;		slice: #value.	pie sliceShape		externalRadius: 240;		innerRadius: 170;		segmentSpacing: 0.4.	pie sliceColor: NSScale category20.			pieLabel := RSPieLabeled new.	pieLabel labelShape fontSize: 13.	pieLabel labelText: [ :obj |		obj key, (obj value * 100 / pie totalSum) rounded asString, ' %' ].		pie build.	pie canvas when: RSExtentChangedEvent do: [ pie canvas zoomToFit ].	pie shapes @ pieLabel.	^ pie canvas.! !!RSPieExamples methodsFor: 'examples'!example18ManyPies	<script: 'self new example18ManyPies open setLabel: ''Prizepool in esports :V'''>	| data pie color canvas shapes pieLabel pieTitle |	data := self esportPrizepool.	color := NSScale google20.	pie := RSPie new.	canvas := pie container.	pie sliceShape		externalRadius: 200;		innerRadius: 100;		segmentSpacing: 0.5.	pie sliceColor: [ :shape | color scale: shape index ].			pieLabel := RSPieLabeled new.	pieLabel		labelText: #key;		rotated.	pieTitle := RSPieTitle new.	pieTitle labelShape		bold;		fontSize: 20.	shapes := data keys collect: [ :key | 		| composite sum |		composite := RSComposite new.		pie			objects: (data at: key);			slice: #value.				pie container: composite; build.		sum := pie totalSum.		pie shapes @ (RSPopup text: [ :obj |			obj value asStringWithCommas , '$, ' ,				(obj value * 100 / sum) rounded asString, '%'  ]).		pie shapes @ pieLabel.				pieTitle labelText: key.		composite @ pieTitle.		composite adjustToChildren.		composite  ] as: RSGroup.	shapes do: [ :e | e scaleBy: 0.5@1.		e matrix shy: 0.25 ].	canvas addAll: shapes.	shapes @ RSDraggable.	canvas showEncompassingRectangles.	RSGridLayout on: canvas nodes.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].	canvas @ RSCanvasController.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example19Buttons	<script: 'self new example19Buttons open setLabel: ''Arc buttons'''>	| canvas shapes pie move |	canvas := RSCanvas new.	shapes := Collection withAllSubclasses collect: [ :cls | 		RSBox new			size: cls numberOfMethods;			draggable;			popup;			model: cls;			yourself ].	RSNormalizer color		shapes: shapes;		normalize: #numberOfMethods.	canvas addAll: shapes.	RSGridLayout on: shapes.	canvas camera position: canvas shapes encompassingRectangle center.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit; signalUpdate ].	canvas @ RSCanvasController.		pie := RSPie new.	pie 		container: canvas;		objects: { 1@0. 1@ -1. 0@ -1. -1@ -1. -1@0. -1@1. 0@1. 1@1 };		slice: [:ob | 1 ].	pie sliceShape		innerRadius:10;		externalRadius: 40;		border: (RSBorder new color: Color lightGray).	pie		sliceColor: ((RadialGradientPaint fromArray: 				{0 -> 'E5EFF0'.				0.6->'D9D9D9'.				1 ->'A0ABAD'})			center: 0 asPoint;			focalPoint: 0 asPoint;			radius: 40);		build.	move := 0@0.	pie canvas newAnimation repeat;		onStepDo: [ :t | 			canvas camera translateBy: move. ].	pie shapes do: [:shape | 		shape 			position: 50 asPoint;			shiftAngles: 45/ -2;			setAsFixed;			when: RSMouseEnter do: [ 				move := shape model.				canvas newAnimation 					duration: 1 second;					easing: RSEasing backOut;					from: 40; to: 50;					on: shape shape set: #externalRadius:. ];			when: RSMouseLeave do: [ 				move := 0@0.				canvas newAnimation 					duration: 1 second;					easing: RSEasing backOut;					from: 50; to: 40;					on: shape shape set: #externalRadius:. ] ] .	^ canvas	! !!RSPieExamples methodsFor: 'examples'!example20AddingRemoving	<script: 'self new example20AddingRemoving open setLabel: ''Click in arcs or labels'''>	| pie objects canvas color shapes updatePie labels removed updateLabel update pieClick |	objects := String withAllSubclasses.	removed := OrderedCollection new.	pie := RSPie new.	canvas := pie canvas.	pie objects: objects;		slice: #linesOfCode.	color := NSScale category10.	labels := RSGroup new.	shapes := nil.	updatePie := nil.	updateLabel := nil.	update := nil.	canvas addShape: (RSBox new		extent: 100@200;		noPaint;		withBorder;		position: 300@100;		yourself).	pie sliceShape		innerRadius: 70;		externalRadius: 220.	pie		sliceColor: [:slice | color scale: slice model ];		build.	pieClick := [ pie shapes when: RSMouseClick do: [ :evt |		objects remove: evt shape model.		removed add: evt shape model.		update value.	] ].	pieClick value.	updatePie := [ 		shapes := pie shapes.		shapes do: #remove.		pie slice: #linesOfCode; build.		pieClick value.		pie shapes do: [:shape | | x y |			x := shape alphaAngle.			y := shape betaAngle.			shapes 				detect: [ :e1 | e1 model = shape model ]				ifFound: [ :e1|					canvas newAnimation 						easing: RSEasing quad;						onStepDo: [:t |							shape 								alphaAngle: (e1 alphaAngle interpolateTo: x at: t);								betaAngle: (e1 betaAngle interpolateTo: y at: t);						 		signalUpdate.						] 				].		].		pie shapes size > shapes size ifTrue: [ 			| shape x |			shape := pie shapes last.			x := shape alphaAngle.			canvas newAnimation				easing: RSEasing quad;				onStepDo: [ :t |					shape 						alphaAngle: (shape betaAngle interpolateTo: x at: t);						signalUpdate. ]		].	].	updateLabel := [ 		labels do: #remove.		canvas addAll: (labels := removed collectWithIndex: [ :m :index | 			RSLabel new				fontName: 'Source Sans Pro';				model: m;				text: m;				position: index * (0@30) +  (300@0);				when: RSMouseClick do: [ :evt | | model |					model := evt shape model.					objects add: model.					removed remove: model.					update value ];				yourself ]).		 ].	update := [ updatePie value. updateLabel value ].	canvas zoomToFit.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ].	^ canvas! !!RSPieExamples methodsFor: 'examples'!example21ProgressLabel	<script: 'self new example21ProgressLabel open setLabel: ''Roassal3 packages by linesOfCode'''>	| data org pie scale |	org := RPackage organizer.	data := (org packageNames 		select: [ :s | 'Roassal3*' match: s  ]		thenCollect: [ :s | org packageNamed: s ]) 		sorted: [:a :b | a linesOfCode < b linesOfCode ].	pie := RSPie new		objects: data;		slice: #linesOfCode.	scale := NSScale eva10.	pie sliceShape 		innerRadius: 50;		segmentSpacing: 0.5;		externalRadius: 100.	pie 		sliceColor: scale;		build. 	RSShowProgressLabelDecorator on: pie.	pie shapes @ (RSPopup text: #name).	pie canvas zoomToFit.	^ pie canvas! !!RSPieExamples methodsFor: 'examples'!example22RotatedAnimation	<script: 'self new example22RotatedAnimation open setLabel: ''Roassal3 packages by #linesOfCode'''>	| data org pie pieLabel animation canvas |	org := RPackage organizer.	data := (org packageNames 		select: [ :s | '*Roassal3*' match: s  ]		thenCollect: [ :s | org packageNamed: s ]) 		sorted: [:a :b | a linesOfCode < b linesOfCode ].	pie := RSPie new		objects: data;		slice: #linesOfCode.	canvas := pie canvas.	animation := nil.	pie sliceColor: NSScale category20b.	pie sliceShape		innerRadius: 70;		segmentSpacing: 0.5;		externalRadius: 220;		when: RSMouseClick do: [ [ animation toggle ] ].	pieLabel := RSPieLabeled new.	pieLabel labelText: #name.	pie build.	pie shapes @ (RSPopup text: [:obj | obj linesOfCode asString, 'LOC']).	pie shapes @ pieLabel.	animation := canvas newAnimation		from: 0; to: 360; repeat; duration: 15 seconds;		onStepDo: [ :t | 			pie shapes do: [ :shape | | att a b l ext ang |				att := shape properties.				a := att at: #a ifAbsentPut: [ shape alphaAngle ].				b := att at: #b ifAbsentPut: [ shape betaAngle ].				shape alphaAngle: a + t.				shape betaAngle: b + t.				l := shape propertyAt: pieLabel labelKey.				ang := ((shape alphaAngle + shape betaAngle)/2) %360.				ext := l extent x/2 @ 0.				(ang between: 90 and: 270) ifFalse: [ ext := ext negated ].				l position: (shape centroid: 80) - ext .			]		].	canvas add:(RSLabel new text: pie totalSum asString, ' LOC').	canvas @ RSCanvasController.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example23RotatedAnimation	<script: 'self new example23RotatedAnimation open setLabel: ''Roassal3 packages by size in the file system'''>	<noTest>	| data pie pieLabel animation canvas lines directorySize |	"data := (IceRepository registry detect: [ :each | each includesPackageNamed: 'Roassal3' ] ifNone: [ self error: 'Please add a clone of this project to Iceberg to access to the resources' ]) location directories."	data := './pharo-local/iceberg/ObjectProfile/Roassal3/src' asFileReference		directories.	directorySize := nil.	directorySize := [ :d | | sum |		sum := 0.		d children do: [ :child |			sum := sum + (child isDirectory 				ifTrue: [ directorySize value: child ]				ifFalse: [ child size ]) ].		sum ].	data := data sort: [ :a :b |		(directorySize value: a) > (directorySize value: b) ].	pie := RSPie new		objects: data;		slice: [:dir | (directorySize value: dir) sqrt ].	canvas := pie canvas.	animation := nil.	pie sliceShape		innerRadius: 70;		segmentSpacing: 0.5;		externalRadius: 220.	pie		sliceColor: NSScale category20b.	pieLabel := RSPieLabeled new.	pieLabel labelText: #basename.	pie build.	pie shapes 		@ (RSPopup text: [ :obj|			obj basename, String cr,			(directorySize value: obj) humanReadableSIByteSize ]);		@ pieLabel;		when: RSMouseClick do: [ animation toggle ].		lines := pie shapes collect: [:s | RSPolyline new		border: (RSBorder new dashArray: #(3));		yourself ].	canvas addAll: lines.	canvas add: (RSLabel new		text: (directorySize value: data first parent) humanReadableSIByteSize;		yourself).	animation := canvas newAnimation		from: 0; to: 360; repeat; duration: 15 seconds;		onStepDo: [ :t | 			pie shapes do: [ :shape | | att a b label ext ang x p1 p2 p3 line |				att := shape properties.				a := att at: #a ifAbsentPut: [ shape alphaAngle ].				b := att at: #b ifAbsentPut: [ shape betaAngle ].				shape alphaAngle: a + t.				shape betaAngle: b + t.				label := shape propertyAt: pieLabel labelKey.				ang := ((shape alphaAngle + shape betaAngle)/2) %360.				ext := label extent x/2 @ 0.				x := -250.				(ang between: 90 and: 270) ifFalse: [ 					ext := ext negated.					x := x negated ].				p1 := shape centroid: 0.				p2 := shape centroid: 80.				p3 := x @ p2 y.				line := lines at: shape index.				line shape 					controlPoints: { p1. p2. p3 }.				label position: p3-ext.			]		].	canvas camera zoomToFit: 270 asPoint.	canvas when: RSExtentChangedEvent do: [ 		canvas camera 			zoomToFit: canvas extent * 0.9			extent: 800@600 ].	^ canvas! !!RSPieExamples methodsFor: 'examples'!example24ManyPies	<script: 'self new example24ManyPies open setLabel: ''Usa population by State'''>	| data labels maxSum radius color canvas pie format |	"data processing"	data := self usaPopulation.	labels := data first.	maxSum := 0.	data := (data allButFirst collect: [ :line | | arr sum |		arr :=  Array new: line size.		sum := 0.		2 to: line size do: [ :n | | v |			v := (line at: n) asNumber.			sum := sum + v.			arr at: n put: v ].		arr at: 1 put: line first -> sum.		maxSum := maxSum max: sum.		arr ]) sorted: [:a :b | a first value > b first value ].		"the visualization"	radius := NSScale sqrt domain: { 0. maxSum }; range: #(0 220).	color := NSScale eva10.	canvas := RSCanvas new.	pie := RSPie new.	pie sliceShape segmentSpacing: 0.5.	pie sliceColor: [ :slice | color scale: slice index ].	format := [ :n | 		n < 1000000 			ifTrue: [ (n / 1000) asInteger asString,'K' ]			ifFalse: [ (n / 1000000) asInteger asString,'M'  ] ].		canvas addAll: (data collect: [:m | | g x |		g := RSGroup new.		x := radius scale: m first value.		pie sliceShape			innerRadius: x * 0.6;			externalRadius: x.		pie 			container: g;			objects: m allButFirst;			slice: #yourself;			build.		pie shapes do: [:s | 			s @ (RSPopup text: [ :obj | (labels at: s index+1),': ',obj asString ] )].		g add: (RSLabel new			fontSize: 12;			bold;			position: 0@ -6;			text: m first key;			yourself).		g add: (RSLabel new			fontSize: 11;			position: 0@5;			text: (format value: m first value);			yourself).		RSComposite new			shapes: g;			yourself.		]).	RSFlowLayout on: canvas nodes.	canvas @ RSCanvasController.	^ canvas! !!RSPieExamples methodsFor: 'examples'!example25Massiva	<script: 'self new example25Massiva open'>	| pie canvas triangles icons |	pie := RSPie new.	canvas := pie container.	canvas color: '1E2D72'.	pie objects: #( 		announcement github class pharo komitterSqueakSourceRemote		calendar database remove smallFind remote).	pie slice: [:m | 1].	pie sliceShape 		innerRadius: 130;		externalRadius: 200;		segmentSpacing: 2.	pie sliceColor: (NSScale ordinal		range: #('ECCD36' '9BCC3E' '218E4D' '365EA6' '64ACDC'			'6058A4' '202056' 'EA2230' 'ED6B2F' 'DC417A')).			pie build.	triangles := pie shapes collect: [ :s | 		RSShapeFactory triangle			color: s color;			extent: 25@20;			yourself.		 ].	icons := pie shapes collect: [ :s |		RSBitmap new			form: (self iconNamed: s model);			scaleBy: 2;			yourself].	canvas addAll: triangles.	canvas addAll: icons.	canvas newAnimation		repeat;		duration: 10 seconds;		from: 0;		to: 360;		onStepDo: [ :t | 			pie shapes doWithIndex: [ :s :i|				| a b triangle icon |				a := s propertyAt: #a ifAbsentPut: [ s alphaAngle ].				b := s propertyAt: #b ifAbsentPut: [ s betaAngle ].				s 					alphaAngle: a +t;					betaAngle: b + t.				triangle := triangles at: i.				a := s middleAngle degreesToRadians.				triangle matrix					loadIdentity;					rotateByRadians: a negated - Float halfPi.				triangle position: (a cos @ a sin negated) * (s innerRadius-8).								icon := icons at: i.				icon position: (s centroid: 0) ] ].	canvas add:(RSPolygon new		noPaint;		border: (RSBorder new width: 5; color: Color white; yourself);		points: 			{-80 @ -50. 			80@ -50. 			80@50.			0@50.			-60@80.			-30@50.			-80@ 50};		position: 0@ 15;		cornerRadii: 20;		yourself).	canvas add: (RSLabel new 		text: 'Roassal3';		fontSize: 30;		color: Color white).	^ canvas! !!RSPieExamples methodsFor: 'data'!usaPopulation	| str |	str := 'State,Under 5 Years,5 to 13 Years,14 to 17 Years,18 to 24 Years,25 to 44 Years,45 to 64 Years,65 Years and OverAL,310504,552339,259034,450818,1231572,1215966,641667AK,52083,85640,42153,74257,198724,183159,50277AZ,515910,828669,362642,601943,1804762,1523681,862573AR,202070,343207,157204,264160,754420,727124,407205CA,2704659,4499890,2159981,3853788,10604510,8819342,4114496CO,358280,587154,261701,466194,1464939,1290094,511094CT,211637,403658,196918,325110,916955,968967,478007DE,59319,99496,47414,84464,230183,230528,121688DC,36352,50439,25225,75569,193557,140043,70648FL,1140516,1938695,925060,1607297,4782119,4746856,3187797GA,740521,1250460,557860,919876,2846985,2389018,981024HI,87207,134025,64011,124834,356237,331817,190067ID,121746,201192,89702,147606,406247,375173,182150IL,894368,1558919,725973,1311479,3596343,3239173,1575308IN,443089,780199,361393,605863,1724528,1647881,813839IA,201321,345409,165883,306398,750505,788485,444554KS,202529,342134,155822,293114,728166,713663,366706KY,284601,493536,229927,381394,1179637,1134283,565867LA,310716,542341,254916,471275,1162463,1128771,540314ME,71459,133656,69752,112682,331809,397911,199187MD,371787,651923,316873,543470,1556225,1513754,679565MA,383568,701752,341713,665879,1782449,1751508,871098MI,625526,1179503,585169,974480,2628322,2706100,1304322MN,358471,606802,289371,507289,1416063,1391878,650519MS,220813,371502,174405,305964,764203,730133,371598MO,399450,690476,331543,560463,1569626,1554812,805235MT,61114,106088,53156,95232,236297,278241,137312NE,132092,215265,99638,186657,457177,451756,240847NV,199175,325650,142976,212379,769913,653357,296717NH,75297,144235,73826,119114,345109,388250,169978NJ,557421,1011656,478505,769321,2379649,2335168,1150941NM,148323,241326,112801,203097,517154,501604,260051NY,1208495,2141490,1058031,1999120,5355235,5120254,2607672NC,652823,1097890,492964,883397,2575603,2380685,1139052ND,41896,67358,33794,82629,154913,166615,94276OH,743750,1340492,646135,1081734,3019147,3083815,1570837OK,266547,438926,200562,369916,957085,918688,490637OR,243483,424167,199925,338162,1044056,1036269,503998PA,737462,1345341,679201,1203944,3157759,3414001,1910571RI,60934,111408,56198,114502,277779,282321,147646SC,303024,517803,245400,438147,1193112,1186019,596295SD,58566,94438,45305,82869,196738,210178,116100TN,416334,725948,336312,550612,1719433,1646623,819626TX,2027307,3277946,1420518,2454721,7017731,5656528,2472223UT,268916,413034,167685,329585,772024,538978,246202VT,32635,62538,33757,61679,155419,188593,86649VA,522672,887525,413004,768475,2203286,2033550,940577WA,433119,750274,357782,610378,1850983,1762811,783877WV,105435,189649,91074,157989,470749,514505,285067WI,362277,640286,311849,553914,1487457,1522038,750146WY,38253,60890,29314,53980,137338,147279,65614'.	^ str lines collect: [ :line |  line trimBoth splitOn: ',' ].! !"Roassal3-Pie-Examples"!!RSColorPaletteChooser commentStamp: '' prior: 0!I am a basic color chooser for the color palettes!!RSEasel commentStamp: '' prior: 0!I am a basic spec example. You can edit a script with roassal then this will be updated on the view!!RSPieChartExample commentStamp: '' prior: 0!I am a basic example of roassal with spec!!RSWorldMenu class methodsFor: '*Roassal3-Spec-Examples'!menu07PalettesOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Palettes)		parent: #Roassal3;		order: 7;		label: 'Color palettes';		icon: (self iconNamed: 'paint');		action: [ RSColorPaletteChooser new openWithSpec ]! !!RSWorldMenu class methodsFor: '*Roassal3-Spec-Examples'!menu12PalettesOn: aBuilder	<worldMenu>	(aBuilder item: #Roassal3Palettes)		parent: #Roassal3;		order: 12;		label: 'Easel';		icon: (self iconNamed: 'haloPaint');		action: [ RSEasel new openWithSpec ]! !!RSColorPaletteChooser class methodsFor: 'specs'!defaultSpec 	<spec: #default>	^ SpBoxLayout newVertical		add: #buttons withConstraints: [ :c | c height: self toolbarHeight ];		add: #colors;		yourself		! !!RSColorPaletteChooser methodsFor: 'rendering'!boxColorFor: color	| label box |		box := RSBox new		extent: 150 @ 30;		color: color;		yourself.	label := RSLabel new		noPaint;		text: color asHexString;		yourself.	^ RSComposite new		  @ boxOver;		  model: color;		  when: RSMouseClick do: [ :evt | self copyToClipboard: evt shape model ];		  shapes: { box. label};		  yourself! !!RSColorPaletteChooser methodsFor: 'rendering'!boxesFor: anArray	^ anArray collect: [ :color | self boxColorFor: color ] as: RSGroup! !!RSColorPaletteChooser methodsFor: 'rendering'!buttonFor: m	| label box |	label := RSLabel new		bold;		text: m key;		color: Color white;		yourself.	box := RSPolygon new		withBorder;		cornerRadii: 5;		paint: ((LinearGradientPaint fromArray: { 				(0 -> 'lightGray').				(0.25 -> 'black').				(1 -> 'gray') })			start: 0 @ -15;			stop: 0 @ 15);		points: m value;		position: 0@0;		yourself.	^ RSComposite new		  model: m;		  shapes: { box. label };		  @ overHighlight;		  when: RSMouseClick		  do: [ :evt | self renderColorPalettesFor: evt shape ];		  yourself! !!RSColorPaletteChooser methodsFor: 'accessing'!buttons	^ buttons! !!RSColorPaletteChooser methodsFor: 'accessing'!buttons: anObject	buttons := anObject! !!RSColorPaletteChooser methodsFor: 'clipboard handling'!clipTextFor: m	| selector |	m isColor 		ifTrue: [ ^ m asHexString ].	selector := currentPalette class paletteName.	^ RSColorPalette name, ' ',  selector asLowercase, ' ', m selector ! !!RSColorPaletteChooser methodsFor: 'accessing'!colors	^ colors! !!RSColorPaletteChooser methodsFor: 'accessing'!colors: anObject	colors := anObject! !!RSColorPaletteChooser methodsFor: 'clipboard handling'!copyToClipboard: object	| name |	Clipboard clipboardText: (self clipTextFor: object). 	name := 'Palette'.	object isColor ifTrue: [ name := 'Color' ].	self inform: name,' copied to clipboard !!!!!!'! !!RSColorPaletteChooser methodsFor: 'initialization'!initializeInteractions	selectedHighlight := RSHighlightable new.	selectedHighlight highlightShapes: [ :e | {e shapes first} ].	selectedHighlight highlightColor: (		(LinearGradientPaint fromArray:			{0->'white'.			0.25->'blue'.			1 ->'lightGray'})			start: 0@ -15;			stop: 0@ 15).	selectedHighlight 		propertyKey: #buttons;		copyKey: #qwer.	overHighlight := RSHighlightable new.	overHighlight 		highlightShapes: [ :e | {e shapes first} ]		butKeep: selectedHighlight.	overHighlight highlightColor: (		(LinearGradientPaint fromArray:			{0->'white'.			0.25->'black'.			1 ->'lightGray'})			start: 0@ -15;			stop: 0@ 15).	"for boxes "	boxOver := RSHighlightable new.	boxOver highlightShapes: [ :s | { s shapes second } ].	boxOver highlightColor: Color black.! !!RSColorPaletteChooser methodsFor: 'initialization'!initializeWidgets	buttons := self instantiate: SpRoassalPresenter.	colors := self instantiate: SpRoassalPresenter.	buttons script: [ :canvas | 		self renderButtonsOn: canvas.		self renderColorPalettesFor: buttonElements first.].	self initializeInteractions.	! !!RSColorPaletteChooser methodsFor: 'initialization'!initializeWindow: w	w 		title: 'Color Palettes';		initialExtent: 800@500;		centered! !!RSColorPaletteChooser methodsFor: 'rendering'!paletteFor: method	| shapes scale |	scale := currentPalette perform: method selector.		shapes := self boxesFor: scale range.	shapes add: (RSLabel new 		bold;		text: method selector;		yourself).	RSVerticalLineLayout new		alignCenter;		gapSize: 0;		on: shapes.	^ RSComposite new		model: method;		shapes: shapes;		padding: 10;		withBorder;		when: RSMouseClick 			do: [ :evt | self copyToClipboard: evt shape model].		! !!RSColorPaletteChooser methodsFor: 'rendering'!palettes	^ (currentPalette class methods sorted: CompiledMethod sortBlock)		collect: [ :met | self paletteFor: met ].! !!RSColorPaletteChooser methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!RSColorPaletteChooser methodsFor: 'rendering'!renderButtonsOn: canvas	| data |	canvas color: '2d5c7f'.	data := { 		('Diverging' -> { 			(0 @ 0).			(150 @ 0).			(130 @ 30).			(0 @ 30) }).		('Qualitative' -> {			(20 @ 0).			(150 @ 0).			(130 @ 30).			(0 @ 30) }).		('Sequential' -> {			(20 @ 0).			(150 @ 0).			(150 @ 30).			(0 @ 30) }) }.	buttonElements := data collect: [ :m | self buttonFor: m ].	RSHorizontalLineLayout new		gapSize: -9;		on: buttonElements.	canvas addAll: buttonElements.	canvas when: RSExtentChangedEvent do: [ canvas zoomToFit ]! !!RSColorPaletteChooser methodsFor: 'rendering'!renderColorPaletteOn: canvas	| shapes controls |	canvas color: 'f8f9fc'.	shapes := self palettes.	canvas addAll: shapes.		controls := RSCanvasController new.	controls noLegend.	controls interactions removeKey: RSDraggableCanvas.	controls interactions at: RSScrollWheelCanvas put: RSScrollWheelCanvas new.	controls configuration 		noZoomToFitOnStart;		padding: 0@ 10;		noZoomToFitOnExtendChanged;		maxScale: 1;		minScale: 1;		hasHorizontalScrolling: false.		canvas when: RSExtentChangedEvent do: [ 		RSFlowLayout new			maxWidth: canvas extent;			on: shapes.		canvas camera translateTo: canvas extent / 2 + (-20@0). ].	canvas @ controls.		! !!RSColorPaletteChooser methodsFor: 'rendering'!renderColorPalettesFor: aShape	| symbol |	symbol := aShape model key.	currentPalette := RSColorPalette perform: symbol asLowercase asSymbol.	overHighlight doUnhighlight: aShape.	selectedHighlight doHighlight: aShape.	aShape signalUpdate.	colors script: [ :canvas | self renderColorPaletteOn: canvas ].! !!RSColorPaletteChooser methodsFor: 'initialization'!run	<script: 'self new openWithSpec'>! !!RSEasel class methodsFor: 'specs'!defaultSpec 	<spec: #default>	^ SpPanedLayout newHorizontal 		position: 35 percent;		add: (SpBoxLayout newVertical			add: #label withConstraints: [ :c | c height: self toolbarHeight ];			add: #text;			add: #button withConstraints: [ :c | c height: self toolbarHeight ]			);		add: #diagram ;		yourself! !!RSEasel class methodsFor: 'specs'!open	<script>	self new openWithSpec! !!RSEasel methodsFor: 'initialization'!configure: canvas	canvas @ RSCanvasController.	canvas color: self theme backgroundColor.! !!RSEasel methodsFor: 'initialization'!connectPresenters	label		label: 'Enter code below. Both view and canvas are accessible'.	text		text: self initialCode;		autoAccept: true.	button		label: 'Draw this!!';		action: [ diagram refresh ].	"This is the code for the Roassal view.	The block takes both a view and a canvas."	diagram script: [ :canvas |		self configure: canvas.		self textAsBlockClosure value: canvas ]! !!RSEasel methodsFor: 'initialization'!initialCode	^'"[:canvas | ]"box := RSBox new	size: 100;	draggable;	yourself.canvas add: box.'! !!RSEasel methodsFor: 'initialization'!initializePresenters	label := self newLabel.	text := self newCode.	button := self newButton.	diagram := self instantiate: SpRoassalPresenter! !!RSEasel methodsFor: 'initialization'!initializeWindow: w	w 		title: 'Roassal3 Spec';		initialExtent: 800@500.! !!RSEasel methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!RSEasel methodsFor: 'running'!run	<script: 'self new openWithSpec'>! !!RSEasel methodsFor: 'accessing'!textAsBlockClosure	"This could be made more clever with regard to compilation and runtime errors. But for this simple example it should suffice."	^ self class compiler		source: '[:canvas | ' , text text asString , ']';		logged: false;		evaluate! !!RSPieChartExample class methodsFor: 'specs'!defaultSpec 	<spec: #default>	^ SpBoxLayout newVertical		add: #droplist withConstraints: [ :c | c height: self toolbarHeight ];		add: (SpBoxLayout newHorizontal 			add: #chart withConstraints: [:c | c width: 70];			add: #pie;			yourself);		yourself! !!RSPieChartExample methodsFor: 'accessing'!chart	^ chart! !!RSPieChartExample methodsFor: 'accessing'!droplist	^ droplist! !!RSPieChartExample methodsFor: 'initialization'!initializeWidgets	| org |	droplist := self instantiate: SpLabelledDropList.	org := RPackage organizer.	packages := (org packageNames		select: [ :s | '*Roassal3*' match: s ]		thenCollect: [ :s | org packageNamed: s ])		sorted: [ :a :b | a linesOfCode > b linesOfCode ].	totalSum := packages max: #linesOfCode.	droplist		label: 'Roassal Packages';		items: packages;		display: [ :i | i name ].	chart := self instantiate: SpRoassalPresenter.	pie := self instantiate: SpRoassalPresenter.	droplist whenSelectedItemChangedDo: [ :pkg | 		chart script: [ :aCanvas | 			aCanvas				when: RSExtentChangedEvent				do: [ aCanvas edges copy do: #remove.					aCanvas nodes copy do: #remove.					self visualizeChart: aCanvas package: pkg ] ].		pie script: [ :view | self visualizePie: view package: pkg ] ].	droplist dropList selectIndex: 1! !!RSPieChartExample methodsFor: 'initialization'!initializeWindow: w	w 		title: 'Roassal packages';		initialExtent: 800@500;		centered! !!RSPieChartExample methodsFor: 'accessing'!pie	^ pie! !!RSPieChartExample methodsFor: 'running'!run	<script: 'self new openWithSpec'>! !!RSPieChartExample methodsFor: 'initialization'!visualizeChart: canvas package: pkg	| generator result ticks scale bscale canvasRect box |	generator := RSLabelGenerator new.	generator setLooseFlag: true.	result := generator searchMin: 0 max: totalSum desired: 10.	ticks := result min to: result max by: result step.	canvasRect := Rectangle		floatCenter: 0@0		extent: canvas extent * 0.9.	scale := NSScale linear		domain: {result min. result max};		range: {canvasRect bottom. canvasRect top }.	bscale := NSScale linear		domain: { 0. totalSum };		range: { 0. canvasRect height }.		box := RSBox new		color: Color lightGray;		extent: 20@ (bscale scale: pkg linesOfCode);		yourself.	box position: -10 @ ((scale scale: 0) - (box height /2 )).	canvas add: box.	canvas addAll: (ticks collect:[:t | 		RSLabel new			position: 20@ (scale scale: t);			text: (t >= 1000				ifTrue: [ ((t / 1000) printShowingDecimalPlaces: 1) ,'K' ]				ifFalse: [ t asInteger asString ]);			yourself ]).		canvas add: (RSPolyline new		controlPoints: (ticks collect: [:p | -10 @ (scale scale: p)]);		marker: (RSBox new extent: 10@2; color: Color black);		yourself)! !!RSPieChartExample methodsFor: 'initialization'!visualizePie: canvas package: pkg	| b rect max |	b := RSPie new.	b container: canvas.		b sliceShape		innerRadius: 70;		externalRadius: 150;		segmentSpacing: 0.1.	b sliceColor: NSScale google20.	b 		objects: (pkg definedClasses sorted: [:x :y | x linesOfCode < y linesOfCode ]);		slice: #linesOfCode;		build.	RSRotatedPieLabelDecoration on: b.	b shapes @ (RSPopup text: [ :cls | 		cls name, String cr, cls linesOfCode asString, 'LOC' ] ).	canvas addShape: (RSLabel new		text: pkg linesOfCode asString,'LOC').	rect := canvas encompassingRectangle.	max := rect origin x abs max: rect corner x.	canvas when: RSExtentChangedEvent do: [ 		canvas camera 			zoomToFit: canvas extent 			rectangle: (Rectangle floatCenter: 0@0 extent: max * 2@0).		canvas signalUpdate ].! !"Roassal3-Spec-Examples"!!RSSunburstExamples commentStamp: '' prior: 0!I have basic examples for sunburst!!RSSunburstExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| sb |	sb := RSSunburstBuilder new.	sb explore: String using: #subclasses.	sb build.	sb canvas @ RSCanvasController.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example02MultipleRoots	<script: 'self new example02MultipleRoots open'>	| sb |	sb := RSSunburstBuilder new.	sb strategy hasCenter: false.	sb sliceShape 		withBorder;		segmentSpacing: 1.	sb from: { String. RSEvent. RSShape } using:  #subclasses.	sb build.	sb canvas @ RSCanvasController.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example03ConstantStrategy	<script: 'self new example03ConstantStrategy open'>	| sb |	sb := RSSunburstBuilder new.	sb constantWidthStrategy arcWidth: 25.	sb explore: Collection using:  #subclasses.	sb build.	sb canvas @ RSCanvasController.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example04Edges	<script: 'self new example04Edges open'>	| sb |	sb := RSSunburstBuilder new.	sb explore: Collection using:  #subclasses.	sb build.	sb canvas @ RSCanvasController.	RSEdgeBuilder arrowedLine		attachPoint: RSSunburstAttachPoint new;		canvas: sb canvas;		connectFrom: #superclass.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example05BezierEdges	<script: 'self new example05BezierEdges open'>	| sb |	sb := RSSunburstBuilder new.	sb sliceShape		withBorder.	sb sliceColor: [:shape | shape model subclasses isEmpty 		ifTrue: [ Color purple ]		ifFalse: [ Color lightGray ] ].	sb explore: Collection using:  #subclasses.	sb build.	sb canvas @ RSCanvasController.	RSEdgeBuilder sunburstBezier		width: 2;		markerEnd: (RSEllipse new 			size: 10;			color: Color white;			withBorder;			yourself);		canvas: sb canvas;		connectFrom: #superclass.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example06Rotation	<script: 'self new example06Rotation open'>	| sb composite canvas controller |	composite := RSComposite new.	sb := RSSunburstBuilder new.	sb strategy extent: 1000@1000.	sb container: composite.	sb sliceShape withBorder.	sb explore: Collection using: #subclasses.	sb build.	RSNormalizer color		from: Color veryLightGray translucent;		to: Color gray;		shapes: (sb shapes reject: #isSLeaf);		normalize: #linesOfCode.	RSNormalizer color		from: (Color colorFrom: '9B366C');		to: (Color colorFrom: '563A63');		shapes: (sb shapes select: #isSLeaf);		normalize: #linesOfCode.	composite adjustToChildren.	RSEdgeBuilder sunburstBezier		width: 1;		markerEnd:			(RSEllipse new				size: 10;				color: Color black;				yourself);		canvas: composite;		connectFrom: #superclass.	canvas := RSCanvas new.	controller := RSCanvasController new.	(controller interactions at: RSDraggableCanvas) right.	canvas @ controller.	canvas add: composite.	composite @ RSRotated.	^ canvas! !!RSSunburstExamples methodsFor: 'examples'!example07FadeInteraction	<script: 'self new example07FadeInteraction open'>	| sb interaction label |	sb := RSSunburstBuilder new.	sb sliceShape		withBorder.	sb explore: Collection using:  #subclasses.	sb build.	sb canvas @ RSCanvasController.	interaction := RSSunburstFadeInteraction new		builder: sb.	label := RSLabel new.	label text: 'fooo'.	label isFixed: true.	 sb shapes 		when: RSMouseEnter do: [ :evt | 			| path |			path := (interaction pathFor: evt shape) reverse.			path := String streamContents: [:s | 				path do: [ :node | s << node model asString ] separatedBy: [ s << '>>' ] ].			label text: path; signalUpdate.			label position: label extent / 2 ];		when: RSMouseLeave do: [ :evt |			label text: '' ].	sb shapes @ interaction.	sb canvas add: label.	^ sb canvas! !!RSSunburstExamples methodsFor: 'examples'!example08SunburstExplorer	<script: 'self new example08SunburstExplorer open'>	| sb canvas newData color newAnimation first interpolate label |	canvas := RSCanvas new.	canvas @ RSCanvasController.	color := NSScale category20c.	newData := nil.	newAnimation := [ :from :to |		canvas newAnimation			"duration: 500 milliSeconds;"			easing: RSEasing bounceOut;			from: from;			to: to;			yourself ].		interpolate := [ :oldShape :newShape :target |		(newAnimation 			value: oldShape alphaAngle			value: newShape alphaAngle)			onStepDo: [ :t | target alphaAngle: t. canvas signalUpdate ].		(newAnimation 			value: oldShape betaAngle			value: newShape betaAngle)			onStepDo: [ :t | target betaAngle: t ].		(newAnimation 			value: oldShape innerRadius			value: newShape innerRadius)			onStepDo: [ :t | target innerRadius: t ].		(newAnimation 			value: oldShape externalRadius			value: newShape externalRadius)			onStepDo: [ :t | target externalRadius: t ];			yourself ].			sb := RSSunburstBuilder new.	sb 		container: canvas;		sliceColor: [:shape | color scale: shape model category ].	sb sliceShape		withBorder.	canvas addShape: (label := RSLabel new 		text: '';		isFixed: true;		yourself).		newData := [ :class | | lastShapes newShapes oshape |		lastShapes := canvas shapes copy.		sb explore: class using:  #subclasses.		sb build.		label text: class name.				newShapes := sb shapes.		first := newShapes first.		first when: RSMouseClick do: [ :evt | | cls |			cls := evt shape model superclass.			cls = Object ifFalse: [ newData value: cls ] ].		(newShapes allButFirst reject: #isSLeaf)			when: RSMouseClick do: [ :evt | newData value: evt shape model ].				newShapes size < lastShapes size ifTrue: [ 			newShapes do: [:new | | old |				old := lastShapes shapeFromModel: new model.				old remove.				interpolate value: old value: new value: new].			oshape := lastShapes shapeFromModel: class.			lastShapes do: [ :old | | new |				new := RSPieSlice new.				oshape betaAngle < old betaAngle 					ifTrue: [ new alphaAngle: 360; betaAngle: 360 ].				old depth = 1 ifTrue: [ new alphaAngle: 0; betaAngle: 360 ].				(interpolate value: old value: new value: old) 					when: RSAnimationLoopEvent do: [ old remove ].				 ].		] ifFalse: [ 			oshape := lastShapes 				ifEmpty: [ RSPieSlice new ] 				ifNotEmpty: [ newShapes shapeFromModel: lastShapes first model. ].			newShapes do: [ :new | | old |				old := lastShapes shapeFromModel: new model.				old ifNil: [ 					old := RSPieSlice new.					oshape betaAngle < new betaAngle						ifTrue: [ old alphaAngle: 360; betaAngle: 360. ]						ifFalse: [ old alphaAngle: 0; betaAngle: 0.]					 ].				new depth = 1 ifTrue: [ old alphaAngle: 0; betaAngle: 360 ].				old remove.				interpolate value: old value: new value: new. ].		]	].	canvas 		when: RSExtentChangedEvent 		do: [ label position: (canvas extent x / 2) @ (canvas extent y - label height) ].				newData value: Collection.	^ canvas.! !"Roassal3-Sunburst-Examples"!!RSDarkUMLClassRenderer commentStamp: '' prior: 0!I am a demo class!!RSUMLExamples commentStamp: '' prior: 0!I have examples of how to manage the uml builder in different cases!!RSDarkUMLClassRenderer methodsFor: 'initialization'!initialize	super initialize.	darkColor := Color r: 0.130 g: 0.130 b: 0.130.	self 		boxColor: darkColor;		textColor: Color white.	self marker shape color: darkColor.	self border 		width: 2;		color: Color white.! !!RSDarkUMLClassRenderer methodsFor: 'initialization'!methodFor: aMethod	| s |	s := super methodFor: aMethod.	aMethod isOverridden ifTrue: [ s color: Color cyan ].	^ s! !!RSDarkUMLClassRenderer methodsFor: 'initialization'!setUpCanvas: aCanvas	aCanvas color: darkColor! !!RSDarkUMLClassRenderer methodsFor: 'initialization'!titleFor: aClass	| shapes |	shapes := RSGroup with: (super titleFor: aClass).	aClass hasAbstractMethods ifTrue: [ 		shapes addFirst: (RSLabel new			color: Color magenta;			italic;			text: '<<Abstract>>') ].	self applyLayoutOn: shapes.	^ RSComposite new 		shapes: shapes;		yourself.! !!RSUMLExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example02ClassDescriptor	<script: 'self new example02ClassDescriptor open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAbstractLine withAllSubclasses.	builder modelDescriptor methodsLimit: 5.	builder renderer edgeBuilder		cornerRadii: 20.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example03DifferentLines	<script: 'self new example03DifferentLines open'>	| builder marker |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	marker := (RSShapeFactory arrow		extent: 20@25;		noPaint;		withBorder) asMarker offset: -7.	builder renderer edgeBuilder: (RSEdgeBuilder verticalBezier		width: 2;		dashArray: #(4);		capRound;		attachPoint: (RSVerticalAttachPoint new startOffset: 20);		markerStart: marker).	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example04Nolines	<script: 'self new example04Nolines open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	builder renderer marker: ((RSShapeFactory arrow		extent: 20@25;		color: Color black) asMarker offset: 25/2).	builder layout grid.	builder build.	builder canvas edges copy do: #remove.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example05Horizontal	<script: 'self new example05Horizontal open'>	| builder marker |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	marker := (RSShapeFactory arrow		extent: 20@25;		noPaint;		withBorder) asMarker offset: -7.	builder renderer edgeBuilder: (RSEdgeBuilder horizontalBezier		width: 2;		dashArray: #(4);		capRound;		attachPoint: (RSHorizontalAttachPoint new startOffset: 20);		markerStart: marker).	builder layout horizontalTree		verticalGap: 50;		horizontalGap: 100.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example06CustomText	<script: 'self new example06CustomText open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSAttachPoint withAllSubclasses.	builder renderer: RSDarkUMLClassRenderer new.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example07TorchRenderer	<script: 'self new example07TorchRenderer open'>	| builder |	builder := RSUMLClassBuilder new.	builder classes: RSEvent withAllSubclasses.	builder renderer: RSTorchUMLClassRenderer new.	builder build.	^ builder canvas! !!RSUMLExamples methodsFor: 'examples'!example08HierarchyPacker	<script: 'self new example08HierarchyPacker open extent: 900@300'>	| builder classes |	builder := RSUMLClassBuilder new.	classes := { 'Roassal3-Layouts'. 'Roassal3' }		flatCollect: [:pkgname | (RPackage organizer			packageNamed: pkgname) definedClasses ].	builder classes: classes.	builder renderer: RSTorchUMLClassRenderer new.	builder build.	builder canvas @ RSHierarchyPacker.	^ builder canvas.! !!RSUMLExamples methodsFor: 'examples'!example09Package	<script: 'self new example09Package open'>	| builder |	builder := RSUMLPackageBuilder new.	builder packages: { self class package}.	builder build.	^ builder canvas! !"Roassal3-UML-Examples"!!RSTest commentStamp: '' prior: 0!I am the top class for tests!!RSAttachPointTest methodsFor: 'tests'!testBorderAttachPoint	| b1 b2 l c |	b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSBorderAttachPoint new.	l update.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.	self assert: (l attachPoint startingPointOf: l) equals: 30 @ 35.	self assert: (l attachPoint endingPointOf: l) equals: 50 @ 45! !!RSAttachPointTest methodsFor: 'tests'!testCenteredAttachPoint	| b1 b2 l c |	b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSCenteredAttachPoint new.	l update.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.	self assert: (l attachPoint startingPointOf: l) equals: 20 @ 30.	self assert: (l attachPoint endingPointOf: l) equals: 60 @ 50! !!RSAttachPointTest methodsFor: 'tests'!testHorizontalAttachPoint	| b1 b2 l c |	b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSHorizontalAttachPoint new.	l update.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.	self assert: (l attachPoint startingPointOf: l) equals: 30 @ 30.	self assert: (l attachPoint endingPointOf: l) equals: 50 @ 50! !!RSAttachPointTest methodsFor: 'tests'!testVerticalAttachPoint	| b1 b2 l c |	b1 := RSBox new size: 20.	b2 := RSBox new size: 20.	b1 translateTo: 20 @ 30.	b2 translateTo: 60 @ 50.	l := RSLine new		from: b1;		to: b2.	l attachPoint: RSVerticalAttachPoint new.	l update.	c := RSCanvas new.	c		add: b1;		add: b2;		add: l.	self assert: (l attachPoint startingPointOf: l) equals: 20 @ 40.	self assert: (l attachPoint endingPointOf: l) equals: 60 @ 40! !!RSCameraTest methodsFor: 'tests'!testPosition	| c |	c := RSCanvas new.	c add: (RSEllipse new size: 30).	c camera translateBy: 25 @ 15.	self assert: c camera position equals: 25 @ 15! !!RSDependencyTest methodsFor: 'tests'!assertPackage: p1Name dependOn: p2Name	| p1 p2 |	p1 := self packageNamed: p1Name.	p2 := self packageNamed: p2Name.	self assert: (p1 dependentPackages includes: p2).! !!RSDependencyTest methodsFor: 'tests'!assertPackage: p1Name doesNotDependOn: p2Name	| p1 p2 |	p1 := self packageNamed: p1Name.	p2 := self packageNamed: p2Name.	self deny: (p1 dependentPackages includes: p2).! !!RSDependencyTest methodsFor: 'testing'!hasPackage: aString 		^ (self packageNamed: aString) notNil.! !!RSDependencyTest methodsFor: 'tests'!packageNamed: aSymbol	^ RPackageOrganizer default packageNamed: aSymbol 		ifAbsent: [ nil ]! !!RSDependencyTest methodsFor: 'tests'!testDependencies	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Layouts'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Animation'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Builders'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Chart'.	self assertPackage: 'Roassal3' doesNotDependOn: 'Roassal3-Colors'.	self assertPackage: 'Roassal3-Shapes' doesNotDependOn: 'Roassal3-Layouts'.	self assertPackage: 'Roassal3-Animation' dependOn: 'Roassal3'.	"Chart uses RSLocation from Layouts"	self assertPackage: 'Roassal3-Chart' dependOn: 'Roassal3-Layouts'.	"not a core package then we can not depent on this package"	(self hasPackage: 'Roassal3-Spec-Examples') ifFalse: [ ^ self ].	self assertPackage: 'Roassal3-Spec-Examples' dependOn: 'Roassal3-Menu'.! !!RSExamplesTest methodsFor: 'tests'!executeTest: method in: exampleClass	| res |	res := exampleClass perform: method selector.	self		  deny: res = exampleClass		  description: [ 		  '''' , method selector, ''', should return a canvas or view.'			"			method browse			" ]! !!RSExamplesTest methodsFor: 'tests'!testExamples	"This tests execute all the examples of Roassal. Introspectively, it looks for subclasses of RSAbstractExamples"	| clazz |	self timeLimit: 10 minutes.	clazz := Smalltalk at: #RSAbstractExamples ifAbsent: [ ^ self ].	clazz subclasses do: [ :cls | 		| inst methods |		inst := cls new.		methods := cls methods 			select: [ :met | 				(met selector beginsWith: 'example') 				and: [ (met hasPragmaNamed: 'noTest') not ] ].		methods sort: CompiledMethod sortBlock.		methods			do: [ :met | self executeTest: met in: inst ]			displayingProgress: [ :met | met selector ]			every: 100 ]		displayingProgress: [ :cls | cls asString ]		every: 500! !!RSForceBasedLayoutTest methodsFor: 'running'!setUp	canvas := RSCanvas new.	classes := Collection withAllSubclasses collect:[:cls |		RSBox new model: cls; size: 10; yourself].	RSEdgeBuilder line		canvas: canvas;		shapes: classes;		color: (Color blue alpha: 0.5);		connectFrom: #superclass to: #yourself.	canvas addAll: classes.! !!RSForceBasedLayoutTest methodsFor: 'tests'!testAddNodesAndEdges	RSForceBasedLayout new		start;		addNodes: classes;		addEdges: canvas edges;		step.		! !!RSForceBasedLayoutTest methodsFor: 'tests'!testAttributes	RSForceBasedLayout new		length: 100;		charge: -300;		center: 200@200;		on: classes		! !!RSForceBasedLayoutTest methodsFor: 'tests'!testBasic	RSForceBasedLayout on: classes.	RSForceBasedLayout new		doNotUseProgressBar;		on: classes.! !!RSRoassal3Test methodsFor: 'tests'!testRemoveInteractionIfPresent	| box |	box := RSBox new.	self deny: (box announcer handleSubscriberClass: RSPopup).	box popup.	self assert: (box announcer handleSubscriberClass: RSPopup).		box removeInteractionIfPresent: RSPopup.	self deny: (box announcer handleSubscriberClass: RSPopup).	self deny: box hasEventCallback.		box := RSBox new.	box popup. 	self assert: (box announcer handleEventClass: RSMouseMove).	box removeInteractionIfPresent: RSMouseMove.	self assert: (box announcer handleEventClass: RSMouseMove).! !!RSRoassal3Test methodsFor: 'tests'!testSubscriberClass	| box |	box := RSBox new.	self deny: (box announcer handleSubscriberClass: RSPopup).	box popup.	self assert: (box announcer handleSubscriberClass: RSPopup).	"but popup adds a lot of events, RSPopup is not an event"	self deny: (box announcer handleEventClass: RSPopup).	{RSPopup activationEvent}, RSPopup removeEvents do: [ :evt | self assert:  (box announcer handleEventClass: evt). ]! !!RSRoassal3Test methodsFor: 'tests'!testsRsValue	| myCutomObjectValueProvider posiblesValuesForRoassal model colors |	myCutomObjectValueProvider := NSScale category10.			posiblesValuesForRoassal:= {		Color red.		nil.		Color random.		[ Color random ].		#color.		[ :obj | obj color ].		myCutomObjectValueProvider  }.			model := Morph new.	colors := posiblesValuesForRoassal collect: [ :value |		value rsValue: model ] as: OrderedCollection.	self assert: (colors includes: nil).	colors remove: nil.	colors do: [ :color | self assert: color class equals: Color ]! !!RSTest class methodsFor: 'testing'!isAbstract	^ self = RSTest! !"Roassal3-Global-Tests"!!RSAnimationTest commentStamp: '' prior: 0!base of animation tests!!RSSequentialAnimationTest commentStamp: '' prior: 0!I have test for sequential animation!!RSTransitionAnimationTest commentStamp: '' prior: 0!I have test for animation in trachel!!RSPAnimationTest class methodsFor: 'building suites'!testParameters	| m classesToConsider |	m := ParametrizedTestMatrix new.	classesToConsider := RSAbstractAnimation allSubclasses select: [ :c | c subclasses isEmpty ].	classesToConsider do: [ :cls | 		m addCase: { (#animationClass -> cls) }	].	^ m 	! !!RSPAnimationTest methodsFor: 'accessing'!animationClass	^ animationClass! !!RSPAnimationTest methodsFor: 'accessing'!animationClass: aClass	animationClass := aClass! !!RSPAnimationTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new! !!RSPAnimationTest methodsFor: 'tests'!testBasic	| animation |	animation := self animationClass new.	self assert: animation loops equals: 1.	self deny: animation hasCompleted.		self deny: animation isRunning.	self assert: animation startTime isNil.	self deny: animation isPaused.	animation start.	self assert: animation isRunning.	self deny: animation startTime isNil.	self deny: animation isPaused.		animation pause.	self assert: animation isPaused.	animation continue.	self deny: animation isPaused.		self assert: animation loops equals: 1.	self should: [animation loops: 0 ] raise: Error.	animation loops: 3.	self assert: animation loops equals: 3.! !!RSPAnimationTest methodsFor: 'tests'!testBasicInCanvas	| animation |	animation := self animationClass new.	canvas addAnimation: animation.	self assert: canvas animations size equals: 1.		self assert: animation isRunning.	self assert: animation duration equals: self animationClass defaultDuration! !!RSPAnimationTest methodsFor: 'tests'!testDelay	| animation |	animation := self animationClass new.	animation delay: 100 milliSeconds.	animation start.	self deny: animation isDelayDone.	(Delay forMilliseconds: 201) wait.	self assert: animation isDelayDone.! !!RSAnimationTest methodsFor: 'tests'!addingInComposite: compositeAnimation duration: aDuration	compositeAnimation		add: (RSTransitionAnimation new			duration: 1 second);		add: (RSTransitionAnimation new			duration: 2 seconds).	canvas addAnimation: compositeAnimation.	self assert: compositeAnimation isRunning.	self assert: compositeAnimation duration equals: aDuration.! !!RSAnimationTest methodsFor: 'tests'!createAnimationWith: block animationClass: class	| animation |	self assert: canvas animations size equals: 0.	animation := block value.	self assert: canvas animations size equals: 1.	self assert: animation class equals: class.	! !!RSAnimationTest methodsFor: 'running'!runAnimation: animation threshold: threshold	| time ended |		ended := false.	animation when: RSAnimationEndEvent do: [ :evt | ended := true ].	time := Time now asDuration.	[ ended ] whileFalse: [ 		(Time now asDuration - time) > threshold milliSeconds ifTrue: [ 			"time up"			self error: 'Time up'.			^ self ].		canvas playAnimations.		].! !!RSAnimationTest methodsFor: 'running'!setUp	canvas := RSCanvas new.! !!RSParallelAnimationTest methodsFor: 'tests'!testAddingAnimations	self 		addingInComposite: canvas parallelAnimation		duration: 2 second! !!RSParallelAnimationTest methodsFor: 'tests'!testDuration 	| animation |	animation := RSParallelAnimation new.	self assert: animation duration equals: 0 seconds.		animation := RSParallelAnimation new		add: (RSTransitionAnimation new duration: 2 seconds);		add: (RSTransitionAnimation new duration: 4 seconds);		yourself.	self assert: animation duration equals: 4 seconds.	self assert: animation allDuration equals: 4 seconds.		animation := RSParallelAnimation new		loops: 5;		add: (RSTransitionAnimation new duration: 2 seconds; loops: 5);		add: (RSTransitionAnimation new duration: 4 seconds);		yourself.	self assert: animation duration equals: 10 seconds.	self assert: animation allDuration equals: 50 seconds.		animation := RSParallelAnimation new		repeat;		add: (RSTransitionAnimation new duration: 2 seconds; repeat);		add: (RSTransitionAnimation new duration: 4 seconds);		yourself.	self assert: animation duration equals: 4 seconds.	self assert: animation allDuration equals: 4 seconds.! !!RSParallelAnimationTest methodsFor: 'tests'!testParallelAnimationCreation	self 		createAnimationWith: [ canvas parallelAnimationFrom: {} ]		animationClass: RSParallelAnimation.	! !!RSParallelAnimationTest methodsFor: 'tests'!testStep	| value animation |	value := 0.	animation := RSParallelAnimation new		add: (RSTransitionAnimation new 			onStepDo: [ :t| value := value + 1 ]);		add: (RSTransitionAnimation new 			onStepDo: [ :t| value := value + 1 ]);		yourself.	canvas addAnimation: animation.	self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 2.! !!RSParallelAnimationTest methodsFor: 'tests'!testStepEvent	| value loop animation |	value := nil.	loop := 0.	animation := RSParallelAnimation new		loops: 3;		add: (RSTransitionAnimation new 			duration: 100 milliSeconds;			onStepDo: [ :t| value := t ]);		when: RSAnimationLoopEvent do: [ :evt | loop := loop + 1.].	canvas addAnimation: animation.	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 500.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning.! !!RSSequentialAnimationTest methodsFor: 'tests'!testAddingAnimations	self 		addingInComposite: canvas sequentialAnimation		duration: 3 second! !!RSSequentialAnimationTest methodsFor: 'tests'!testDuration	| animation |	animation := RSSequentialAnimation new.	self assert: animation duration equals: 0 seconds.		animation := RSSequentialAnimation new		add: (RSTransitionAnimation new duration: 2 seconds);		yourself.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds.		animation := RSSequentialAnimation new		loops: 5;		add: (RSTransitionAnimation new duration: 2 seconds; loops: 5);		yourself.	self assert: animation duration equals: 10 seconds.	self assert: animation allDuration equals: 50 seconds.		animation := RSSequentialAnimation new		repeat;		add: (RSTransitionAnimation new duration: 2 seconds;  repeat);		yourself.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds.! !!RSSequentialAnimationTest methodsFor: 'tests'!testSequentialAnimationCreation	self 		createAnimationWith: [ canvas animationFrom: {} ]		animationClass: RSSequentialAnimation.! !!RSSequentialAnimationTest methodsFor: 'tests'!testStep	| value animation |	value := 0.	animation := RSSequentialAnimation new		add: (RSTransitionAnimation new 			onStepDo: [ :t| value := value + 1 ]);		yourself.	canvas addAnimation: animation.	self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 1.! !!RSSequentialAnimationTest methodsFor: 'tests'!testStepEvent	| value loop animation |	value := nil.	loop := 0.	animation := RSSequentialAnimation new		loops: 3;		add: (RSTransitionAnimation new 			duration: 100 milliSeconds;			onStepDo: [ :t| value := t ]);		when: RSAnimationLoopEvent do: [ :evt | loop := loop + 1.].	canvas addAnimation: animation.	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 500.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning.! !!RSTransitionAnimationTest methodsFor: 'tests'!testDuration	| animation |	animation := RSTransitionAnimation new duration: 2 seconds.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds.		animation := RSTransitionAnimation new duration: 2 seconds; loops: 5.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 10 seconds.		animation := RSTransitionAnimation new duration: 2 seconds; repeat.	self assert: animation duration equals: 2 seconds.	self assert: animation allDuration equals: 2 seconds.! !!RSTransitionAnimationTest methodsFor: 'tests'!testStep	| value |	value := 0.	canvas newAnimation		onStepDo: [ :t| value := value + 1 ].			self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 1.! !!RSTransitionAnimationTest methodsFor: 'tests'!testStepEvent	| value loop animation |	value := nil.	loop := 0.	animation := canvas newAnimation		duration: 100 milliSeconds;		loops: 3;		onStepDo: [ :t| value := t ];		when: RSAnimationLoopEvent do: [ :evt | loop := loop + 1.].	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 3000.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning.! !!RSTransitionAnimationTest methodsFor: 'tests'!testStepReset	| animation |	animation := canvas newAnimation		duration: 100 milliSeconds.	self runAnimation: animation threshold: 500.		self deny: animation isRunning.	self assert: animation currentLoop equals: nil.	self assert: canvas animations size equals: 0.		animation reset;		duration: 100 milliSeconds.	canvas addAnimation: animation.		self assert: canvas animations size equals: 1.	self runAnimation: animation threshold: 500.! !!RSTransitionAnimationTest methodsFor: 'tests'!testTransitionAnimationCreation	self 		createAnimationWith: [ canvas newAnimation ]		animationClass: RSTransitionAnimation.! !"Roassal3-Animation-Tests"!!RSAthensRendererTest commentStamp: '' prior: 0!I am the test class for TSAthensRenderer !!RSBoundingTest commentStamp: '' prior: 0!Test for all shapes with a matrix an one encompassing rectangle!!RSCanvasTest commentStamp: '' prior: 0!I have common tests for shapes and canvas!!RSCompositeTest commentStamp: '' prior: 0!I am test class for composite shapes in roassal!!RSEdgeBuilderTest commentStamp: '' prior: 0!I have tests for RSEdgeBuilder!!RSGroupTest commentStamp: '' prior: 0!A TSGroupTest is a test class for testing the behavior of TSGroup!!RSLabelTest commentStamp: '' prior: 0!A TSLabelTest is a test class for testing the behavior of TSLabel!!RSLinesTest commentStamp: '' prior: 0!Test for all the lines of trachel!!RSNormalizerTest commentStamp: '' prior: 0!I am test for RSNormalizer!!RSPBoundingTest class methodsFor: 'building suites'!testParameters	| m classesToConsider |	m := ParametrizedTestMatrix new.	classesToConsider := RSBoundingShape allSubclasses select: [ :c | c isAbstract not ].	classesToConsider do: [ :cls | 		m addCase: { (#shapeClass -> cls) }	].	^ m 	! !!RSPBoundingTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new! !!RSPBoundingTest methodsFor: 'accessing'!shapeClass	^ shapeClass! !!RSPBoundingTest methodsFor: 'accessing'!shapeClass: aShapeClass	shapeClass := aShapeClass! !!RSPBoundingTest methodsFor: 'tests'!testDraw	canvas addShape: (self shapeClass new extent: 50 @ 50).	canvas createMorph drawOnMockCanvas.! !!RSPBoundingTest methodsFor: 'tests'!testDrawBorder	canvas addShape: (self shapeClass new		extent: 100 @ 100;		withBorder;		yourself).	canvas createMorph drawOnMockCanvas.! !!RSPBoundingTest methodsFor: 'tests'!testPosition	| b |	b := self shapeClass new.	self assert: b position equals: 0@0.	b position: 0@0.! !!RSPLinesTest class methodsFor: 'building suites'!testParameters	| m classesToConsider |	m := ParametrizedTestMatrix new.	classesToConsider := RSAbstractLine allSubclasses select: [ :c | c isAbstract not ].	classesToConsider do: [ :cls | 		m addCase: { (#shapeClass -> cls) }	].	^ m 	! !!RSPLinesTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new! !!RSPLinesTest methodsFor: 'accessing'!shapeClass	^ shapeClass! !!RSPLinesTest methodsFor: 'accessing'!shapeClass: aClass	"It is expected to have a subclass of RSAbstractLine"	shapeClass := aClass! !!RSPLinesTest methodsFor: 'tests'!testDraw	canvas addShape: (self shapeClass new		strokeColor: Color red;		width: 2). 	canvas createMorph drawOnMockCanvas.! !!RSPLinesTest methodsFor: 'tests'!testDrawMarkers	| line m |	m := RSPolygon new 		points: { -10@0. 0@ -10. 10@0 };		color: Color black;		size: 10.	line := self shapeClass new		startPoint: 50@50;		endPoint: 250@50.	line markerStart: m.	canvas addShape: line.	canvas createMorph drawOnMockCanvas.! !!RSAthensRendererTest methodsFor: 'tests'!testArcCorner	| renderer |	renderer := RSAthensRenderer new.	self assert: (renderer		arcCornerTangets: -17.172947580489485@ -71.29423293069038		p1: -58.258908750504766 @ -212.1459392757739		r: 220		rc: 11.316433244555238		cw: true)				equals: (-54.9506649278924@ 200.80455223867077) -> (-46.47771241701749@ 215.03446758248086)! !!RSBoundingTest methodsFor: 'running'!setUp	canvas := RSCanvas new! !!RSBoundingTest methodsFor: 'running'!testDrawBitmap	canvas addShape: (RSBitmap new		form: (ColorForm extent: 100@100 depth: 32)).	canvas createMorph drawOnMockCanvas.! !!RSBoundingTest methodsFor: 'running'!testDrawBorder	canvas addShape: (RSEllipse new		radius: 100;		withBorder;		yourself).	canvas createMorph drawOnMockCanvas.! !!RSBoundingTest methodsFor: 'running'!testDrawBoxCornerRadius	canvas addShape: (RSBox new		extent: 100@100;		cornerRadius: 5;		yourself).	canvas createMorph drawOnMockCanvas.! !!RSBoundingTest methodsFor: 'running'!testDrawPolygon	canvas addShape: (RSPolygon new).	canvas addShape: (RSPolygon new		points: { 200@10. 250@190. 160@210 };		yourself).	canvas addShape: (RSPolygon new		cornerRadii: 20;		points: { 200@10. 250@190. 160@210 };		yourself).	self assert: canvas shapes second points equals: {(-5@ -100). (45@80). (-45@100)}.	canvas createMorph drawOnMockCanvas.! !!RSBoundingTest methodsFor: 'running'!testDrawRing	| r |	r := RSPieSlice new.	"empty"	canvas addShape: r.	"circle"	canvas addShape: (RSPieSlice new		innerRadius: 0;		externalRadius: 100;		alphaAngle: 0;		betaAngle: 360).	"slice"	canvas addShape: (RSPieSlice new		externalRadius: 100;		alphaAngle: 30;		betaAngle: 90;		segmentSpacing: 5).	"donut"	canvas addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 360).	"corner radii"	canvas addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 45;		cornerRadii: 20).	"same radius"	canvas addShape: (RSPieSlice new		externalRadius: 100;		innerRadius: 100;		alphaAngle: 0;		betaAngle: 45;		cornerRadii: 20).	canvas createMorph drawOnMockCanvas.! !!RSBoundingTest methodsFor: 'tests'!testFromRectangle	| box |	box := RSBox new.	self assert: box position equals: 0 @ 0.	self assert: box extent equals: 0 @ 0.	box fromRectangle: (10 @ 10 corner: 50 @ 40).	self assert: box position equals: 30 @ 25.	self assert: box extent equals: 40 @ 30.		! !!RSBoundingTest methodsFor: 'tests'!testHasChildren	| b |	b := RSBox new.	self deny: b hasChildren.	b := RSEllipse new.	self deny: b hasChildren! !!RSBoundingTest methodsFor: 'tests'!testPosition	| b |	b := RSBox new.	self assert: b position equals: 0@0.	b position: 0@0.! !!RSCanvasTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new! !!RSCanvasTest methodsFor: 'running'!testAddOneShape	canvas addShape: RSBox new.	self assert: canvas numberOfShapes equals: 1.	self assert: canvas numberOfFixedShapes equals: 0! !!RSCanvasTest methodsFor: 'tests'!testAddShapeBefore	| shape1 shape2 |	shape1 := RSBox new size: 20.	shape2 := RSEllipse new size: 10.		canvas add: shape2.	canvas addShape: shape1 before: shape2.	self assert: canvas shapes asArray equals: { shape1 . shape2 }! !!RSCanvasTest methodsFor: 'running'!testDrawCanvas	canvas addShape: (RSBox new		extent: 100@100;		yourself).	canvas addShape: (RSEllipse new		position: 100@100;		extent: 100@100;		yourself).	canvas createMorph drawOnMockCanvas.! !!RSCanvasTest methodsFor: 'running'!testDrawCanvasWithGroup	| g |	g := RSComposite new.	g add: (RSBox new		extent: 100@100;		yourself).	g add: (RSEllipse new		position: 100@100;		extent: 100@100;		yourself).	canvas addShape: g.	canvas createMorph drawOnMockCanvas.! !!RSCanvasTest methodsFor: 'running'!testDrawFixed	| box |	box := RSBox new		extent: 100@100;		yourself.	box isFixed: true.	canvas addShape: box.		box := RSBox new		extent: 100@100;		yourself.	canvas addShape: box.	self deny: box isFixed.	box setAsFixed.	self assert: box isFixed.	self assert: canvas numberOfShapes equals: 0.	self assert: canvas numberOfFixedShapes equals: 2.	canvas createMorph drawOnMockCanvas.! !!RSCanvasTest methodsFor: 'tests'!testElementFromModel	| shapes |	shapes := (1 to: 3) collect: [ :m | RSBox new model: m; yourself ].	canvas addAll: shapes.		self assert: (canvas shapeFromModel: 1) equals: shapes first.	self assert: (canvas shapeFromModel: 2) equals: shapes second.	self assert: (canvas shapeFromModel: 3) equals: shapes third.	self assert: (canvas shapeFromModel: 4) isNil! !!RSCanvasTest methodsFor: 'running'!testEmpty	self assert: canvas numberOfShapes equals: 0! !!RSCanvasTest methodsFor: 'tests'!testEncompassingRectangle	| rect |	rect := canvas encompassingRectangle.	self assert: rect equals: (Rectangle center: 0@0 extent: RSCamera minimumExtent).	! !!RSCanvasTest methodsFor: 'events'!testEvent 	| box |	box := RSBox new.	box when: RSMouseClick do: [ :evt |  ]! !!RSCanvasTest methodsFor: 'tests'!testEventKnowsItsCanvas	| evt t |	evt := RSEvent new.	t := false.	canvas when: RSEvent do: [ :ex | t := true ].	canvas announce: evt.	self assert: evt canvas equals: canvas.	self assert: t.! !!RSCanvasTest methodsFor: 'tests'!testEventKnowsItsCanvas02	| evt shape |	shape := RSBox new size: 20.	canvas add: shape.		evt := RSShapeAddedEvent new shape: shape.	canvas announce: evt.	self assert: evt canvas equals: canvas.! !!RSCanvasTest methodsFor: 'events'!testLowLevelEvent	| box |	box := RSBox new size: 30.	box when: RSMouseDragging do: [ :evt | box ].	canvas addShape: box.	self assert: canvas extent equals: 500 asPoint.	self		assert: (canvas shapeWithAction: RSMouseDragging forPositionInPixels: 250 @ 250)		identicalTo: box! !!RSCanvasTest methodsFor: 'tests'!testNestedShape	| shape innerShape |	shape := RSComposite new.	canvas addShape: shape.	innerShape := RSBox new.	shape add: innerShape.		self assert: shape canvas equals: canvas.	self assert: innerShape parent equals: shape.	self assert: innerShape canvas equals: canvas.	! !!RSCanvasTest methodsFor: 'tests'!testNestedShapeNotAddedToACanvas	| shape innerShape |	shape := RSComposite new.	innerShape := RSBox new.	shape add: innerShape.		self assert: shape canvas isNil.	self assert: innerShape parent equals: shape.	self assert: innerShape canvas isNil.	! !!RSCanvasTest methodsFor: 'running'!testNodesShapesAndEdges	| n1 n2 n3 eb nodes |	n1 := RSEllipse new size: 10; model: 1.	n2 := RSEllipse new size: 10; model: 2.	n3 := RSEllipse new size: 10; model: 3.	nodes := Array with: n1 with: n2 with: n3.	canvas addAll: nodes.	eb := RSEdgeBuilder line.	eb canvas: canvas.	eb useAssociations: (Array with: (1 -> 2) with: (2 -> 3) with: (3 -> 1)).	self assert: canvas shapes size equals: 6.	self assert: (canvas shapes includesAll: nodes).	self assert: canvas nodes equals: nodes asGroup.	self assert: canvas edges size equals: 3.! !!RSCanvasTest methodsFor: 'running'!testOpening	canvas open delete! !!RSCanvasTest methodsFor: 'tests'!testRemovingShapes	| e |	e := RSEllipse new.	canvas addShape: e.	self assert: canvas shapes size equals: 1.	e remove.	self assert: canvas shapes size equals: 0.! !!RSCompositeTest methodsFor: 'tests'!testAdjustChildren	| box circle g composite |	box := RSBox new size: 20.	circle := RSEllipse new size: 20.	g := RSGroup new.	g add: box; add: circle.	composite := g asShape.	self assert: composite extent equals: (20 @ 20). 	RSVerticalLineLayout on: g.	self assert: composite extent equals: (20 @ 20).	composite adjustToChildren.	self assert: composite extent equals: (20 @ 50).! !!RSCompositeTest methodsFor: 'tests'!testEdgesCanvasAndComposite01	"basic case in a canvas"	| c b1 b2 e1 |	c := RSCanvas new.	b1 := RSBox new position: 0@0.	b2 := RSBox new position: 100@100.	e1 := RSLine new from: b1; to: b2.	c addAll: { b1. b2. e1 }.		self assert: e1 startPoint equals: b1 position.	self assert: e1 endPoint equals: b2 position.! !!RSCompositeTest methodsFor: 'tests'!testEdgesCanvasAndComposite02	"basic example in composite"	| c b1 b2 e1 |	c := RSComposite new.	b1 := RSBox new position: 0@0.	b2 := RSBox new position: 100@100.	e1 := RSLine new from: b1; to: b2.	c shapes: { b1. b2. e1 }.		self assert: e1 startPoint equals: b1 position.	self assert: e1 endPoint equals: b2 position.! !!RSCompositeTest methodsFor: 'tests'!testEdgesCanvasAndComposite03	"from box to child"	| c b1 b2 e1 com |	c := RSCanvas new.	com := RSComposite new.	b1 := RSBox new size: 10; position: 0@0.	com add: b1.	com adjustToChildren.	b1 position: 50@50.	com position: 200@0.	b2 := RSBox new size: 10; position: 100@100.	e1 := RSLine new from: b1; to: b2.	c addAll: { com. b2. e1 }.		self assert: e1 startPoint equals: com position + b1 position.	self assert: e1 endPoint equals: b2 position.! !!RSCompositeTest methodsFor: 'tests'!testEdgesCanvasAndComposite04	"from child to child"	| c b1 b2 e1 com1 com2 |	c := RSCanvas new.	com1 := RSComposite new.	b1 := RSBox new size: 10; position: 0@0.	com1 add: b1.	com1 adjustToChildren.	b1 position: 50@50.	com1 position: 200@0.		com2 := RSComposite new.	b2 := RSBox new size: 10.	com2 add: b2.	com2 adjustToChildren.	com2 position: -100@0.	b2 position: 100@100.		e1 := RSLine new from: b1; to: b2.	c addAll: { com1. com2. e1 }.		self assert: e1 startPoint equals: com1 position + b1 position.	self assert: e1 endPoint equals: com2 position + b2 position.! !!RSCompositeTest methodsFor: 'tests'!testEdgesCanvasAndComposite05	"from child to box, where the edge is with the child"	| c b1 b2 e1 com |	c := RSCanvas new.	com := RSComposite new.	b1 := RSBox new size: 10; position: 50@50.	com add: b1.	com position: 200@0.	b2 := RSBox new size: 10; position: 100@100.	e1 := RSLine new from: b1; to: b2.		com add: e1.	com adjustToChildren.	c addAll: { com. b2. }.		self assert: e1 startPoint equals: b1 position.	"but b2 is not in the space of com"	self assert: e1 endPoint equals: b2 position.		! !!RSCompositeTest methodsFor: 'tests'!testHasChildren	| b |	b := RSComposite new.	self deny: b hasChildren.	b shapes: {}.	self deny: b hasChildren.	b shapes: {RSBox new. RSEllipse new}.	self assert: b hasChildren.! !!RSCompositeTest methodsFor: 'tests'!testPaddingOkay	"No error should be raised"		RSComposite new		shapes: (RSGroup new add: RSBox new; yourself);		padding: 5.	RSComposite new		shapes: (RSGroup new add: RSBox new; add: RSBox new; yourself);		padding: 5.			RSComposite new		shapes: (RSGroup new);		padding: 5.! !!RSCompositeTest methodsFor: 'tests'!testPositionInCanvas	| box composite canvas |	canvas := RSCanvas new.	box := RSBox new		size: 100;		yourself.	composite := RSComposite new		shapes: { box };		position: 100@100;		yourself.	canvas add: composite.	box translateTo: 10@10.	self assert: composite position equals: 100@100.	self assert: composite positionInCanvas equals: 100@100.	self assert: box position equals: 10@10.	self assert: box positionInCanvas equals: 110@110.! !!RSEdgeBuilderTest methodsFor: 'tests'!expectedFailures	^ #(#testFromAll #testUseInLayout #testWithMoveBehind #testWithMoveBehind02)! !!RSEdgeBuilderTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new.	shapes := (1 to: 10) collect: [ :n | RSBox new model: n; size: 5; yourself ] as: RSGroup.	canvas addAll: shapes. 	b := RSEdgeBuilder line.! !!RSEdgeBuilderTest methodsFor: 'tests'!testAllowRepetitionAndUseAssociations	| eb |	canvas := RSCanvas new.	canvas addAll: ((1 to: 3) collect: [ :n | RSBox new model: n; yourself] ).	eb := RSEdgeBuilder line.	eb canvas: canvas.	eb color: (Color red alpha: 0.5).	eb noRepetition.	eb useAssociations: (Array with: 1 -> 2 with: 2 -> 3 with: 1 -> 2).		(Smalltalk globals at: #RSGridLayout)  on: canvas nodes.		self assert: canvas numberOfEdges equals: 2! !!RSEdgeBuilderTest methodsFor: 'tests'!testBorder	| numberOfEdges |	b canvas: canvas.	b connectFrom: [ :vv | vv // 2 ].		numberOfEdges := canvas edges size.	self assert: numberOfEdges > 0.		self assert: (canvas edges collect: #border) asSet size equals: numberOfEdges! !!RSEdgeBuilderTest methodsFor: 'tests'!testConnectFrom	| e |	b canvas: canvas.	b objects: #(1 2).	b connectFrom: [ :v | v - 1 ].		self assert: canvas numberOfEdges equals: 1.		e := canvas edges anyOne.	self assert: e from model equals: 1.	self assert: e to model equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testConnectFromAll	| c es |	c := RSCanvas new.	es := (1 to: 2) collect: [ :m | RSEllipse new size: 20; model: m; yourself ].	c addAll: es.		self assert: c edges size equals: 0.	RSEdgeBuilder line		canvas: c;		objects: (1 to: 2);		connectFromAll: (Array with: 1) to: 2.			(Smalltalk globals at: #RSTreeLayout) on: es.	self assert: c edges size equals: 1.	self assert: c edges first from position equals: (15.0@15.0).	self assert: c edges first to position equals: (15.0@55.0).! !!RSEdgeBuilderTest methodsFor: 'tests'!testConnectTo	| e |	b canvas: canvas.	b objects: #(1 2).	b connectTo: [ :v | v - 1 ].		self assert: canvas numberOfEdges equals: 1.		e := canvas edges anyOne.	self assert: e from model equals: 2.	self assert: e to model equals: 1.! !!RSEdgeBuilderTest methodsFor: 'tests'!testConnectToAll	| eFrom eTo |	b canvas: canvas.	b objects: #(1 2 3).	b connectToAll: [ :v | Array with: v - 1 with: v - 2 ].		self assert: canvas numberOfEdges equals: 3.	 	eFrom := (canvas edges collect: [ :edge | edge from model ]) sorted asArray.	eTo := (canvas edges collect: [ :edge | edge to model ]) sorted asArray.	self assert: eFrom equals: #(2 3 3).	self assert: eTo equals: #(1 1 2).! !!RSEdgeBuilderTest methodsFor: 'tests'!testDefault	self assert: canvas numberOfEdges equals: 0! !!RSEdgeBuilderTest methodsFor: 'tests'!testElements	| es |	b := RSEdgeBuilder line.	b canvas: canvas.	self assert: b fromShapes equals: canvas nodes.		es := (1 to: 4) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	b shapes: es.	self assert: b fromShapes equals: es.! !!RSEdgeBuilderTest methodsFor: 'tests'!testElementsToLookup	| es1 es2 edges c |	es1 := #(1 2 3) collect: [:n | RSEllipse new model: n; yourself].	es2 := #(1 2 3) collect: [:n | RSBox new model: n; yourself].	c := RSCanvas new.	c addAll: es1.	c addAll: es2.	edges := RSEdgeBuilder line					canvas: c;					fromShapes: es1;					toShapes: es2;					connectTo: #yourself.	self assert: edges size equals: 3.		self assert: edges first from equals: es1 first.	self assert: edges first to equals: es2 first.! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjects	| edges |	b canvas: canvas.	b fromObjects: #(1 2).	b connectFrom: #yourself to: 10.	self assert: canvas numberOfEdges equals: 2.	edges := canvas edges.	self assert: edges first from model equals: 1.	self assert: edges first to model equals: 10.	self assert: b toObjects asArray equals: (1 to: 10) asArray.	self assert: b fromObjects asArray equals: #(1 2).! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjects02	b canvas: canvas.	b fromObjects: #(1).	b connectFrom: #yourself to: 10.	self assert: canvas numberOfEdges equals: 1.	self assert: b toObjects asArray equals: (1 to: 10) asArray.	self assert: b fromObjects asArray equals: #(1).! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjectsError"view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."	self should: [ RSEdgeBuilder new  fromObjects: #(1 2) ] raise: Error! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjectsToElements	| edges |	b canvas: canvas.	edges := 		b fromObjects: #(1 2);			toShapes: (shapes copyFrom: 10 to: 10);			connectTo: 10.	self assert: edges size equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testHasEdges	| e s1 s2 |	s1 := canvas nodes first.	s2 := canvas nodes second.	self deny: s1 hasEdges.	self deny: s2 hasEdges.		b canvas: canvas.	b objects: #(1 2).	b connectTo: [ :v | v - 1 ].		self assert: s1 hasEdges.	self assert: s2 hasEdges.	self assert: s1 connectedEdges size equals: 1	! !!RSEdgeBuilderTest methodsFor: 'tests'!testInit	| eb |	eb := RSEdgeBuilder line.	self deny: eb shouldAllowRepetition.	eb allowRepetition.	self assert: eb shouldAllowRepetition.! !!RSEdgeBuilderTest methodsFor: 'tests'!testNoMoveBehind	RSEdgeBuilder line		canvas: canvas;		useAssociations: (Array 									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: (canvas canvas shapes collect: [ :c | c class name ]) asArray equals: #(#RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSLine #RSLine #RSLine)! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjectFrom	| e |	b canvas: canvas.	b objects: #(1 2); connectFrom: [ :v | v - 1 ].		self assert: canvas numberOfEdges equals: 1.		e := canvas edges anyOne.	self assert: e from model equals: 1.	self assert: e to model equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjectTo	| e |	b canvas: canvas.	b objects: #(1 2); connectTo: [ :v | v - 1 ].		self assert: canvas numberOfEdges equals: 1.		e := canvas edges anyOne.	self assert: e from model equals: 2.	self assert: e to model equals: 1.! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjects	b canvas: canvas.	b objects: (1 to: 5).	self assert: b fromShapes equals: (shapes copyFrom: 1 to: 5)"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjects02	b canvas: canvas.	b objects: #even.	self assert: (b fromShapes collect: #model) asArray equals: #(2 4 6 8 10)! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjects03	b canvas: canvas.	b objects: #odd.	self assert: (b fromShapes collect: #model) asArray equals: #(1 3 5 7 9)! !!RSEdgeBuilderTest methodsFor: 'tests'!testShouldAllowBidirection	self assert: canvas numberOfEdges equals: 0.	self assert: b isBidirectional.	b canvas: canvas.	b noBidirectional.	b objects: #(1 2).	b useAssociations: (Array with: 1 -> 2 with: 2 -> 1 ).	self deny: b isBidirectional. 		shapes := canvas shapesFromModels: #(1 2).	self assert: shapes size equals: 2.	self assert: (b shouldCreateEdgeFrom: shapes first to: shapes second).		self assert: canvas numberOfEdges equals: 1.	self assert: canvas edges anyOne from model equals: 1.	self assert: canvas edges anyOne to model equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testShouldNotAllowBidirection	self assert: canvas numberOfEdges equals: 0.	b canvas: canvas.	b objects: #(1 2).	b useAssociations: (Array with: 1 -> 2 with: 2 -> 1).	self assert: canvas numberOfEdges equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testShouldNotInstantiate	self should: [ RSEdgeBuilder new ] raise: Error! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple	RSEdgeBuilder line		canvas: canvas;		useElementAssociations: (Array 									with: shapes first -> shapes second									with: shapes second -> shapes third).	self assert: canvas numberOfEdges equals: 2! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple2	RSEdgeBuilder line		canvas: canvas;		useAssociations: (Array 									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: canvas numberOfEdges equals: 3! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple3	RSEdgeBuilder line		canvas: canvas;		fromObjects: #(1 2 3 6);		toObjects: (1 to: 10);		connectFrom: #yourself to: [ :v | v + 1 ].	self assert: canvas numberOfEdges equals: 4.	self assert: (canvas edges collect: [ :e | e from model -> e to model ]) asArray equals: ((Array new: 4) at: 1 put: (1->2); at: 2 put: (2->3); at: 3 put: (3->4); at: 4 put: (6->7); yourself)! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple4	RSEdgeBuilder line		canvas: canvas;		fromObjects: #(1 2 3 6);		toObjects: #(1 2 3 6);		connectFrom: #yourself to: [ :v | v + 1 ].	self assert: canvas numberOfEdges equals: 2.	self assert: (canvas edges collect: [ :e | e from model -> e to model ]) asArray equals: ((Array new: 2) at: 1 put: (1->2); at: 2 put: (2->3); yourself)! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple5	RSEdgeBuilder line		canvas: canvas;		fromObjects: #(1 2 3 6);		connectFrom: #yourself toAll: [ :v | Array with: v + 1 with: v + 2 ].			self assert: canvas numberOfEdges equals: 8.! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple6	RSEdgeBuilder line		canvas: canvas;		fromObjects: (Array with: 2);		connectFromAll: (Array with: 2) to: 3.	self assert: canvas numberOfEdges equals: 1.! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple7	RSEdgeBuilder line		canvas: canvas;		useAssociation: 1 -> 2;		useAssociation: 2 -> 3;		useAssociation: 5 -> 6.	self assert: canvas numberOfEdges equals: 3! !!RSEdgeBuilderTest methodsFor: 'tests'!testSource	| c es eb col |	c := RSCanvas new.	es := #(1 2 3) collect: [:n | RSBox new model: n; yourself]. 	c addAll: es.		eb := RSEdgeBuilder line.	eb canvas: c.		col := OrderedCollection new.	col add: 1 -> 2.	col add: 3 -> 1.	eb source: col connectFrom: #key to: #value.		self assert: c numberOfEdges equals: 2! !!RSEdgeBuilderTest methodsFor: 'tests'!testToObjects	b canvas: canvas.	b toObjects: #(1 2).	b connectFrom: #yourself to: 10.	self assert: canvas numberOfEdges equals: 0.	self assert: b toObjects asArray equals: #(1 2).	self assert: b fromObjects asArray equals: (1 to: 10) asArray.! !!RSEdgeBuilderTest methodsFor: 'tests'!testWithMoveBehind	RSEdgeBuilder new		view: canvas;		moveBehind;		useAssociations: (Array 									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: (canvas canvas shapes collect: [ :c | c class name ]) asArray equals: #(#RSLine #RSLine #RSLine #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox)! !!RSEdgeBuilderTest methodsFor: 'tests'!testWithMoveBehind02	RSEdgeBuilder new		view: canvas;		moveBehind;		connectFrom: [ :v | v - 1 ].	self assert: (canvas canvas shapes collect: [ :c | c class name ]) asArray equals: #(#RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSLine #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox #RSBox)! !!RSEdgeBuilderTest methodsFor: 'tests'!testconnectFromToAll	| es1 es2 edges c |	es1 := #(1 2 3) collect: [:n | RSEllipse new model: n; yourself].	es2 := #(1 2 3) collect: [:n | RSBox new model: n; yourself].	c := RSCanvas new.	c addAll: es1; addAll: es2.	edges := RSEdgeBuilder line					canvas: c;					fromShapes: es1;					toShapes: es2;					connectFrom: #yourself toAll: [ :obj | Array with: obj ].	self assert: edges size equals: 3.		self assert: edges first from equals: es1 first.	self assert: edges first to equals: es2 first.! !!RSGroupTest methodsFor: 'tests'!testAddShape	| g |	g := RSGroup new.	g add: RSBox new.! !!RSGroupTest methodsFor: 'tests'!testAsGroup	| t |	t := #(1 2 3) asGroup.	self assert: t asArray equals: #(1 2 3).	self assert: t class equals: RSGroup! !!RSGroupTest methodsFor: 'tests'!testCache01	| shapes shape |	shapes := (1 to: 5) collect: [:n | RSBox new model: n; yourself ] as: RSGroup.	self assert: shapes class equals: RSGroup.	self assert: shapes shapeFromModelCache isEmpty.		shape := shapes shapeFromModel: 2.	self assert: shape class equals: RSBox.	self assert: shape model equals: 2.		self deny: shapes shapeFromModelCache isEmpty.! !!RSGroupTest methodsFor: 'tests'!testCache02	| shapes s sps |	shapes := #(1 1) collect: [:n | RSBox new model: n; yourself] as: RSGroup.		s := shapes shapeFromModel: 1.	self assert: s class equals: RSBox.	self assert: s model equals: 1.		sps := shapes shapesFromModel: 1.	self assert: sps class equals: RSGroup.	self assert: sps size equals: 2! !!RSGroupTest methodsFor: 'tests'!testCache03	| shapes shape |	shapes := #(1 1) collect: [:n | RSBox new model: n; yourself] as: RSGroup.		shapes shapesFromModel: 1.	shape := shapes shapeFromModel: 1.	self assert: shape class equals: RSBox.	self assert: shape model equals: 1.	! !!RSGroupTest methodsFor: 'tests'!testCache04	| es |	es := #(1) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	self assert: (es shapesFromModel: 1) size equals: 1.		es addAll: (#(1) collect: [:n | RSBox new model: n; yourself] as: RSGroup). 	self assert: (es shapesFromModel: 1) size equals: 2.! !!RSGroupTest methodsFor: 'tests'!testDrawGroup	| g c com |	c := RSCanvas new.	g := RSGroup new.	g add: RSBox new.	com := RSComposite new		shapes: g.	c addShape: com.	self assert: c numberOfShapes equals: 1.	c createMorph drawOnMockCanvas.! !!RSGroupTest methodsFor: 'tests'!testElementFromModel	| group |	group := (1 to: 5) collect: [:n | RSBox new model: n; yourself] as: RSGroup.	self assert: (group shapeFromModel: 1) equals: group first.	self assert: (group shapeFromModel: 5) equals: group last.! !!RSGroupTest methodsFor: 'tests'!testModels	| g |	g := RSGroup new.	g add: RSBox new.	g add: RSBox new.	g add: RSBox new.	self assert: (g allSatisfy: [ :s | s model isNil ]).	g models: #('hello' 'world' 'bonjour').		self assert: (g collect: [ :s | s model ]) asArray equals: #('hello' 'world' 'bonjour')	 ! !!RSGroupTest methodsFor: 'tests'!testTranslucent	| g |	g := RSGroup new.	g add: RSBox new.	g add: RSBox new.	g add: RSBox new.	self assert: (g allSatisfy: [ :s | s color alpha = 1 ]).	g translucent.	self assert: (g allSatisfy: [ :s | s color alpha < 1 ]).	 ! !!RSLabelTest methodsFor: 'running'!setUp	canvas := RSCanvas new! !!RSLabelTest methodsFor: 'tests'!testDrawBorderLabel	|  |	canvas addShape: (RSLabel new		withBorder;		color: (Color purple alpha: 0.5);		fontName: 'Source Sans Pro';		position: -50 @ 0;		text: 'Hello world!!';		yourself).	canvas createMorph drawOnMockCanvas.! !!RSLabelTest methodsFor: 'tests'!testDrawLabel		canvas addShape: (RSLabel new		color: (Color purple alpha: 0.5);		position: -50 @ 0;		text: 'Hello world!!';		yourself).	canvas createMorph drawOnMockCanvas.! !!RSLabelTest methodsFor: 'tests'!testHasChildren	| b |	b := RSLabel new.	self deny: b hasChildren.	! !!RSLabelTest methodsFor: 'tests'!testUnderlineStruckout	| label |	label := RSLabel new.	self assert: label isNormal.	label underline.	label bold.	self assert: label isBold.	self assert: label isUnderlined.! !!RSLinesTest methodsFor: 'running'!setUp	canvas := RSCanvas new! !!RSLinesTest methodsFor: 'running'!testArrowedLine	| line head other |	line := RSArrowedLine new.	line startPoint: 0@0; endPoint: 100@100.	head := line markerEnd.	self assert: head isNotNil.		head := head shape.	self assert: head class equals: RSPolygon.	line color: Color blue.	self assert: line color equals: Color blue.	self assert: head border color equals: Color blue.		line border: (RSBorder new width: 2; color: Color red).	self assert: line border width equals: 2.	self assert: line color equals: Color red.	self assert: head border width equals: 2.	self assert: line color equals: Color red.		other := line copy.	self deny: other equals: line.	self deny: other markerEnd hash equals: line markerEnd hash.	! !!RSLinesTest methodsFor: 'tests - colors'!testColorLineAndMarker	| line |	line := RSShapeFactory arrowedLine.	line color: Color blue.	self 		assert: line color equals: Color blue;		assert: line markerEnd shape borderColor equals: Color blue.! !!RSLinesTest methodsFor: 'running'!testDrawBezierLine	canvas addShape: (RSBezier new		strokeColor: Color red;		width: 2). 	canvas createMorph drawOnMockCanvas.! !!RSLinesTest methodsFor: 'running'!testDrawLine	canvas addShape: (RSLine new		strokeColor: Color red;		width: 2). 	canvas createMorph drawOnMockCanvas.! !!RSLinesTest methodsFor: 'running'!testDrawMarkers	| line m |	m := RSPolygon new 		points: { -10@0. 0@ -10. 10@0 };		color: Color black;		size: 10.	line := RSLine new		startPoint: 50@50;		endPoint: 250@50.	line markerStart: m.	canvas addShape: line.	canvas createMorph drawOnMockCanvas.! !!RSLinesTest methodsFor: 'running'!testLineIncludesPoint	| line |	line := RSLine new		startPoint: 0@0;		endPoint: 0@100;		width: 8;		yourself.	self assert: (line includesPoint: 0@0).	self assert: (line includesPoint: 0@100).	self assert: (line includesPoint: 0@50).	self assert: (line includesPoint: 4@50).	self deny: (line includesPoint: 5@50).	self deny: (line includesPoint: 500@500).! !!RSLinesTest methodsFor: 'running'!testPolylineIncludesPoint	| line |	line := RSPolyline new.	line width: 10.	line controlPoints: { 0@0. 0@100 }.	self assert: (line includesPoint: 0@0).	self assert: (line includesPoint: 0@100).	self assert: (line includesPoint: 0@50).	self assert: (line includesPoint: 5@50).		self deny: (line includesPoint: 500@500).	self deny: (line includesPoint: 6@50).! !!RSNormalizerTest methodsFor: 'tests'!testBasic 	| shapes |	shapes := (1 to: 2) collect: [ :n | RSBox new model: n; yourself ].		self assert: shapes size equals: 2.	self assert: shapes first color equals: Color lightGray.	RSNormalizer color		shapes: shapes;		normalize: #yourself.	self assert: shapes first color equals: Color green.	RSNormalizer size		shapes: shapes;		from: 100;		to: 200;		normalize: #yourself.	self assert: shapes first extent equals: 100@100.	self assert: shapes first extent equals: 100@100.! !"Roassal3-Shapes-Tests"!!RSDraggableCanvasTest commentStamp: '' prior: 0!For drag view tests!!RSControlsViewTest methodsFor: 'tests'!testBasic	| canvas controller |	canvas := RSCanvas new.	canvas @ RSCanvasController.	controller := canvas controllerInteraction.	self assert: controller class equals: RSCanvasController.	canvas @ RSCanvasController.	self assert: controller equals: canvas controllerInteraction.	! !!RSDraggableCanvasTest methodsFor: 'running'!setUp	canvas := RSCanvas new.	canvas add: (RSEllipse new width: 40; height: 20; yourself).	! !!RSDraggableCanvasTest methodsFor: 'tests'!testDefault	self assert: canvas canvas camera position equals: 0@0.! !!RSDraggableCanvasTest methodsFor: 'tests'!testDraggingModeLeft	canvas @ RSDraggableCanvas left.	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (0 @ 0)).		canvas removeInteractionIfPresent: RSDraggableCanvas.		canvas @ RSDraggableCanvas left.	canvas canvas announce: (RSMouseDragStart new canvas: canvas canvas).	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas ).	canvas canvas announce: (RSMouseDragEnd new canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (0 @ 0)).		canvas canvas announce: (RSMouseLeftDragStart new canvas: canvas canvas).	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas ).	canvas canvas announce: (RSMouseDragEnd new canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (-10 @ -5)).! !!RSDraggableCanvasTest methodsFor: 'tests'!testDraggingModeMiddle	canvas @ RSDraggableCanvas middle.	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (0 @ 0)).		canvas removeInteractionIfPresent: RSDraggableCanvas.		canvas @ RSDraggableCanvas middle.	canvas canvas announce: (RSMouseDragStart new canvas: canvas canvas).	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	canvas canvas announce: (RSMouseDragEnd new canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (0 @ 0)).		canvas canvas announce: (RSMouseMiddleDragStart new canvas: canvas canvas).	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	canvas canvas announce: (RSMouseDragEnd new canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (-10 @ -5)).! !!RSDraggableCanvasTest methodsFor: 'tests'!testDraggingModeRight	canvas @ RSDraggableCanvas right.	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (0 @ 0)).		canvas removeInteractionIfPresent: RSDraggableCanvas.		canvas @ RSDraggableCanvas right.	canvas canvas announce: (RSMouseDragStart new canvas: canvas canvas).	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	canvas canvas announce: (RSMouseDragEnd new canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (0 @ 0)).		canvas canvas announce: (RSMouseRightDragStart new canvas: canvas canvas).	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	canvas canvas announce: (RSMouseDragEnd new canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (-10 @ -5)).! !!RSDraggableCanvasTest methodsFor: 'tests'!testDraggingOnDraggable	canvas @ RSDraggableCanvas.	canvas canvas announce: (RSMouseDragStart new canvas: canvas canvas).	canvas canvas announce: (RSMouseDragging new step: 10 @ 5; canvas: canvas canvas).	canvas canvas announce: (RSMouseDragEnd new canvas: canvas canvas).	self assert: (canvas canvas camera position closeTo: (-10 @ -5))! !!RSDraggableCanvasTest methodsFor: 'tests'!testDraggingOnNotDraggable	canvas canvas announce: (RSMouseDragging step: 10 @ 5).	self assert: canvas canvas camera position = (0 @ 0)! !!RSHighlightableTest methodsFor: 'tests'!testBasic	| c shapes previousColor |	c := RSCanvas new.	shapes := (1 to: 10) collect: [ :n | RSEllipse new size: 20; model: n ] as: RSGroup.	c addAll: shapes.	RSGridLayout on: shapes.	previousColor := shapes fifth color.	RSHighlightable new doHighlight: shapes fifth.	self assert: shapes fifth color equals: previousColor.		RSHighlightable new record: shapes fifth selector: #color value: Color blue.	self assert: shapes fifth color equals: Color blue.		RSHighlightable new restore: shapes fifth selector: #color .	self assert: shapes fifth color equals: previousColor.! !!RSPopupTest methodsFor: 'running'!setUp	super setUp.	canvas := RSCanvas new.	shapes := #(1 2) collect: [ :m | RSBox new model: m; yourself ] as: RSGroup.	shapes addLast: (RSBox new		model: 'Foobar';		yourself).	canvas addAll: shapes! !!RSPopupTest methodsFor: 'tests'!testMultiline.	shapes @ RSPopup.	self assert: canvas fixedShapes size equals: 0 .		shapes last announce: RSMouseMove.	self assert: canvas numberOfShapes equals: shapes size.	self assert: canvas fixedShapes size equals: 1.	self assert: canvas fixedShapes first shapes second shapes size equals: 2! !!RSPopupTest methodsFor: 'tests'!testNoPopup	shapes first announce: RSMouseEnter.	self assert: canvas numberOfShapes equals: shapes size.! !!RSPopupTest methodsFor: 'tests'!testPopup	"Test created while debugging https://github.com/ObjectProfile/Roassal3/issues/150"	| c |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSEllipse new  model: v; size: 10 ] as: RSGroup.	shapes @ RSPopup.	c addAll: shapes.	RSEdgeBuilder line	    canvas: c;	    withBorderAttachPoint;	    connectFrom: [ :v | v // 2 ].	RSTreeLayout on: shapes."	c edges pushBack."	c @ RSCanvasController.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes size equals: 3.	shapes first announce: RSMouseMove.	self assert: shapes first model equals: 1.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes size equals: 4.	self assert: c fixedShapes last children last text equals: '1'.		shapes first announce: RSMouseLeave.		shapes second announce: RSMouseMove.	self assert: c fixedShapes size equals: 4.	self assert: c fixedShapes last children last text equals: '2'.! !!RSPopupTest methodsFor: 'tests'!testPopupOnElementNotAddedToAView	| b |	b := RSBox new.	b @ RSPopup.	b announce: RSMouseEnter.	"Should not produce an error"! !!RSPopupTest methodsFor: 'tests'!testPopupSimple	| c s |	c := RSCanvas new.	s := RSEllipse new size: 10; model: 42.	s @ RSPopup.	c add: s.	self assert: c numberOfShapes equals: 1.	self assert: c fixedShapes isEmpty.	c shapes first announce: RSMouseMove.	self assert: c shapes first model equals: 42.	self assert: c numberOfShapes equals: 1.	self assert: c fixedShapes size equals: 1.	self assert: c fixedShapes first children second text equals: '42'! !!RSPopupTest methodsFor: 'tests'!testPopupWithoutMouseLeave	"Test created while debugging https://github.com/ObjectProfile/Roassal3/issues/150"	| c |	c := RSCanvas new.	shapes := (1 to: 30) collect: [ :v | RSEllipse new  model: v; size: 10 ] as: RSGroup.	shapes @ RSPopup.	c addAll: shapes.	RSEdgeBuilder line	    canvas: c;	    withBorderAttachPoint;	    connectFrom: [ :v | v // 2 ].	RSTreeLayout on: shapes."	c edges pushBack."	c @ RSCanvasController.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes size equals: 3.	shapes first announce: RSMouseMove.	self assert: shapes first model equals: 1.	self assert: c numberOfShapes equals: 59.	self assert: c fixedShapes size equals: 4.	self assert: c fixedShapes last children last text equals: '1'.		"Note that we do not announce RSMouseLeave"	shapes second announce: RSMouseMove.	self assert: c fixedShapes size equals: 4.	self assert: c fixedShapes last children last text equals: '2'.! !!RSPopupTest methodsFor: 'tests'!testWithPopup	shapes @ RSPopup.	self assert: canvas fixedShapes size equals: 0 .		shapes first announce: RSMouseMove.	self assert: canvas numberOfShapes equals: shapes size.	self assert: canvas fixedShapes size equals: 1.! !!RSSearchInCanvasTest methodsFor: 'running'!setUp	c := RSCanvas new.	shapes := (1 to: 10) * 100		collect: [ :n | 			RSEllipse new				size: 20;				color: Color gray;				model: n ]		as: RSGroup.	c addAll: shapes.	RSGridLayout on: shapes.	shapes @ RSPopup.	con := RSCanvasController new.	search := RSSearchInCanvas new.	con addInteraction: search.	search canvas: c.	c @ con! !!RSSearchInCanvasTest methodsFor: 'tests'!testBasic	search searchForShapes: '*4*'.	self assert: shapes fourth color ~= Color gray.	self assert: shapes fifth color = Color gray.		search searchForShapes: '*5*'.	self assert: shapes fourth color == Color gray.	self assert: shapes fifth color ~= Color gray.		self assert: search numberOfHighlightedShapes equals: 1.	search resetAllHighlightedShapes.	self assert: shapes fourth color = Color gray.	self assert: shapes fifth color = Color gray.! !!RSSearchInCanvasTest methodsFor: 'tests'!testExactMatch	search useExactMatch.	search searchForShapes: '4'.	self assert: shapes fourth color equals: Color gray.		search doNotUseExactMatch.	search searchForShapes: '4'.	self assert: shapes fourth color ~= Color gray.! !!RSSearchInCanvasTest methodsFor: 'tests'!testIsRegExpValid	self deny: (search isRegExpValid: '').	self deny: (search isRegExpValid: nil).! !!RSSearchInCanvasTest methodsFor: 'tests'!testNoSearch	self assert: (c shapes allSatisfy: [ :s | s color = Color gray ])! !!RSSearchInCanvasTest methodsFor: 'tests'!testWithEdge	| l |	l := RSLine new.	l attachPoint: RSCenteredAttachPoint new.	l color: Color black.	l from: shapes first.	l to: shapes last.	c add: l.		search searchForShapes: '*5*'.	self assert: l color equals: Color black.		search searchForShapes: '*1*'.	self assert: l color equals: Color black.		search searchForShapes: '*10*'.	self assert: l color equals: Color black! !!RSSearchInCanvasTest methodsFor: 'tests'!testWithEdgeAndhighlightable	| l interaction |		interaction := RSHighlightable new.	interaction highlightBorder: (RSBorder new width: 2).	interaction withEdges.	c shapes @ interaction.		l := RSLine new.	l attachPoint: RSCenteredAttachPoint new.	l color: Color black.	l from: shapes first.	l to: shapes last.	c add: l.		search searchForShapes: '*5*'.	self assert: l color equals: Color black.		search searchForShapes: '*1*'.	self assert: l color equals: Color black.		search searchForShapes: '*10*'.	self assert: l color equals: Color black! !!RSTransformableTest methodsFor: 'running'!setUp	canvas := RSCanvas new.	shapes := (1 to: 5) 		collect: [ :i | RSBox new size: 10; position: 10@10 * i]		as: RSGroup.	canvas addAll: shapes.! !!RSTransformableTest methodsFor: 'running'!testBasic	shapes @ RSTransformable.	! !!RSTransformableTest methodsFor: 'running'!testBasic02	| s interaction handles |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseLeftClick new.	self assert: canvas shapes size > shapes size.	handles := canvas propertyAt: interaction key.	self assert: handles notNil.	self assert: handles isNotEmpty.		canvas announce: RSMouseClick new.		self assert: canvas shapes size equals: shapes size.	handles := canvas propertyAt: interaction key.	self assert: handles isNil.			! !!RSTransformableTest methodsFor: 'running'!testCornerDirections	| interaction base new |	interaction := RSTransformable new.	base := 20@20 corner: 100@100.		new := interaction bottomRight: 10@120 rectangle: base.	self assert: new equals: 20@20 -> (10@120).		new := interaction bottomCenter: 10@120 rectangle: base.	self assert: new equals: 20@20 -> (100@120).		new := interaction bottomLeft: 0@120 rectangle: base.	self assert: new equals: 0@20 -> (100@120).		new := interaction topLeft: 0@0 rectangle: base.	self assert: new equals: 0@0 -> (100@100).		new := interaction topCenter: 50@0 rectangle: base.	self assert: new equals: 20@0 -> (100@100).		new := interaction topRight: 120@0 rectangle: base.	self assert: new equals: 20@0 -> (120@100).		new := interaction leftCenter: 0@120 rectangle: base.	self assert: new equals: 0@20 -> (100@100).		new := interaction rightCenter: 120@120 rectangle: base.	self assert: new equals: 20@20 -> (120@100).! !!RSTransformableTest methodsFor: 'running'!testDrag	| s interaction |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseLeftClick new.	self assert: (canvas propertyAt: interaction key) notNil.	s announce: RSMouseDragStart new.	self assert: (canvas propertyAt: interaction key) isNil.	s announce: RSMouseDragEnd new.	self assert: (canvas propertyAt: interaction key) notNil.! !!RSTransformableTest methodsFor: 'running'!testDrag2	| s interaction |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseDragStart new.	self assert: (canvas propertyAt: interaction key) isNil.	s announce: RSMouseDragEnd new.	self assert: (canvas propertyAt: interaction key) isNil.! !!RSTransformableTest methodsFor: 'running'!testUpdateShape	| s interaction rect handles |	interaction := RSTransformable new.	shapes @ interaction .	s := shapes first.	s announce: RSMouseLeftClick new.	rect := s encompassingRectangle.	handles := (canvas propertyAt: interaction key).	self assert: handles first class equals: RSPolygon.	handles second 		translateTo: 10@10.	self deny: rect equals: s encompassingRectangle.	! !"Roassal3-Interaction-Tests"!!RSAlignmentTest methodsFor: 'running'!setUp	super setUp.	align := RSAlignment new.! !!RSAlignmentTest methodsFor: 'tests'!testCenter 	| es |	es := (1 to: 5) collect: [ :v | RSBox new size: 10 ] as: RSGroup.	RSHorizontalLineLayout on: es.	align shapes: es.	self assert: align middle equals: align.	self assert: es encompassingRectangle equals: ((0.0@0.0) corner: (90.0@10.0)).	"		RSCanvas new addAll: es; yourself.	"! !!RSAlignmentTest methodsFor: 'tests'!testCenter2	align center.! !!RSAlignmentTest methodsFor: 'tests'!testFromBottom	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSHorizontalLineLayout on: es.	es second translateBy: 0 @ 150.	self assert: (es collect: [ :e | e encompassingRectangle bottom ]) asArray equals: #(10.0 170.0 30.0 40.0 50.0 60.0 70.0 80.0 90.0 100.0).	self assert: align bottomMostShape equals: es second.	align bottom.	self assert: (es collect: [ :e | e encompassingRectangle bottom ]) asArray equals: #(170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0)	"		RSView new addAll: es; yourself.	"! !!RSAlignmentTest methodsFor: 'tests'!testFromLeft	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSVerticalLineLayout on: es.	es second translateBy: -150 @ 0.	self assert: (es collect: [ :e | e encompassingRectangle left ]) asArray equals: #(0.0 -150.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align leftMostShape equals: es second.	align left.	self assert: (es collect: [ :e | e encompassingRectangle left ]) asArray equals: #(-150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0)"		RSView new addAll: es; inspect.	"! !!RSAlignmentTest methodsFor: 'tests'!testFromLeftWithAFixShape	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSVerticalLineLayout on: es.	es second translateBy: -150 @ 0.	align fixedShape: es first.	align left.	self assert: (es collect: [ :e | e encompassingRectangle left ]) asArray equals: #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)"		RSView new addAll: es; inspect.	"! !!RSAlignmentTest methodsFor: 'tests'!testFromLeftWithFixedShape	| es c |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSVerticalLineLayout on: es.	es second translateBy: -150 @ 0.	c := RSCanvas new.	c addAll: es.	es do: [ :s | s setAsFixed ].	self assert: (es collect: [ :e | e encompassingRectangle left ]) asArray equals: #(0.0 -150.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align leftMostShape equals: es second.	align left.	self assert: (es collect: [ :e | e encompassingRectangle left ]) asArray equals: #(-150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0)"		RSView new addAll: es; inspect.	"! !!RSAlignmentTest methodsFor: 'tests'!testFromRight	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSVerticalLineLayout on: es.	es second translateBy: 150 @ 0.	self assert: (es collect: [ :e | e encompassingRectangle right ]) asArray equals: #(10.0 170.0 30.0 40.0 50.0 60.0 70.0 80.0 90.0 100.0).	self assert: align rightMostShape equals: es second.	align right.	self assert: (es collect: [ :e | e encompassingRectangle right ]) asArray equals: #(170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0)! !!RSAlignmentTest methodsFor: 'tests'!testFromTop	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSHorizontalLineLayout on: es.	es second translateBy: 0 @ -50.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(0.0 -50.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align topMostShape equals: es second.	align top.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(-50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0).! !!RSAlignmentTest methodsFor: 'tests'!testFromTopWithAFixShape	| es |	es := (10 to: 100 by: 10) collect: [ :n | RSBox new size: n; yourself ].	align shapes: es.	RSHorizontalLineLayout on: es.	es second translateBy: 0 @ -50.	align fixedShape: es third.		self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(0.0 -50.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align topMostShape equals: es third.	align top.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)."For debugging only:RSCanvas new addAll: es; yourself."! !!RSAlignmentTest methodsFor: 'tests'!testHasElement	self deny: align hasShape.	align shapes: (Array with: RSBox new).	self assert: align hasShape.	align shapes: #().	self deny: align hasShape.! !!RSAlignmentTest methodsFor: 'tests'!testNoErrorOnDefault	RSAlignment new left; right; top; bottom! !!RSResizeTest methodsFor: 'running'!setUp	super setUp.	shapes := (1 to: 3) collect: [ :o | 		RSBox new			height: o;			width: o + 1;			yourself ].	resize := RSResize new.	resize shapes: shapes.! !!RSResizeTest methodsFor: 'tests'!testBiggestExtent	self assert: resize biggestExtent equals: 4 @ 3! !!RSResizeTest methodsFor: 'tests'!testBiggestShape	self assert: resize biggestShape equals: shapes last.	resize useBiggestShape.	self assert: resize fixedShape equals: shapes last.! !!RSResizeTest methodsFor: 'tests'!testHighestShape	self assert: resize highestShape equals: shapes last.! !!RSResizeTest methodsFor: 'tests'!testSameHeight	resize fixedShape: shapes second.	resize sameHeight.	self assert: (shapes collect: #extent) sorted asArray equals: (Array with: (2.0@2.0) with: (3.0@2.0) with: (4.0@2.0))! !!RSResizeTest methodsFor: 'tests'!testSameSize	resize fixedShape: shapes second.	resize sameSize.	self assert: (shapes collect: #extent) asSet asArray equals: (Array with: (3.0@2.0))! !!RSResizeTest methodsFor: 'tests'!testSameSizeWithoutFixedShape	resize sameSize.	self assert: (shapes collect: #extent) asSet asArray equals: (Array with: (4.0 @ 3.0))! !!RSResizeTest methodsFor: 'tests'!testSameWidth	resize fixedShape: shapes second.	resize sameWidth.	self assert: (shapes collect: #extent) sorted asArray equals: (Array with: (3.0@1.0) with:(3.0@2.0) with: (3.0@3.0))! !!RSResizeTest methodsFor: 'tests'!testWidestShape	self assert: resize widestShape equals: shapes last.! !!RSEdgeBuilderTest methodsFor: '*Roassal3-Layouts-Tests'!testUseInLayout	b		canvas: canvas;		connectTo: [ :v | v + 1 ].	RSTreeLayout on: canvas nodes.	self assert: (canvas nodes collect: #position) asArray equals: ((Array new: 10) at: 1 put: ((7.5@7.5)); at: 2 put: ((15.5@7.5)); at: 3 put: ((23.5@7.5)); at: 4 put: ((31.5@7.5)); at: 5 put: ((39.5@7.5)); at: 6 put: ((47.5@7.5)); at: 7 put: ((55.5@7.5)); at: 8 put: ((63.5@7.5)); at: 9 put: ((71.5@7.5)); at: 10 put: ((79.5@7.5)); yourself)! !!RSEdgeBuilderTest methodsFor: '*Roassal3-Layouts-Tests'!testUseInLayoutDefault	b 		canvas: canvas;		connectTo: [ :v | v + 1 ].	RSTreeLayout on: canvas nodes.		self assert: (canvas nodes collect: #position) asArray equals: ((Array new: 10) at: 1 put: ((7.5@7.5)); at: 2 put: ((7.5@32.5)); at: 3 put: ((7.5@57.5)); at: 4 put: ((7.5@82.5)); at: 5 put: ((7.5@107.5)); at: 6 put: ((7.5@132.5)); at: 7 put: ((7.5@157.5)); at: 8 put: ((7.5@182.5)); at: 9 put: ((7.5@207.5)); at: 10 put: ((7.5@232.5)); yourself)! !"Roassal3-Layouts-Tests"!!RSAbstractChartTest class methodsFor: 'testing'!isAbstract	^ self =  RSAbstractChartTest! !!RSAbstractChartTest methodsFor: 'tests'!classToTest	self subclassResponsibility! !!RSAbstractChartTest methodsFor: 'tests'!setUp 	super setUp.	chart := RSChart new.	! !!RSAbstractChartTest methodsFor: 'tests'!testBasic	self assert: chart numberOfPlots equals: 0! !!RSAbstractChartTest methodsFor: 'tests'!testEmptyPlot	| p |	p := self classToTest new x: #(0) y: #(0).	chart addPlot: p.	chart addDecoration: (RSVerticalTick new integer fontSize: 10; doNotUseNiceLabel).	chart addDecoration: (RSHorizontalTick new  integer fontSize: 10; doNotUseNiceLabel).	chart build.! !!RSAbstractChartTest methodsFor: 'tests'!testOpening	| x |	chart := RSChart new.	x := 0 to: 2 by: 1 / 100.	chart addPlot: (self classToTest new x: x y: x).	chart addPlot: (self classToTest new x: x y: (x collect: #squared)).	chart addPlot: (self classToTest new x: x y: (x collect: [ :v | v * v * v ])).	chart build.	chart show delete! !!RSAbstractChartTest methodsFor: 'tests'!testWithOnePlot	| p |	p := self classToTest new x: #(1 2 3) y: #(1 2 3).	chart addPlot: p.	self assert: chart numberOfPlots equals: 1.	chart build.		self assert: chart plots size equals: 1.	self assert: chart plots first equals: p.	self assert: p chart equals: chart! !!RSAbstractChartTest methodsFor: 'tests'!testWithOnePlotWithTitle	| p |	p := self classToTest new x: #(1 2 3) y: #(1 2 3).	chart addPlot: p.	self assert: chart numberOfPlots equals: 1.	chart title: 'Hello World'.	chart build.		self assert: chart plots size equals: 1.	self assert: chart plots first equals: p.	self assert: p chart equals: chart! !!RSAbstractChartTest methodsFor: 'tests'!testWithOnePlotWithTitleAndTitleOnAxes	| p |	p := self classToTest new x: #(1 2 3) y: #(1 2 3).	chart addPlot: p.	chart xlabel: 'X Axis'.	chart ylabel: 'Y Axis'.	self assert: chart numberOfPlots equals: 1.	chart title: 'Hello World'.	chart build.		self assert: chart plots size equals: 1.	self assert: chart plots first equals: p.	self assert: p chart equals: chart! !!RSAbstractChartTest methodsFor: 'tests'!testWithTwoPlots	| p1 p2 |	p1 := self classToTest new x: #(1 2 3) y: #(1 2 3).	p2 := self classToTest new x: #(-1 0 1) y: #(-2 0 2).	chart addPlot: p1.	chart addPlot: p2.	self assert: chart numberOfPlots equals: 2.	self assert: chart minValueX equals: -1.	self assert: chart maxValueX equals: 3.	self assert: chart maxValueY equals: 3.	self assert: chart minValueY equals: -2.! !!RSBarPlotTest methodsFor: 'tests'!classToTest	^ RSBarPlot! !!RSBarPlotTest methodsFor: 'tests'!test2BarPlots	| d1 d2 extent vtick |	d1 := #(4 10 5 9).	d2 := #(-5 -6 -3 -3 ).	extent := chart extent.	chart addPlot: (RSBarPlot new y: d1).	chart addPlot: (RSBarPlot new y: d2).	vtick := RSVerticalTick new withNoLabels.	chart addDecoration: vtick.	chart build.	self 		assert: chart canvas encompassingRectangle extent 		equals: extent+(vtick configuration tickSize @0).! !!RSLinePlotTest methodsFor: 'tests'!classToTest	^ RSLinePlot! !!RSScatterPlotTest methodsFor: 'tests'!classToTest	^ RSScatterPlot! !!RSChartTest methodsFor: 'tests'!testBasic	| x |	x := -10.0 to: 20.0 count: 100.	RSChart new    addPlot: (RSScatterPlot new x: x y: (x raisedTo: 3));    addPlot: (RSLinePlot new x: x y: (x raisedTo: 2));	addDecoration: RSHorizontalTick new;	addDecoration: RSVerticalTick new;	build! !!RSChartTest methodsFor: 'tests'!testMinMaxValue	| y c |	y := #(10 13 15).	c := RSChart new.	c addPlot: (RSLinePlot new y: y).	c build.	self assert: c minValueX equals: 1.	self assert: c maxValueX equals: 3.	self assert: c minValueY equals: 10.	self assert: c maxValueY equals: 15.! !!RSChartTest methodsFor: 'tests'!testMinMaxValue2	| y c x |	y := #(-10 -13 -15).	x := #(4 6 9).	c := RSChart new.	c addPlot: (RSLinePlot new x: x y: y).	c build.	self assert: c minValueX equals: 4.	self assert: c maxValueX equals: 9.	self assert: c minValueY equals: -15.	self assert: c maxValueY equals: -10.! !!RSChartTest methodsFor: 'tests'!testMustInclude0	| y c |	y := #(10 13 15).	c := RSChart new.	c addPlot: (RSLinePlot new y: y).	c mustInclude0inY.	c build.	self assert: c minValueX equals: 1.	self assert: c maxValueX equals: 3.	self assert: c minValueY equals: 0.	self assert: c maxValueY equals: 15.! !!RSChartTest methodsFor: 'tests'!testMustInclude02	| y c |	y := #(-10 -13 -15).	c := RSChart new.	c addPlot: (RSLinePlot new y: y).	c mustInclude0inY.	c build.	self assert: c minValueX equals: 1.	self assert: c maxValueX equals: 3.	self assert: c minValueY equals: -15.	self assert: c maxValueY equals: 0.! !!RSChartTest methodsFor: 'tests'!testMustInclude03	| y c x |	y := #(-10 -13 -15).	x := #(4 6 9).	c := RSChart new.	c addPlot: (RSLinePlot new x: x y: y).	c mustInclude0inX.	c build.	self assert: c minValueX equals: 0.	self assert: c maxValueX equals: 9.	self assert: c minValueY equals: -15.	self assert: c maxValueY equals: -10.! !!RSChartTest methodsFor: 'tests'!testWithWeirdValues	| values g d line c |	values := {Float infinity negated. Float infinity negated. 0.30102999566398114. 0.47712125471966244}.	g := RSChart new.	d := RSLinePlot new y: values.	g addPlot: d.	g build.	c := g canvas.		self assert: c numberOfShapes equals: 2.	self assert: c shapes first class equals: RSBox.		line := c shapes second.	self assert: line controlPoints size equals: 2.! !!RSChartTest methodsFor: 'tests'!testWithWeirdValuesBar		| values g d line c |	self skip.	values := {Float infinity negated. Float infinity negated. 0.30102999566398114. 0.47712125471966244}.	g := RSChart new.	d := RSScatterPlot new y: values.	g addPlot: d.	g build.	c := g canvas.		self assert: c numberOfShapes equals: 2.	self assert: c shapes first class equals: RSBox.		line := c shapes second.	self assert: line controlPoints size equals: 2.! !!RSChartTest methodsFor: 'tests'!testWithWeirdValuesLine	| values g d line c |	values := {Float infinity negated. Float infinity negated. 0.30102999566398114. 0.47712125471966244}.	g := RSChart new.	d := RSLinePlot new y: values.	g addPlot: d.	g build.	c := g canvas.		self assert: c numberOfShapes equals: 2.	self assert: c shapes first class equals: RSBox.		line := c shapes second.	self assert: line controlPoints size equals: 2.! !!RSChartTest methodsFor: 'tests'!testWithWeirdValuesLineWithTicks	| values g d line c |	values := {Float infinity negated. Float infinity negated. 0.30102999566398114. 0.47712125471966244}.	g := RSChart new.	d := RSLinePlot new y: values.	g addPlot: d.	g addDecoration: RSHorizontalTick new.	g addDecoration: RSVerticalTick new.	g build.	c := g canvas.		self assert: c numberOfShapes equals: 20.	self assert: c shapes first class equals: RSBox.		line := c shapes second.	self assert: line controlPoints size equals: 2.! !!RSChartTest methodsFor: 'tests'!testWithWeirdValuesLineWithTicks2	| x g d c labels |	x := { -5 . 0 . 1 . 2 }.	g := RSChart new.	d := RSLinePlot new x: x y: x log.	g addPlot: d.	g addDecoration: RSVerticalTick new.	g build.		self assert: g minValueX equals: -5.	self assert: g minValueY equals: 0.	self assert: g maxValueX equals: 2.	self assert: g maxValueY equals: 8 / 25.	c := g canvas.		labels := c shapes select: [ :s | s class == RSLabel ].	self assert: labels first position y <= 0	! !!RSChartTest methodsFor: 'tests'!testWithWeirdValuesLineWithTicks3	| x g d c labels |	x := -5 to: 5 by: 0.1.	self skip.	g := RSChart new.	d := RSLinePlot new x: x y: x log.	g addPlot: d.	g addDecoration: RSVerticalTick new.	g build.		self assert: g minValueX equals: -5.	self assert: g minValueY closeTo: -1.0000000000000044.	self assert: g maxValueX equals: 5.	self assert: g maxValueY equals: 4 / 5.	c := g canvas.		labels := c shapes select: [ :s | s class == RSLabel ].	self assert: labels first position y <= 0	! !!RSChartTest methodsFor: 'tests'!testYMarker	| x c p1 p2 marker line |	x := -3.14 to: 3.14 by: 0.01.	c := RSChart new.	p1 := RSLinePlot new.	p1 x: x y: x sin * 0.22.	c addPlot: p1.	p2 := RSLinePlot new.	p2 x: x y: x cos * 0.18.	c addPlot: p2.	c addDecoration: RSHorizontalTick new.	c addDecoration: RSVerticalTick new asFloat.	marker := RSYMarkerDecoration new.	c addDecoration: marker.	c build.		line := marker createMarkerLineFromPlot: p2.	self assert: line from equals: (0@ -175.0).	self assert: line to equals: (200@ -175.0)! !!RSChartTitleDecorationTest methodsFor: 'tests'!testBasic	| c |	c := RSChart new.	c title: 'hello'.	c build.		self assert: c canvas numberOfShapes equals: 2.	self assert: c canvas shapes second class equals: RSLabel.	self assert: c canvas shapes second fontSize equals: RSChartTitleDecoration new defaultFontSize.! !!RSChartTitleDecorationTest methodsFor: 'tests'!testBasic2	| c |	c := RSChart new.	c addDecoration: (RSChartTitleDecoration new title: 'hello'; fontSize: 20).	c build.	 	self assert: c canvas numberOfShapes equals: 2.	self assert: c canvas shapes second class equals: RSLabel.	self assert: c canvas shapes second fontSize equals: 20! !!RSLabelGeneratorTest methodsFor: 'running'!setUp	| nice |	super setUp.	nice := RSNiceStepSizeGenerator new.	lg := RSLabelGenerator nice: nice! !!RSLabelGeneratorTest methodsFor: 'tests'!testError	self		should: [ lg searchMin: -98.0 max: 18.0 desired: 1 ]		raise: Error		description: 'entry to short'.	self		should: [ lg searchMin: -98.0 max: 18.0 desired: 0 ]		raise: Error		description: 'entry to short'! !!RSLabelGeneratorTest methodsFor: 'tests'!testSearch	| label |	lg setLooseFlag: true.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self		assert: label asString		equals: '(Score: 0.14) -100.00	-60.00	-20.00	20.00	'.	lg setLooseFlag: false.	label := lg searchMin: -98.0 max: 18.0 desired: 3.	self		assert: label asString		equals: '(Score: 0.62) -100.00	-50.00	0.00	'.	lg setLooseFlag: true.	label := lg searchMin: -1 max: 3.5 desired: 4.	self		assert: label asString		equals: '(Score: 0.54) -1.00	0.00	1.00	2.00	3.00	4.00	'.	lg setLooseFlag: false.	label := lg searchMin: -1 max: 3.5 desired: 4.	self		assert: label asString		equals: '(Score: 0.63) -1.00	0.00	1.00	2.00	3.00	'.	lg setLooseFlag: true.	label := lg searchMin: -1 max: 200 desired: 3.	self		assert: label asString		equals: '(Score: -0.29) -25.00	50.00	125.00	200.00	'.	lg setLooseFlag: false.	label := lg searchMin: -1 max: 200 desired: 3.	self		assert: label asString		equals: '(Score: 1.00) 0.00	100.00	200.00	'.	lg setLooseFlag: true.	label := lg searchMin: 119 max: 178 desired: 3.	self		assert:			(label asString = '(Score: -0.65) 110.00	150.00	190.00	'				or: [ label asString						= '(Score: -0.65) 110.00	130.00	150.00	170.00	190.00	' ]).	lg setLooseFlag: false.	label := lg searchMin: 119 max: 178 desired: 3.	self		assert: label asString		equals: '(Score: 0.48) 120.00	150.00	180.00	'.	lg setLooseFlag: true.	label := lg searchMin: -31 max: 27 desired: 4.	self		assert: label asString		equals: '(Score: 0.07) -40.00	-30.00	-20.00	-10.00	0.00	10.00	20.00	30.00	'.	lg setLooseFlag: false.	label := lg searchMin: -31 max: 27 desired: 3.	self		assert: label asString		equals: '(Score: 0.71) -30.00	0.00	30.00	'.	lg setLooseFlag: true.	label := lg searchMin: -55.45 max: -49.99 desired: 2.	self assert: label asString equals: '(Score: -1.13) -56.00	-48.00	'.	lg setLooseFlag: false.	label := lg searchMin: -55.45 max: -49.99 desired: 3.	self		assert: label asString		equals: '(Score: 0.49) -55.00	-52.50	-50.00	'.	lg setLooseFlag: false.	label := lg searchMin: 0 max: 100 desired: 2.	self assert: label asString equals: '(Score: 1.00) 0.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 3.	self		assert: label asString		equals: '(Score: 0.95) 0.00	50.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 4.	self		assert: label asString		equals: '(Score: 0.70) 0.00	50.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 5.	self		assert: label asString		equals: '(Score: 0.85) 0.00	25.00	50.00	75.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 6.	self		assert: label asString		equals: '(Score: 0.90) 0.00	20.00	40.00	60.00	80.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 7.	self		assert: label asString		equals: '(Score: 0.80) 0.00	20.00	40.00	60.00	80.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 8.	self		assert: label asString		equals:			'(Score: 0.79) 0.00	10.00	20.00	30.00	40.00	50.00	60.00	70.00	80.00	90.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 9.	self		assert: label asString		equals:			'(Score: 0.88) 0.00	10.00	20.00	30.00	40.00	50.00	60.00	70.00	80.00	90.00	100.00	'.	label := lg searchMin: 0 max: 100 desired: 10.	self		assert: label asString		equals:			'(Score: 0.94) 0.00	10.00	20.00	30.00	40.00	50.00	60.00	70.00	80.00	90.00	100.00	'! !"Roassal3-Chart-Tests"!!RoassalSpecTest methodsFor: 'tests'!testBasic	| spec value window |	"comment"	spec := Smalltalk globals at: #SpRoassalPresenter 		ifPresent: [:cls | cls new]		ifAbsent: [^ self ].	self assert: spec class equals: SpRoassalPresenter.	window := spec openWithSpec.	value := 0.		spec script: [ :view | view addShape: RSBox new. value := value + 1 ].	self assert: value equals: 1.	spec script: [ :view | view addShape: RSBox new. value := 0 ].	self assert: value equals: 0.	window close.! !"Roassal3-Spec-Tests"!!RSUMLClassBuilderTest methodsFor: 'tests'!classToTest	^ RSUMLClassBuilder! !!RSUMLClassBuilderTest methodsFor: 'tests'!testBasic	| builder classes |	classes := RSAttachPoint withAllSubclasses.	builder := self classToTest new.	builder classes: classes.	builder build.	self assert: builder shapes size equals: classes size! !!RSUMLClassBuilderTest methodsFor: 'tests'!testJustClassName	| builder shape  |	builder := self classToTest new.	builder classes: {RSMouseMove}.	builder build.	shape := builder shapes first.	self assert: shape shapes size equals: 2.	self assert: shape shapes first class equals: RSBox.	self assert: shape shapes second class equals: RSComposite.		builder := self classToTest new.	builder classes: {RSMouseMove}.	builder renderer: RSTorchUMLClassRenderer new.	builder build.	shape := builder shapes first.	self assert: shape shapes size equals: 3.	self assert: shape shapes first class equals: RSBox.	self assert: shape shapes second class equals: RSComposite.	self assert: shape shapes third class equals: RSBox.! !"Roassal3-UML-Tests"!!RSAreaPlot commentStamp: '' prior: 0!TODO!!RSSVGPathLine commentStamp: '' prior: 0!I represent path a complex line from one point to another with an svg path!!RSBimetricLine commentStamp: '' prior: 0!I am a line with different sizes in each side.Here is how to use it, from Roassal code```| view e1 e2 box l |	view := RSView new.	box := RSShapeBuilder box 		size: 100;		draggable.	e1 := box element.	e1 color: Color blue.	e2 := box element.	e2 translateTo: 400@0.	l := RSSingleEdgeBuilder bimetricLine		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: e1;		to: e2;		edge.	view addAll: { e1. e2. l}.	view @ RSControlsView. 	view open```!!RSBimetricEdgeBuilder commentStamp: '' prior: 0!I am an edge builder for bimetric lines!!RSMultiBezierEdgeBuilder commentStamp: '' prior: 0!I am a special edge builder with some especial contruction with #linePath and #multiBezierMy instances provide a new edges that you can connect with ancestors between modelsHere is an example:-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=v := RSView new.classes := Collection withAllSubclasses.es := RSShapeBuilder circle elementsOn: classes.v addAll: es.es @ RSPopup @ RSDraggable.eb := RSEdgeBuilder line.eb color: Color gray.eb view: v.eb elements: es.eb withBorderAttachPoint."eb following: #superclass."eb connectFrom: #superclass.RSNormalizer size	elements: es;	to: 20;	normalize: #numberOfMethods.	RSNormalizer color	elements: es;	normalize: #numberOfMethods.RSClusterLayout on: es.eb2 := RSMultiBezierEdgeBuilder multiBezier.eb2 borderColor: (Color blue alpha: 0.5).eb2 view: v.eb2 elements: es.eb2 withBorderAttachPoint.eb2 following: #superclass.eb2 connectToAll: #dependentClasses.v @ RSControlsView.v  -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=!!RSSVGPath commentStamp: '' prior: 0!TODO!!RSShapeFactory class methodsFor: '*Roassal3-SVG'!svgPath	^ RSSVGPath new! !!RSAreaPlot methodsFor: 'rendering'!addPointAt: index in: s	| xval y1val y2val |	index > xValues size ifTrue: [ ^ self ].	s << (index = 1 		ifTrue: [ 'M' ]		ifFalse: [ 'L' ]).	xval := xValues at: index.	y1val := yValues at: index.	s << (self pointFor: xval@y1val).	self addPointAt: index + 1 in: s.	y2Values isNumber ifTrue: [ 		index = 1 ifTrue: [ 			s << 'L'.			y2val := y2Values.			s << (self pointFor: xValues last @ y2val).			s << 'L'.			s << (self pointFor: xValues first @ y2val).			s << 'Z'. ]	] ifFalse: [ 		s << 'L'.		y2val := y2Values at: index.		s << (self pointFor: xval@y2val).		index = 1 ifTrue: [ s << 'Z' ].	 ]			! !!RSAreaPlot methodsFor: 'rendering'!computePath	^ String streamContents: [ :s | 		self addPointAt: 1 in: s ].! !!RSAreaPlot methodsFor: 'initialization'!defaultShape	^ RSSVGPath new noPaint! !!RSAreaPlot methodsFor: 'rendering'!definedValuesY	| temp| 	temp := y2Values.	temp isNumber ifTrue: [ temp := { temp } ].	^ yValues , temp select: [ :v | v isNaN not and: [ v isInfinite not ] ]! !!RSAreaPlot methodsFor: 'rendering'!pointFor: aPoint	| spoint |	spoint := (xScale scale: aPoint x) @ (yScale scale: aPoint y).	self 		assert: (self isPointWellDefined: spoint) 		description: 'can not use invalid point to plot the graph'.	^ spoint x asFloat printString,' ',spoint y asFloat printString		! !!RSAreaPlot methodsFor: 'rendering'!renderIn: canvas	canvas add: (self shape		color: self computeColor;		svgPath: self computePath;		yourself).! !!RSAreaPlot methodsFor: 'public'!x: aCollection1 y1: aCollection2 y2: aCollection3OrNumber	"collections should have the same size"	xValues := aCollection1.	yValues := aCollection2.	y2Values := aCollection3OrNumber! !!RSAreaPlot methodsFor: 'public'!x: aCollection y: aCollection2	self shouldNotImplement! !!RSAreaPlot methodsFor: 'public'!y: aCollection	self shouldNotImplement! !!RSAthensRenderer methodsFor: '*Roassal3-SVG'!buildSVGLinePath: line	| string |	string := line svgPath value: line.		string isString ifTrue: [ | converter |		converter := ASPathConverter new stream: string readStream.		converter convertPathData do: [ :each | 			builder 				perform: each first 				withArguments: each second ]	] ifFalse: [		string value: builder.	].! !!RSAthensRenderer methodsFor: '*Roassal3-SVG'!buildSVGPath: svg	svg segments ifNil: [ ^ self ].	svg segments		do: [ :each | builder perform: each first withArguments: each second ]! !!RSBimetricLine methodsFor: 'initialization'!initialize	super initialize.	widthFrom := widthTo := 0.	self initializeSVG.! !!RSBimetricLine methodsFor: 'initialization'!initializeSVG	self		svgPath: [ :aLine | 			| e w1 w2 dist z sourcePoint targetPoint |			sourcePoint := aLine startPoint.			targetPoint := aLine endPoint.			e := 0.001.			w1 := aLine widthTo max: e.			w2 := aLine widthFrom max: e.			dist := sourcePoint distanceTo: targetPoint.			dist := dist max: e.			z := (w1 + w2) * 2.			z > dist				ifTrue: [ w1 := w1 * dist / z.					w2 := w2 * dist / z ].			[ :builder | 			| first side |			first := true.			side := [ :vector :end :size | 			| left right u unit middle l r |			u := vector normal.			unit := vector / (vector r max: e).			middle := end - (unit * size).			left := (middle - (u * size)) asFloatPoint.			l := (end - (u * size)) asFloatPoint.			right := (middle + (u * size)) asFloatPoint.			r := (end + (u * size)) asFloatPoint.			first				ifTrue: [ builder moveTo: left ]				ifFalse: [ builder lineTo: left ].			builder				curveVia: l to: end;				curveVia: r to: right ].			builder absolute.			side				value: targetPoint - sourcePoint				value: targetPoint				value: w1 / 2.			first := false.			side				value: sourcePoint - targetPoint				value: sourcePoint				value: w2 / 2.			builder close ] ]! !!RSBimetricLine methodsFor: 'accessing'!widthFrom	^ widthFrom! !!RSBimetricLine methodsFor: 'accessing'!widthFrom: aNumber	widthFrom := aNumber! !!RSBimetricLine methodsFor: 'accessing'!widthTo	^ widthTo! !!RSBimetricLine methodsFor: 'accessing'!widthTo: aNumber	widthTo := aNumber! !!RSSVGPathLine methodsFor: 'visiting'!buildPathOn: visitor	visitor buildSVGLinePath: self.! !!RSSVGPathLine methodsFor: 'accessing'!color	^ self paint! !!RSSVGPathLine methodsFor: 'accessing'!color: aColor	self paint: aColor! !!RSSVGPathLine methodsFor: 'initialization'!initialize	super initialize.	self svgPath: [:line |''].! !!RSSVGPathLine methodsFor: 'accessing'!svgPath	^svgPath! !!RSSVGPathLine methodsFor: 'accessing'!svgPath: aBlock	"aBlock return a string and recives 2 arguments, the start point and the end point"	svgPath := aBlock 	! !!RSBimetricEdgeBuilder methodsFor: 'private - utility'!edgeFrom: source to: target	| edge |	edge := super edgeFrom: source to: target.	edge		widthFrom: (widthFrom rsValue: edge model);		widthTo: (widthTo rsValue: edge model).	^ edge! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthFrom	^ widthFrom! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthFrom: anObject	widthFrom := anObject! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthTo	^ widthTo! !!RSBimetricEdgeBuilder methodsFor: 'accessing'!widthTo: anObject	widthTo := anObject! !!RSEdgeBuilder class methodsFor: '*Roassal3-SVG'!bimetricLine	^ RSBimetricEdgeBuilder new: RSBimetricLine new! !!RSMultiBezierEdgeBuilder class methodsFor: 'as yet unclassified'!multiBezier	^ self new: RSSVGPathLine new.! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!applyTensionOn: points	| n dp p1 ten |	n := points size - 1.	p1 := points first.	dp := points last - p1.	ten := self tension.	2 to: n do: [ :i| | p t |		p := points at: i.		t := (i -1)/n. 		points at: i put: (1 - ten) * (p1 + (t * dp)) + (ten * p)].! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!commonAncestor: edge with: selector	| a b aNodes bNodes sharedNode remove |	a := edge from.	b := edge to.	a == b ifTrue: [ ^ a ].	aNodes := self followersOf: a with: selector.	bNodes := self followersOf: b with: selector.	a := aNodes removeLast.	b := bNodes removeLast.	sharedNode := nil.	remove := [ :list | list 		ifEmpty: [ nil ]		ifNotEmpty: [ list removeLast ] ].	[ a == b ] whileTrue: [ 		sharedNode := a.		sharedNode ifNil: [ ^ nil ].		a := remove value: aNodes.		b := remove value: bNodes. ].	^ sharedNode.! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!commonShapes: edge with: selector	"obtaint a list of points from the elements in the view based on a selector"	| from to ancestor shapes search index |	from := edge from.	to := edge to.	ancestor := self commonAncestor: edge with: selector.	ancestor ifNil: [ 		shapes := (self followersOf: from with: selector),			(self followersOf: to with: selector) reverse.		^ shapes ].	search := [ :model | canvas shapeFromModel: (selector rsValue: model) ].	shapes := OrderedCollection new.	shapes add: from.	[ from == ancestor ] whileFalse: [ 		from := search value: from model.		shapes add: from ].	index := shapes size.	[ to == ancestor ] whileFalse: [ 		shapes add: to afterIndex: index.		to := search value: to model ].	shapes do: [ :e | (e connectedEdges includes: edge)		ifFalse: [ e addConnectedEdge: edge ] ].	^ shapes.	! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!followersOf: element with: selector	| t followers |	followers := OrderedCollection new.	t := element. 	[ t notNil ] whileTrue: [ 		followers add: t.		t := canvas shapeFromModel: (selector rsValue: t model) ].	^ followers! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!following: selector	self shape svgPath: [ :line | [:builder | 		| points commonShapes att a b |		att := line properties.		a := line startPoint.		b := line endPoint.		commonShapes := att			at: #commom			ifAbsentPut: [ self commonShapes: line with: selector ].		points := commonShapes collect: [ :e | e position asFloatPoint ].		points removeFirst; removeLast; addFirst: a; addLast: b.		self applyTensionOn: points. 		builder absolute; moveTo: points first.		2 to: points size - 2 do: [ :i | | p1 p2 |			p1 := points at: i.			p2 := points at: i +1.			builder 				curveVia: p1				to: (p1 + p2)/2 ].		builder			curveVia:( points at: points size -1)			to: points last ] ].! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!tension	^ tension ifNil: [ tension := 0.7 ]! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!tension: aNumberOrBlock	"tension should evaluate it and return a value between 0 and 1. 	0 means straight lines	1 means a curve line"	tension := aNumberOrBlock! !!RSSVGPath methodsFor: 'visiting'!buildPathOn: visitor	visitor buildSVGPath: self.! !!RSSVGPath methodsFor: 'private'!centerSegment: segment absolute: absolute position: position	"maybe we can have an iterator with polymorphic objects"	| key args |	key := segment first.	args := segment second.	key = #absolute ifTrue: [ ^ true ].	key = #relative ifTrue: [ ^ false ].	(key = #ellipticalArc:xrot:large:sweep:to:relative:) ifTrue: [ 		absolute ifTrue: [ 			args at: 5 put: args fifth - position.			args at: 6 put: false ].		^ absolute ].	key = #vLineTo: ifTrue: [ 		absolute ifTrue: [ args at: 1 put: args first - position y ]. 		^ absolute].	key = #hLineTo: ifTrue: [ 		absolute ifTrue: [ args at: 1 put: args first - position x ]. 		^ absolute].	absolute ifTrue: [ 		args doWithIndex: [ :point :index | 			args at: index put: point - position ] ].	^ absolute! !!RSSVGPath methodsFor: 'private'!centerSegments	| rect absolute position |	rect := self segmentsRectangle.	position := rect floatCenter.	absolute := true.	segments do: [ :segment | 		absolute := self 			centerSegment: segment 			absolute: absolute 			position: position  ].					polygons do: [ :polygon |		polygon doWithIndex: [ :point :index |			polygon at: index put: point - position ] ].	rect := self segmentsRectangle.	self position: position.	baseRectangle := Rectangle floatCenter: 0@0 extent: rect extent.! !!RSSVGPath methodsFor: 'private'!computePolygons	| subPath absolute position point |	polygons := OrderedCollection new.	subPath := OrderedCollection new.	absolute := true.	position := 0@0.	point := [:da | position := absolute 		ifTrue:[ da ] 		ifFalse: [ position + da ].		subPath add: position ].	segments do: [ :segment | | key args |		key := segment first.		args := segment second.		key = #absolute ifTrue: [ absolute := true ].		key = #relative ifTrue: [ absolute := false ].		key = #moveTo: ifTrue: [ 			subPath ifNotEmpty: [ 				polygons add: subPath ]. 			subPath:= OrderedCollection new.			point value: args first ].		key = #close ifTrue: [ 			position := subPath first ].		key = #curveVia:and:to: ifTrue: [ 			point value: args third ].		key = #curveVia:to: ifTrue: [ 			point value: args second ].		key = #lineTo: ifTrue: [ 			point value: args first ].		key = #reflectedCurveVia:to: ifTrue: [ 			point value: args second ].		key = #ellipticalArc:xrot:large:sweep:to:relative: ifTrue: [ 			point value: args fifth ].		key = #hLineTo: ifTrue: [			position := absolute				ifTrue: [ args first @ position y ]				ifFalse: [ position + (args first @ 0) ].			subPath add: position ].		key = #vLineTo: ifTrue: [ 			position := absolute				ifTrue: [ position x @ args first ]				ifFalse: [ position + (0 @ args first) ].			subPath add: position ].		].	polygons add: subPath	! !!RSSVGPath methodsFor: 'private'!computeSegments	| pathData | 	pathData := ASPathConverter new stream: svgPath readStream.	segments := pathData convertPathData.! !!RSSVGPath methodsFor: 'accessing'!extent: newExtent	| min max s extent |	segments ifNil: [ ^ self ].	extent := baseRectangle extent.	extent = newExtent 		ifTrue: [ ^ self ].	min := self position - (extent / 2).	max := self position + (extent / 2).	s := newExtent / (max - min).	segments do: [ :segment | | args |		args := segment second.		args doWithIndex: [ :point :index |			args at: index put: (point isPoint				ifTrue: [ point * s ]				ifFalse: [ point * s x ] ) ] ].	polygons do: [ :polygon|		polygon doWithIndex: [ :point :index |			polygon at: index put: point * s ]  ].	super extent: newExtent.! !!RSSVGPath methodsFor: 'testing'!includesPoint: aPoint	| invertedPoint |	invertedPoint := matrix inverseTransform: aPoint.		^ (self baseRectangle containsPoint: invertedPoint)		ifFalse: [ false ]		ifTrue: [ | apt |			apt := AthensPolygonTester new.			polygons anySatisfy: [ :eachPolygon | 				(apt polygon: eachPolygon) includesPoint: invertedPoint]]! !!RSSVGPath methodsFor: 'accessing'!segments	^ segments! !!RSSVGPath methodsFor: 'private'!segments: aCollection	segments := aCollection! !!RSSVGPath methodsFor: 'private'!segmentsRectangle	| allPoints |	allPoints := polygons flatCollect: [:poly | poly ].	^ Rectangle encompassing: allPoints! !!RSSVGPath methodsFor: 'accessing'!svgPath 	^ svgPath! !!RSSVGPath methodsFor: 'accessing'!svgPath: aString 	svgPath := aString.	self computeSegments.	self computePolygons.	self centerSegments.	self resetPath.! !"Roassal3-SVG"!!RSSVGTest methodsFor: 'as yet unclassified'!testDrawSVG	canvas addShape: (RSSVGPath new).	canvas addShape: (RSSVGPath new		svgPath: 'M 100 350 q 150 -300 300 0';		yourself).	canvas createMorph drawOnMockCanvas.! !!RSSVGTest methodsFor: 'as yet unclassified'!testDrawSVGLine	canvas addShape: (RSSVGPathLine new		strokeColor: Color red;		svgPath: [ :aLine | 'M 100 100 L 200 200' ];		width: 2). 	canvas addShape: (RSSVGPathLine new		strokeColor: Color red;		svgPath: [:aLine | String streamContents: [:stream |			| a b |			a := aLine startPoint.			b := aLine endPoint.			stream 				nextPutAll: 'M ';				nextPutAll: a x asString;				space;				nextPutAll: a y asString;				space;				nextPutAll: 'L ';				nextPutAll: b x asString;				space;				nextPutAll: b y asString.		] ];		startPoint: 100@100;		endPoint: 200@200;		width: 2). 	canvas addShape: (RSSVGPathLine new		strokeColor: Color red;		svgPath: [ :aLine | [ :canvas| 			canvas				absolute;				moveTo: aLine startPoint;				lineTo: aLine endPoint. ] ];		width: 2). 	canvas createMorph drawOnMockCanvas.! !"Roassal3-SVG-Tests"!!RSSVGShapeExamples commentStamp: '' prior: 0!I have basic svg examples!!RSSVGAnimatioinExamples commentStamp: '' prior: 0!I have animated svg examples!!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example13AreaPlot	<script: 'self new example13AreaPlot open'>	| x y1 y2  c canvas charts |	x := 0 to: 2 by: 0.01.	y1 := (2 * Float pi * x) sin.	y2 := 1.2 * (4 * Float pi * x) sin.	canvas := RSCanvas new.	charts := {'Between y1 and 0'-> (y1 -> 0).	'Between y2 and 1'-> (y1 -> 1).	'Between y1 and y2'-> (y1 -> y2)} collect: [ :assoc | | g |		g := RSGroup new.		c := RSChart new.		c container: g.		c extent: 500@100.		c addPlot: (RSAreaPlot new x: x y1: assoc value key y2: assoc value value).		c addDecoration: (RSHorizontalTick new numberOfTicks: 10; asFloat).		c addDecoration: (RSVerticalTick new numberOfTicks: 3; asFloat).		c ylabel: assoc key.		c build.		g asShape	].	RSVerticalLineLayout on: charts.	canvas addAll: charts.	canvas @ RSCanvasController.	^ canvas ! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example14AreaPlotWithError	<script: 'self new example14AreaPlotWithError open'>	| x y polyfit res y_est y_err c |	x := 0 to: 10.	y := #(3.9 4.4 10.8 10.3 11.2 13.1 14.1 9.9 13.9 15.1 12.5).	polyfit := [ :x1 :y1 :n |  		"TODO"		"Need a real polyfit implementation for any n"		"maybe not in roassal3 maybe in polymath"		"https://en.wikipedia.org/wiki/Curve_fitting"		0.9-> 6].	res := polyfit value: x value: y value: 1.	y_est := res key * x + res value.	y_err := x stdev * ( (1/x size) + 		(( (x - x average) raisedTo: 2) / 		((x - x average) raisedTo: 2) sum) ) sqrt. 			c := RSChart new.	c addPlot: (RSAreaPlot new x: x y1: y_est + y_err y2: y_est - y_err; color: (Color blue alpha: 0.1) ).	c addPlot: (RSLinePlot new x: x y: y_est; color: Color red).	c addPlot: (RSScatterPlot new x: x y: y).	c addDecoration: (RSHorizontalTick new numberOfTicks: 10; asFloat).	c addDecoration: (RSVerticalTick new numberOfTicks: 3; asFloat).	^ c ! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example15AreaBox	<script: 'self new example15AreaBox open'>	| x y1 y2 c |	x := #(0 1 2 3).	y1 := #(0.8 0.8 0.2 0.2).	y2 := #(0 0 1 1).	c := RSChart new.	c extent: 150@50.	c addPlot: (RSAreaPlot new x: x y1: y1 y2: y2).	c addPlot: (RSLinePlot new x: x y: y1; color: Color red; fmt: 's--').	c addPlot: (RSLinePlot new x: x y: y2; color: Color orange; fmt: 'o--').	c addDecoration: (RSHorizontalTick new numberOfTicks: 7; asFloat).	c addDecoration: (RSVerticalTick new asFloat).	^ c! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example16Series	<script: 'self new example16Series open'>	| x cumsum c b y error |	x := 1 to: 100.	cumsum := [:arr | | sum |		sum := 0.		arr collect: [ :v | sum := sum + v. sum ] ].	c := RSChart new.	c extent: 400@400.	b := RSLegend new.	b container: c canvas.	b layout horizontal gapSize: 30.	#(	series1 red	series2 blue) pairsDo: [ :label :color |		y := (x collect: [ :i | 50 atRandom - 25 ]).		y := cumsum value: y.		error := x.				c addPlot: (RSAreaPlot new 			x: x y1: y + error y2: y - error;			color: (color value: Color) translucent).		c addPlot: (RSLinePlot new x: x y: y; fmt: 'o';			color: (color value: Color)).		b text: label withBoxColor: (color value: Color)		 ].	c build.	b build.	^ c canvas.! !!RSChartExample methodsFor: '*Roassal3-SVG-Examples'!example17CLPvsUSD	<script: 'self new example17CLPvsUSD open'>	| dates y data x c plot paint |	dates := OrderedCollection new.	y := OrderedCollection new.	data := 	{'04-jun-2020'.	769.13.	'03-jun-2020'.	782.86.	'02-jun-2020'.	796.46.	'01-jun-2020'.	806.32.	'29-may-2020'.	812.74.	'28-may-2020'.	816.47.	'27-may-2020'.	802.10.	'26-may-2020'.	803.74.	'25-may-2020'.	805.75.	'22-may-2020'.	806.17.	'20-may-2020'.	819.08.	'19-may-2020'.	820.65.	'18-may-2020'.	823.86.	'15-may-2020'.	822.93.	'14-may-2020'.	820.38.	'13-may-2020'.	821.88.	'12-may-2020'.	826.05.	'11-may-2020'.	827.65.	'08-may-2020'.	836.27.	'07-may-2020'.	839.08.	'06-may-2020'.	832.84.	'05-may-2020'.	838.74.	'04-may-2020'.	837.92} reverse.		data pairsDo: [ :f :d |			dates add: d.			y add: f ].	x := 1 to: dates size.	c := RSChart new.	c extent: 300@200.	plot := RSAreaPlot new x: x y1: y y2: 750.	paint := LinearGradientPaint fromArray: 		{0-> (Color green alpha: 0.3).		0.8 -> Color transparent}.	paint start: 0@ -100; stop: 0@ 100.	plot shape paint: paint.	c addPlot: plot.	plot := RSLinePlot new x: x y: y.	plot color: Color green muchDarker.	plot width: 2.	plot joinRound.	plot markerEnd: (RSEllipse new size: 10).	c addPlot: plot.	c addDecoration: (RSHorizontalTick new fromNames: dates).	c addDecoration: (RSVerticalTick new numberOfTicks: 10; asFloat).	c title: 'CLP vs USD'.	^ c! !!RSLayoutExamples methodsFor: '*Roassal3-SVG-Examples'!example14ClassHierarchy	<script: 'self new example14ClassHierarchy open'>	| c classes |	c := RSCanvas new.	classes := (Object withAllSubclasses first: 300)		flatCollect: #withAllSuperclasses.	classes := classes asSet 		collect: [:cls | RSEllipse new draggable; popup; model: cls; yourself] 		as: RSGroup.	c addAll: classes.	RSEdgeBuilder line		color: Color gray;		canvas: c;		shapes: classes;		connectFrom: #superclass.	RSNormalizer size		shapes: classes;		to: 20;		normalize: #numberOfMethods.	RSNormalizer color		shapes: classes;		normalize: #numberOfMethods.	RSClusterLayout on: classes.	RSMultiBezierEdgeBuilder multiBezier		borderColor: (Color blue alpha: 0.3);		canvas: c;		shapes: classes;		withBorderAttachPoint;		following: #superclass;		connectToAll: #dependentClasses.	c @ RSCanvasController.	^ c! !!RSBasicShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example16BasicLinePath	<script: 'self new example16BasicLinePath open'>	| c b1 b2 translate l arrowWidth arrowHeight middle |	c := RSCanvas new.	b1 := RSBox new size: 100@100.	b2 := RSBox new size: 100@100; color: Color blue; position: 100@100.	c addShape: b1.	c addShape: b2.		l := RSSVGPathLine new		svgPath: [ :aLine |			[ :canvas | | vector u unit left right left1 right1 a b |			a := aLine startPoint.			b := aLine endPoint.			arrowWidth := 50.			arrowHeight := 30.			vector := a-b.			u := vector normal.			unit := vector / (vector r max: 1).			middle := b + (unit* arrowHeight).			left := middle - (u * arrowWidth / 4).			right := middle + (u * arrowWidth / 4).			left1 := middle - (u * arrowWidth / 2).			right1 := middle + (u * arrowWidth / 2).						canvas				absolute;				moveTo: a;				lineTo: left;				lineTo: left1;				lineTo: b;				lineTo: right1;				lineTo: right;				close.			 ]			 ];		width: 5;		paint: Color yellow;		dashArray: { 10. 2 };		joinMiter;		startPoint: 0@0;		endPoint: 100@100.	c addShape: l.		translate := [ :evt |		l 			startPoint: b1 position;			endPoint: b2 position.		evt shape translateBy: evt step.		evt signalUpdate ].	b1 when: RSMouseDragging do: translate.	b2 when: RSMouseDragging do: translate.	^ c! !!RSSVGShapeExamples methodsFor: 'examples'!example01SVGShape	<script: 'self new example01SVGShape open'>	| c |	c := RSCanvas new.	c addShape: (RSSVGPath new		paint: nil;		withBorder;		svgPath: 'M 100 350 q 150 -300 300 0';		yourself).	c addShape: (RSSVGPath new		paint: nil;		border: (RSBorder new color: Color red);		svgPath: 'M 100 350 l 150 -300';		yourself).	c addShape: (RSSVGPath new		paint: nil;		border: (RSBorder new color: Color red);		svgPath: 'M 250 50 l 150 300';		yourself).	c addShape: (RSSVGPath new		paint: nil;		border: (RSBorder new color: Color green);		svgPath: 'M 175 200 l 150 0';		yourself).	c showEncompassingRectangles.	c zoomToFit.	^ c! !!RSSVGShapeExamples methodsFor: 'examples'!example02SpockLizard	<script: 'self new example02SpockLizard open'>	| canvas radius paint arrow relations color lb |	canvas := RSCanvas new.	radius := 1500.	paint := LinearGradientPaint fromArray: {(0 -> 'E0BA82'). (1 -> 'F4DFA5')}.	paint start: -900 @ 900; stop: 900 @ -900.	canvas addShape: (RSEllipse new		noPaint;		border: (RSBorder new 			width: 300; 			paint: paint;			yourself);		radius: 1500;		yourself).	arrow := RSShapeFactory triangle		extent: 380 @ 200;		color: '36C5B8';		yourself.	1 to: 5 do: [ :i | 		| angle a |		angle := i * 360 / 5 + 45.		canvas addShape: (RSPieSlice new			color: '36C5B8';			innerRadius: 1350;			externalRadius: 1650;			alphaAngle: angle;			betaAngle: (angle := angle + 15)).		a := arrow copy.		a matrix rotateByDegrees: angle negated.		angle := (angle + 3) degreesToRadians.		a position: angle cos @ angle sin negated * radius.		canvas addShape: a ].		canvas addAll: (#('paper' 'scissors' 'spock' 'lizard' 'rock') 		collectWithIndex: [:m :index|			| com ang circle hand |			ang := index * Float twoPi / 5 - Float halfPi.			hand := RSSVGPath new				svgPath: (self perform: m asSymbol).			circle := RSEllipse new 				color: Color white;				position: hand position;				size: (hand extent x max: hand extent y);				yourself.					com := RSComposite new				popup;				draggable;				model: m;				shapes: { circle. hand };				position: ang cos @ ang sin * radius				yourself.			index = 5 ifTrue: [ com scaleBy: 2 ].			com		]).	relations := {('scissors' -> 'lizard').	('lizard' -> 'paper').	('paper' -> 'spock').	('spock' -> 'rock').	('rock' -> 'scissors')}.	color := NSScale category20c.	RSEdgeBuilder bezier		controlPointsController: (RSBlockCPController new			block: [ :aLine | 				| vec f t a b |				a := aLine from position.				b := aLine to position.				vec := b - a.				f := vec * 0.25 + a.				t := vec * 0.75 + a.				Array with: f with: 0@0 with: t ];			yourself);		canvas: canvas;		useAssociations: relations.	canvas edges do: [ :ed | | col |		col := color scale: ed.		ed			border: (RSBorder new				width: 300;				color: col;				yourself);			markerEnd: ((arrow copy 				color: col				yourself) asMarker				offset: -90;				yourself)  ].  	lb := RSLegend new.	lb defaultLabel fontSize: 50.	lb container: canvas.	lb leyendDo: [ :l |l withBorder;padding: 50 ].	lb		text:			'... It''s very simple. Scissors cuts paper, paper covers rock, rock crushes lizard, lizard poisons Spock, Spock smashes scissors, ';		text:			'scissors decapitates lizard, lizard eats paper, paper disproves Spock, Spock vaporizes rock, and, as it always has, rock crushes scissors';		build.	canvas @ RSCanvasController.	^ canvas! !!RSSVGShapeExamples methodsFor: 'data - svg'!lizard	^ 'M560.8,71.3c19.5,0,38,4.5,55.5,13.4c17.5,8.9,32.1,21.2,43.5,36.8l273.7,373.7c37.6,50.7,56.5,108,56.5,171.8v169.9c0,25.5-8.9,47.2-26.8,65.1s-39.6,26.8-65.1,26.8H714.4c-25.5,0-47.2-8.9-65.1-26.8s-26.8-39.6-26.8-65.1v-84.7l-136.9-68.4H224.4c-25.5,0-47.2-8.9-65.1-26.8c-17.9-17.9-26.8-39.6-26.8-65.1v-15.3c0-38,13.5-70.4,40.4-97.4c27-27,59.4-40.4,97.4-40.4h201l20.1-61.3H163.1c-31.9,0-59.6-10.8-83-32.3c-23.4-21.5-36.4-48.1-39-79.7C20.4,240.3,10,211.3,10,178.4v-15.3c0-25.5,8.9-47.2,26.8-65.1c17.9-17.9,39.6-26.8,65.1-26.8H560.8L560.8,71.3z M928.8,836.9V667c0-50.1-14.8-95.4-44.5-135.9L610.1,157.4c-12.4-16.6-28.9-24.9-49.3-24.9H101.9c-8.3,0-15.5,3-21.5,9.1c-6.1,6.1-9.1,13.2-9.1,21.5c0,10.2,0.2,18.1,0.7,23.7c0.5,5.6,2,12,4.5,19.4s6.5,14.2,12,20.6c3.2-9.9,8.9-17.9,17-23.9s17.1-9.1,27-9.1h398.1v15.3H132.5c-8.3,0-15.5,3-21.5,9.1c-6.1,6.1-9.1,13.2-9.1,21.5c0,14,0.5,23.3,1.4,27.8c2.6,14,9.6,25.7,21.1,34.9c11.5,9.3,24.4,13.9,38.8,13.9h349.8c12.8,0,23.6,4.5,32.5,13.4c8.9,8.9,13.4,19.8,13.4,32.5c0,4.8-0.8,9.6-2.4,14.4l-30.6,91.9c-3.2,9.3-8.8,16.8-16.7,22.7c-8,5.9-16.9,8.9-26.8,8.9h-212c-21.1,0-39.1,7.5-54.1,22.5c-15,15-22.5,33-22.5,54.1v15.3c0,8.3,3,15.5,9.1,21.5c6.1,6.1,13.2,9.1,21.5,9.1h268.4c5.1,0,9.7,1.1,13.9,3.3l151.7,75.6c7.7,4.1,13.8,9.9,18.4,17.2c4.6,7.3,6.9,15.3,6.9,23.9v94.3c0,8.3,3,15.5,9.1,21.5c6.1,6.1,13.2,9.1,21.5,9.1h183.8c8.3,0,15.5-3,21.5-9.1C925.7,852.3,928.8,845.2,928.8,836.9L928.8,836.9z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!paper	^ 'M535.1,80.1c-16.8,0-31.2,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2v358.8h-17.5V211.3c0-16.8-6-31.2-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-16.8,0-31.1,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2v428.8l-84.2-112.1c-13.9-18.6-32.5-27.9-55.8-27.9c-19.3,0-35.8,6.8-49.5,20.5c-13.7,13.7-20.5,30.2-20.5,49.5c0,15.7,4.7,29.7,14.2,42.1l210,280c13.9,18.6,32.5,27.9,55.8,27.9h376.3c12.4,0,23.5-4,33.4-12c9.8-8,16.1-18.2,18.6-30.7l41.6-221.5c1.8-11.7,2.7-22.4,2.7-32.3V351.3c0-16.8-6-31.2-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-16.8,0-31.1,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2V500h-17.5V211.3c0-16.8-6-31.1-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-16.8,0-31.1,6-43.2,18.1c-12,12-18.1,26.4-18.1,43.2V500h-17.5V141.2c0-16.8-6-31.1-18.1-43.2C566.3,86,551.9,80,535.1,80.1L535.1,80.1z M535.1,10.1c24.8,0,47.6,6.5,68.6,19.4c21,12.9,37.1,30.5,48.4,52.8c6.9-1.4,14.6-2.2,23-2.2c36.1,0,67,12.9,92.7,38.6c25.7,25.7,38.6,56.6,38.6,92.7v9.3c38.3-2.2,71.2,9.5,98.7,35c27.5,25.5,41.3,57.4,41.3,95.7v272.4c0,14.6-1.4,29.7-4.3,45.4L900.3,890c-5.1,28.8-19,52.7-41.9,71.6c-22.8,18.9-49,28.4-78.5,28.4H403.8c-21.9,0-42.8-5-62.6-15.1c-19.9-10-36.4-23.6-49.5-40.7l-210-280C63,629.4,53.8,601.4,53.8,570c0-38.6,13.7-71.6,41-99c27.3-27.3,60.3-41,99-41c28.4,0,51.8,6.2,70,18.6V211.3c0-36.1,12.9-67,38.6-92.7C328,92.9,358.9,80,395,80c8.4,0,16.1,0.7,23,2.2c11.3-22.3,27.4-39.9,48.4-52.8c21-12.9,43.8-19.4,68.6-19.4L535.1,10.1z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!rock	^ 'M408.864 79.052c-22.401-33.898-66.108-42.273-98.813-23.588-29.474-31.469-79.145-31.093-108.334-.022-47.16-27.02-108.71 5.055-110.671 60.806C44.846 105.407 0 140.001 0 187.429v56.953c0 32.741 14.28 63.954 39.18 85.634l97.71 85.081c4.252 3.702 3.11 5.573 3.11 32.903 0 17.673 14.327 32 32 32h252c17.673 0 32-14.327 32-32 0-23.513-1.015-30.745 3.982-42.37l42.835-99.656c6.094-14.177 9.183-29.172 9.183-44.568V146.963c0-52.839-54.314-88.662-103.136-67.911zM464 261.406a64.505 64.505 0 0 1-5.282 25.613l-42.835 99.655c-5.23 12.171-7.883 25.04-7.883 38.25V432H188v-10.286c0-16.37-7.14-31.977-19.59-42.817l-97.71-85.08C56.274 281.255 48 263.236 48 244.381v-56.953c0-33.208 52-33.537 52 .677v41.228a16 16 0 0 0 5.493 12.067l7 6.095A16 16 0 0 0 139 235.429V118.857c0-33.097 52-33.725 52 .677v26.751c0 8.836 7.164 16 16 16h7c8.836 0 16-7.164 16-16v-41.143c0-33.134 52-33.675 52 .677v40.466c0 8.836 7.163 16 16 16h7c8.837 0 16-7.164 16-16v-27.429c0-33.03 52-33.78 52 .677v26.751c0 8.836 7.163 16 16 16h7c8.837 0 16-7.164 16-16 0-33.146 52-33.613 52 .677v114.445z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!scissors	^ 'M596.9,920h-96.8c-59.4,0-100.6-25.7-123.6-77.1c-8.4-17.9-12.6-36.5-12.6-55.8v-2.7c-22.6-10.9-40.6-27-53.9-48.4c-13.3-21.3-20-44.6-19.9-69.7c0-13.9,0.9-22.6,2.7-26.3H150c-38.6,0-71.6-13.7-99-41c-27.3-27.3-41-60.3-41-99c0-38.6,13.7-71.6,41-99s60.3-41,99-41h61.8l-24.1-9.3c-27-10.2-48.8-27.3-65.4-51.1c-16.6-23.8-24.9-50.4-24.9-79.6c0-38.6,13.7-71.6,41-99s60.3-41,99-41c16.8,0,33.3,3.1,49.8,9.3L630.7,220H850c38.6,0,71.6,13.7,99,41c27.3,27.3,41,60.3,41,99v365.3c0,32.1-9.8,60.8-29.5,86.1c-19.7,25.3-45.2,41.8-76.6,49.5l-185.4,46.5C665,915.8,631.1,920,596.9,920L596.9,920z M570.1,531.2L485.3,570l-89.1,40.5c-10.9,5.1-19.7,12.6-26.3,22.7c-6.6,10-9.9,21.1-9.9,33.1c0,16.8,6,31.1,18.1,43.2c12,12,26.4,18.1,43.2,18.1c9.5,0,17.8-1.8,25.1-5.5l184.9-84.2c-17.9-3.6-32.5-12.8-44-27.4c-11.5-14.6-17.2-31-17.2-49.2V531.2L570.1,531.2z M745.1,701.3c0-16.8-6-31.1-18.1-43.2c-12-12-26.4-18.1-43.2-18.1c-9.5,0-17.9,1.8-25.1,5.5l-158.6,72.2c-10.2,4.8-17,7.9-20.2,9.3c-3.3,1.4-8.8,4.6-16.7,9.3c-7.8,4.8-13.2,9.1-16.1,12.9c-2.9,3.8-5.8,9.1-8.7,15.9c-2.9,6.8-4.4,14.1-4.3,22.1c0,18.2,5.7,33.2,17.2,44.9c11.5,11.7,26.3,17.5,44.6,17.5c7.3,0,14.2-1.6,20.8-4.9l192.5-87.5c10.9-5.1,19.7-12.6,26.3-22.7c6.6-10,9.9-21.1,9.9-33.1L745.1,701.3z M618.2,290L262.8,154.4c-8.7-2.9-17.1-4.3-25.1-4.3c-19.3,0-35.8,6.8-49.5,20.5s-20.5,30.2-20.5,49.5c0,14.6,4.1,27.9,12.3,39.9s19.1,20.6,32.5,25.7l287.6,109.4v35h-350c-19.3,0-35.8,6.8-49.5,20.5c-13.7,13.7-20.5,30.2-20.5,49.5s6.8,35.8,20.5,49.5c13.7,13.7,30.2,20.5,49.5,20.5h292.6l127.4-58V403.8c0-23,8.4-42.3,25.1-58l60.7-55.8L618.2,290L618.2,290z M596.9,850c29.9,0,58.2-3.5,84.8-10.4L867,793.2c15.7-4,28.4-12.3,38.3-24.9c9.8-12.6,14.8-26.9,14.8-42.9V360.1c0-19.3-6.8-35.8-20.5-49.5c-13.7-13.7-30.2-20.5-49.5-20.5H681.7L607.3,359c-13.1,12-19.7,27-19.7,44.9v161.9c0,16.8,6,30.8,18.1,42.1c12,11.3,26.4,17,43.2,16.9c16.8,0,31.1-6.4,43.2-19.1c12-12.7,18.1-27.5,18.1-44.3V447.6h17.5v113.8c0,25.5-10.4,46.3-31.1,62.4c18.9,2.9,34.7,11.7,47.3,26.5c12.6,14.8,18.9,31.8,18.9,51.1c0,15.3-4.2,29.5-12.6,42.6c-8.4,13.1-19.5,22.8-33.4,29l-169.5,77.1H597L596.9,850z'! !!RSSVGShapeExamples methodsFor: 'data - svg'!spock	^ 'M426.6,107.9c-16.3,0-29.9,5.8-40.6,17.4c-10.7,11.6-16.1,25.5-16.1,41.9c0,4.7,0.5,9.5,1.5,14.3L448,500h-13.3l-59.2-246.1c-3-12.9-9.8-23.5-20.2-31.6c-10.4-8.1-22.2-12.2-35.5-12.2c-16,0-29.4,5.8-40.3,17.4c-10.9,11.6-16.3,25.4-16.3,41.4c0,3.7,0.7,8.7,2,14.8c1,4.4,7.6,31.8,19.9,82.2c12.3,50.4,23.9,98.3,34.7,143.9c10.8,45.6,16.3,69.1,16.3,70.4v115.9L179.5,578.7c-11.6-8.8-24.7-13.3-39.3-13.3c-17.7,0-32.9,6.2-45.7,18.6c-12.8,12.4-19.1,27.5-19.1,45.2c0,22.8,9.5,41.5,28.6,56.1l258.8,193.5c11.6,8.8,24.5,13.3,38.8,13.3h354.3c11.2,0,21.3-3.5,30.1-10.5c8.8-7,14.6-15.9,17.4-26.8l51-204.7c2.7-10.2,4.4-25.2,5.1-45c0.7-19.8,2.2-34.4,4.6-43.9l59.2-244c1-4.1,1.5-8.5,1.5-13.3c0-15.6-5.6-29.1-16.9-40.3c-11.2-11.2-24.9-16.9-40.8-16.9c-12.9,0-24.7,4.3-35.2,13c-10.5,8.7-17.3,19.3-20.4,31.9L761,500h-13.3l67.4-279.2c1-4.7,1.5-9.5,1.5-14.3c0-16-5.4-29.6-16.3-40.8c-10.9-11.2-24.5-16.9-40.8-16.9c-12.9,0-24.6,4.1-35,12.2c-10.4,8.1-17.1,18.7-20.2,31.6l-74,307.3h-64.8l-83.7-348.1c-3-12.9-9.8-23.5-20.2-31.6C451.1,112,439.4,107.9,426.6,107.9L426.6,107.9z M755.8,957.3H401.5c-28.9,0-55-8.7-78.1-26l-258.8-194c-17-12.9-30.4-28.9-40.1-48c-9.7-19-14.5-39.1-14.6-60.2c0-35.7,12.8-66.2,38.3-91.3c25.5-25.2,56.2-37.8,91.9-37.8c8.5,0,16.9,0.9,25.3,2.8c8.4,1.9,15.4,3.7,21.2,5.6s12.7,5.4,20.9,10.5c8.2,5.1,14.1,9,17.8,11.8c3.7,2.7,10.3,7.8,19.7,15c9.4,7.3,15.8,12.1,19.1,14.6l-62.8-261.4c-2.4-11.9-3.6-21.9-3.6-30.1c0-31.7,10.2-59.2,30.6-82.7c20.4-23.5,46.3-36.9,77.6-40.3c4.7-29.6,18.4-54.2,41.1-73.8c22.7-19.6,49.1-29.3,79.4-29.3c28.2,0,53.4,8.8,75.5,26.3c22.1,17.5,36.6,40.1,43.4,67.6L598,355l42.3-177.7c6.8-27.6,21.3-50.1,43.4-67.6c22.1-17.5,47.3-26.3,75.5-26.3c29.6,0,55.6,9.2,77.8,27.6c22.3,18.4,36.3,42,42.1,71c31.7,3.4,58,16.7,79.1,39.8S990,272.3,990,304c0,10.2-1.2,19.9-3.6,29.1l-59.2,243.5c-1.7,7.5-2.5,18.9-2.5,34.2c0,17.3-2.2,35.7-6.7,55.2l-51.6,204.7c-6.4,25.5-20,46.4-40.6,62.5c-20.6,16.2-44,24.2-70.2,24.2L755.8,957.3z'! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example03LinePath	<script: 'self new example03LinePath open'>	| canvas shapes form paint line path |	canvas := RSCanvas new.	form := self iconNamed: #remote.	paint := (AthensCairoPatternSurfacePaint 		createForSurface: (AthensCairoSurface 			fromForm: form)).	paint origin: (form extent / 2) negated.	shapes := #(-1 1 ) collect: [ :m |		RSBox new			size: form extent x;			paint: paint;			position: m * 50 asPoint;			draggable;			yourself		].	path := [ :aLine | String streamContents: [ :s|		| point number vector u unit middle middle2 l r a b |		a := aLine startPoint.		b := aLine endPoint.		number := [ :n | 			s nextPutAll: n asFloat asString ].		point := [ :p | 			number value: p x.			s space.			number value: p y.			s space. ].		vector := a - b.		u := vector normal.		unit := vector / vector r.			1 to: 3 do: [ :i |			middle := a - (unit * (i+1)* 5).			middle2 := a - (unit * (i*2)*5).			l := middle - (u * ((i-1) * 7)).			r := middle + (u * ((i-0.9) * 7)).						s nextPutAll: 'M'.			point value: l. 			s nextPutAll: 'Q '.			point value: middle2.			point value: r.			].		 ] ].	line := [:m | RSSVGPathLine new		borderColor: (m alpha: 0.4);		svgPath: path;		width: 4;		capRound;		yourself].	canvas add: ((line value: Color red)		from: shapes first;		to: shapes second).	canvas add: ((line value: Color blue)		from: shapes second;		to: shapes first).	canvas addAll: shapes.	canvas camera scale: 1.	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example06JoinStyles	<script: 'self new example06JoinStyles open'>	| canvas line path styles |	canvas := RSCanvas new.	path := [ :aLine | String streamContents: [ :s| 		| mid number point a b |		a := aLine startPoint.		b := aLine endPoint.		number := [ :n | 			s nextPutAll: n asFloat asString ].		point := [ :p | 			number value: p x.			s space.			number value: p y.			s space. ].				mid := (a + b)/2 + (0@ -50).		s nextPutAll: 'M'.		point value: a.		s nextPutAll: 'L'.		point value: mid.		s nextPutAll: 'L'.		point value: b.		 ] ].		styles := #('joinMiter' 'joinRound' 'joinBevel').	styles doWithIndex: [ :style :i|		line := RSSVGPathLine new 			svgPath: path;			borderColor: Color gray;			draggable;			width: 25;			from: ((i-2) * 80)@0;			to: (((i-2) * 80) + 50)@0;			perform: style asSymbol;			yourself.		canvas add: line.		.	].	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example15BimetricLine	<script: 'self new example15BimetricLine open'>	| canvas s1 s2 l |	canvas := RSCanvas new.	s1 := RSBox new		color: Color blue;		draggable;		size: 100;		yourself.	s2 := RSBox new		translateTo: 400@0;		draggable;		size: 100;		yourself.	l := RSBimetricLine new		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: s1;		to: s2;		yourself.	canvas addAll: { s1. s2. l}.	canvas @ RSCanvasController. 	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example18ExampleFromMondrian	<script: 'self new example18ExampleFromMondrian open'>	| canvas legend |	canvas := RSCanvas new.	canvas addAll: (Collection withAllSubclasses collect: [:cls | 		RSEllipse new			draggable;			model: cls;			popup;			color: Color red translucent;			yourself]).	RSNormalizer size		from: 5;		to: 50;		shapes: canvas nodes;		normalize: #numberOfMethods.	RSEdgeBuilder line		color: Color lightGray;		shapes: canvas nodes;		canvas: canvas;		connectFrom: #superclass.	RSForceBasedLayout on: canvas nodes.	RSMultiBezierEdgeBuilder multiBezier		borderColor: (Color blue alpha: 0.1);		shapes: canvas nodes;		canvas: canvas;		tension: 0.7;		following: #superclass;		connectToAll: #dependentClasses.		legend := (RSMultilineLabelBuilder new		shapeFor: 'Circle = classes, size = number of methods; gray links = inheritance;blue links = dependencies; layout = force based layout on the inheritance links')		padding: 10;		withBorder;		yourself.	RSLocation new		below;		offset: 10;		move: legend on: canvas nodes.	canvas add: legend.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example25BimetricLineOnLargeExample	<script: 'self new example25BimetricLineOnLargeExample open'>	| packagesRegExp packages l packageElements high canvas |	packagesRegExp := { 'Calypso*' }.		packages := packagesRegExp flatCollect: [ :regExp | 		RPackageOrganizer default packages 			select: [ :p | regExp match: p packageName ] ].			l := RSLabeled new text: [ :model | model packageName ].	packageElements  := packages collect: [ :pkg | | shapes |		shapes := pkg definedClasses collect: [ :cls |			RSBox new				color: Color black;				size: cls numberOfMethods sqrt;				yourself			 ].		RSGridLayout on: shapes.		RSComposite new			color: Color blue translucent;			model: pkg;			addInteraction: l;			draggable;			shapes: shapes;			padding: 5;			yourself ] as: RSGroup.	high := RSHighlightable new.	high withEdges.	high highlightColor: Color red translucent.								packageElements @ high.							canvas := RSCanvas new.	canvas addAll: packageElements.	RSEdgeBuilder bimetricLine		canvas: canvas;		objects: packages;		noBorder;		widthFrom:[ :edge | (edge key numberOfDependenciesToward: edge value) sqrt * 4 ];		widthTo:[ :edge | (edge value numberOfDependenciesToward: edge key) sqrt * 4 ];		paint: Color blue translucent;		withBorderAttachPoint;		connectFrom: #yourself toAll: #dependentPackages.	RSWeightedCircleLayout new initialRadius: 300; on: packageElements.	canvas @ RSCanvasController.	^ canvas! !!RSShapeExamples methodsFor: '*Roassal3-SVG-Examples'!example25BisBimetricLineOnLargeExample	<script: 'self new example25BisBimetricLineOnLargeExample open'>	"Same than example25BimetricLineOnLargeExample, but with no label"	| packagesRegExp packages packageElements high canvas |	packagesRegExp := { 'Calypso*' }.		packages := packagesRegExp flatCollect: [ :regExp | 		RPackageOrganizer default packages 			select: [ :p | regExp match: p packageName ] ].			packageElements  := packages collect: [ :pkg | | shapes |		shapes := pkg definedClasses collect: [ :cls |			RSBox new				color: Color black;				size: cls numberOfMethods sqrt;				yourself			 ].		RSGridLayout on: shapes.		RSComposite new			color: Color blue translucent;			model: pkg;			draggable;			shapes: shapes;			padding: 5;			yourself ] as: RSGroup.	high := RSHighlightable new.	high withEdges.	high highlightColor: Color red translucent.								packageElements @ high.							canvas := RSCanvas new.	canvas addAll: packageElements.	RSEdgeBuilder bimetricLine		canvas: canvas;		objects: packages;		noBorder;		widthFrom:[ :edge | (edge key numberOfDependenciesToward: edge value) sqrt * 4 ];		widthTo:[ :edge | (edge value numberOfDependenciesToward: edge key) sqrt * 4 ];		paint: Color blue translucent;		withBorderAttachPoint;		connectFrom: #yourself toAll: #dependentPackages.	RSWeightedCircleLayout new initialRadius: 300; on: packageElements.	canvas @ RSCanvasController.	^ canvas! !!RSAnimationExamples methodsFor: '*Roassal3-SVG-Examples'!example04Phyco	<script: 'self new example04Phyco open'>	| update canvas theta slices unit color sc1 sc2 |	canvas := RSCanvas new.	slices := 50.	unit := Float pi * 2 / slices.	"domain: aBoolean, range: aColor"	color := NSScale ordinal rangeFrom: { '480D4A'. 'BB1C60' }.	"input: a number between {-1 1} ouput: a number between 100 and 350"	sc1 := NSScale linear domain: #(-1 1);range: { 100. 350 }.	sc2 := NSScale linear domain: #(-1 1);range: { 350. 100 }.	"for zoom to fit"	canvas add: (RSBox new extent: 800@800; noPaint; yourself).	theta := 0.	update := [ 		canvas edges copy do: #remove.		1 to: slices do: [ :i | | line sz  |			line := RSSVGPathLine new				model: i;				yourself.			sz := i even				ifTrue: [ sc1 scale: (i *unit + theta) sin ]				ifFalse: [ sc2 scale: (line model*unit - theta) sin ].			line 				width:  sz /2;				borderColor: (color scale: i even);				from: (i even					ifTrue: [-25@ -25 ]					ifFalse: [ 25@25 ]);				to: 0@0.			line svgPath: [ :theLine |				"this block returns a block to use complex operations of Athens Canvas"				"in this part you can also return a string, the svg path"				[ :athensCanvas | 					| angle a |					a := theLine startPoint.					angle := i * unit.					athensCanvas  						moveTo: a + (sz * (angle cos@ angle sin));						arcCenterX: a x							centerY: a y 							radius: sz							startAngle: line model* unit							endAngle: (line model+1)*unit 					 ] ].			canvas add: line.		].	].	canvas when: RSMouseClick do: [ :evt | canvas edges inspect ].	canvas newAnimation repeat onStepDo: [ :t |		update value.		theta := theta + 0.0523 ].	canvas when: RSExtentChangedEvent do: [ :evt | 		canvas zoomToFit ].	^ canvas! !!RSSVGAnimatioinExamples methodsFor: 'data - svg'!america	^ 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM19.158,23.269c-0.079,0.064-0.183,0.13-0.105,0.207c0.078,0.078-0.09,0.131-0.09,0.17s0.104,0.246,0.052,0.336c-0.052,0.092-0.091,0.223-0.13,0.301c-0.039,0.077-0.131,0.155-0.104,0.272c0.025,0.116-0.104,0.077-0.104,0.194c0,0.116,0.116,0.065,0.09,0.208c-0.025,0.144-0.09,0.183-0.09,0.285c0,0.104,0.064,0.247,0.064,0.286s-0.064,0.17-0.155,0.272c-0.092,0.104-0.155,0.17-0.144,0.233c0.014,0.065,0.104,0.144,0.091,0.184c-0.013,0.037-0.129,0.168-0.116,0.259c0.014,0.09,0.129,0.053,0.155,0.116c0.026,0.065-0.155,0.118-0.078,0.183c0.078,0.064,0.183,0.051,0.156,0.208c-0.019,0.112,0.064,0.163,0.126,0.198c-0.891,0.221-1.818,0.352-2.777,0.352C9.639,27.533,4.466,22.36,4.466,16c0-2.073,0.557-4.015,1.518-5.697c0.079-0.042,0.137-0.069,0.171-0.062c0.065,0.013,0.079,0.104,0.183,0.13c0.104,0.026,0.195-0.078,0.26-0.117c0.064-0.039,0.116-0.195,0.051-0.182c-0.065,0.013-0.234,0-0.234,0s0.183-0.104,0.183-0.169s0.025-0.169,0.129-0.208C6.83,9.655,6.83,9.681,6.765,9.837C6.7,9.993,6.896,9.928,6.973,9.863s0.13-0.013,0.272-0.104c0.143-0.091,0.143-0.143,0.221-0.143c0.078,0,0.221,0.143,0.299,0.091c0.077-0.052,0.299,0.065,0.429,0.065c0.129,0,0.545,0.169,0.624,0.169c0.078,0,0.312,0.09,0.325,0.259c0.013,0.169,0.09,0.156,0.168,0.156s0.26,0.065,0.26,0.13c0,0.065-0.052,0.325,0.078,0.39c0.129,0.064,0.247,0.169,0.299,0.143c0.052-0.026,0-0.233-0.064-0.26c-0.065-0.026-0.027-0.117-0.052-0.169c-0.026-0.051,0.078-0.051,0.117,0.039c0.039,0.091,0.143,0.26,0.208,0.26c0.064,0,0.208,0.156,0.168,0.247c-0.039,0.091,0.039,0.221,0.156,0.221c0.116,0,0.26,0.182,0.312,0.195c0.052,0.013,0.117,0.078,0.117,0.117c0,0.04,0.065,0.26,0.065,0.351c0,0.09-0.04,0.454-0.053,0.597s0.104,0.39,0.234,0.52c0.129,0.13,0.246,0.377,0.324,0.429c0.079,0.052,0.13,0.195,0.247,0.182c0.117-0.013,0.195,0.078,0.299,0.26c0.104,0.182,0.208,0.48,0.286,0.506c0.078,0.026,0.208,0.117,0.142,0.182c-0.064,0.064-0.168,0.208-0.051,0.208c0.117,0,0.156-0.065,0.247,0.053c0.09,0.116,0.208,0.181,0.194,0.26c-0.013,0.077,0.104,0.103,0.156,0.116c0.052,0.013,0.169,0.247,0.286,0.143c0.117-0.104-0.155-0.259-0.234-0.326c-0.078-0.064,0-0.207-0.182-0.35c-0.182-0.143-0.156-0.247-0.286-0.351c-0.13-0.104-0.233-0.195-0.104-0.286c0.13-0.091,0.143,0.091,0.195,0.208c0.052,0.116,0.324,0.351,0.441,0.454c0.117,0.104,0.326,0.468,0.39,0.468s0.247,0.208,0.247,0.208s0.103,0.168,0.064,0.22c-0.039,0.052,0.053,0.247,0.144,0.299c0.09,0.052,0.455,0.22,0.507,0.247c0.052,0.027,0.155,0.221,0.299,0.221c0.142,0,0.247,0.014,0.286,0.053c0.039,0.038,0.155,0.194,0.234,0.104c0.078-0.092,0.09-0.131,0.208-0.131c0.117,0,0.168,0.091,0.233,0.156c0.065,0.065,0.247,0.235,0.338,0.222c0.091-0.013,0.208,0.104,0.273,0.064s0.169,0.025,0.22,0.052c0.054,0.026,0.234,0.118,0.222,0.272c-0.013,0.157,0.103,0.195,0.182,0.234c0.078,0.039,0.182,0.13,0.248,0.195c0.064,0.063,0.206,0.077,0.246,0.116c0.039,0.039,0.065,0.117,0.182,0.052c0.116-0.064,0.092-0.181,0.092-0.181s0.129-0.026,0.194,0.026c0.064,0.05,0.104,0.22,0.144,0.246c0.038,0.026,0.115,0.221,0.063,0.362c-0.051,0.145-0.038,0.286-0.091,0.286c-0.052,0-0.116,0.17-0.195,0.209c-0.076,0.039-0.285,0.221-0.272,0.286c0.013,0.063,0.131,0.258,0.104,0.35c-0.025,0.091-0.194,0.195-0.154,0.338c0.038,0.144,0.312,0.183,0.323,0.312c0.014,0.131,0.209,0.417,0.235,0.546c0.025,0.13,0.246,0.272,0.246,0.453c0,0.184,0.312,0.3,0.377,0.312c0.063,0.013,0.182,0.131,0.272,0.17s0.169,0.116,0.233,0.221s0.053,0.261,0.053,0.299c0,0.039-0.039,0.44-0.078,0.674C19.145,23.021,19.235,23.203,19.158,23.269zM10.766,11.188c0.039,0.013,0.117,0.091,0.156,0.091c0.04,0,0.234,0.156,0.286,0.208c0.053,0.052,0.053,0.195-0.013,0.208s-0.104-0.143-0.117-0.208c-0.013-0.065-0.143-0.065-0.208-0.104C10.805,11.344,10.66,11.152,10.766,11.188zM27.51,16.41c-0.144,0.182-0.13,0.272-0.195,0.286c-0.064,0.013,0.065,0.065,0.09,0.194c0.022,0.112-0.065,0.224,0.063,0.327c-0.486,4.619-3.71,8.434-8.016,9.787c-0.007-0.011-0.019-0.025-0.021-0.034c-0.027-0.078-0.027-0.233,0.064-0.285c0.091-0.053,0.312-0.233,0.363-0.272c0.052-0.04,0.13-0.221,0.091-0.247c-0.038-0.026-0.232,0-0.26-0.039c-0.026-0.039-0.026-0.092,0.104-0.182c0.13-0.091,0.195-0.222,0.247-0.26c0.052-0.039,0.155-0.117,0.195-0.209c0.038-0.09-0.041-0.039-0.118-0.039s-0.117-0.142-0.117-0.207s0.195,0.026,0.339,0.052c0.143,0.024,0.077-0.065,0.064-0.142c-0.013-0.078,0.026-0.209,0.105-0.17c0.076,0.039,0.479-0.013,0.531-0.026c0.052-0.013,0.194-0.246,0.246-0.312c0.053-0.065,0.064-0.129,0-0.168c-0.065-0.04-0.143-0.184-0.168-0.221c-0.026-0.041-0.039-0.274-0.013-0.34c0.025-0.063,0,0.377,0.181,0.43c0.183,0.052,0.286,0.078,0.455-0.078c0.169-0.155,0.298-0.26,0.312-0.363c0.013-0.104,0.052-0.209,0.117-0.246c0.065-0.039,0.104,0.103,0.182-0.065c0.078-0.17,0.156-0.157,0.234-0.299c0.077-0.144-0.13-0.325,0.024-0.43c0.157-0.103,0.43-0.233,0.43-0.233s0.078-0.039,0.234-0.078c0.155-0.038,0.324-0.014,0.376-0.09c0.052-0.079,0.104-0.247,0.182-0.338c0.079-0.092,0.169-0.234,0.13-0.299c-0.039-0.065,0.104-0.352,0.091-0.429c-0.013-0.078-0.13-0.261,0.065-0.416s0.402-0.391,0.416-0.454c0.012-0.065,0.169-0.338,0.154-0.469c-0.012-0.129-0.154-0.285-0.245-0.325c-0.092-0.037-0.286-0.05-0.364-0.154s-0.299-0.208-0.377-0.182c-0.077,0.026-0.208,0.051-0.312-0.015c-0.104-0.063-0.272-0.143-0.337-0.194c-0.066-0.051-0.234-0.09-0.312-0.09s-0.065-0.053-0.182,0.103c-0.117,0.157,0,0.209-0.208,0.182c-0.209-0.024,0.025-0.038,0.144-0.194c0.115-0.155-0.014-0.247-0.144-0.207c-0.13,0.039-0.039,0.117-0.247,0.156c-0.207,0.038-0.207-0.092-0.077-0.117c0.13-0.026,0.363-0.143,0.363-0.194c0-0.053-0.026-0.196-0.13-0.196s-0.078-0.129-0.233-0.297c-0.156-0.17-0.351-0.274-0.508-0.249c-0.154,0.026-0.272,0.065-0.35-0.076c-0.078-0.144-0.169-0.17-0.222-0.247c-0.051-0.078-0.182,0-0.221-0.039s-0.039-0.039-0.039-0.039s-0.169,0.039-0.077-0.078c0.09-0.117,0.129-0.338,0.09-0.325c-0.038,0.013-0.104,0.196-0.168,0.183c-0.064-0.013-0.014-0.04-0.144-0.117c-0.13-0.078-0.337-0.013-0.337,0.052c0,0.065-0.065,0.117-0.065,0.117s-0.039-0.038-0.078-0.117c-0.039-0.078-0.221-0.091-0.312-0.013c-0.09,0.078-0.142-0.196-0.207-0.196s-0.194,0.065-0.26,0.184c-0.064,0.116-0.038,0.285-0.092,0.272c-0.05-0.013-0.063-0.233-0.05-0.312c0.012-0.079,0.155-0.208,0.05-0.234c-0.103-0.026-0.259,0.13-0.323,0.143c-0.065,0.013-0.195,0.104-0.273,0.209c-0.077,0.103-0.116,0.168-0.195,0.207c-0.077,0.039-0.193,0-0.167-0.039c0.025-0.039-0.222-0.181-0.261-0.13c-0.04,0.052-0.155,0.091-0.272,0.144c-0.117,0.052-0.222-0.065-0.247-0.117s-0.079-0.064-0.091-0.234c-0.013-0.168,0.027-0.351,0.065-0.454c0.038-0.104-0.195-0.312-0.286-0.3c-0.091,0.015-0.182,0.105-0.272,0.091c-0.092-0.012-0.052-0.038-0.195-0.038c-0.143,0-0.026-0.025,0-0.143c0.025-0.116-0.052-0.273,0.092-0.377c0.142-0.104,0.091-0.351,0-0.363c-0.092-0.014-0.261,0.039-0.377,0.026c-0.116-0.014-0.208,0.091-0.169,0.207c0.039,0.117-0.065,0.195-0.104,0.183c-0.039-0.013-0.09-0.078-0.234,0.026c-0.142,0.103-0.194,0.064-0.337-0.052c-0.143-0.118-0.299-0.234-0.325-0.416c-0.026-0.182-0.04-0.364,0.013-0.468c0.051-0.104,0.051-0.285-0.026-0.312c-0.078-0.025,0.09-0.155,0.181-0.181c0.092-0.026,0.234-0.143,0.26-0.195c0.026-0.052,0.156-0.04,0.298-0.04c0.143,0,0.169,0,0.312,0.078c0.143,0.078,0.169-0.039,0.169-0.078c0-0.039,0.052-0.117,0.208-0.104c0.156,0.013,0.376-0.052,0.416-0.013s0.116,0.195,0.194,0.143c0.079-0.051,0.104-0.143,0.131,0.014c0.025,0.155,0.09,0.39,0.208,0.429c0.116,0.039,0.052,0.194,0.168,0.207c0.115,0.013,0.17-0.246,0.131-0.337c-0.04-0.09-0.118-0.363-0.183-0.428c-0.064-0.065-0.064-0.234,0.064-0.286c0.13-0.052,0.442-0.312,0.532-0.389c0.092-0.079,0.338-0.144,0.261-0.248c-0.078-0.104-0.104-0.168-0.104-0.247s0.078-0.052,0.117,0s0.194-0.078,0.155-0.143c-0.038-0.064-0.026-0.155,0.065-0.143c0.091,0.013,0.116-0.065,0.078-0.117c-0.039-0.052,0.091-0.117,0.182-0.091c0.092,0.026,0.325-0.013,0.364-0.065c0.038-0.052-0.078-0.104-0.078-0.208c0-0.104,0.155-0.195,0.247-0.208c0.091-0.013,0.207,0,0.221-0.039c0.012-0.039,0.143-0.143,0.155-0.052c0.014,0.091,0,0.247,0.104,0.247c0.104,0,0.232-0.117,0.272-0.129c0.038-0.013,0.286-0.065,0.338-0.078c0.052-0.013,0.363-0.039,0.325-0.13c-0.039-0.09-0.078-0.181-0.118-0.22c-0.039-0.039-0.077,0.013-0.13,0.078c-0.051,0.065-0.143,0.065-0.168,0.013c-0.026-0.051,0.012-0.207-0.078-0.156c-0.092,0.052-0.104,0.104-0.157,0.078c-0.052-0.026-0.103-0.117-0.103-0.117s0.129-0.064,0.038-0.182c-0.09-0.117-0.221-0.091-0.35-0.025c-0.13,0.064-0.118,0.051-0.273,0.09s-0.234,0.078-0.234,0.078s0.209-0.129,0.299-0.208c0.091-0.078,0.209-0.117,0.286-0.195c0.078-0.078,0.285,0.039,0.285,0.039s0.105-0.104,0.105-0.039s-0.027,0.234,0.051,0.234c0.079,0,0.299-0.104,0.21-0.131c-0.093-0.026,0.129,0,0.219-0.065c0.092-0.065,0.194-0.065,0.247-0.09c0.052-0.026,0.092-0.143,0.182-0.143c0.092,0,0.13,0.117,0,0.195s-0.143,0.273-0.208,0.325c-0.064,0.052-0.026,0.117,0.078,0.104c0.104-0.013,0.194,0.013,0.286-0.013s0.143,0.026,0.168,0.065c0.026,0.039,0.104-0.039,0.104-0.039s0.169-0.039,0.221,0.026c0.053,0.064,0.092-0.039,0.053-0.104c-0.039-0.064-0.092-0.129-0.13-0.208c-0.039-0.078-0.091-0.104-0.194-0.078c-0.104,0.026-0.13-0.026-0.195-0.064c-0.065-0.04-0.118,0.052-0.065-0.04c0.053-0.09,0.078-0.117,0.117-0.195c0.039-0.078,0.209-0.221,0.039-0.259c-0.169-0.04-0.222-0.065-0.247-0.143c-0.026-0.078-0.221-0.221-0.272-0.221c-0.053,0-0.233,0-0.247-0.065c-0.013-0.065-0.143-0.208-0.208-0.273c-0.064-0.065-0.312-0.351-0.351-0.377c-0.039-0.026-0.091-0.013-0.208,0.143c-0.116,0.157-0.22,0.183-0.312,0.144c-0.091-0.039-0.104-0.026-0.193-0.13c-0.093-0.104,0.09-0.117,0.051-0.182c-0.04-0.064-0.247-0.091-0.377-0.104c-0.13-0.013-0.221-0.156-0.416-0.169c-0.194-0.013-0.428,0.026-0.493,0.026c-0.064,0-0.064,0.091-0.09,0.234c-0.027,0.143,0.09,0.182-0.027,0.208c-0.116,0.026-0.169,0.039-0.052,0.091c0.117,0.052,0.273,0.26,0.273,0.26s0,0.117-0.092,0.182c-0.09,0.065-0.182,0.13-0.233,0.053c-0.053-0.079-0.195-0.065-0.155,0.013c0.038,0.078,0.116,0.117,0.116,0.195c0,0.077,0.117,0.272,0.039,0.337c-0.078,0.065-0.168,0.014-0.233,0.026s-0.131-0.104-0.078-0.13c0.051-0.026-0.014-0.221-0.014-0.221s-0.155,0.221-0.143,0.104c0.014-0.117-0.064-0.13-0.064-0.221c0-0.091-0.079-0.13-0.194-0.104c-0.118,0.026-0.26-0.04-0.482-0.079c-0.22-0.039-0.311-0.064-0.493-0.156c-0.182-0.091-0.247-0.026-0.338-0.013c-0.091,0.013-0.052-0.182-0.169-0.207c-0.116-0.027-0.181,0.025-0.207-0.144c-0.026-0.168,0.039-0.208,0.324-0.39c0.286-0.182,0.247-0.26,0.468-0.286c0.22-0.026,0.325,0.026,0.325-0.039s0.052-0.325,0.052-0.195S16.95,9.109,16.832,9.2c-0.116,0.091-0.052,0.104,0.04,0.104c0.091,0,0.259-0.091,0.259-0.091s0.208-0.091,0.26-0.013c0.053,0.078,0.053,0.156,0.144,0.156s0.285-0.104,0.116-0.195c-0.168-0.091-0.272-0.078-0.376-0.182s-0.078-0.065-0.195-0.039c-0.116,0.026-0.116-0.039-0.156-0.039s-0.104,0.026-0.13-0.026c-0.025-0.052,0.014-0.065,0.145-0.065c0.129,0,0.285,0.039,0.285,0.039s0.155-0.052,0.194-0.065c0.039-0.013,0.247-0.039,0.208-0.155c-0.04-0.117-0.169-0.117-0.208-0.156s0.078-0.09,0.143-0.117c0.065-0.026,0.247,0,0.247,0s0.117,0.013,0.117-0.039S17.897,8.2,17.976,8.239s0,0.156,0.117,0.13c0.116-0.026,0.143,0,0.207,0.039c0.065,0.039-0.013,0.195-0.077,0.221c-0.065,0.025-0.169,0.077-0.026,0.09c0.144,0.014,0.246,0.014,0.246,0.014s0.092-0.091,0.131-0.169c0.038-0.078,0.104-0.026,0.155,0c0.052,0.025,0.247,0.065,0.065,0.117c-0.183,0.052-0.221,0.117-0.26,0.182c-0.038,0.065-0.053,0.104-0.221,0.065c-0.17-0.039-0.26-0.026-0.299,0.039c-0.039,0.064-0.013,0.273,0.053,0.247c0.063-0.026,0.129-0.026,0.207-0.052c0.078-0.026,0.39,0.026,0.467,0.013c0.078-0.013,0.209,0.13,0.248,0.104c0.039-0.026,0.117,0.052,0.194,0.104c0.078,0.052,0.052-0.117,0.194-0.013c0.144,0.104,0.065,0.104,0.144,0.104c0.076,0,0.246,0.013,0.246,0.013s0.014-0.129,0.144-0.104c0.13,0.026,0.245,0.169,0.232,0.064c-0.012-0.103,0.013-0.181-0.09-0.259c-0.104-0.078-0.272-0.13-0.299-0.169c-0.026-0.039-0.052-0.091-0.013-0.117c0.039-0.025,0.221,0.013,0.324,0.079c0.104,0.065,0.195,0.13,0.273,0.078c0.077-0.052,0.17-0.078,0.208-0.117c0.038-0.04,0.13-0.156,0.13-0.156s-0.391-0.051-0.441-0.117c-0.053-0.065-0.235-0.156-0.287-0.156s-0.194,0.091-0.246-0.039s-0.052-0.286-0.105-0.299c-0.05-0.013-0.597-0.091-0.674-0.13c-0.078-0.039-0.39-0.13-0.507-0.195s-0.286-0.156-0.389-0.156c-0.104,0-0.533,0.052-0.611,0.039c-0.078-0.013-0.312,0.026-0.403,0.039c-0.091,0.013,0.117,0.182-0.077,0.221c-0.195,0.039-0.169,0.065-0.13-0.13c0.038-0.195-0.131-0.247-0.299-0.169c-0.169,0.078-0.442,0.13-0.377,0.221c0.065,0.091-0.012,0.157,0.117,0.247c0.13,0.091,0.183,0.117,0.35,0.104c0.17-0.013,0.339,0.025,0.339,0.025s0,0.157-0.064,0.182c-0.065,0.026-0.169,0.026-0.196,0.104c-0.025,0.078-0.155,0.117-0.155,0.078s0.065-0.169-0.026-0.234c-0.09-0.065-0.117-0.078-0.221-0.013c-0.104,0.065-0.116,0.091-0.169-0.013C16.053,8.291,15.897,8.2,15.897,8.2s-0.104-0.129-0.182-0.194c-0.077-0.065-0.22-0.052-0.234,0.013c-0.013,0.064,0.026,0.129,0.078,0.247c0.052,0.117,0.104,0.337,0.013,0.351c-0.091,0.013-0.104,0.026-0.195,0.052c-0.091,0.026-0.13-0.039-0.13-0.143s-0.04-0.195-0.013-0.234c0.026-0.039-0.104,0.027-0.234,0c-0.13-0.025-0.233,0.052-0.104,0.092c0.13,0.039,0.157,0.194,0.039,0.233c-0.117,0.039-0.559,0-0.702,0s-0.35,0.039-0.39-0.039c-0.039-0.078,0.118-0.129,0.208-0.129c0.091,0,0.363,0.012,0.467-0.13c0.104-0.143-0.13-0.169-0.233-0.169c-0.104,0-0.183-0.039-0.299-0.155c-0.118-0.117,0.078-0.195,0.052-0.247c-0.026-0.052-0.156-0.014-0.272-0.014c-0.117,0-0.299-0.09-0.299,0.014c0,0.104,0.143,0.402,0.052,0.337c-0.091-0.064-0.078-0.156-0.143-0.234c-0.065-0.078-0.168-0.065-0.299-0.052c-0.129,0.013-0.35,0.052-0.415,0.039c-0.064-0.013-0.013-0.013-0.156-0.078c-0.142-0.065-0.208-0.052-0.312-0.117C12.091,7.576,12.182,7.551,12,7.538c-0.181-0.013-0.168,0.09-0.35,0.065c-0.182-0.026-0.234,0.013-0.416,0c-0.182-0.013-0.272-0.026-0.299,0.065c-0.025,0.091-0.078,0.247-0.156,0.247c-0.077,0-0.169,0.091,0.078,0.104c0.247,0.013,0.105,0.129,0.325,0.117c0.221-0.013,0.416-0.013,0.468-0.117c0.052-0.104,0.091-0.104,0.117-0.065c0.025,0.039,0.22,0.272,0.22,0.272s0.131,0.104,0.183,0.13c0.051,0.026-0.052,0.143-0.156,0.078c-0.104-0.065-0.299-0.051-0.377-0.116c-0.078-0.065-0.429-0.065-0.52-0.052c-0.09,0.013-0.247-0.039-0.299-0.039c-0.051,0-0.221,0.13-0.221,0.13S10.532,8.252,10.494,8.2c-0.039-0.052-0.104,0.052-0.156,0.065c-0.052,0.013-0.208-0.104-0.364-0.052C9.818,8.265,9.87,8.317,9.649,8.304s-0.272-0.052-0.35-0.039C9.22,8.278,9.22,8.278,9.22,8.278S9.233,8.33,9.143,8.382C9.052,8.434,8.986,8.499,8.921,8.421C8.857,8.343,8.818,8.343,8.779,8.33c-0.04-0.013-0.118-0.078-0.286-0.04C8.324,8.33,8.064,8.239,8.013,8.239c-0.04,0-0.313-0.015-0.491-0.033c2.109-2.292,5.124-3.74,8.478-3.74c2.128,0,4.117,0.589,5.83,1.598c-0.117,0.072-0.319,0.06-0.388,0.023c-0.078-0.043-0.158-0.078-0.475-0.061c-0.317,0.018-0.665,0.122-0.595,0.226c0.072,0.104-0.142,0.165-0.197,0.113c-0.055-0.052-0.309,0.06-0.293,0.165c0.016,0.104-0.039,0.225-0.175,0.199c-0.134-0.027-0.229,0.06-0.237,0.146c-0.007,0.087-0.309,0.147-0.332,0.147c-0.024,0-0.412-0.008-0.27,0.095c0.097,0.069,0.15,0.027,0.27,0.052c0.119,0.026,0.214,0.217,0.277,0.243c0.062,0.026,0.15,0,0.189-0.052c0.04-0.052,0.095-0.234,0.095-0.234s0,0.173,0.097,0.208c0.095,0.035,0.331-0.026,0.395-0.017c0.064,0.008,0.437,0.061,0.538,0.112c0.104,0.052,0.356,0.087,0.428,0.199c0.071,0.113,0.08,0.503,0.119,0.546c0.04,0.043,0.174-0.139,0.205-0.182c0.031-0.044,0.198-0.018,0.254,0.042c0.056,0.061,0.182,0.208,0.175,0.269C21.9,8.365,21.877,8.459,21.83,8.425c-0.048-0.034-0.127-0.025-0.096-0.095c0.032-0.069,0.048-0.217-0.015-0.217c-0.064,0-0.119,0-0.119,0s-0.12-0.035-0.199,0.095s-0.015,0.26,0.04,0.26s0.184,0,0.184,0.034c0,0.035-0.136,0.139-0.128,0.2c0.009,0.061,0.11,0.268,0.144,0.312c0.031,0.043,0.197,0.086,0.244,0.096c0.049,0.008-0.111,0.017-0.07,0.077c0.04,0.061,0.102,0.208,0.189,0.243c0.087,0.035,0.333,0.19,0.363,0.26c0.032,0.069,0.222-0.052,0.262-0.061c0.04-0.008,0.032,0.182,0.143,0.191c0.11,0.008,0.15-0.018,0.245-0.096s0.072-0.182,0.079-0.26c0.009-0.078,0-0.138,0.104-0.113c0.104,0.026,0.158-0.018,0.15-0.104c-0.008-0.087-0.095-0.191,0.07-0.217c0.167-0.026,0.254-0.138,0.357-0.138c0.103,0,0.389,0.043,0.419,0c0.032-0.043,0.167-0.243,0.254-0.251c0.067-0.007,0.224-0.021,0.385-0.042c1.582,1.885,2.561,4.284,2.673,6.905c-0.118,0.159-0.012,0.305,0.021,0.408c0.001,0.03,0.005,0.058,0.005,0.088c0,0.136-0.016,0.269-0.021,0.404C27.512,16.406,27.512,16.408,27.51,16.41zM17.794,12.084c-0.064,0.013-0.169-0.052-0.169-0.143s-0.091,0.169-0.04,0.247c0.053,0.078-0.104,0.169-0.155,0.169s-0.091-0.116-0.078-0.233c0.014-0.117-0.077-0.221-0.221-0.208c-0.143,0.014-0.208,0.13-0.259,0.169c-0.053,0.039-0.053,0.259-0.04,0.312s0.013,0.235-0.116,0.221c-0.118-0.013-0.092-0.233-0.079-0.312c0.014-0.078-0.039-0.273,0.014-0.376c0.053-0.104,0.207-0.143,0.312-0.156s0.324,0.065,0.363,0.052c0.04-0.014,0.222-0.014,0.312,0C17.729,11.837,17.858,12.071,17.794,12.084zM18.027,12.123c0.04,0.026,0.311-0.039,0.364,0.026c0.051,0.065-0.054,0.078-0.183,0.13c-0.129,0.052-0.169,0.039-0.221,0.104s-0.221,0.09-0.299,0.168c-0.078,0.079-0.217,0.125-0.246,0.065c-0.04-0.078,0.013-0.039,0.025-0.078c0.013-0.039,0.245-0.129,0.245-0.129S17.988,12.097,18.027,12.123zM16.988,11.668c-0.038,0.013-0.182-0.026-0.3-0.026c-0.116,0-0.091-0.078-0.143-0.064c-0.051,0.013-0.168,0.039-0.247,0.078c-0.078,0.039-0.208,0.03-0.208-0.04c0-0.104,0.052-0.078,0.221-0.143c0.169-0.065,0.352-0.247,0.429-0.169c0.078,0.078,0.221,0.169,0.312,0.182C17.144,11.5,17.026,11.655,16.988,11.668zM15.659,7.637c-0.079,0.026-0.347,0.139-0.321,0.199c0.01,0.023,0.078,0.069,0.19,0.052c0.113-0.018,0.276-0.035,0.355-0.043c0.078-0.009,0.095-0.139,0.009-0.147C15.805,7.689,15.736,7.611,15.659,7.637zM14.698,7.741c-0.061,0.026-0.243-0.043-0.338,0.018c-0.061,0.038-0.026,0.164,0.07,0.172c0.095,0.009,0.259-0.06,0.276-0.008c0.018,0.052,0.078,0.286,0.234,0.208c0.156-0.078,0.147-0.147,0.19-0.156c0.043-0.009-0.008-0.199-0.078-0.243C14.983,7.689,14.758,7.715,14.698,7.741zM14.385,7.005c0.017,0.044-0.008,0.078,0.113,0.095c0.121,0.018,0.173,0.035,0.243,0.035c0.069,0,0.042-0.113-0.018-0.19c-0.061-0.078-0.043-0.069-0.199-0.113c-0.156-0.043-0.312-0.043-0.416-0.035c-0.104,0.009-0.217-0.017-0.243,0.104c-0.013,0.062,0.07,0.112,0.174,0.112S14.368,6.962,14.385,7.005zM14.611,7.481c0.043,0.095,0.043,0.051,0.165,0.061C14.896,7.551,14.991,7.421,15,7.378c0.009-0.044-0.061-0.13-0.225-0.113c-0.165,0.017-0.667-0.026-0.736,0.034c-0.066,0.058,0,0.233-0.026,0.251c-0.026,0.017,0.009,0.095,0.077,0.078c0.069-0.017,0.104-0.182,0.157-0.182C14.299,7.447,14.568,7.386,14.611,7.481zM12.982,7.126c0.052,0.043,0.183,0.008,0.173-0.035c-0.008-0.043,0.053-0.217-0.051-0.225C13,6.858,12.854,6.962,12.697,7.014c-0.101,0.033-0.078,0.13-0.009,0.13S12.931,7.083,12.982,7.126zM13.72,7.282c-0.087,0.043-0.114,0.069-0.191,0.052c-0.078-0.017-0.078-0.156-0.217-0.13c-0.138,0.026-0.164,0.104-0.207,0.139s-0.139,0.061-0.173,0.043c-0.034-0.017-0.234-0.129-0.234-0.129s-0.416-0.018-0.433-0.07c-0.017-0.052-0.086-0.138-0.277-0.121s-0.52,0.13-0.572,0.13c-0.052,0,0.062,0.104-0.009,0.104c-0.069,0-0.155-0.008-0.181,0.069c-0.018,0.053,0.078,0.052,0.189,0.052c0.112,0,0.295,0,0.347-0.026c0.052-0.026,0.312-0.087,0.303-0.009c-0.009,0.079,0.104,0.199,0.164,0.182c0.061-0.017,0.183-0.13,0.243-0.086c0.061,0.043,0.07,0.146,0.13,0.173c0.061,0.025,0.226,0.025,0.304,0c0.077-0.027,0.294-0.027,0.389-0.009c0.095,0.018,0.373,0.069,0.399,0.018c0.026-0.053,0.104-0.061,0.112-0.113s0.051-0.216,0.051-0.216S13.806,7.239,13.72,7.282zM18.105,16.239c-0.119,0.021-0.091,0.252,0.052,0.21C18.3,16.407,18.223,16.217,18.105,16.239zM19.235,15.929c-0.104-0.026-0.221,0-0.299,0.013c-0.078,0.013-0.299,0.208-0.299,0.208s0.143,0.026,0.233,0.026c0.092,0,0.144,0.051,0.221,0.09c0.078,0.04,0.221-0.052,0.272-0.052c0.053,0,0.118,0.156,0.131-0.013C19.508,16.032,19.339,15.955,19.235,15.929zM15.616,7.507c-0.043-0.104-0.259-0.139-0.304-0.035C15.274,7.563,15.659,7.611,15.616,7.507zM18.093,15.292c0.143-0.026,0.064-0.144-0.053-0.13C17.922,15.175,17.949,15.318,18.093,15.292zM19.82,16.095c-0.119,0.022-0.092,0.253,0.051,0.211C20.015,16.264,19.937,16.074,19.82,16.095zM18.247,15.708c-0.09,0.013-0.285-0.09-0.389-0.182c-0.104-0.091-0.299-0.091-0.377-0.091c-0.077,0-0.39,0.091-0.39,0.091c-0.013,0.13,0.117,0.091,0.273,0.091s0.429-0.026,0.479,0.039c0.053,0.064,0.286,0.168,0.352,0.221c0.064,0.052,0.272,0.065,0.285,0.013S18.338,15.695,18.247,15.708zM16.698,7.412c-0.13-0.009-0.295-0.009-0.399,0c-0.104,0.008-0.182-0.069-0.26-0.113c-0.077-0.043-0.251-0.182-0.354-0.199c-0.104-0.017-0.086-0.017-0.303-0.069c-0.11-0.027-0.294-0.061-0.294-0.086c0-0.026-0.052,0.121,0.043,0.165c0.095,0.043,0.251,0.121,0.363,0.164c0.114,0.043,0.329,0.052,0.399,0.139c0.069,0.086,0.303,0.156,0.303,0.156l0.277,0.026c0,0,0.191-0.043,0.39-0.026c0.199,0.017,0.493,0.043,0.659,0.035c0.163-0.008,0.189-0.061,0.208-0.095c0.016-0.035-0.304-0.104-0.383-0.095C17.271,7.42,16.827,7.42,16.698,7.412zM17.182,9.404c-0.034,0.039,0.157,0.095,0.191,0.043C17.407,9.396,17.271,9.309,17.182,9.404zM17.764,9.585c0.086-0.035,0.043-0.139-0.079-0.104C17.547,9.521,17.676,9.62,17.764,9.585z'! !!RSSVGAnimatioinExamples methodsFor: 'examples'!example01SVGIcons	<script: 'self new example01SVGIcons open setLabel: ''Icons'''>	| canvas shapes color r theta |	canvas := RSCanvas new.	r := Random new.	color := RSGradientPalette gradient21.	color range at: 1 put: RSGradientPalette trueSunset.	theta := (1 to: 3) collect: [:i | r next * Float twoPi ].		shapes := #(america puzzlePiece supermarketCart) collectWithIndex: [ :m :index |		| grad |		grad := (color scale: m)			start: -20 asPoint;			stop: 20 asPoint.		RSSVGPath new			draggable;			index: index;			svgPath: (self perform: m);			position: (r next * 50)@ (r next * 50) - 25;			color: grad;			yourself ].	canvas addAll: shapes.	canvas newAnimation repeat onStepDo: [:t | 		shapes do: [:shape | | p ang ext block | 			p := shape position.			ext := shape extent / 2.			ang := theta at: shape index.			block := [ 				ang := Float pi / 4 + ang.				p := (ang cos@ ang sin) * 1.5 + shape position. ].			p := (ang cos@ ang sin) * 1.5 + p.			(p x + ext x) > 50 ifTrue: block.			(p y + ext y)  > 50 ifTrue: block.			(p x - ext x) < -50 ifTrue: block.			(p y - ext y) < -50 ifTrue: block.			theta at: shape index put: ang.			shape position: p.			 ] ].	canvas addShape: (RSBox new		extent: 100@100;		noPaint;		withBorder).	canvas 		when: RSExtentChangedEvent 		do: [ canvas camera zoomToFit: canvas extent extent: 100 asPoint ].	^ canvas	! !!RSSVGAnimatioinExamples methodsFor: 'examples'!example02Miku	<script: 'self new example02Miku open setLabel: ''Miku'''>	| random canvas lines easing |	random := Random new.	canvas := RSCanvas new.	lines := self miku lines.	lines := (0 to: lines size / 2 - 1)		collect: [ :i | (lines at: i * 2 + 1) -> (lines at: i * 2 + 2) ].	canvas addAll: (lines collectWithIndex: [ :line :index |		RSSVGPath new			draggable;			index: index;			svgPath: line key;			color: line value;			yourself ] ).	canvas @ RSCanvasController.	easing := RSEasing elasticOut.	canvas nodes do: [ :e | | position |		position := (random next * 1000) @ (random next * 1000) - 100.		canvas newAnimation			easing: easing;			delay: (e index * 50) milliSeconds;			from: position;			to: e position;			duration: 5 seconds;			on: e shape set: #position:.			e position: position ].	canvas addShape: (RSLabel new		text: 'Roassal';		fontName: 'Marker Felt';		noPaint;		border: (RSBorder new color: Color transparent; width: 1.5);		fontSize: 100;		position: 320 @ 630).	canvas newAnimation		delay: 6 seconds;		duration: 3 seconds;		from: Color transparent;		to: Color black;		on: canvas shapes last border set: #color:.	^ canvas! !!RSSVGAnimatioinExamples methodsFor: 'examples'!example03Boat	<script: 'self new example03Boat open'>	| canvas perlin frame scale lines boat x pharo g updateLines |	canvas := RSCanvas new.	canvas color: Color pink.	perlin := NSPerlinNoise2 new.	frame := 0.	"perlin octaves: 3."	scale := 20.	lines := (1 to: 25) collect: [ :i |		RSPolyline new			"width: i log;"			yourself ] as: RSGroup.	g := RSGroup new.	g add: (RSSVGPath new		svgPath:'M254.4,440.8c0,2.4-2.4,4.8-4.8,4.8l0,0c-2.4,0-4.8-2.4-4.8-4.8V24c0-2.4,2.4-4.8,4.8-4.8l0,0c2.4,0,4.8,2.4,4.8,4.8V440.8z';		color: '788787').	g add: (RSSVGPath new		svgPath: 'M9.6,418.4c10.4,45.6,113.6,80.8,240,80.8s229.6-36,240-80.8H9.6z';		color: '9E6226').	g add: (RSSVGPath new		svgPath: 'M17.6,434.4c4.8,6.4,12,12.8,20,18.4h423.2c8.8-5.6,15.2-12,20-18.4H17.6z';		color: 'AF7643').	g add: (RSSVGPath new		svgPath: 'M367.2,488c24-4.8,44.8-11.2,63.2-18.4H68.8c17.6,7.2,39.2,13.6,63.2,18.4H367.2z';		color: 'AF7643').	g add: (RSSVGPath new		svgPath:'M497.6,414.4c0,2.4-2.4,4.8-4.8,4.8H6.4c-3.2,0-4.8-2.4-4.8-4.8l0,0c0-3.2,2.4-4.8,4.8-4.8H492C495.2,409.6,497.6,411.2,497.6,414.4L497.6,414.4z';		color: 'AF7643').	g add: (RSEllipse new		position: 249.6@ 18.4; radius: 18.4;		color: '788787').		g add: (RSSVGPath new		svgPath: 'M454.4,371.2c0-7.2,0.8-14.4,0.8-22.4c0-166.4-84.8-302.4-189.6-305.6v328H454.4z';		color: '0C91C4').	g add: (RSSVGPath new		svgPath: 'M454.4,371.2c0-7.2,0.8-14.4,0.8-22.4c0-166.4-84.8-302.4-189.6-305.6';		color: '22B3E0').	g add: (RSPolygon new		points: {232.8@43.2. 144.8@87.2. 232.8@130.4};		color: 'FFAE0B').	g add: (RSPolygon new		points: {232.8@80.8. 144.8@87.2. 232.8@130.4};		color: 'FF860D').	g add: (RSPolygon new		points: {231.2@144.8. 231.2@363.2. 89.6@363.2};		color: 'E00E0E').	g add: (RSPolygon new		points: {231.2@198.4. 231.2@363.2. 89.6@363.2};		color: 'BF1111').	boat := RSComposite new shapes: g; yourself.	x := 1.	updateLines := [ 		lines doWithIndex: [:line :m |			| points |			points := (1 to: 200) collect: [ :i | | y |				y := (perlin snoise: (i+ frame)/scale and: (m + frame) / scale) * 20.				i @ (7* m + y)].			line controlPoints: points ] ].	updateLines value.	canvas newAnimation		repeat; 		onStepDo: [ :t | 			| cp p1 p2 vector |			frame := frame + 0.5.			updateLines value.			cp := (lines at: lines size / 2) controlPoints.			x := x + 0.3.					(x between: 1 and: cp size - 1)				ifFalse: [ x := cp size - 1 ].			p1 := cp at: x.			p2 := cp at: x + 1.			vector := p2 - p1.			boat matrix				loadIdentity;				rotateByRadians: vector angle;				scaleBy: 0.025;				translation: x @ p1 y.			canvas signalUpdate. ].	canvas addAll: lines.	pharo := RSBitmap new		form: (self iconNamed: #pharo);		yourself.	canvas zoomToFit.	canvas camera scale: 2.5.	canvas add: pharo.	canvas add: boat.	RSLocation new 		inner; bottom; right;		move: pharo on: lines.	^ canvas! !!RSSVGAnimatioinExamples methodsFor: 'examples'!example04RoassalIcon	<script: 'self new example04RoassalIcon open'>	| c newEllipse paint eAnimation |	c := RSCanvas new.	newEllipse := [ RSEllipse new		color: 'E83A54';		radius: 0;		yourself].	paint := (LinearGradientPaint 		fromArray: { 0-> '25B4AF'. 1-> '0088AC'})		start: 28.879@143.392;		stop: 272.3663@143.392.	c 		addShape: (RSSVGPath new 			noPaint;			border: (RSBorder new paint: paint; width: 21);			svgPath: 'M77,24.4v243.9			M264.2,232.3c0,0-24.1,30-51.7,30C144.3,262.3,174,113,77,113c-18.5,0-37.6,12.6-37.6,30		c0,16,11.8,28,38.3,28s115.7-10.7,115.7-77.1c0-53.9-45.7-69.5-116.5-69.5c-11.8,0-21.8,1.4-30.1,3.4c-4.6,1.1-8.7,2.4-12.3,3.8');		addShape: (newEllipse value position: 264.2@232.3);		addShape: (newEllipse value position: 143.6@158.1);		addShape: (newEllipse value position: 77@268.4);		addShape: (newEllipse value position: 34.6@31.6).	c newAnimation		from: 0; to: 1000;		duration: 10 seconds;		onStepDo: [ :t |			c shapes first border dashArray: {t. 10000}.			c signalUpdate ].	eAnimation := [ :duration :shape | 		c newAnimation 			duration: duration milliSeconds;			when: RSAnimationEndEvent do: [ 				c newAnimation					from: 0;					to: 20.4;					easing: RSEasing elasticOut;					on: shape set: #radius:.  ] ].	eAnimation value: 1 value: c shapes second.	eAnimation value: 2000 value: c shapes third.	eAnimation value: 2500 value: c shapes fourth.	eAnimation value: 7500 value: c shapes fifth.	c @ RSCanvasController.	^ c! !!RSSVGAnimatioinExamples methodsFor: 'examples'!example05Corona	<script: 'self new example05Corona open'>	| canvas extent mainScale curveScale yscale color axis title ytitle xtitle lineTitle line curve normalY spoint |	canvas := RSCanvas new.	extent := 500@250.	mainScale := NSScale linear		domain: {0@0. 100@100};		range: {0@extent y. extent x@ 0}.	curveScale := NSScale linear		domain: #(0 0.5 1);		range: #(50 90 50).	yscale := NSScale linear		domain: #(40 100);		range: #(500 40).	color := NSScale linear		domain: #(40 80 100);		range: { Color red. Color orange. Color green }.	axis := RSPolyline new		controlPoints:  ({ 0@100. 0@0. 100@0} collect: [:p| mainScale scale: p]);		markerStartEnd: (RSShapeFactory arrow			extent: 10@15;			color: Color black);		yourself.	title := RSLabel new		text: 'Simulation';		bold;		fontSize: 20;		position: (mainScale scale: 50@100);		yourself.	ytitle := RSLabel new		text: 'Number of cases';		bold;		position: (mainScale scale: -3@ 50);		rotateByDegrees: -90;		yourself.	xtitle := RSLabel new		text: 'Time';		bold;		position: (mainScale scale: 50@ -7);		yourself.	lineTitle := RSLabel new		text: 'Heal care system capacity';		bold;		position: (mainScale scale: 75@ 30);		yourself.	line := RSLine new		startPoint: (mainScale scale: 0@20);		dashArray: #(10);		endPoint: (mainScale scale: 100@20);		yourself.	curve := RSSVGPath new withBorder.	normalY := [ :x :mean :std |		(-0.5 * (2* Float pi) log - std log -		 ( ((x - mean) raisedTo: 2) / (2 * std * std))) exp].	spoint := [ :s :p | s << p x asFloat asString; space; << p y asFloat asString ].	canvas newAnimation		repeat;		duration: 10 seconds;		scale: curveScale;		onStepDo: [ :t | 			| low upp mean stdDev series y first |			low := 0.			upp := t.			mean := (low + upp) / 2.			stdDev := (upp - low) / 4.			first := nil.			series := (low to: upp) collect: [ :x | 				y := normalY value: x value: mean value: stdDev.				y := y * (yscale scale: t).				first ifNil: [ first := y ].				mainScale scale: x @ (y - first ) ].			curve svgPath: (String streamContents: [ :s |				s << 'M'.				spoint value: s value: (mainScale scale: 0@0).				series do: [ :p | s << 'L'. spoint value: s value: p ].				s << 'L'.				spoint value: s value: series last x@ 250.				s << 'Z' ]).						curve paint: (color scale: t).			canvas signalUpdate.			].	canvas add: axis.	canvas add: title.	canvas add: ytitle.	canvas add: xtitle.	canvas add: curve. 	canvas add: line.	canvas add: lineTitle.	canvas @RSCanvasController.	^ canvas! !!RSSVGAnimatioinExamples methodsFor: 'examples'!example06AnimatedSVG	<script: 'self new example06AnimatedSVG open'>	| monsterPath monster c |	monsterPath := 'M256,200.348c-30.736,0-55.652,24.917-55.652,55.652s24.917,55.652,55.652,55.652s55.652-24.917,55.652-55.652			S286.736,200.348,256,200.348z M272.696,256c-9.208,0-16.696-7.492-16.696-16.696c0-9.204,7.487-16.696,16.696-16.696			c9.208,0,16.696,7.492,16.696,16.696C289.391,248.508,281.904,256,272.696,256zM418.265,117.344l22.177-22.179c6.529,3.119,13.752,5.009,21.471,5.009c27.662,0,50.087-22.424,50.087-50.087			S489.576,0,461.913,0s-50.087,22.424-50.087,50.087c0,7.718,1.89,14.94,5.009,21.471L389.092,99.3			C350.286,78.679,304.711,66.783,256,66.783S161.714,78.679,122.909,99.3L95.165,71.558c3.119-6.53,5.009-13.753,5.009-21.471			C100.174,22.424,77.749,0,50.087,0S0,22.424,0,50.087s22.424,50.087,50.087,50.087c7.718,0,14.94-1.89,21.471-5.009l22.177,22.177			C36.543,158.204,0,220.156,0,289.391C0,412.135,114.843,512,256,512s256-99.865,256-222.609			C512,220.156,475.457,158.204,418.265,117.344z M322.783,445.217H200.348c-9.223,0-16.696-7.473-16.696-16.696			c0-9.223,7.473-16.696,16.696-16.696h122.435c9.223,0,16.696,7.473,16.696,16.696			C339.478,437.744,332.005,445.217,322.783,445.217z M256,378.435c-67.51,0-122.435-54.934-122.435-122.435			S188.489,133.565,256,133.565c67.511,0,122.435,54.934,122.435,122.435S323.511,378.435,256,378.435z'.	monster := RSSVGPath new svgPath: monsterPath.	c := RSCanvas new.	c add: monster.	c newAnimation repeat		duration: 0.1 seconds;		when: RSAnimationLoopEvent			do: [ :evt | monster rotateByDegrees: 5 ].	c @ RSCanvasController.	^ c! !!RSSVGAnimatioinExamples methodsFor: 'data - svg'!miku	^ 'm 148.25647,236.39122 -3.89508,14.84999 -14.11966,51.12292 -10.10286,26.9004 -15.70204,33.35162 -14.849996,32.37785 -10.589748,26.90039 -6.207783,20.20573 -5.477456,18.25819 -3.408195,26.77867 0.365164,20.69261 2.556146,18.62335 6.329504,21.42294 1.095491,-13.38934 2.434425,-21.7881 3.89508,-24.34425 7.546717,-21.1795 5.477456,19.84057 7.303275,27.63072 11.92868,23.97908 17.04097,22.8836 9.61598,9.25081 5.84262,-16.43237 6.81639,-24.1008 3.28648,-15.21516 2.3127,-20.57089 2.55615,-15.70204 0.48688,-21.7881 0.60861,-26.90039 3.85187,-84.73722 3.09851,-18.41896 3.09852,-17.73041 7.57415,23.58316 2.23782,-5.85275 8.95127,-21.51748 5.1642,-11.18909 6.71345,27.54237 8.60699,21.34534 3.27066,-26.85381 4.13136,15.83686 4.64777,18.24682 6.88559,16.86971 4.64778,5.33633 -0.17214,-11.87765 0.34428,-15.49258 228.94597,2.23782 2.06568,14.45974 0.8607,18.5911 1.03284,24.616 0.51642,34.08369 0.17214,32.53443 1.54926,22.55031 5.33633,26.3374 2.92638,17.38612 8.43485,32.70657 4.13136,-2.23782 17.55826,-19.62394 15.83687,-20.3125 12.22192,-17.7304 12.22193,-21.34534 9.12341,-22.72246 7.74629,-25.64883 5.68062,17.7304 8.09057,30.12447 4.81992,22.20604 2.40995,18.93538 0.51642,9.29555 2.75424,-7.22987 4.13136,-14.80403 2.58209,-14.80403 -0.86069,-19.10752 -2.75424,-16.52542 -3.4428,-16.18114 -4.99205,-13.25477 -8.26272,-17.55826 -6.19703,-12.73835 -10.84481,-20.82892 -14.63188,-25.4767 -9.4677,-19.96822 -7.05773,-16.35328 -6.36917,-14.97617 -3.95922,-11.18908 -21.87474,-45.37302 -14.3631,-37.73359 -37.73359,15.33688 0.73033,17.28442 -4.86885,6.08606 -0.24344,-23.12704 -60.86062,13.63278 -74.4934,10.22459 -67.92046,-2.19099 -54.77455,-7.30327 z#299ca3m 267.67744,453.58845 2.58209,-2.92637 10.50053,-6.19704 9.98411,-7.22987 7.7463,-7.57415 0.57862,-2.65433 -0.85205,-6.20779 3.28648,-2.55614 3.28647,-7.18156 2.06926,-9.98114 1.94754,-8.64221 1.46066,-12.53729 -0.36517,-11.07663 -0.12172,-9.37253 10.95491,-0.73033 16.67581,-3.4082 10.83319,-2.43442 6.45123,0.60861 22.27499,28.60449 0.48688,21.90982 0.48689,11.19835 4.74712,1.0955 -0.97377,6.69466 -0.48688,3.77336 4.13852,5.7209 11.56352,7.425 5.84262,5.7209 -4.09974,22.93458 -32.36229,29.95233 -38.9036,-3.09852 -40.96928,-9.29555 -17.90254,-22.0339 z#ffffffm 266.81674,454.44915 8.09057,9.29555 8.77913,9.81197 10.15625,9.63983 5.33634,-1.54925 9.63983,-4.99206 11.87764,-7.57415 5.33634,-3.27066 5.68061,6.88559 7.57416,9.29556 10.15625,7.91843 4.99205,1.37712 6.54132,-3.78708 6.74264,-6.5708 9.37254,-5.59918 4.86885,-4.13852 6.93811,-5.59918 -1.94754,-8.76393 5.35573,2.43442 4.0168,-0.36516 4.62541,-8.27704 2.67787,-4.0168 10.71147,3.89507 -1.21722,6.32951 -10.3463,20.57089 c 0,0 -12.65901,15.94548 -12.29385,15.82376 0.36517,-0.12172 -11.68524,8.39877 -11.68524,8.39877 l -6.81639,2.79958 -17.04097,4.86885 -15.58032,2.67787 -9.12909,0.85205 -12.78073,-0.73033 -11.80696,-2.55614 -8.15533,-2.43443 -11.68523,-3.65164 -9.85942,-5.84261 -9.00738,-6.32951 -8.27704,-6.69467 2.92131,-4.0168 -7.05983,-6.93811 -6.32951,-10.58975 9.37254,-5.11229 z#808791m 241.86011,504.54312 5.59917,6.20778 11.32008,4.62541 9.85942,2.79959 -10.58975,13.38933 -17.52786,20.93606 -12.53728,15.33687 -5.1123,5.59918 -7.30327,3.65164 -11.56352,0.12172 -9.85942,-2.06926 -5.47746,-1.21722 1.94754,-6.69466 17.04098,-23.61393 10.71147,-13.63277 10.3463,-11.19836 9.25082,-10.22458 z#808791m 254.27567,493.5882 8.76393,7.05984 13.38934,8.76393 -7.18155,9.37253 -9.61598,-2.92131 -10.58975,-4.13852 -7.18155,-6.81639 z#fdf4ebm 408.73993,485.79804 6.45123,-2.06926 8.39876,-4.99057 0.85205,11.80696 -4.74713,15.94549 -6.3295,17.52785 -7.54672,14.48483 -0.12172,6.45123 2.55614,10.3463 1.21722,9.00738 -2.31271,5.72089 -6.57294,2.79959 -9.25082,0.12172 -5.47745,-0.85204 -7.18156,-1.94754 -4.86885,-4.62541 -1.21721,-7.425 2.3127,-13.26761 6.45123,-15.09344 4.86885,-9.85942 4.86885,-11.56352 0.97377,-6.3295 6.93811,-5.96434 6.57295,-7.91188 1.70409,-2.43443 z#808792m 247.79529,463.48649 3.87314,6.97167 9.7259,11.4473 -2.15174,2.49602 7.83236,6.97167 11.53337,7.1438 7.74629,4.81991 17.12791,5.33634 13.94333,3.09852 14.71795,0.60249 10.84481,-0.94677 13.08263,-2.92638 12.82442,-3.18459 11.27516,-5.33633 8.34878,-6.19704 7.66022,-8.60699 7.57415,-11.10302 4.21743,-6.97166 4.13136,-9.12341 1.80746,-6.88559 3.52887,1.46318 1.80747,3.70101 -1.11891,7.66022 -5.07813,13.68512 -4.30349,6.54131 -8.26271,9.46769 -8.34879,8.52093 -6.54131,5.16419 -11.79158,5.93882 -10.15625,3.4428 -7.48808,1.7214 -9.38162,2.66817 -12.308,2.15174 -6.02489,-0.77462 -11.70551,-0.68856 -8.43485,-2.32389 -7.40202,-0.43035 -2.15174,-2.15175 -4.47564,-0.60249 -7.40201,-1.97961 -8.77913,-3.61493 -4.99206,-3.78708 -7.66022,-3.87315 -6.62738,-5.4224 -4.21743,-4.3035 -1.63533,-2.15174 1.97961,-3.01245 -6.45524,-8.26271 -4.90599,-7.14381 -1.63533,-3.95921 3.35673,-3.27066 z#93d3d5m 416.16493,468.75707 4.86885,4.26024 1.94754,5.96435 -5.47746,3.16475 -7.425,2.67786 2.31271,-6.81638 z#fdf4ebm 319.27482,371.98868 5.23401,-4.6254 4.13852,0.6086 5.7209,3.65164 0.24344,2.55615 -3.52991,5.23401 3.40819,11.19835 3.65164,13.02418 -1.7041,6.81639 -7.30327,8.39876 -7.05983,5.59918 -3.65164,-2.79959 -4.50369,-9.12909 -4.38196,-9.61598 2.43442,-5.11229 4.62541,-8.27705 4.62541,-10.83319 z#93d3d5m 284.58426,368.94565 8.39877,-2.3127 9.85942,-4.50369 4.50369,-2.55614 -9.49426,-0.85205 -10.95491,-0.97377 -3.28648,-2.67787 26.65696,-0.73033 21.42293,-1.21721 14.72827,-0.48688 -7.91188,2.92131 -4.99057,1.70409 -5.59917,10.10287 -2.79959,0.6086 -3.04303,-4.26024 -2.31271,-4.99057 -10.10286,1.09549 0.12172,17.52786 -6.93811,4.13852 -10.58975,5.7209 -4.86885,-11.68524 z#fdf4ebm 354.08709,353.24361 32.86474,0 -2.92131,4.50369 -7.425,7.30327 -1.94754,17.1627 -3.65164,8.27704 -5.59917,2.31271 -4.13852,-0.60861 -4.01681,-5.23401 -3.16475,-12.90246 -0.48688,-13.02417 z#fdf4ebm 201.4036,388.5196 24.96028,-7.57416 19.62394,-4.99205 28.05879,-8.77913 12.39407,30.29661 -9.81197,8.26271 -18.82312,14.33499 -27.75244,20.08401 -11.6077,-21.76672 z#808791m 190.90307,392.30667 9.89804,-3.87314 11.53337,20.3125 17.98861,32.01801 -11.18909,7.31594 -10.58659,-19.53787 -11.4473,-22.63639 z#93d3d5m 274.30482,367.43247 7.31594,-1.89354 3.87315,6.2831 6.11096,11.70551 2.32389,7.74629 -7.66022,5.50848 -5.07813,-11.27516 -6.19703,-13.59905 z#93d3d5m 178.56506,409.23538 2.06926,-6.93811 4.26025,-4.13852 8.27704,0.12172 14.60655,29.69999 -5.35573,7.30327 -7.66844,4.13852 -4.13853,1.82582 -8.76392,4.13852 -6.32951,0.24345 -6.20778,-2.79959 -5.11229,-8.88565 -3.52992,-8.88565 -3.77336,-10.34631 1.21721,-4.50369 5.35574,-7.42499 2.43442,8.88565 6.20779,-0.97377 z#fdf4ebm 177.99259,446.70286 6.36917,14.45975 6.71345,10.50053 5.50848,0.51641 5.59454,-4.5617 0.94677,-3.27066 -3.35673,-9.12341 -6.36917,-15.23437 -3.4428,1.89353 -5.25026,2.66817 -6.79952,1.03284 z#ffffffm 150.10593,227.74099 2.75424,-17.90254 -10.50053,7.22988 0.17214,-10.50053 2.40996,-12.73835 7.05773,-6.71346 7.22987,-7.74629 2.17303,-8.34279 3.89508,-6.57294 5.47745,-4.26025 10.71147,0.73033 5.59918,-2.55615 11.56352,-17.04097 -8.15533,-7.05983 -7.91188,-6.93811 -6.20778,-8.15533 -3.16475,-6.08606 12.17212,6.81639 19.84056,8.64221 12.90246,2.79959 15.94548,1.82582 6.3295,-1.46066 14.60655,-4.0168 25.43974,-4.26024 22.88359,-1.94754 59.54143,-10.9726 53.01907,28.91949 5.50848,16.69756 7.83236,15.57866 25.033,2.60391 42.11555,37.97702 -78.87536,23.37048 -62.80816,15.09344 -61.10407,4.86885 -73.76307,-4.62541 -68.65078,-14.11966 z#93d3d5m 72.667581,151.91668 6.694669,1.94754 9.737699,6.57295 5.599177,4.86885 9.250814,9.85942 8.0336,10.71147 7.79016,11.92868 0.48689,-9.85942 1.82582,-13.26762 3.52991,-15.58032 6.32951,-16.0672 5.23401,-11.32008 4.92159,-9.06132 6.19703,-7.74629 5.50848,-2.66817 6.88559,-0.34428 8.17664,3.27066 5.85276,4.21742 1.7214,6.62738 -0.77463,8.43486 -5.76669,11.27516 -6.97166,9.98411 -4.38957,7.40201 -6.62738,11.70551 -3.61494,10.24232 -3.35672,9.55376 -1.54926,8.34878 -0.97863,6.41624 -0.36516,17.1627 0.85205,17.1627 2.3127,15.58031 3.16475,18.37991 3.4082,16.91925 -20.57089,8.27705 -5.47746,-22.76187 -3.89508,-17.1627 -4.99057,-18.62335 -4.62541,-13.63278 -5.59917,-9.49425 -6.938113,-10.22459 -9.615978,-9.61598 -6.451226,-7.30327 -6.675989,-5.36698 -8.305746,-5.20723 -4.647776,-4.30349 -1.204979,-9.29555 2.496028,-9.63983 3.959216,-6.41221 z#5fc5c9m 166.37315,411.41419 6.54131,-0.77462 6.02489,-1.7214 1.80747,-6.62739 -4.64777,-11.53337 -4.99206,-21.34533 -5.68061,-20.82892 -5.50848,-22.20604 -8.26271,-34.25583 c -6.20014,3.16792 -11.49776,7.01271 -21.1732,7.57415 l 7.57415,33.05085 8.77914,29.43591 7.57415,18.50503 7.74629,18.59111 z#ffffffm 74.966896,158.45471 1.979608,2.79727 0.25821,4.1744 -0.860699,4.30349 -1.850503,3.78708 -1.506224,2.45299 -2.108713,1.97961 -2.237817,-0.0861 -1.721399,-1.67836 c -0.758778,-9.75855 3.696766,-18.27448 8.047537,-17.73038 z#299da4m 152.90321,117.61454 c 7.03567,-1.57483 15.78503,3.49999 17.62825,9.8666 l -0.27387,1.46065 -1.61281,2.03883 -2.79959,1.36937 -2.37356,-0.18258 -4.89928,-1.88668 -5.17315,-3.95594 -1.94754,-2.58658 -0.79119,-2.58658 0.27387,-1.94754 0.88248,-1.09549 z#299da4m 448.25212,176.09905 21.34534,-22.20604 -12.39407,-13.25477 -5.86103,-6.73631 -14.60654,-13.99794 -11.03402,-10.25092 -11.96372,-9.46769 -9.20948,-7.660223 -5.33633,-10.07018 -3.70101,-11.877648 -3.35673,-14.804025 -1.72139,-12.049789 -0.43035,-11.016949 -3.09852,-4.733845 -9.20948,-4.905985 -6.36917,0.08607 -6.97167,2.582097 -2.8403,5.422405 -0.60249,15.320445 1.29104,15.750794 2.23782,10.41446 4.90599,10.930879 0.90373,3.657971 -5.2933,1.075875 -16.43935,1.118908 -19.71001,3.442797 -13.85726,3.442797 -8.0045,3.356726 -3.18459,3.70101 -0.94677,9.55376 1.20498,9.29555 3.18459,7.05773 2.06568,0.60249 11.96371,-3.18459 19.96822,-3.52886 22.8946,-0.25821 15.49259,2.49603 16.18114,9.81197 14.97617,9.63983 14.11546,11.79157 z#5fc5c9m 431.98491,162.84428 15.92293,13.85725 -3.01245,11.27516 -2.92637,8.34879 1.63532,13.68511 8.17665,28.57521 -8.52093,9.03735 -6.88559,-13.68512 -9.29555,-17.30005 -4.5617,-13.08263 0.60248,-8.09057 4.04529,-13.85726 3.01245,-11.70551 z#808791m 247.36494,201.05932 17.21398,49.57627 10.67267,23.06674 12.39407,21.34534 13.08262,15.32044 13.77119,13.59905 -0.68856,-12.91049 -1.54926,-38.73146 5.1642,-36.49364 8.26271,-42.3464 36.66578,57.4947 13.59905,35.97723 -1.05197,13.58121 -1.15635,23.12704 -0.79119,9.61598 -36.1512,9.37253 -54.65284,3.89508 -22.39671,-5.59917 -24.58769,3.52991 -6.45123,-6.69467 -1.33893,-11.44179 -0.85205,-18.86679 -0.24344,-12.78073 -1.58238,-21.05778 13.99795,-49.90571 z#fdf4ebm 480.0625,208.28125 c -10.91988,4.12393 -21.98027,8.0309 -33.15625,11.6875 l 3.3125,12.625 c 3.80711,-1.2643 7.63016,-2.57732 11.46875,-3.9375 l 1.53125,-1.6875 L 467.375,223 l 3.53125,2.3125 c 3.08442,-1.14879 6.17882,-2.31867 9.28125,-3.53125 l 1.34375,-3.15625 4.125,-4.5 -5.59375,-5.84375 z m -49.25,16.75 c -6.10399,1.83639 -12.23387,3.58742 -18.40625,5.25 l 4.125,12.4375 c 6.93741,-1.85936 13.9349,-3.88821 21,-6.0625 l -6.71875,-11.625 z m -280.59375,4.0625 -3.125,12.25 c 18.02488,7.60993 44.65417,14.50638 77.75,18.09375 l 2.71875,-13.375 c -25.52993,-3.0698 -51.33015,-8.56718 -77.34375,-16.96875 z M 405.96875,232 c -15.43506,3.98249 -31.08297,7.36842 -46.90625,10.0625 l 4.625,12.21875 c 13.911,-2.3659 28.2087,-5.32857 42.8125,-8.96875 L 405.96875,232 z M 311.875,247.8125 c -15.10479,1.11216 -30.35409,1.5248 -45.71875,1.09375 L 270.25,262 c 13.20733,0.10471 27.07798,-0.31428 41.53125,-1.375 l 0.0937,-12.8125 z#ffffffm 187.69415,157.69844 2.43443,-9.79856 2.0084,-5.17316 5.11229,-1.82581 4.74713,2.0084 7.18155,4.86885 -5.59917,2.19098 -9.25082,4.50368 z#7f8791m 198.64907,141.57037 c -1.88612,4.4324 -2.97264,8.465 -3.89508,12.41557 l 3.65163,-0.60861 c 0.86888,-4.04055 1.97288,-7.84596 3.16476,-11.56351 z#fb9ae7m 440.50583,170.5045 3.01244,2.5821 c -3.10015,10.35019 -10.10675,24.24455 -9.46769,26.5956 0.9743,3.58438 3.14331,6.66171 4.13136,10.24232 5.43376,19.69146 7.99932,25.03314 11.87765,29.86626 l -2.84031,3.09852 c -2.56504,-5.67442 -7.68573,-16.66677 -10.5866,-25.21849 -1.76587,-5.20575 -0.84787,-7.95931 -2.8403,-13.08262 -0.39089,-1.00512 -2.1206,-4.09214 -2.23782,-5.1642 -0.45037,-4.11903 3.0183,-11.72928 8.95127,-28.91949 z#fb9ae7m 405.21716,281.53469 6.11097,-5.4224 1.63532,2.66816 0.17214,7.48809 -8.26271,10.50053 z#fb9ae7m 404.78681,281.96504 4.99206,-4.13135 2.40996,-1.7214 1.72139,9.12341 12.22193,-16.18115 -4.38956,-5.50847 -1.54926,-8.34878 -2.92638,-9.46769 -3.18459,-12.04979 -4.30349,-9.81197 -4.21743,-8.17664 -0.0861,14.97616 1.46319,16.69757 -1.29105,25.90704 z#808791m 478.24276,230.18344 1.46065,-8.88565 3.52992,-5.96434 4.86885,-2.67787 6.81639,1.33893 3.16475,3.04303 4.38197,-4.38196 3.16475,-6.57295 1.21721,-4.99057 -3.40819,-2.67787 -0.12173,-1.94754 4.38197,-1.15635 6.99897,3.7125 12.11126,10.10286 6.57295,7.97274 4.99057,10.28545 -1.09549,6.45122 -2.79959,6.75553 -4.3211,8.03361 -5.53832,4.0168 -3.83422,0.6086 -1.64323,4.32111 -4.13853,2.617 -6.45122,1.15635 -5.35574,0.36517 -7.48585,-11.1375 -9.55512,-11.62437 -6.3295,-5.7209 z#fdf4ebm 467.22699,223.00188 -8.27705,8.39877 6.26865,4.26024 8.45962,6.69467 8.94651,10.28545 5.29488,7.66843 5.17315,10.10287 5.35574,12.47642 6.14692,23.30962 3.22561,0.54775 4.74713,-3.65164 5.96434,-6.08606 -3.10389,-10.65061 -10.52889,-21.11864 -5.23401,-7.54671 -8.0336,-12.65901 -8.76393,-10.10286 -9.61598,-8.27705 z#93d3d4m 381.47437,333.52477 10.22982,-0.4342 12.39406,-1.03284 20.74285,-1.97961 13.51298,-0.43035 17.12791,-1.54925 9.46769,-0.51642 8.69306,-4.47564 11.87765,-9.38162 11.18909,-7.05773 6.62739,-0.60249 6.62738,1.80747 4.90598,7.83236 1.03284,7.40201 -2.58209,5.59455 -7.66023,4.90598 -10.50053,4.38957 -11.79157,3.44279 -7.83237,1.11891 13.51298,5.68062 20.91499,8.77913 20.05429,9.7259 16.78363,9.03734 8.8652,7.74629 2.40996,6.62739 -2.15175,9.38162 -3.25366,5.11167 -3.80407,4.52816 -7.31594,5.16419 -5.1642,0.60249 -9.20948,-3.61494 -11.79158,-10.07018 -11.79157,-11.10301 -11.70551,-10.24232 -12.91049,-9.72591 -9.63983,-7.22987 -10.41446,-4.81991 -9.46769,-3.61494 -10.50053,-0.34428 -17.12791,-0.60249 -24.01351,-0.0861 -17.64433,-0.34428 z#5fc5c9m 378.27728,328.87315 -3.35673,4.13135 6.45525,0.0861 z#93d3d4m 385.73462,353.42619 12.71987,0.0609 5.29487,5.05144 -6.69467,5.05143 -5.78176,-3.52992 -4.92971,-5.05143 z#93d3d4m 458.92479,232.13056 4.99205,2.66817 9.29556,7.1438 10.15625,10.67267 6.2831,10.15625 5.68061,11.87765 3.70101,10.07018 3.70101,11.36123 2.23781,9.89804 -5.25026,0.0861 -4.64778,1.80747 -6.54131,4.30349 -11.10302,8.09057 -8.77913,5.68062 -5.25027,2.5821 -10.93087,0.17214 -11.83865,0.7461 -11.68524,0.48688 -12.35471,1.21722 -13.57192,1.03463 -5.41659,0.6086 -15.1543,0.42603 -4.13852,-8.88565 6.57295,-5.59918 4.92971,13.57192 7.91188,-0.60861 3.46905,-12.53729 1.94754,-11.19835 1.27808,-10.22458 4.74712,-6.81639 7.60758,-9.25082 8.06757,-10.8095 8.95127,-12.04979 12.39407,-14.63188 11.96372,-12.39407 z#808791m 399.62262,353.66128 12.99655,0.25821 -9.12341,4.90599 z#808791m 236.17585,344.27966 2.23782,-5.33633 7.31594,-4.13136 12.99656,-0.60249 15.40651,-0.0861 2.49603,5.1642 5.76668,1.63532 6.62739,-1.63532 3.95921,-3.35673 7.31595,3.95921 7.57415,1.11891 6.71345,-1.63532 6.45524,-5.93883 6.62739,-0.8607 17.55826,0.43035 16.43935,0.8607 18.41897,-0.17214 3.701,-0.17214 c -1.46829,4.78103 -1.9166,11.60199 -1.54925,20.05429 l -14.63189,-0.25821 -21.86176,-0.43035 -18.16075,1.03284 -17.47219,0.60249 -20.91499,0.43035 -18.50504,0.17214 -13.4269,0.17214 -8.34878,-0.51642 -8.26272,-1.37712 -4.38956,-3.52887 z#ffffffm 552.371,389.75998 c -2.49095,9.6659 -6.94355,16.46199 -13.81537,19.71885 l -3.10389,-1.33894 -0.18258,-3.7125 1.21721,-4.80798 2.67787,-5.59918 3.52992,-3.65164 3.52991,-2.19098 3.83422,-1.21721 1.71442,0.87064 z#299ca3m 538.12961,234.20024 7.18155,12.53729 4.50369,12.29384 0.12172,6.93811 -2.67787,4.74713 -3.65163,2.92131 -2.67787,0.54775 -3.46906,-3.52992 -6.51208,-8.09446 -6.81639,-9.7377 5.78176,-4.50369 4.07766,-5.96434 2.67787,-7.18155 z#ffffffm 485.60646,214.40016 5.25027,-0.51642 7.91843,2.84031 3.61494,-4.13136 3.52886,-6.79952 0.51642,-5.07813 -7.40201,-9.12341 -7.523,-10.46185 -9.61597,-12.29385 -14.60656,-18.01474 c -7.65585,12.01479 -15.38301,18.65231 -23.00531,22.64015 l 20.08401,18.37991 16.18892,16.0672 z#ffffffm 223.78178,263.71822 1.54926,19.10752 c 7.42354,-28.43554 16.28337,-50.63582 22.20604,-74.19227 4.3298,19.47745 11.43985,39.4604 25.82097,60.76536 l -8.43485,-22.37817 -6.02489,-22.55032 -3.78708,-16.35329 -1.7214,-20.3125 -0.68856,-19.10752 -3.95921,6.71346 -4.99206,16.52542 -4.13136,12.04979 -7.05773,24.61599 z#f8bba6m 317.25371,165.9428 5.68061,6.36917 8.09057,12.39407 9.63984,18.5911 13.59904,29.43591 9.63983,23.7553 c -14.91707,-17.72028 -27.14191,-35.93006 -37.01006,-54.56833 -3.97848,18.72673 -8.76077,47.90307 -14.11547,84.52066 l -1.20498,-23.7553 1.7214,-27.37023 0.8607,-25.13242 1.54926,-22.72246 z#f8bba6m 155.125,209.125 -3.34375,2.125 c -1.19191,7.58216 -2.51216,15.4045 -4.25,23.03125 -1.13172,5.29018 -2.40529,10.6577 -3.75,16.0625 l 1.25,6.75 c 1.82232,-7.15843 3.55969,-14.32927 5.25,-21.5625 2.08211,-9.04014 3.55542,-17.99909 4.84375,-26.40625 z m -25.59375,89.40625 c -1.22344,3.54891 -2.43061,7.01443 -3.65625,10.3125 -23.29503,63.59916 -64.03125,122.16517 -64.03125,189.25 0,18.6086 4.187985,36.84136 8.919678,48.90884 1.230121,3.13724 2.285052,4.28124 3.091048,4.05766 0.805996,-0.22358 1.092635,-1.9105 1.320275,-4.86445 1.82224,-23.64618 3.983515,-47.09643 10.436204,-68.13804 0.773996,-2.52393 1.76968,-5.57549 2.514045,-5.57047 0.744365,0.005 0.894453,2.99632 1.385426,5.41439 7.300589,35.95584 21.141314,67.85441 45.611034,91.28735 1.58142,1.51441 3.34127,2.77095 4.57424,2.54929 1.23297,-0.22166 1.76376,-1.84855 2.45611,-3.6903 20.19014,-53.70883 19.44685,-92.93263 20.72319,-133.73552 0.36982,-5.23993 -1.45168,-7.94582 -3.8125,-10 1.79353,45.24895 -1.58002,91.22691 -18.30123,139.00221 -0.5714,1.63257 -0.76411,3.38147 -2.06557,3.56511 -1.30146,0.18364 -2.51798,-1.36983 -3.86206,-2.73881 -28.3933,-28.91926 -37.112825,-62.12083 -43.700293,-95.76591 -0.523738,-2.67496 -0.57079,-3.49989 -1.969947,-3.81392 -1.399156,-0.31404 -2.099286,1.07435 -3.238228,3.70467 -6.029559,13.92491 -9.798966,28.86851 -12.766938,65.63269 -0.21294,2.63768 -0.02193,5.03411 -0.885194,5.15919 -0.863258,0.12509 -1.968502,-2.68814 -2.563441,-5.03455 C 67.643566,525.87487 65.25,512.88476 65.25,498.59375 c 0,-67.11566 42.17483,-128.50301 63.3125,-188.21875 0.90203,-2.37718 1.78085,-4.73456 2.625,-7.09375 z#000000m 176.61752,446.84725 1.47057,-1.48444 1.93763,1.60616 c 0,0 7.49134,23.7965 12.90245,23.7965 3.26872,0 8.94651,-3.35424 8.94651,-5.29487 0,-5.48726 -9.92028,-23.4922 -9.92028,-23.4922 l 1.21721,-2.06926 2.3127,1.33893 c 0,0 8.88565,18.77162 8.88565,24.46597 0,3.77364 -6.82795,7.72929 -11.38093,7.72929 -6.56381,0 -11.26047,-14.49902 -16.37151,-26.59608 z#000000m 171.84375,298.625 c -2.85759,15.3187 -5.72399,30.49037 -7.96875,45.8125 l 2.59375,10.53125 c 1.06462,-12.78171 2.8288,-25.43522 6.46875,-43.5625 L 171.84375,298.625 z M 159.6875,393.25 c -0.006,0.46079 -0.0279,0.91337 -0.0312,1.375 l -0.0937,11.71875 4.5,-2 c 0.012,-0.27879 0.0194,-0.44244 0.0312,-0.71875 l -4.4063,-10.375 z#000000m 160.34825,404.87288 c 0,0 -4.99205,5.25958 -4.99205,8.43485 0,3.9951 4.72479,11.3353 6.36917,17.4722 1.54529,5.76709 3.90438,16.61149 16.52542,16.61149 7.15488,0 12.34049,-5.72226 16.00901,-5.93883 7.28991,-0.43035 14.63188,-11.36122 14.63188,-11.36122 l -1.80746,-3.35673 c 0,0 -5.09149,10.62263 -13.25477,11.27516 -2.82496,0.22581 -6.6816,6.02489 -15.40652,6.02489 -8.55579,0 -9.49679,-3.94525 -11.72228,-8.47034 -1.21925,-2.47909 -2.99567,-3.87558 -3.68423,-7.36652 -1.13118,-5.73501 -4.38957,-11.55254 -4.38957,-14.97617 0,-3.4319 6.0249,-8.34878 6.0249,-8.34878 z#000000m 156.97065,110.82851 c 8.65658,0 20.67766,5.08911 20.67766,16.78975 0,15.33809 -12.60506,24.23485 -21.52895,42.80853 -7.36801,15.33537 -12.89902,32.61104 -12.89902,49.74005 0,33.63945 8.23568,65.12984 16.45638,98.02644 5.91996,23.68975 10.12224,43.99383 18.14373,72.04772 0.68607,2.39944 3.87314,11.79158 3.87314,11.79158 l -2.15175,3.27065 c 0,0 -2.0746,-8.0815 -4.5617,-15.06223 -7.44753,-20.90356 -12.77937,-49.25654 -18.21055,-70.95563 -8.43911,-33.71657 -16.30349,-66.01529 -16.30349,-100.49565 0,-18.78214 5.77733,-38.4196 12.64807,-49.83623 9.27198,-15.4066 22.43892,-33.05931 22.43892,-41.03271 0,-7.84344 -10.37384,-14.65277 -18.21728,-14.65277 -13.82406,0 -28.70684,34.2996 -33.63582,60.23358 -2.96922,15.62256 -1.51073,28.33236 -3.37425,28.33236 -1.88463,0 -6.01878,-10.5924 -13.70697,-20.41117 -10.808656,-13.80397 -26.50237,-28.21833 -34.147901,-28.21833 -2.395694,0 -8.606992,12.48112 -8.606992,19.62394 0,8.1786 4.870582,7.89565 11.189089,12.73835 15.196452,11.64703 35.820634,35.72632 38.731464,44.41207 15.01519,44.80452 22.37051,111.06298 50.04551,170.22387 2.79816,5.98163 3.09093,9.87194 4.40662,9.40276 4.10047,-1.46225 11.61115,-1.9828 11.61115,-1.9828 l -0.79209,2.92855 c 0,0 -11.23008,3.74551 -14.12802,2.38587 -1.92184,-0.90168 -0.43804,-5.7025 -3.02712,-10.97517 -15.9584,-32.49931 -29.01209,-79.67101 -36.80362,-117.7329 -6.11416,-29.86787 -9.5759,-36.33093 -14.63107,-53.22495 -2.30271,-7.6955 -21.526955,-31.68977 -36.602028,-42.93248 -5.283146,-3.94007 -12.640953,-5.43559 -12.640953,-15.26866 0,-8.36137 6.333661,-22.58162 10.921671,-22.58162 7.777044,0 27.347107,14.53391 36.69931,28.21354 5.42501,7.93525 9.61266,15.57192 9.93912,15.57192 0.32646,0 -0.40762,-10.08087 2.057,-21.69525 5.25342,-24.7564 20.39861,-61.48298 36.13074,-61.48298 z#000000m 177.3901,411.93061 c 0,-7.33191 3.68905,-15.39503 9.89804,-15.49258 1.98952,-0.0313 5.93882,0.60249 5.93882,0.60249 l 0.94677,3.01245 c 0,0 -4.9212,-0.77463 -7.40201,-0.77463 -3.13916,0 -6.36918,5.29918 -6.36918,12.39406 0,5.58091 2.56211,11.01695 5.07813,11.01695 3.41181,0 -0.13347,-9.96061 3.44279,-9.7259 2.66396,0.17483 0.89486,5.60549 1.63533,8.34878 0.95054,3.52157 3.2769,5.90082 4.04529,12.22193 0.25358,2.08608 -0.60249,5.85276 -0.60249,5.85276 l -3.95922,2.75423 c 0,0 -1.41666,-1.43564 1.09646,-2.88659 0.88691,-0.51206 1.03464,-3.9322 0.964,-5.52827 -0.12627,-2.85321 -2.3763,-10.28752 -3.53409,-10.28752 -1.40229,0 -1.21575,2.09089 -3.43235,2.09089 -4.35615,0 -7.74629,-7.69387 -7.74629,-13.59905 z#000000m 221.30562,445.05505 c 22.92826,-16.76309 46.24633,-33.0145 69.63218,-53.41572 1.19842,-0.80536 1.11432,-1.33 0.77871,-2.49147 -1.8367,-6.03689 -5.60053,-13.03734 -9.40221,-20.05672 -0.76082,-1.77284 -1.12393,-1.88943 -2.75308,-1.39997 -28.73356,8.59439 -73.20649,18.7757 -86.31977,25.55523 -0.66624,0.26024 -0.8572,0.74362 -0.45046,1.60277 8.47649,17.88549 17.35796,35.36554 26.33071,49.77353 0.74287,1.49646 1.04381,1.26638 2.18392,0.43235 z m 16.10114,-68.49451 c 8.06997,-2.30699 29.93795,-8.63547 42.36507,-12.53403 1.97258,-0.91595 2.29603,-0.19009 3.2265,1.37333 4.93685,8.346 8.90828,16.37019 11.82532,24.04292 0.81101,1.63884 0.64777,2.08506 -0.57039,3.13816 -21.5295,18.56984 -46.79294,36.91613 -71.77744,55.27912 -0.52818,0.3882 -1.70176,1.37889 -2.77318,1.21709 -1.07143,-0.16179 -2.03138,-1.34058 -2.25756,-1.74155 -14.13892,-25.06442 -19.81454,-37.68038 -27.70129,-53.48098 -0.22439,-0.44954 -0.23539,-1.33202 -0.003,-2.00773 0.23214,-0.67571 0.90296,-1.31228 1.43393,-1.51277 15.77351,-5.95615 22.05873,-6.86297 46.23229,-13.77356 z#000000m 199.25767,389.2731 3.04303,-1.09549 c 9.95284,17.24177 19.54344,34.20423 28.84794,51.12292 l -2.19098,1.82582 c -9.04577,-16.77188 -19.03223,-34.10817 -29.69999,-51.85325 z#000000m 273.02075,368.45877 2.55614,-0.97377 c 3.95594,10.62501 7.54672,20.72127 11.50266,28.78707 l -1.82582,2.13012 c -4.01098,-8.64762 -8.06074,-18.07062 -12.23298,-29.94342 z#000000m 283.25609,368.12103 c 8.56571,-2.6387 16.47429,-5.56945 22.98067,-9.12341 l 4.3035,0.94676 c -6.12149,3.70101 -15.31864,7.40201 -26.25133,11.10302 z#000000m 292.29343,386.28178 c 5.82083,-3.31186 11.68231,-6.82698 17.73041,-11.27516 l 0.17214,3.35673 c -5.31773,3.83366 -11.10221,7.30908 -16.69757,10.15625 z#000000m 223.99569,212.88476 c 2.44838,-1.79166 8.70933,19.39485 40.31025,30.77305 l 0.61726,3.53499 c -32.75735,-12.12348 -43.3759,-32.51638 -40.92751,-34.30804 z#000000m 335.5437,244.03878 c -1.54327,-2.01708 6.22883,-3.82083 19.63888,-14.46395 17.3319,-13.75577 21.14919,-19.59885 22.76187,-17.89303 1.61268,1.70582 -4.65072,6.71639 -20.98647,20.22662 -14.26057,11.79398 -19.87101,14.14744 -21.41428,12.13036 z#000000m 249.93839,294.34539 c -1.08843,-13.81741 -3.39074,-33.66454 0.74762,-34.40202 4.08713,-0.72834 3.95335,12.49575 4.74862,28.0415 0.44725,8.74294 0.58322,17.65725 -1.01196,18.25189 -2.84295,1.05978 -4.0511,-6.39217 -4.48428,-11.89137 z#000000m 344.59284,252.58014 c 3.62536,-0.15165 3.87607,20.20414 3.89508,30.43031 0.0122,6.58257 -0.003,19.31888 -2.43443,19.59712 -3.44964,0.3948 -4.96536,-26.99989 -4.74713,-38.22047 0.0794,-4.0845 0.17705,-11.67689 3.28648,-11.80696 z#000000m 72.556939,157.85222 c 0,0 4.133465,0.19322 4.131356,6.8856 -0.0012,3.75088 -4.19954,12.82441 -6.713454,12.82441 -2.427261,0 -3.873146,-3.44279 -3.873146,-3.44279 0,0 0.529439,4.5617 3.959216,4.5617 2.605358,0 7.574153,-7.87294 7.574153,-14.20153 0,-8.03334 -5.078125,-6.62739 -5.078125,-6.62739 z#000000m 154.28167,117.1044 c 0,0 -3.16475,0.87752 -3.16475,3.95594 0,4.54214 10.56257,11.08555 13.69364,10.83319 6.06022,-0.48844 5.84262,-6.39036 5.84262,-6.39036 0,0 1.46619,7.54672 -6.14692,7.54672 -3.86668,0 -14.405,-6.47409 -14.48483,-12.11127 -0.0555,-3.91575 4.26024,-3.83422 4.26024,-3.83422 z#000000m 206.83841,181.53767 c -0.55762,3.3853 -1.13144,6.68726 -1.87662,9.86612 -11.62549,49.59324 -17.74277,83.92057 3.47477,143.5815 1.63208,4.57631 1.34631,4.36292 1.86668,0.0572 8.20046,-67.80527 23.10991,-126.32341 40.15006,-167.08876 2.1378,-5.11428 3.06825,-3.64589 3.33805,0.41178 3.52836,53.06509 10.08558,105.62102 57.43218,150.99979 1.66327,1.36913 1.55393,0.56499 1.6168,-0.80847 -4.29057,-49.68136 -1.45931,-98.85411 2.21538,-147.96644 0.34474,-4.60751 0.3183,-6.61391 1.07675,-6.97744 0.47421,-0.22729 1.1255,-0.42398 2.7666,1.67499 14.92912,19.09443 28.39621,46.21862 40.28098,74.71218 13.65128,32.72874 25.09124,67.15274 31.78859,92.79428 l 5.55487,-0.8877 c 2.30722,-12.21832 6.6699,-28.2312 6.6699,-37.44042 0,-46.25986 10.20351,-88.72236 -19.4832,-131.6081 -1.32743,-1.91762 -1.88853,-4.1705 -2.35358,-6.43102 -0.40798,-1.72104 -0.24844,-2.47305 0.0625,-2.53716 0.54773,-0.11291 0.70573,0.65634 1.65951,2.15099 27.58001,43.24245 27.16452,60.29308 23.00328,138.75357 -0.62975,11.87402 -3.35545,24.58775 -6.37325,37.86562 l -12.13586,1.29105 C 376.0696,286.06075 352.97625,221.9036 321.249,173.21897 c -1.53034,-2.51656 -2.07113,-2.41823 -2.45849,-2.43498 -0.53981,-0.0233 -0.58101,0.81914 -0.80743,3.71091 -3.51167,44.87584 -5.85773,91.69438 -2.46498,148.07758 0.42155,2.9416 -0.67752,3.00703 -2.58358,1.61488 -39.00648,-29.36009 -61.66245,-93.97244 -61.29921,-146.70942 0.0932,-5.04388 0.25069,-4.88949 -1.31821,-0.54853 -18.90316,52.32828 -29.72011,109.2985 -38.23456,165.11326 -0.55582,5.55752 -0.96017,6.09042 -3.4041,0.95416 -28.47729,-62.02075 -17.5003,-116.54305 -2.97072,-163.54086 2.4702,-8.06614 2.76034,-7.83153 1.13066,2.0817 z#000000m 196.21464,295.06086 -1.94754,-5.84262 c -5.26961,12.00005 -9.80287,24.42087 -14.28363,36.87169 0,0 -0.68006,2.6445 -1.37538,2.54257 -0.69531,-0.10193 -0.73501,-1.51861 -1.04676,-2.82489 -7.67983,-32.17914 -1.74447,-59.21869 0.45811,-74.54092 0.31701,-2.2053 0.81436,-4.47309 0.15092,-4.74919 -0.66344,-0.27611 -2.11038,2.03085 -3.42262,3.60866 -8.48495,10.20215 -16.86838,20.6581 -23.8134,34.71011 -2.75754,-34.01406 14.14817,-63.9577 29.30139,-90.83717 1.07749,-1.91129 2.0947,-3.3903 1.56285,-3.96637 -0.53185,-0.57607 -1.95183,0.56538 -3.71353,1.67274 -10.74858,6.75627 -20.96688,12.89053 -35.42775,23.38453 l 1.46065,-13.7545 c 6.74826,-16.25273 28.23339,-33.04462 61.59095,-50.27087 l 3.43446,-1.22659 c 0,0 2.04168,-0.83434 2.19388,-1.50844 0.1522,-0.6741 -0.0556,-1.6479 -1.0555,-2.22496 -11.73883,-6.77463 -23.48722,-14.42682 -30.95212,-25.26941 -0.97985,-1.4232 -2.53488,-2.88836 -1.79919,-3.6091 0.73569,-0.72074 1.89644,0.92996 3.28064,1.75512 21.53222,12.83591 39.64489,15.21867 48.8665,15.24479 0.34729,9.8e-4 0.68917,-0.0721 0.7898,0.19308 0.10398,0.27396 -0.0365,0.89007 0.13294,1.12647 0.19996,0.27894 0.83467,0.32118 1.14294,0.22971 25.58212,-7.59111 48.88731,-11.54314 72.25569,-12.69532 l -0.34428,-2.75424 c -19.41767,0.73051 -41.96076,1.92651 -70.23305,12.91049 -0.68646,0.2667 -0.11878,-0.58647 -0.42835,-1.03028 -0.35953,-0.51542 -1.58388,-0.65914 -2.32589,-0.69112 -19.58094,-0.84397 -39.54973,-8.83242 -55.36771,-19.40231 -1.80202,-1.20415 -2.98842,-2.41164 -3.77709,-1.94124 -0.78866,0.4704 -0.18828,2.17262 0.68821,4.23996 3.97976,9.38687 11.9573,20.13945 33.39907,32.41141 0.70626,0.40421 0.89018,0.61107 0.8934,0.74422 0.003,0.13314 -0.0737,0.2943 -0.99366,0.4492 -10.85517,1.82774 -43.63068,25.48341 -58.33003,40.47704 l -4.13136,14.28761 -0.89024,16.89058 c 11.69268,-8.10748 20.27882,-14.23962 29.0903,-19.73733 1.20131,-0.74953 2.25725,-1.8424 2.80727,-1.31288 0.55001,0.52953 -0.36056,1.16778 -1.4107,2.87156 -6.71505,10.89473 -24.49878,39.45812 -24.60458,75.3082 l 3.27066,15.49258 c 5.59093,-13.29105 12.8929,-22.51523 19.78182,-31.85638 1.04969,-1.42335 2.15152,-3.55629 2.68243,-3.17407 0.53091,0.38221 -0.18615,2.31975 -0.48545,4.13645 -3.38887,20.56955 -5.71761,49.02927 3.05694,70.72303 0.55994,1.38437 1.14537,3.39693 2.20538,3.37807 1.06002,-0.0189 1.45188,-1.87586 2.12232,-3.498 5.12328,-12.39585 9.82394,-25.37302 15.54029,-36.94167 z#000000m 174.5625,158.4375 c -9.52407,-0.0682 -14.23155,9.03951 -17.46875,22.5 l 3.59375,-2.65625 c 2.9046,-10.50801 7.13459,-17.04175 15.1875,-16.75 2.17976,0.079 6.46875,1.09375 6.46875,1.09375 l 4.25,-2.6875 c -2.93853,-0.80821 -5.22297,-0.65099 -9.71875,-1.3125 -0.79289,-0.11667 -1.5781,-0.18224 -2.3125,-0.1875 z#000000m 201.23146,142.87606 c -10.4521,0.4076 -8.11711,-0.27116 -12.56621,14.54581 l -3.52886,2.84031 c 5.45094,-20.10126 5.08028,-20.68404 13.77118,-19.62394 z#000000m 215.32488,312.58872 c 4.01949,17.21093 6.72949,36.63324 14.99368,52.72691 1.00237,1.95203 1.68133,3.4007 2.50375,3.08227 0.82242,-0.31842 0.5746,-1.74035 0.48966,-3.63951 -0.37556,-8.39707 -0.61608,-13.65583 -0.33751,-22.46969 l 2.79959,1.33894 c 0.18688,7.67134 -0.15201,17.44248 0.11225,25.92976 0.0998,3.20457 -0.37149,4.18459 -1.20775,4.50054 -0.83625,0.31596 -2.45959,-0.0118 -4.32214,-2.93166 -9.71228,-15.22566 -14.459,-41.7398 -16.0053,-51.11257 z#000000m 225.34375,260.78125 -2.4375,7.0625 c 0,0 2.78125,27.08184 2.78125,48.8125 0,17.99661 -0.87282,22.15173 9.28125,29 0.43866,0.29585 0.94257,0.60904 1.4375,0.90625 l 0.0937,-3.125 c -0.12494,-0.0701 -0.25359,-0.14865 -0.375,-0.21875 -9.54454,-5.51054 -6.46106,-11.31452 -7.28125,-27 -1.13139,-21.63678 -3.5,-55.4375 -3.5,-55.4375 z m 146.56906,65.70195 c -0.12425,1.45943 -0.43519,5.15968 -1.81906,6.92305 l 3.1875,1 c 0.33806,-0.52515 0.59375,-0.96875 0.59375,-0.96875 2.03407,-15.13437 1.9791,-29.01533 2.50432,-43.24439 l -2.66542,-7.56086 c 0,0 -0.56645,29.34887 -1.80109,43.85095 z M 348.8125,353.5 l -9.125,0.15625 c -7.67299,2.49629 -16.88255,4.15625 -27.84375,4.15625 -12.44914,0 -24.81462,-1.13264 -36.03125,-2.9375 l -14.78125,0.4375 c 13.1811,2.9707 30.31289,5.0625 51.09375,5.0625 15.559,0 27.5729,-2.94471 36.6875,-6.875 z#000000m 274.37489,329.17323 c 0.32235,0.14256 0.40567,0.39236 0.53068,0.99568 0.65915,3.18125 1.26783,9.62883 8.23281,9.62883 3.70201,0 7.10418,-4.94015 10.03156,-4.94015 2.74751,0 4.28911,5.02622 13.93275,5.02622 7.65622,0 10.7677,-4.71828 13.17625,-8.80835 0.67297,-1.14279 1.29872,-1.71773 1.59379,-1.61537 1.07361,0.37242 1.29071,1.74297 0.70492,3.0012 -2.75652,5.92074 -7.34358,9.94048 -15.80447,9.94048 -9.86891,0 -11.81474,-4.25159 -13.66843,-4.25159 -1.78964,0 -6.29696,4.74713 -9.98114,4.74713 -10.30018,0 -10.82804,-9.23667 -9.60946,-12.77325 0.26678,-0.77426 0.53839,-1.09338 0.86074,-0.95083 z#000000m 253.3019,492.12755 2.19099,2.19098 c -32.59003,27.22711 -65.54689,75.39477 -65.54689,77.96246 1e-5,2.67704 9.81672,3.04736 15.93504,3.04736 14.56582,0 16.50197,-1.29475 25.3311,-13.35737 4.62675,-6.32122 10.01003,-12.74794 15.45777,-19.27648 10.13827,-12.14964 20.71182,-24.22788 28.54182,-33.6477 l 2.06926,1.46066 c -7.99137,9.55323 -18.64267,21.93678 -28.78451,34.35699 -5.23006,6.40499 -10.76689,12.44065 -14.80563,18.89833 -9.6377,15.41007 -17.64989,14.40945 -28.05771,14.40945 -7.20728,0 -18.8519,-0.66098 -18.8519,-5.83039 0,-4.20001 19.8118,-29.73004 30.8444,-43.45238 9.93086,-12.352 18.81217,-21.03832 35.67626,-36.76191 z#000000m 243.00058,504.19323 c 7.03354,8.41444 17.16608,9.85614 26.65647,12.74268 l -1.7214,2.40996 c -8.98747,-3.02714 -18.14715,-3.75808 -26.68168,-12.82442 z#000000m 416.28665,467.53986 c 0,0 9.25081,3.92497 9.25081,18.13646 0,20.25713 -18.86679,51.13311 -18.86679,57.57415 0,7.96006 4.62541,10.17706 4.62541,20.81433 0,4.63567 -5.15041,10.34631 -19.59712,10.34631 -8.12387,0 -20.5709,-3.19442 -20.5709,-13.51106 0,-19.19642 17.13795,-45.88375 19.59713,-57.81759 l 3.28647,-2.79959 c 0.57798,13.56246 -20.08401,39.5991 -20.08401,60.1303 0,9.38345 13.46684,11.68524 18.25819,11.68524 7.59642,0 16.0672,-3.64083 16.0672,-7.79016 0,-8.73591 -4.13852,-12.81591 -4.13852,-21.05778 0,-10.02895 18.62335,-36.41339 18.62335,-57.45243 0,-12.20369 -7.91188,-15.33687 -7.91188,-15.33687 z#000000m 408.92251,483.8505 c 5.29105,-1.01969 9.47253,-3.5928 13.1459,-6.87725 l 1.39979,3.34734 c -6.66033,4.37135 -11.85711,6.12924 -16.24979,6.45122 z#000000m 395.43666,461.64682 c -2.34308,0 -5.00609,-4.00871 -6.2852,-3.14745 -1.1364,0.76517 0.86428,4.03705 0.86428,7.07818 0,2.49628 -9.11773,7.50567 -16.56997,13.1261 -6.06389,4.57335 -15.94347,14.03251 -20.08901,14.03251 -3.64102,0 -11.44703,-6.35837 -16.02402,-10.75523 -8.17382,-7.85215 -10.62371,-14.355 -12.144,-14.355 -1.7452,0 -7.39486,5.53003 -14.44969,9.42373 -6.78107,3.74261 -14.62665,7.57487 -16.7466,7.70943 -3.00201,0.19054 -8.73045,-7.55741 -15.26022,-14.69449 -6.59756,-7.21119 -12.77132,-11.92133 -12.77132,-16.0358 0,-2.13932 5.33773,-3.74931 11.93838,-8.98264 8.08967,-6.41389 19.2132,-14.428 19.95259,-17.18743 0.65521,-2.44529 -1.96637,-5.27359 -0.85205,-7.54671 0.48088,-0.98095 2.20014,-0.79077 2.79959,-1.7041 3.11177,-4.74117 5.49193,-15.94257 6.78125,-23.29122 3.28305,-18.71224 1.49579,-36.47391 1.49579,-36.47391 l 2.67787,0.24344 c 0,0 2.03081,17.72313 -1.47846,36.70232 -1.43142,7.74157 -3.68313,20.05531 -7.52891,24.64519 -0.41201,0.49173 -1.48438,0.0655 -1.82582,0.6086 -1.19727,1.90448 1.66593,4.5975 0.85205,6.69467 -1.60539,4.13671 -3.59063,5.96753 -8.03041,9.78138 -3.67694,3.15855 -9.61093,8.44192 -13.25457,10.65182 -5.57082,3.37874 -10.1191,4.44037 -10.1191,6.22375 0,2.24946 6.26658,7.88387 11.55209,13.90118 5.83778,6.64607 10.83836,13.60783 12.91388,13.60783 2.87126,0 8.65993,-3.36779 14.82404,-6.99333 7.6389,-4.49296 14.89636,-10.53454 17.18864,-10.53454 2.36648,0 6.59244,9.40259 13.37025,15.57456 6.23747,5.67994 10.87813,9.81477 14.26659,9.81477 2.43878,0 9.19684,-7.00762 17.11727,-12.24913 5.63247,-3.7274 16.70673,-10.60962 16.5221,-12.50459 -0.48425,-4.96987 -3.70299,-11.75918 -0.50345,-12.61649 2.71613,-0.72779 4.37245,5.80875 7.99362,5.80875 1.18239,0 6.33952,-9.71894 6.33952,-12.22871 0,-2.60891 -21.79199,-13.49454 -21.79199,-18.66327 0,-6.12202 1.94754,-6.41527 1.94754,-9.31168 0,-1.36529 -4.94425,-0.026 -5.23402,-3.65163 -0.27854,-3.48506 -0.38027,-10.20923 -0.49324,-15.08765 -0.23863,-10.30468 -0.11536,-19.11602 -0.11536,-19.11602 l 1.21721,-14.24139 2.06926,-2.55614 c 0,0 -0.53564,47.6682 0.73033,50.27087 0.97465,2.00377 4.99057,-0.52414 4.99057,3.40819 0,5.2266 -2.13012,4.82096 -2.13012,9.49427 0,4.23753 22.64015,15.15835 22.64015,18.86678 0,2.6438 -7.46836,16.26023 -9.34733,16.26023 z#000000m 386.76924,457.98474 c 15.81572,17.23035 20.18336,27.75245 22.82274,27.75245 2.40946,0 10.58975,-21.38961 10.58975,-29.15224 0,-6.73096 -16.55409,-11.56352 -16.55409,-11.56352 l -1.09549,3.28647 c 0,0 15.32211,2.59339 15.32211,8.61268 0,3.39833 -6.67324,24.00862 -8.62745,24.00862 -1.94438,0 -4.86162,-6.90788 -20.084,-24.52683 z#000000m 374.57627,475.88056 2.15175,-0.8607 c 2.49478,4.77176 9.14483,27.62844 11.87765,27.62844 1.25338,0 14.59718,-11.89315 18.33289,-20.57071 l 3.09852,2.23782 c -5.43655,7.9806 -18.53249,22.72246 -22.20604,22.72246 -2.77576,0 -10.31268,-20.17816 -13.25477,-31.15731 z#000000m 356.7598,489.90996 c 0.34657,14.52929 0.32652,26.50953 2.84031,26.50953 5.67248,0 17.24265,-5.20727 27.71451,-11.70551 l 1.29105,1.63533 c -7.84202,6.53879 -25.29893,12.91049 -29.43591,12.91049 -4.40149,0 -4.14006,-7.87148 -4.73385,-27.71451 z#000000m 333.60699,476.39698 2.40996,3.09852 c -0.89076,14.23072 -5.09809,42.54169 -2.66817,42.69068 2.81889,0.17284 15.55655,-2.6595 24.09958,-5.1642 l 1.89354,1.89354 c -9.7276,3.359 -19.52336,5.74272 -27.54238,5.59454 -4.63846,-0.0857 1.18375,-32.03505 1.80747,-48.11308 z#000000m 310.87605,475.8169 c -1.83066,6.8258 -4.79068,16.72841 -7.08528,24.61912 -2.3308,8.01524 -3.71954,13.80982 -3.15407,15.92017 0.77141,2.87893 6.85145,1.21757 15.03685,3.61525 4.41194,1.29234 11.26186,1.508 15.89511,1.97781 l 0.32952,1.87624 c -3.3601,-0.46868 -10.60298,0.79963 -17.07868,-1.58311 -6.97743,-2.56736 -14.00915,-0.10939 -15.87213,-3.33616 -1.55579,-2.69471 -0.0705,-10.0921 2.44293,-19.39624 1.97195,-7.29978 4.60983,-16.13727 6.68616,-22.35414 z#000000m 288.47934,479.46854 1.82582,1.94754 c -4.97799,9.4234 -14.87087,21.84428 -14.87087,24.3799 0,3.34758 13.36518,9.5897 23.51308,9.94549 l 0.85205,3.04303 c -10.30463,-0.25821 -27.40816,-8.36791 -27.40816,-11.89303 0,-5.12364 9.58371,-16.20795 16.08808,-27.42293 z#000000m 275.5098,464.6054 c -8.73865,9.31072 -23.84137,24.56481 -23.84137,26.68168 0,4.2216 16.32964,14.81612 22.46425,17.55826 l -0.0861,-2.92638 c -6.2113,-2.66339 -19.27966,-12.09541 -19.27966,-14.37367 0,-1.96621 14.48042,-15.38985 22.29211,-24.78814 z#000000m 267.84958,453.41631 c -5.46019,-0.68666 -27.88666,11.70691 -27.88666,16.00901 0,1.47385 7.03221,10.49689 14.63189,19.96822 l 1.63533,-1.97961 c -5.26976,-6.98611 -12.82442,-15.51329 -12.82442,-18.07468 0,-2.25422 18.37097,-13.07324 24.01351,-13.51298 z#000000m 249.08634,463.05614 c 4.05476,6.32627 8.2092,12.50302 13.16869,17.4722 l -2.23782,2.66816 c -5.03287,-6.11096 -9.27964,-12.22193 -13.16869,-18.33289 z#000000m 259.93114,483.71292 c 5.66754,5.07559 11.80693,9.20747 18.16076,12.91049 l -1.11891,2.32389 c -7.25838,-3.88144 -13.75255,-8.16205 -19.02145,-13.08263 z#000000m 278.78046,497.82839 c 6.34256,4.32241 14.22041,6.72571 22.37817,8.77913 l -1.1189,2.92638 c -7.86915,-2.79432 -16.31443,-4.86848 -22.46425,-9.81197 z#000000m 301.50291,506.60752 c 10.17086,3.9213 20.18229,4.81319 30.12447,4.38957 l -0.34428,3.35672 c -9.02847,-0.74075 -16.87813,-0.24654 -30.46875,-5.76668 z#000000m 332.22987,511.42744 c 7.91843,-0.52074 15.83687,-2.16096 23.7553,-4.04529 l 0.51642,2.92638 c -8.3883,1.55305 -16.71431,2.91922 -24.87421,3.78707 z#000000m 356.32945,507.21001 c 11.48527,-2.07751 19.04528,-6.45127 26.07918,-11.36123 l 1.7214,3.09852 c -7.85107,4.82714 -16.25257,9.14316 -27.28416,11.01695 z#000000m 383.69968,495.76271 c 8.14024,-5.69978 13.40544,-13.19646 17.90255,-21.1732 l 2.06567,2.5821 c -3.73941,7.74308 -10.29315,14.95009 -18.84931,21.77569 z#000000m 402.54899,474.50344 c 4.88229,-8.95376 9.84974,-17.95011 9.81198,-24.44385 l 2.75423,1.11891 c -1.24312,9.11387 -6.01102,17.34655 -10.84481,25.56276 z#000000m 306.92532,424.66896 c 8.20172,5.33995 20.21973,7.89823 31.60422,10.05541 -9.10736,0.36189 -29.24628,-4.98873 -31.60422,-10.05541 z#000000m 385.61289,354.09566 4.16194,0.20272 c -5.70226,6.04504 -11.83037,9.86498 -11.83037,11.96941 0,5.25206 -1.31838,28.23932 -13.26762,28.23932 -9.53857,0 -13.71275,-18.24618 -12.90245,-41.99382 l 2.79959,0.85204 c -0.51522,23.24137 4.11444,38.25951 10.10286,38.22047 9.35915,-0.061 10.08198,-20.04026 10.08198,-25.4102 0,-4.21862 5.75756,-5.17792 10.85407,-12.07994 z#000000m 501.9375,304.71875 c -3.05781,0.12604 -6.50239,0.79133 -10.34375,3.375 -10.57046,7.10961 -23.88725,18.8125 -28.03125,18.8125 -13.61104,0 -52.62424,4.1046 -79,4.96875 -17.5059,0.57353 -34.0581,-0.16453 -51.46875,-0.0312 -3.87007,0.0296 -7.78008,0.0632 -11.6875,0.125 l -0.6875,2.15625 c 4.24337,-0.0873 8.49287,-0.15898 12.71875,-0.1875 16.62106,-0.11217 32.89072,1.16992 49.5,0.5625 27.38661,-1.00156 65.81102,-4.84375 80.65625,-4.84375 7.92199,0 27.83509,-22.34375 39.3125,-22.34375 6.31336,0 11.71875,6.8724 11.71875,14.28125 0,9.74198 -28.72611,19.58365 -46,20.6875 21.84959,7.56508 43.09162,17.00065 59.875,25.5625 16.14148,8.23439 28.25,15.58879 28.25,22.875 0,8.26997 -8.95374,22.40625 -19,22.40625 -10.1627,0 -20.67914,-12.90357 -34.46875,-25.03125 -15.60494,-13.72424 -36.21314,-30.05522 -50.46875,-33.875 -3.81308,-1.02171 -27.32501,-1.34571 -52.21875,-1.71875 -16.78702,-0.25155 -33.86702,-0.78923 -47.21875,-0.5625 -28.54836,0.48477 -58.07714,2.03125 -81.09375,2.03125 -7.85551,0 -35.03125,2.73369 -35.03125,-7.75 0.3672,-8.68555 9.85842,-10.75 22.75,-10.75 4.8326,0 9.6764,-0.0689 14.53125,-0.15625 l -0.59375,-2.46875 c -4.57092,0.055 -9.12432,0.125 -13.65625,0.125 -7.6447,0 -25.46875,-1.09178 -25.46875,13.40625 0,12.11891 13.79243,9.96875 37.375,9.96875 21.26912,0 48.92668,-1.26109 75.8125,-1.46875 48.7184,-0.3763 95.70662,0.45364 103.34375,2.5 17.74073,4.75362 35.0506,20.04945 50.5625,34.03125 13.99231,12.6121 24.62924,25 36.03125,25 9.9157,0 21.8125,-15.2755 21.8125,-27.21875 0,-15.66649 -58.03462,-36.16161 -77.40625,-46.46875 10.9255,-2.60648 34.96875,-8.35896 34.96875,-20.65625 0,-10.73215 -6.28291,-17.34375 -14.09375,-17.34375 -0.42168,0 -0.84442,-0.018 -1.28125,0 z#000000m 541.17264,409.72227 c -3.91602,-1.17614 -5.11229,-1.13155 -5.11229,-4.86885 0,-5.67922 7.0103,-16.91925 14.11966,-16.91925 1.98945,0 1.76361,1.56905 1.52152,3.71249 2.26925,-2.09021 0.66324,-4.99057 -1.52151,-4.99057 -8.5754,0 -15.58033,12.29569 -15.58033,18.92766 0,3.75229 1.24986,5.04116 6.57295,4.13852 z#000000m 364.29091,395.6634 c 0,0 1.49582,7.15552 1.49582,9.54983 0,3.38733 -1.88313,9.59628 -1.88313,12.82835 0,3.51628 4.1987,8.03431 8.79976,15.48157 1.66791,2.69966 5.59294,8.46603 6.34855,11.45831 -3.20494,-5.00454 -4.86974,-7.62579 -6.727,-10.24882 -6.02894,-8.51474 -9.10987,-12.37188 -9.10987,-16.51892 0,-4.9997 1.70053,-8.03659 1.70053,-12.69599 0,-3.36296 -0.62466,-9.85433 -0.62466,-9.85433 z#000000m 357.23318,422.21597 c 4.02135,-1.98682 7.88398,-4.21173 11.4473,-6.88559 -4.10703,1.65441 -7.91404,3.96888 -11.4473,6.88559 z#000000m 321.64327,359.3419 c 0.48795,1.82107 2.68424,7.18683 4.47564,7.18683 1.53816,0 4.09259,-5.95169 5.33633,-8.9943 l 4.64778,-0.94677 c -2.21722,2.677 -6.67042,8.32336 -6.67042,10.28536 0,0.89002 3.5043,2.45423 5.25657,3.73022 2.54006,1.84966 4.34758,3.88696 5.33003,3.88696 0.98164,0 2.2534,-4.31602 4.13334,-9.58706 1.31767,-3.69454 3.24063,-8.01152 4.25848,-10.98365 l 3.52886,0.17214 c -1.47289,3.54324 -3.62271,7.76813 -5.24469,11.84516 -2.48763,6.25293 -4.43199,11.86711 -6.24564,11.86711 -2.0822,0 -4.36915,-2.51591 -7.01376,-4.83315 -2.58543,-2.26539 -5.3596,-3.85992 -7.14474,-3.85992 -1.21208,0 -3.7344,1.90914 -5.87485,4.28793 -2.05946,2.28877 -3.73344,5.05066 -5.1421,5.05066 -2.18229,0 -2.58,-8.90647 -2.92638,-19.4518 l 2.92638,0.086 c -0.0196,4.69846 -0.36226,14.15849 1.11891,14.15849 1.07961,0 2.65136,-1.96047 3.61424,-2.92336 1.35205,-1.35204 2.62583,-2.44071 2.62583,-3.35973 0,-1.23985 -3.43413,-4.84577 -4.00225,-8.13361 z#000000m 322.62748,370.41358 c 0,0 -1.27893,5.47389 -0.19481,6.67349 0.71687,0.79323 8.40016,0.93177 8.9365,0.15734 0.66776,-0.96419 1.7214,-5.59455 1.7214,-5.59455 l 3.09852,2.32389 c 0,0 -2.37238,4.01136 -3.55229,5.41017 -0.83978,0.99558 -11.09275,1.32169 -11.90032,0.23911 -1.46067,-1.95806 -1.33102,-6.59605 -1.33102,-6.59605 z#000000m 321.95268,379.17024 c -2.15913,9.07663 -10.94565,20.82022 -11.07663,24.34425 -0.0535,1.43972 3.84563,8.31009 7.00952,13.4994 1.77715,2.91482 2.96884,5.71167 3.96016,5.71167 1.34498,0 4.26183,-3.54904 7.72709,-6.82886 3.33321,-3.15482 6.98641,-6.31475 6.98641,-9.94779 0,-7.28864 -6.28639,-19.52688 -6.57294,-26.77867 l 2.3127,-0.73033 c 0.9004,7.79336 6.81639,22.13484 6.81639,27.38728 0,5.2109 -4.39329,8.57395 -8.19883,12.36483 -4.16933,4.15327 -7.87859,7.8763 -9.69419,7.59745 -2.06523,-0.31719 -3.12014,-3.49845 -5.57253,-7.28407 -3.7335,-5.76321 -8.18668,-12.85195 -7.69509,-14.99091 0.70832,-3.08195 9.44823,-18.15186 12.53729,-26.41351 z#000000m 467.0666,221.9616 c -0.77903,0.27169 -1.46375,0.84304 -2.11759,1.47176 -34.6979,33.36534 -44.2692,51.87533 -60.60526,71.97289 l 0,4.65625 c 17.60239,-20.94232 26.44104,-39.06574 61.08947,-73.34455 0.72946,-0.72168 1.34009,-1.65158 2.35213,-1.75635 1.01205,-0.10478 1.45525,0.73609 2.23733,1.3406 21.80627,16.85514 38.33746,44.56702 46.15003,68.52657 0.29902,0.91701 0.69398,1.61573 0.5573,2.43249 -0.13669,0.81675 -0.72725,1.29151 -1.2605,1.78134 -2.72674,2.50471 -5.78557,4.92052 -9.18826,7.30115 L 508.625,307.75 c 3.40565,-2.4744 6.52178,-4.98767 9.31608,-7.52979 0.66289,-0.60308 1.36443,-1.18359 1.63268,-2.1152 0.26824,-0.93162 -0.0247,-1.81814 -0.23291,-2.88422 -6.11373,-31.30601 -37.71273,-65.93071 -49.85755,-72.62806 -0.98438,-0.54285 -1.63766,-0.90282 -2.4167,-0.63113 z m -82.1916,94.38215 c -2.28395,2.16204 -4.70596,4.3899 -7.31585,6.69191 -0.79355,0.69993 -1.32615,1.16266 -1.61649,2.07756 -0.29033,0.91489 -0.0686,1.51619 0.32235,2.24816 1.12844,2.11282 2.34646,4.20019 3.64124,6.26362 l 4.1875,-0.6875 c -0.98197,-1.49323 -1.9951,-3.07401 -3.12004,-4.84133 -0.51709,-0.81236 -0.92454,-1.58377 -0.8123,-2.60795 0.11225,-1.02419 0.6533,-1.2715 1.36702,-1.92133 1.50781,-1.37281 2.95274,-2.72172 4.34657,-4.03564 z m 11.28125,37.4375 c 1.81311,1.74941 3.64828,3.37814 5.4912,4.86938 0.75197,0.60848 1.58195,1.0638 2.60308,1.1101 1.02113,0.0463 1.67938,-0.32783 2.74139,-0.82723 2.65751,-1.24967 5.51566,-2.55189 8.50808,-3.90225 l -5.71875,-0.375 c -0.74492,0.35727 -1.48286,0.70962 -2.22313,1.06339 -1.00723,0.48135 -1.67712,0.91656 -2.71384,0.82234 -1.03672,-0.0942 -1.5952,-0.61044 -2.17301,-1.19508 -0.4049,-0.40969 -0.80098,-0.81213 -1.20252,-1.2219 z#000000m 459.98457,231.1572 c 33.73254,18.64689 41.01287,55.04132 46.25407,75.34545 l -2.79959,-0.6086 c -7.30842,-26.05981 -15.27965,-54.99767 -45.40202,-73.39791 z#000000m 375.14487,333.88994 3.89508,-4.13853 -1.58238,-2.79959 -4.86885,4.74713 1.33893,2.31271 z#000000m 388.04732,354.70427 c 0,0 6.01666,6.84429 8.27704,6.93811 1.80665,0.075 6.20779,-4.38197 6.20779,-4.38197 l 2.79959,1.94754 c 0,0 -6.40548,5.59918 -9.1291,5.59918 -2.19478,0 -10.58975,-7.79016 -10.58975,-7.79016 z#000000m 479.40943,231.35593 c 0,0 -0.25085,-16.18114 10.50053,-16.18114 5.57059,0 11.98931,5.47632 12.56621,11.01695 0.17827,1.71214 -1.49884,3.88791 -3.22024,3.88791 -1.70564,0 -3.85848,-1.21162 -5.80611,-2.33608 -2.51514,-1.45212 -3.25244,-2.92899 -4.25795,-1.76394 -1.00552,1.16504 0.85937,2.32236 3.08658,3.9799 2.03554,1.5149 5.17355,2.9752 7.25046,2.9752 2.9253,0 5.35721,-3.93911 5.35721,-6.91513 0,-5.72163 -7.90239,-14.14501 -15.0057,-14.14501 -12.77567,0 -12.88095,18.62064 -12.88095,18.62064 z#000000m 495.52718,231.15721 c -0.49402,0.67385 -0.60861,1.22719 -0.60861,2.3127 0,3.72979 3.69524,6.98326 6.64898,8.65644 6.86789,3.8904 12.87102,9.84519 19.76453,9.84519 7.60137,0 15.82376,-17.19737 15.82376,-23.4922 0,-5.84691 -16.43963,-27.62455 -30.55203,-31.28236 -1.28853,-0.33398 -1.80329,0.31556 -2.67787,1.46066 l -2.37356,-2.13012 c 1.10243,-0.86887 2.73098,-1.82582 4.86885,-1.82582 9.84379,0 33.04731,22.09042 33.04731,33.77764 0,6.37402 -7.47405,26.04834 -18.19732,26.04834 -7.46103,0 -18.53724,-8.49031 -25.38401,-13.23411 -2.86653,-1.98608 -3.40307,-6.20853 -3.40307,-7.94538 0,-1.34457 0.44011,-2.51557 1.21722,-3.77336 z#000000m 503.89758,196.87217 c 0,0 3.91492,1.64217 3.91492,4.96178 0,6.35165 -8.0045,16.52542 -8.0045,16.52542 l -2.23782,-1.9796 c 0,0 6.84876,-6.72191 7.22987,-14.20154 0.0324,-0.6362 -0.90247,-5.30606 -0.90247,-5.30606 z#000000m 519.38454,253.43219 c -2.27354,7.09841 -9.65136,6.94336 -16.06721,8.15533 l 1.7311,2.40489 c 8.23646,-1.25602 15.52973,-3.29212 16.84184,-10.27501 z#000000m 484.96875,215.25 3.71875,-1.28125 c -6.90455,-7.10093 -14.22188,-14.6095 -22.71875,-23.125 -13.52559,-13.55524 -35.70202,-33.66951 -55.82105,-48.5732 -5.81406,-4.30692 -11.80057,-7.31799 -17.01257,-10.47058 -6.24648,-3.77833 -11.5307,-7.38435 -16.09636,-8.60771 -12.14844,-3.25517 -31.41762,-2.25815 -43.09292,-0.6685 -15.26367,2.07822 -21.69874,5.53556 -24.28701,5.53556 -3.31206,0 -4.99058,-5.02549 -4.99058,-14.11967 0,-3.98884 -1.53725,-8.9323 1.46066,-11.56352 7.38337,-6.480281 38.52463,-10.55366 58.30448,-12.537285 1.66103,-0.166576 3.42501,0.006 5.14658,0.153639 1.79347,0.153764 3.21068,-0.645223 3.48571,-1.193864 0.27503,-0.548638 -0.41122,-1.930704 -1.32461,-3.437316 -5.96764,-9.843532 -9.37694,-19.340353 -9.37694,-43.845795 0,-4.665275 0.66403,-11.881744 2.77259,-14.220501 2.45797,-2.726307 5.57753,-2.642216 9.24827,-2.642216 5.33562,0 14.37176,6.429958 14.37176,10.533213 0,21.799923 8.68648,55.007465 16.57027,60.732701 8.25342,5.993654 16.07313,11.852364 23.61047,18.737544 13.80312,12.60883 27.25467,27.22562 39.71875,41.1875 13.0445,14.61206 23.74922,31.67537 36.25,45.59375 0.2388,0.26588 0.47852,0.51853 0.71875,0.78125 l -0.84375,-4.40625 -0.5,-1.84375 0.28125,0.21875 c -11.79708,-13.62956 -20.94393,-28.24199 -34.5,-43.46875 -12.97394,-14.57288 -26.2676,-28.74464 -40.75,-41.65625 -7.15931,-6.38279 -14.63742,-12.366647 -22.28034,-17.644489 -6.08019,-4.198692 -15.71314,-37.367064 -15.71314,-58.558984 0,-6.603653 -9.1006,-13.236041 -16.62897,-13.276267 -4.72691,-0.02526 -8.67993,1.453788 -12.4451,4.311712 -2.30627,1.750552 -2.44308,11.712201 -2.44308,16.4079 0,12.422854 0.32808,27.521265 7.14416,40.228853 0.71223,1.327839 1.61893,2.864535 1.28035,3.426038 -0.33859,0.561504 -1.04628,0.670318 -2.38524,0.635184 -0.67443,-0.0177 -1.41703,-0.04008 -2.25979,-0.04008 -9.64506,0 -52.70292,6.397525 -59.27824,13.511063 -3.34605,3.61993 -2.67788,8.61196 -2.67788,14.60655 0,6.71052 3.47659,16.76281 6.32951,16.79753 1.64247,0.02 11.62392,-2.99997 27.39302,-4.96116 12.61418,-1.56881 30.29559,-2.5841 40.28718,0.0931 4.14207,1.10987 8.50333,4.50234 14.71456,8.35537 4.99438,3.09818 11.54991,6.25077 17.37482,10.60359 26.63498,19.90373 59.58886,50.50578 77.24443,69.69156 z m 52.6875,16.3125 -1,4.03125 c 0.68459,1.09639 1.35033,2.21431 1.96875,3.375 4.21044,7.90236 10.34375,15.71231 10.34375,24.6875 0,2.81677 -4.92786,9.125 -8.15625,9.125 -1.83008,0 -4.99756,-9.03753 -15.5625,-20.84375 l -3.34375,1.125 c 9.06668,11.04246 15.68874,22.28125 18.78125,22.28125 5.29017,0 10.46875,-6.6455 10.46875,-11.9375 0,-9.87256 -6.2175,-18.58637 -10.75,-27.25 -0.83453,-1.59516 -1.77593,-3.10599 -2.75,-4.59375 z#000000m 421.57045,154.92585 c 2.869,4.5768 5.73799,8.38791 8.60699,16.009 0,0 -1.42034,3.39697 -1.7214,2.75424 -1.02435,-2.18686 -14.38086,-25.34767 -14.28761,-24.78814 z#000000m 448.5964,177.47616 c -1.09549,10.17976 -5.2404,16.90451 -5.24414,19.20837 -0.01,5.97441 6.20883,27.09179 9.54764,40.35202 l -2.06568,2.92637 c -5.00553,-13.72498 -10.63578,-37.97576 -10.84481,-43.72351 -0.0705,-1.93898 4.24241,-11.04458 6.36917,-20.14036 z#000000m 432.84074,163.4802 c -1.34328,11.27206 -9.1291,31.83126 -9.1291,37.97702 0,6.49839 13.66599,29.67395 20.57089,45.40203 l -2.43442,2.19098 c -7.75457,-18.30577 -21.16183,-37.76897 -21.05778,-47.59301 0.11448,-10.80892 5.54043,-16.03603 9.49426,-39.07251 z#000000m 437.75159,238.06938 c -0.0268,7.11051 -0.61824,13.88224 -2.92638,19.62395 l 4.13136,-4.3035 c 1.47051,-4.10932 1.79801,-7.7798 1.89354,-11.36123 z#000000m 405.21001,209.24738 c 9.7274,22.56975 16.55409,39.77396 16.55409,50.75776 0,2.57256 2.5809,6.26099 5.23402,8.27705 l -1.94754,2.43442 c -3.03688,-2.87042 -6.27493,-7.36443 -6.45123,-10.83319 -0.48512,-9.54464 -7.09419,-28.7342 -12.41557,-41.50694 z#000000m 406.79239,249.41539 c 4.33296,-0.18016 8.60026,0.13203 12.29385,4.74713 l -0.73033,-4.38196 c -2.62571,-1.77365 -4.70938,-3.95383 -11.07664,-2.92131 z#000000m 406.54895,262.56129 c 4.20465,-0.6642 8.27192,-1.46578 14.3631,-0.24344 l 1.33894,2.55614 c -4.93459,-0.65807 -10.00205,-0.91589 -15.58032,0.36516 z#000000m 405.45346,284.59283 c 0,0 4.80798,-6.45123 5.90347,-6.08606 1.0955,0.36516 0.42603,8.64221 0.42603,8.64221 l 3.16475,-3.52992 c 0,0 0.0812,-7.89928 -2.0084,-8.88565 -2.08961,-0.98636 -7.24241,5.59918 -7.24241,5.59918 z#000000m 466.15466,362.01006 c 3.19923,26.33245 3.71863,64.39733 2.7468,78.73861 -2.79763,41.28461 11.46608,104.38145 16.61197,122.86304 0.80181,2.87972 1.09227,4.28624 2.06831,4.28624 0.97605,0 1.85005,-1.48736 2.96453,-2.65183 43.54284,-45.49597 63.22587,-85.68975 72.23254,-123.51101 0.68923,-2.89424 1.33028,-3.07654 2.06861,-3.04318 0.73833,0.0334 1.54144,0.24766 2.38019,3.13729 10.01082,34.48884 17.72566,65.50146 20.0174,83.44393 0.3633,2.84428 0.43409,5.53642 1.15547,5.74433 0.72139,0.20792 1.09714,-2.8716 1.84102,-5.55099 2.30784,-8.31262 4.15734,-18.77878 4.15734,-29.87592 0,-69.16011 -53.45009,-119.81074 -78.4225,-195.66086 l 2.67787,-2.3127 c 27.11887,78.73308 78.5102,129.91128 78.5102,198.04046 0,14.85947 -3.42589,31.0045 -8.22618,43.99853 -1.35617,3.67106 -2.66532,7.96757 -3.68189,7.60247 -1.01658,-0.36509 -0.39333,-4.61478 -0.4714,-8.32858 -0.55347,-26.32961 -8.15539,-56.84425 -18.67951,-89.09393 -0.48941,-1.49973 -0.79073,-2.6151 -1.21291,-2.59311 -0.42217,0.022 -0.8003,1.06267 -1.10511,2.55776 -7.83243,38.4178 -33.91467,79.11684 -73.56067,121.51135 -1.38154,1.47731 -2.31983,2.36791 -3.46349,2.36882 -1.14367,9.1e-4 -1.86415,-1.05219 -2.47775,-2.853 -7.42803,-21.79997 -18.97634,-66.92927 -18.62374,-130.81056 0.11887,-21.53784 1.38221,-45.10044 -2.0892,-79.21214 z#000000'! !!RSSVGAnimatioinExamples methodsFor: 'data - svg'!puzzlePiece	^ 'M3.739,13.619c0,0,3.516-4.669,5.592-3.642c2.077,1.027-0.414,2.795,1.598,3.719c2.011,0.924,5.048-0.229,4.376-2.899c-0.672-2.67-1.866-0.776-2.798-2.208c-0.934-1.432,4.586-4.59,4.586-4.59s3.361,6.651,4.316,4.911c1.157-2.105,3.193-4.265,5.305-1.025c0,0,1.814,2.412,0.246,3.434s-2.917,0.443-3.506,1.553c-0.586,1.112,3.784,4.093,3.784,4.093s-2.987,4.81-4.926,3.548c-1.939-1.262,0.356-3.364-2.599-3.989c-1.288-0.23-3.438,0.538-3.818,2.34c-0.13,2.709,1.604,2.016,2.797,3.475c1.191,1.457-4.484,4.522-4.484,4.522s-1.584-3.923-3.811-4.657c-2.227-0.735-0.893,2.135-2.917,2.531c-2.024,0.396-4.816-2.399-3.46-4.789c1.358-2.391,3.275-0.044,3.441-1.951C7.629,16.087,3.739,13.619,3.739,13.619z'! !!RSSVGAnimatioinExamples methodsFor: 'data - svg'!supermarketCart	^ 'M29.02,11.754L8.416,9.473L7.16,4.716C7.071,4.389,6.772,4.158,6.433,4.158H3.341C3.114,3.866,2.775,3.667,2.377,3.667c-0.686,0-1.242,0.556-1.242,1.242c0,0.686,0.556,1.242,1.242,1.242c0.399,0,0.738-0.201,0.965-0.493h2.512l5.23,19.8c-0.548,0.589-0.891,1.373-0.891,2.242c0,1.821,1.473,3.293,3.293,3.293c1.82,0,3.294-1.472,3.297-3.293c0-0.257-0.036-0.504-0.093-0.743h5.533c-0.056,0.239-0.092,0.486-0.092,0.743c0,1.821,1.475,3.293,3.295,3.293s3.295-1.472,3.295-3.293c0-1.82-1.473-3.295-3.295-3.297c-0.951,0.001-1.801,0.409-2.402,1.053h-7.136c-0.601-0.644-1.451-1.052-2.402-1.053c-0.379,0-0.738,0.078-1.077,0.196l-0.181-0.685H26.81c1.157-0.027,2.138-0.83,2.391-1.959l1.574-7.799c0.028-0.145,0.041-0.282,0.039-0.414C30.823,12.733,30.051,11.86,29.02,11.754zM25.428,27.994c-0.163,0-0.295-0.132-0.297-0.295c0.002-0.165,0.134-0.297,0.297-0.297s0.295,0.132,0.297,0.297C25.723,27.862,25.591,27.994,25.428,27.994zM27.208,20.499l0.948-0.948l-0.318,1.578L27.208,20.499zM12.755,11.463l1.036,1.036l-1.292,1.292l-1.292-1.292l1.087-1.087L12.755,11.463zM17.253,11.961l0.538,0.538l-1.292,1.292l-1.292-1.292l0.688-0.688L17.253,11.961zM9.631,14.075l0.868-0.868l1.292,1.292l-1.292,1.292l-0.564-0.564L9.631,14.075zM9.335,12.956l-0.328-1.24L9.792,12.5L9.335,12.956zM21.791,16.499l-1.292,1.292l-1.292-1.292l1.292-1.292L21.791,16.499zM21.207,14.5l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,14.5zM18.5,15.791l-1.293-1.292l1.292-1.292l1.292,1.292L18.5,15.791zM17.791,16.499L16.5,17.791l-1.292-1.292l1.292-1.292L17.791,16.499zM14.499,15.791l-1.292-1.292l1.292-1.292l1.292,1.292L14.499,15.791zM13.791,16.499l-1.292,1.291l-1.292-1.291l1.292-1.292L13.791,16.499zM10.499,17.207l1.292,1.292l-0.785,0.784l-0.54-2.044L10.499,17.207zM11.302,20.404l1.197-1.197l1.292,1.292L12.5,21.791l-1.131-1.13L11.302,20.404zM13.208,18.499l1.291-1.292l1.292,1.292L14.5,19.791L13.208,18.499zM16.5,19.207l1.292,1.292L16.5,21.79l-1.292-1.291L16.5,19.207zM17.208,18.499l1.292-1.292l1.291,1.292L18.5,19.79L17.208,18.499zM20.499,19.207l1.292,1.292L20.5,21.79l-1.292-1.292L20.499,19.207zM21.207,18.499l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,18.499zM23.207,16.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,16.499zM25.207,14.499l1.292-1.292L27.79,14.5l-1.291,1.292L25.207,14.499zM24.499,13.792l-1.156-1.156l2.082,0.23L24.499,13.792zM21.791,12.5l-1.292,1.292L19.207,12.5l0.29-0.29l2.253,0.25L21.791,12.5zM14.5,11.791l-0.152-0.152l0.273,0.03L14.5,11.791zM10.5,11.792l-0.65-0.65l1.171,0.129L10.5,11.792zM14.5,21.207l1.205,1.205h-2.409L14.5,21.207zM18.499,21.207l1.206,1.206h-2.412L18.499,21.207zM22.499,21.207l1.208,1.207l-2.414-0.001L22.499,21.207zM23.207,20.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,20.499zM25.207,18.499l1.292-1.291l1.291,1.291l-1.291,1.292L25.207,18.499zM28.499,17.791l-1.291-1.292l1.291-1.291l0.444,0.444l-0.429,2.124L28.499,17.791zM29.001,13.289l-0.502,0.502l-0.658-0.658l1.016,0.112C28.911,13.253,28.956,13.271,29.001,13.289zM13.487,27.994c-0.161,0-0.295-0.132-0.295-0.295c0-0.165,0.134-0.297,0.295-0.297c0.163,0,0.296,0.132,0.296,0.297C13.783,27.862,13.651,27.994,13.487,27.994zM26.81,22.414h-1.517l1.207-1.207l0.93,0.93C27.243,22.306,27.007,22.428,26.81,22.414z'! !"Roassal3-SVG-Examples"!!TestCoverage commentStamp: '' prior: 0!I wrap a method in order to detect whether it has been called or not. Then I can be used to calculate test coverage for SUnit.!!TestCoverage class methodsFor: 'instance creation'!on: aMethodReference	^ self new initializeOn: aMethodReference! !!TestCoverage methodsFor: 'private'!doesNotUnderstand: aMessage	^ method perform: aMessage selector withArguments: aMessage arguments! !!TestCoverage methodsFor: 'testing'!hasRun	^ hasRun! !!TestCoverage methodsFor: 'initialization'!initializeOn: aMethodReference	hasRun := false.	reference := aMethodReference.	method := reference compiledMethod! !!TestCoverage methodsFor: 'actions'!install	reference actualClass methodDict		at: reference selector		put: self! !!TestCoverage methodsFor: 'private'!mark	hasRun := true! !!TestCoverage methodsFor: 'private'!reference	^ reference! !!TestCoverage methodsFor: 'evaluation'!run: aSelector with: anArray in: aReceiver	self mark; uninstall.	^ aReceiver withArgs: anArray executeMethod: method! !!TestCoverage methodsFor: 'actions'!uninstall	reference actualClass methodDict		at: reference selector		put: method! !"TestCoverage"!!ManifestMuTalkModel commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!CompiledMethod methodsFor: '*MuTalk-Model'!ignoredMutationOperators	^ (self pragmaAt: #ignoreForMutations:)		ifNil: [ Array new ] 		ifNotNil: [ :aPragma |			aPragma arguments first 				collect: [:each | Smalltalk globals at: each ifAbsent: [ nil ] ]				thenSelect: #notNil ]! !!ManifestMuTalkModel class methodsFor: 'code-critics'!ruleAssignmentInBlockRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#MutantEvaluation #value #false)) #'2017-05-23T23:10:24.213312+02:00') )! !!MethodWrapperForCoverage class methodsFor: 'instance creation'!on: aMethodReference for: aCoverageAnalysis	^ self new initializeOn: aMethodReference for: aCoverageAnalysis! !!MethodWrapperForCoverage methodsFor: 'initialization'!initializeOn: aMethodReference for: aCoverageAnalysis	self initializeOn: aMethodReference.	coverageAnalysis := aCoverageAnalysis.	tests := Set new! !!MethodWrapperForCoverage methodsFor: 'private'!mark	|currentTest|	super mark.	currentTest := coverageAnalysis currentTest.	currentTest ifNotNil: [tests add: currentTest]. 	! !!MethodWrapperForCoverage methodsFor: 'accessing'!run: aSelector with: anArray in: aReceiver	self mark.	^ aReceiver withArgs: anArray executeMethod: method! !!MethodWrapperForCoverage methodsFor: 'accessing'!tests	^tests! !!TestSuite methodsFor: '*MuTalk-Model'!runStoppingOnFirstFailOrError    | result |     result := TestResult new.    self resources do: [ :res |        res isAvailable ifFalse: [^res signalInitializationError]].    [self runStoppingOnFirstFailOrError: result] ensure: [self resources do: [:each | each reset]].    ^result! !!TestSuite methodsFor: '*MuTalk-Model'!runStoppingOnFirstFailOrError: aResult    self tests do: [:each |        self changed: each.        each run: aResult.        (aResult failuresSize > 0 or: [ aResult errorsSize > 0]) ifTrue: [ ^ self ]].! !!TestSuiteWrappedForCoverage class methodsFor: 'instance creation'!for: aCoverageAnalysis named: aString 	^self new initializeFor: aCoverageAnalysis named: aString.! !!TestSuiteWrappedForCoverage methodsFor: 'initialization'!initializeFor: aCoverageAnalysis named: aString	self name: aString.	coverageAnalysis := aCoverageAnalysis.! !!TestSuiteWrappedForCoverage methodsFor: 'running'!run: aResult 	self tests do: [:each |coverageAnalysis currentTest: each.								self changed: each.								each run: aResult.								coverageAnalysis currentTest: nil]				 displayingProgress: 'Analysing Coverage'.! !!TestResult methodsFor: '*MuTalk-Model'!concreteErrors    ^ errors! !!TestResult methodsFor: '*MuTalk-Model'!concreteFailures    ^ failures! !!TestResult methodsFor: '*MuTalk-Model'!concretePassed    ^ passed! !!TestResult methodsFor: '*MuTalk-Model'!errorsSize    ^ errors size! !!TestResult methodsFor: '*MuTalk-Model'!failuresSize    ^ failures size! !!Boolean methodsFor: '*MuTalk-Model'!bEqv: aBlock	^self eqv: aBlock value! !!Boolean methodsFor: '*MuTalk-Model'!bXor: aBlock	^self xor: aBlock value! !!Boolean methodsFor: '*MuTalk-Model'!nand: alternativeBlock 	^(self and: alternativeBlock) not! !!CoverageAnalysis class methodsFor: 'instance creation'!for: aCollectionOfClasses running: aCollectionOfTestCases	^self new initializeFor: aCollectionOfClasses running: aCollectionOfTestCases! !!CoverageAnalysis methodsFor: 'private'!addTestsFrom: aWrapper to: methodToTestDictionary 	aWrapper tests notEmpty		ifTrue: [(methodToTestDictionary				at: aWrapper reference compiledMethod				ifAbsentPut: [IdentitySet new])				addAll: aWrapper tests]! !!CoverageAnalysis methodsFor: 'private'!classesAndMetaclasses	classesAndMetaclasses isNil ifTrue:[		classesAndMetaclasses := (classes collect:[:aClass | aClass class]) asOrderedCollection.		classesAndMetaclasses addAll: classes.].	^classesAndMetaclasses.! !!CoverageAnalysis methodsFor: 'accessing'!currentTest	^ currentTest ! !!CoverageAnalysis methodsFor: 'private'!currentTest: aTestCase	currentTest := aTestCase.! !!CoverageAnalysis methodsFor: 'private'!flushMethodLookupCaches	Behavior flushCache.	! !!CoverageAnalysis methodsFor: 'initialize-release'!initializeFor: aCollectionOfClasses running: aCollectionOfTestCases 	classes := aCollectionOfClasses. 	testCases := aCollectionOfTestCases! !!CoverageAnalysis methodsFor: 'private'!installAll: wrappers 	wrappers do: [ :each | each install ]! !!CoverageAnalysis methodsFor: 'private'!methodReferences	^ self classesAndMetaclasses		inject: OrderedCollection new		into: [:methodReferences :aClass | 			methodReferences				addAll: (aClass selectors						collect: [:aSelector | RGMethodDefinition class: aClass selector: aSelector]).			methodReferences]! !!CoverageAnalysis methodsFor: 'private'!methodToTestDictionaryFrom: wrappers 	^ wrappers		inject: IdentityDictionary new		into: [:methodToTestDictionary :aWrapper | 			self addTestsFrom: aWrapper to: methodToTestDictionary.			methodToTestDictionary]! !!CoverageAnalysis methodsFor: 'private'!methodWrappersFor: methodReferences 	^ methodReferences collect: [ :each | MethodWrapperForCoverage on: each for: self ]! !!CoverageAnalysis methodsFor: 'accessing'!result	^result! !!CoverageAnalysis methodsFor: 'evaluating'!run	| wrappers methodReferences |	methodReferences := self methodReferences.	wrappers := self methodWrappersFor: methodReferences.	self runTestsInstalling: wrappers.	result := CoverageAnalysisResult from: (self methodToTestDictionaryFrom: wrappers) elapsedTime: testRunningElapsedTime! !!CoverageAnalysis methodsFor: 'private'!runTests	|suite|	testRunningElapsedTime := Time millisecondsToRun: 		[suite := TestSuiteWrappedForCoverage for:self named: 'Test Suite for Coverage'.		 suite addTests: testCases.	    suite run ].! !!CoverageAnalysis methodsFor: 'private'!runTestsInstalling: wrappers 	[self installAll: wrappers.	self flushMethodLookupCaches.	self runTests]		ensure: [self uninstallAll: wrappers]! !!CoverageAnalysis methodsFor: 'private'!uninstallAll: wrappers 	^ wrappers do: [ :each | each uninstall ]! !!CoverageAnalysisResult class methodsFor: 'instance creation'!from: aDictionaryOfMethodToTestCasesRelations 	^self new initializeFrom: aDictionaryOfMethodToTestCasesRelations.! !!CoverageAnalysisResult class methodsFor: 'instance creation'!from: aDictionaryOfMethodToTestCasesRelations elapsedTime: aTimeToRunTests	^self new initializeFrom: aDictionaryOfMethodToTestCasesRelations elapsedTime: aTimeToRunTests.! !!CoverageAnalysisResult methodsFor: 'accessing'!coveredMethods	^methodToTestDictionary keys asIdentitySet. "select:[:each | (methodToTestDictionary at:each) notEmpty]."! !!CoverageAnalysisResult methodsFor: 'initialize-release'!initializeFrom: aDictionaryOfMethodToTestCasesRelations 	methodToTestDictionary := aDictionaryOfMethodToTestCasesRelations! !!CoverageAnalysisResult methodsFor: 'initialize-release'!initializeFrom: aDictionaryOfMethodToTestCasesRelations elapsedTime: aTimeToRunTests	methodToTestDictionary := aDictionaryOfMethodToTestCasesRelations.	timeToRunTests := aTimeToRunTests.! !!CoverageAnalysisResult methodsFor: 'accessing'!testCasesThatCovers: aCompiledMethod 	^methodToTestDictionary at:aCompiledMethod ifAbsent:[OrderedCollection new.].! !!CoverageAnalysisResult methodsFor: 'accessing'!timeToRunTests	^timeToRunTests! !!MethodInstaller methodsFor: 'installing'!install: aMethod for: selector in: aClass 	aClass addSelectorSilently: selector withMethod: aMethod! !!MethodInstaller methodsFor: 'installing'!installFromSource: aSourceCode in: aClass 	"Install a SourceCode in aClass. Raise exception in case de installation is	not posible."	| selector |	[selector := aClass		compile: aSourceCode ] 		on: Error, SyntaxErrorNotification 		do: [ :error | MethodInstallerException signal ].		self install: (aClass>>selector) for: selector in: aClass.! !!MethodInstaller methodsFor: 'installing'!uninstall: aSelector from: aClass 	"Uninstall a method referenced by aSelector in aClass. Raise exception in	case de uninstall is	not posible."	[aClass basicRemoveSelector: aSelector]		on: Error		do: [:error | MethodInstallerException signal]! !!MethodMutation class methodsFor: 'instance creation'!for: aMethod using: anOperatorApplied result: aModifiedSource ofClass: aClass	^ self new		initializeFor: aMethod		using: anOperatorApplied		result: aModifiedSource		ofClass: aClass;		 yourself! !!MethodMutation methodsFor: 'initialize-release'!initializeFor: aMethod using: anOperatorApplied result: aModifiedSource ofClass: aClass	originalMethod := aMethod.	operator := anOperatorApplied.	modifiedSource := aModifiedSource.	originalClass := aClass! !!MethodMutation methodsFor: 'installing'!install	"Install the mutant compiling the modified source into the class."	MethodInstaller new installFromSource: modifiedSource in: originalClass! !!MethodMutation methodsFor: 'private'!lookUpForNodesFromChildrenOfMutated: aPossibleMutatedRBMethodNode comparingWithChildrenOfOriginal: anOriginalRBMethodNode 	| childrenOfMutatedMethod childrenOfOriginalMethod |	childrenOfMutatedMethod := aPossibleMutatedRBMethodNode children.	childrenOfOriginalMethod := anOriginalRBMethodNode children.	1 to: childrenOfMutatedMethod size do: 		[ :childNumber | 			self lookUpForNodesFromMutated:  (childrenOfMutatedMethod at: childNumber)				  comparingWithOriginal: (childrenOfOriginalMethod at: childNumber).			mutatedNode ifNotNil: [^self]]	! !!MethodMutation methodsFor: 'private'!lookUpForNodesFromMutated: aPossibleMutatedRBMethodNode comparingWithOriginal: anOriginalRBMethodNode 	(self operator 		isNodeOfMutation: aPossibleMutatedRBMethodNode		comparingWith: anOriginalRBMethodNode) ifTrue: 		[ nodeToMutate := anOriginalRBMethodNode.		mutatedNode := aPossibleMutatedRBMethodNode ].	aPossibleMutatedRBMethodNode children isEmpty ifTrue: [ ^ nil ].	^ self 		lookUpForNodesFromChildrenOfMutated: aPossibleMutatedRBMethodNode		comparingWithChildrenOfOriginal: anOriginalRBMethodNode! !!MethodMutation methodsFor: 'private'!lookupForNodes	self lookUpForNodesFromMutated: (RBParser parseMethod: self modifiedSource)		  comparingWithOriginal: (RBParser parseMethod: self originalSource ).! !!MethodMutation methodsFor: 'accessing'!modifiedSource	^ modifiedSource! !!MethodMutation methodsFor: 'accessing'!mutatedNode	mutatedNode ifNil:[self lookupForNodes ].	^mutatedNode. ! !!MethodMutation methodsFor: 'accessing'!mutatedNode: aNode	mutatedNode := aNode! !!MethodMutation methodsFor: 'accessing'!nodeToMutate	nodeToMutate ifNil: [ self lookupForNodes ].	^ nodeToMutate! !!MethodMutation methodsFor: 'accessing'!nodeToMutate: aNode	nodeToMutate := aNode! !!MethodMutation methodsFor: 'accessing'!operator	^operator! !!MethodMutation methodsFor: 'accessing'!originalClass	^ originalClass! !!MethodMutation methodsFor: 'accessing'!originalMethod	^originalMethod.! !!MethodMutation methodsFor: 'accessing'!originalSource	^ originalMethod sourceCode asString! !!MethodMutation methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: operator description;		 nextPutAll: ' in ';		 nextPutAll: originalClass printString;		nextPutAll: '>>';		nextPutAll: originalMethod  selector printString.! !!MethodMutation methodsFor: 'installing'!uninstall	"UnInstall the mutant recompiling the original method into the class."	MethodInstaller new install:originalMethod for: originalMethod selector in: originalClass ! !!MutantEvaluation class methodsFor: 'instance creation'!for: aMutation using:aCollectionOftestCases following: aMutantEvaluationStrategy 	^self for: aMutation using: aCollectionOftestCases following: aMutantEvaluationStrategy andConsidering:nil  ! !!MutantEvaluation class methodsFor: 'instance creation'!for: aMutation using: aCollectionOftestCases following: aMutantEvaluationStrategy and: aTestSelectionStrategy 	|tests|	tests := aTestSelectionStrategy testCasesFromReferencies: aCollectionOftestCases.	^self for: aMutation using: tests following: aMutantEvaluationStrategy andConsidering:nil! !!MutantEvaluation class methodsFor: 'instance creation'!for: aMutation using:aCollectionOftestCases following: aMutantEvaluationStrategy andConsidering: aCoverageAnalysisResult 	^self new initializeFor: aMutation using:aCollectionOftestCases following: aMutantEvaluationStrategy andConsidering: aCoverageAnalysisResult! !!MutantEvaluation methodsFor: 'accessing'!coverageAnalysisResult	^coverageAnalysisResult ! !!MutantEvaluation methodsFor: 'initialize-release'!initializeCoverageResultIfNil	coverageAnalysisResult 		ifNil:[ |coverageAnalysis|				coverageAnalysis := CoverageAnalysis for: (OrderedCollection with: mutation originalClass)															 running: testCases. 				coverageAnalysisResult := coverageAnalysis run;result].! !!MutantEvaluation methodsFor: 'initialize-release'!initializeFor: aMutation using:aCollectionOftestCases following: aMutantEvaluationStrategy andConsidering: aCoverageAnalysisResult	mutation := aMutation.	testCases := aCollectionOftestCases.	strategy := aMutantEvaluationStrategy.	coverageAnalysisResult := aCoverageAnalysisResult	! !!MutantEvaluation methodsFor: 'private'!runTests	"Collect all suite test and execute them."	| suite |	suite := TestSuite named: 'MutationEvaluation'.	suite addTests: ((strategy	testCasesToEvaluate: mutation									for: self) collect: [ :each | each testCase ]).	^ [ suite runStoppingOnFirstFailOrError ] 		on: Error		do: [ :ex | nil ]! !!MutantEvaluation methodsFor: 'accessing'!strategy	^strategy! !!MutantEvaluation methodsFor: 'accessing'!testCases	^testCases! !!MutantEvaluation methodsFor: 'private'!testResults 	^ [ self runTests ] valueWithin: (strategy timeoutForTestsOf: self) milliSeconds onTimeout: [ nil ]! !!MutantEvaluation methodsFor: 'evaluation'!value	| testResults |	Stdio stdout nextPutAll: mutation originalMethod name asString; lf; flush.	self initializeCoverageResultIfNil.	testResults := [ mutation install.	self testResults ]		ensure: [ mutation uninstall ].	^ MutantEvaluationResult		for: mutation		results: testResults		producedBy: self! !!MutantEvaluationResult class methodsFor: 'instance creation'!canHandle: aMutant withResults: aTestResult	self subclassResponsibility ! !!MutantEvaluationResult class methodsFor: 'instance creation'!for: aMutant results: aTestResult 	"This method is use for running tests. That's the reason why it sends nil as argument"	^ self 		for: aMutant		results: aTestResult		producedBy: nil! !!MutantEvaluationResult class methodsFor: 'instance creation'!for: aMutant results: aTestResult producedBy: aMutantEvaluation 	| handler |	handler := self subclasses 		detect: 			[ :class | 			class 				canHandle: aMutant				withResults: aTestResult ]		ifNone: [ self error: 'There are missing classes' ].	^ handler 		newFor: aMutant		results: aTestResult		producedBy: aMutantEvaluation! !!MutantEvaluationResult class methodsFor: 'instance creation'!newFor: aMutant results: aTestResult producedBy: aMutantEvaluation 	self subclassResponsibility! !!MutantEvaluationResult methodsFor: 'testing'!killed	self subclassResponsibility! !!MutantEvaluationResult methodsFor: 'accessing'!killingSuggestions 		self subclassResponsibility ! !!MutantEvaluationResult methodsFor: 'accessing'!mutant	^ mutant! !!MutantEvaluationResult methodsFor: 'accessing'!mutantEvaluation 	^mutantEvaluation! !!MutantEvaluationResult methodsFor: 'accessing'!particularResults 		self subclassResponsibility ! !!MutantEvaluationResult methodsFor: 'printing'!printDetailedResultOn: aStream 	self subclassResponsibility ! !!MutantEvaluationResult methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self mutant printString! !!MutantEvaluationResult methodsFor: 'browsing'!resultClass	self subclassResponsibility! !!MutantEvaluationResult methodsFor: 'accessing'!resultString 	self subclassResponsibility ! !!MutantEvaluationResult methodsFor: 'testing'!runCount	self subclassResponsibility! !!MutantEvaluationResult methodsFor: 'testing'!survived	self subclassResponsibility! !!MutantEvaluationResult methodsFor: 'testing'!terminated	self subclassResponsibility! !!MutantEvaluationResultKilled class methodsFor: 'instance creation'!canHandle: aMutant withResults: aTestResult 	^aTestResult notNil and:[aTestResult errorsSize + aTestResult failuresSize > 0]	! !!MutantEvaluationResultKilled class methodsFor: 'instance creation'!newFor: aMutant results: aTestResult producedBy: aMutantEvaluation 	^ self new		initializeFor: aMutant			results: aTestResult			producedBy: aMutantEvaluation;		yourself! !!MutantEvaluationResultKilled methodsFor: 'initialize-release'!initializeFor: aMutant results: aTestResult producedBy: aMutantEvaluation 	mutant := aMutant.	result := aTestResult.	mutantEvaluation := aMutantEvaluation! !!MutantEvaluationResultKilled methodsFor: 'testing'!killed		^true! !!MutantEvaluationResultKilled methodsFor: 'accessing'!killingSuggestions 		^'MUTANT KILLED'! !!MutantEvaluationResultKilled methodsFor: 'browsing'!particularResults		^result tests! !!MutantEvaluationResultKilled methodsFor: 'printing'!printDetailedResultOn: aStream 		aStream cr; nextPutAll: 'PASSED'; cr.		result passed do:		[:test | aStream nextPutAll: test printString; cr.].		aStream cr; nextPutAll: 'FAILURES'; cr.		result failures do:		[:test | aStream nextPutAll: test printString; cr.].		aStream cr; nextPutAll: 'ERRORS'; cr.		result errors do:		[:test | aStream nextPutAll: test printString; cr.].		aStream cr.! !!MutantEvaluationResultKilled methodsFor: 'accessing'!result	^result! !!MutantEvaluationResultKilled methodsFor: 'browsing'!resultClass		^result tests first class! !!MutantEvaluationResultKilled methodsFor: 'testing'!resultString		^result printString ! !!MutantEvaluationResultKilled methodsFor: 'testing'!runCount	^result runCount! !!MutantEvaluationResultKilled methodsFor: 'testing'!survived		^false! !!MutantEvaluationResultKilled methodsFor: 'testing'!terminated	^false! !!MutantEvaluationResultSurvived class methodsFor: 'instance creation'!canHandle: aMutant withResults: aTestResult 	^ aTestResult notNil		and: [aTestResult errorsSize + aTestResult failuresSize = 0]! !!MutantEvaluationResultSurvived class methodsFor: 'instance creation'!newFor: aMutant results: aTestResult producedBy: aMutantEvaluation 	^ self new		initializeFor: aMutant			results: aTestResult			producedBy: aMutantEvaluation;		yourself! !!MutantEvaluationResultSurvived methodsFor: 'initialize-release'!initializeFor: aMutant results: aTestResult producedBy: aMutantEvaluation 	mutant := aMutant.	result := aTestResult.	mutantEvaluation := aMutantEvaluation! !!MutantEvaluationResultSurvived methodsFor: 'testing'!killed	^false! !!MutantEvaluationResultSurvived methodsFor: 'accessing'!killingSuggestions	^ (MutantKillingSuggestionGenerator new suggestionFor: mutant)! !!MutantEvaluationResultSurvived methodsFor: 'testing'!particularResults	^result tests! !!MutantEvaluationResultSurvived methodsFor: 'printing'!printDetailedResultOn: aStream 		aStream cr; nextPutAll: 'PASSED'; cr.		result passed do:		[:test | aStream nextPutAll: test printString; cr.].		aStream cr; nextPutAll: 'FAILURES'; cr.		result failures do:		[:test | aStream nextPutAll: test printString; cr.].		aStream cr; nextPutAll: 'ERRORS'; cr.		result errors do:		[:test | aStream nextPutAll: test printString; cr.].		aStream cr.! !!MutantEvaluationResultSurvived methodsFor: 'accessing'!result	^result! !!MutantEvaluationResultSurvived methodsFor: 'browsing'!resultClass		^result tests isEmpty 		ifTrue: [mutant originalClass] 		ifFalse: [result tests first class] ! !!MutantEvaluationResultSurvived methodsFor: 'testing'!resultString		^result printString! !!MutantEvaluationResultSurvived methodsFor: 'testing'!runCount	^result runCount! !!MutantEvaluationResultSurvived methodsFor: 'testing'!survived	^true! !!MutantEvaluationResultSurvived methodsFor: 'testing'!terminated	^false! !!MutantEvaluationResultTerminated class methodsFor: 'instance creation'!canHandle: aMutant withResults: aTestResult	^aTestResult isNil! !!MutantEvaluationResultTerminated class methodsFor: 'instance creation'!newFor: aMutant results: aTestResult producedBy: aMutantEvaluation 	^ self new		initializeFor: aMutant			producedBy: aMutantEvaluation;		yourself! !!MutantEvaluationResultTerminated methodsFor: 'initialize-release'!initializeFor: aMutation producedBy: aMutantEvaluation 	mutant := aMutation.	mutantEvaluation := aMutantEvaluation! !!MutantEvaluationResultTerminated methodsFor: 'testing'!killed	^false! !!MutantEvaluationResultTerminated methodsFor: 'accessing'!killingSuggestions 		^'MUTANT KILLED'! !!MutantEvaluationResultTerminated methodsFor: 'testing'!particularResults		^OrderedCollection new! !!MutantEvaluationResultTerminated methodsFor: 'printing'!printDetailedResultOn: aStream		aStream cr; nextPutAll: 'TEST EXECUTION TERMINATED'; cr.! !!MutantEvaluationResultTerminated methodsFor: 'accessing'!result	^nil! !!MutantEvaluationResultTerminated methodsFor: 'browsing'!resultClass		^mutant originalClass! !!MutantEvaluationResultTerminated methodsFor: 'testing'!resultString	^'Mutation TERMINATED'! !!MutantEvaluationResultTerminated methodsFor: 'testing'!runCount	^0! !!MutantEvaluationResultTerminated methodsFor: 'testing'!survived	^false! !!MutantEvaluationResultTerminated methodsFor: 'testing'!terminated	^true! !!AllTestsMethodsRunningMutantEvaluationStrategy methodsFor: 'private'!testCasesToEvaluate: aMutation for: aMutantEvaluation	^aMutantEvaluation testCases.	! !!MutantEvaluationStrategy methodsFor: 'evaluating'!testCasesToEvaluate: aMutation for: aMutantEvaluation	self subclassResponsibility! !!MutantEvaluationStrategy methodsFor: 'evaluating'!timeoutForTestsOf: aMutantEvaluation	^aMutantEvaluation coverageAnalysisResult timeToRunTests * 3! !!SelectingFromCoverageMutantEvaluationStrategy methodsFor: 'private'!testCasesToEvaluate: aMutation for: aMutantEvaluation  	^ aMutantEvaluation coverageAnalysisResult testCasesThatCovers: aMutation originalMethod! !!MutantKillingSuggestionGenerator methodsFor: 'evaluating'!suggestionFor: aMutation	^aMutation operator suggestionFor: aMutation using: self.! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByADoBlockWithEmptyBlockOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that there is an iteration doing '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' on each element of '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByARemoveCaretOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case to check that the method is returning '.		aStream nextPutAll: aMutation mutatedNode formattedCode asText allBold ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByARemoveExceptionHandlerOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that when an exception of kind '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is signaled, it is handled evaluating the block '.		aStream nextPutAll: aMutation nodeToMutate arguments second formattedCode asText allBold.]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceAndArgumentWithTrueOperator: aMutation 	^Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is true and '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is false' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceAndReceiverWithTrueMutantOperator: aMutation	^Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is false and '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is true' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceAndWithEqvMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where both conditions '.		aStream nextPutAll: aMutation mutatedNode receiver formattedCode asText allBold.		aStream nextPutAll: ' and '.		aStream nextPutAll: aMutation mutatedNode arguments first formattedCode asText allBold.		aStream nextPutAll: ' are false.' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceAndWithFalseOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where both conditions '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' and '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' are true.' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceAndWithOrMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where only one of the conditions '.		aStream nextPutAll: aMutation mutatedNode receiver formattedCode asText allBold.		aStream nextPutAll: ' and '.		aStream nextPutAll: aMutation mutatedNode arguments first formattedCode asText allBold.		aStream nextPutAll: ' is True.' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceGreaterOrEqualWithEqualMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is greater than '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold. ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceGreaterOrEqualWithGreaterMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is equal to '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold. ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceIfFalseReceiverWithFalseOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that when '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is true, '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is not evaluated'.]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceIfFalseReceiverWithTrueOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that when '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is false, '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is evaluated'.]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceIfTrueIfFalseReceiverWithFalseOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that when '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is true, '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is evaluated and '.		aStream nextPutAll: aMutation nodeToMutate arguments second formattedCode asText allBold.		aStream nextPutAll: ' is not']! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceIfTrueIfFalseReceiverWithTrueOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that when '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is false, '.		aStream nextPutAll: aMutation nodeToMutate arguments second formattedCode asText allBold.		aStream nextPutAll: ' is evaluated and '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is not']! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceIfTrueReceiverWithFalseOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that when '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is true, '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is evaluated'.]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceIfTrueReceiverWithTrueOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll:  'It is missing a test case to check that when '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is false, '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is not evaluated'.]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceLessOrEqualWithEqualMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is less than '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold. ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceLessOrEqualWithLessMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is equal to '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold. ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceLessOrEqualWithTrueOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is greater than '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold. ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceOrArgumentWithFalseOperator: aMutation 	^Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is false and '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is true' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceOrReceiverWithFalseOperator: aMutation 	^Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' is true and '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' is false' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceOrWithAndMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where only one of the conditions '.		aStream nextPutAll: aMutation mutatedNode receiver formattedCode asText allBold.		aStream nextPutAll: ' and '.		aStream nextPutAll: aMutation mutatedNode arguments first formattedCode asText allBold.		aStream nextPutAll: ' is True.' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceOrWithTrueOperator: aMutation 		^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where both conditions '.		aStream nextPutAll: aMutation nodeToMutate receiver formattedCode asText allBold.		aStream nextPutAll: ' and '.		aStream nextPutAll: aMutation nodeToMutate arguments first formattedCode asText allBold.		aStream nextPutAll: ' are false.' ]! !!MutantKillingSuggestionGenerator methodsFor: 'suggestions'!suggestionForMutationProducedByAReplaceOrWithXorMutantOperator: aMutation 	^ Text streamContents: 		[ :aStream | 		aStream nextPutAll: 'It is missing a test case where both conditions '.		aStream nextPutAll: aMutation mutatedNode receiver formattedCode asText allBold.		aStream nextPutAll: ' and '.		aStream nextPutAll: aMutation mutatedNode arguments first formattedCode asText allBold.		aStream nextPutAll: ' are true.' ]! !!MutantOperator class methodsFor: 'accessing'!allConcreteSubclasses	^ self allSubclasses reject: [:ea | ea isAbstract]! !!MutantOperator class methodsFor: 'accessing'!contents	^(self allConcreteSubclasses collect: [:class |class new]) 		asSortedCollection: [:elem1 :elem2 | elem1 description <= elem2 description]! !!MutantOperator class methodsFor: 'accessing'!isAbstract	^self subclasses isNotEmpty! !!MutantOperator methodsFor: 'printing'!description	self subclassResponsibility! !!MutantOperator methodsFor: 'applying'!expressionToReplace	self subclassResponsibility! !!MutantOperator methodsFor: 'private'!is: originalRBMethodNode equalTo: nodeThatMatches 	^ nodeThatMatches formattedCode = originalRBMethodNode formattedCode! !!MutantOperator methodsFor: 'private'!isAPosibleMutatedNode: aRBMethodNode 	|nodeThatMatches |		nodeThatMatches := (RBParseTreeSearcher treeMatching: self newExpression												  in: aRBMethodNode). 		^ nodeThatMatches notNil and: [self is: nodeThatMatches equalTo: aRBMethodNode]! !!MutantOperator methodsFor: 'private'!isAPosibleNodeToMutate: aRBMethodNode 	| nodeThatMatches |	nodeThatMatches := RBParseTreeSearcher treeMatching: self expressionToReplace												in: aRBMethodNode.		^ nodeThatMatches notNil and: [ self is: aRBMethodNode equalTo: nodeThatMatches ]! !!MutantOperator methodsFor: 'testing'!isNodeOfMutation: posibleMutatedRBMethodNode comparingWith: originalRBMethodNode 	^ (self isAPosibleNodeToMutate: originalRBMethodNode) 		and: [ self isAPosibleMutatedNode: posibleMutatedRBMethodNode ]! !!MutantOperator methodsFor: 'private'!modifiedSourceFor: aCompiledMethod number: aNumber 	"this method must be removed, it is only added because some tests send this message - Gabo"		^self modifiedSourceFor: aCompiledMethod with: aCompiledMethod parseTree number: aNumber ! !!MutantOperator methodsFor: 'private'!modifiedSourceFor: aCompiledMethod with: aParseTree number: aNumber 	| rewriter parser number nNode |	rewriter := RBParseTreeRewriter new.	number := aNumber.	parser := aParseTree copy.	rewriter 		replace: self expressionToReplace		withValueFrom: [ :oNode | 			nNode := RBParser parseRewriteExpression: self newExpression.			nNode := nNode copyInContext: rewriter context.			oldNode := oNode.			newNode := nNode.			newNode ]		when: 			[ :node | number := number - 1.						number = 0 ].	rewriter executeTree: parser.	^ rewriter tree formattedCode! !!MutantOperator methodsFor: 'private'!mutationFor: aCompiledMethod with: aParseTree number: aNumberOfSelector 	^ (MethodMutation		for: aCompiledMethod		using: self		result:		(self				modifiedSourceFor: aCompiledMethod				with: aParseTree				number: aNumberOfSelector)		ofClass: aCompiledMethod methodClass)		nodeToMutate: oldNode;		mutatedNode: newNode;		yourself! !!MutantOperator methodsFor: 'mutant generation'!mutationsFor: aCompiledMethod 	(aCompiledMethod ignoredMutationOperators includes: self class) ifTrue: [ ^ Array new ].	^self mutationsFor: aCompiledMethod with: aCompiledMethod parseTree.	! !!MutantOperator methodsFor: 'mutant generation'!mutationsFor: aCompiledMethod with: aParseTree 	| numberOfMutations |	numberOfMutations := ((aCompiledMethod hasPragmaNamed: #ignoreForMutations) or: [ aCompiledMethod hasPragmaNamed: #ignoreForCoverage ])		ifTrue: [ ^ Array new ]		ifFalse: [ self timesToApplyIn: aCompiledMethod with: aParseTree ].	^ (1 to: numberOfMutations)		collect: [:aNumberOfSelector | self				mutationFor: aCompiledMethod				with: aParseTree				number: aNumberOfSelector]! !!MutantOperator methodsFor: 'applying'!newExpression	self subclassResponsibility! !!MutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^'No Suggestion'! !!MutantOperator methodsFor: 'applying'!timesToApplyIn: aCompiledMethod 	^self timesToApplyIn: aCompiledMethod  with: aCompiledMethod parseTree.	! !!MutantOperator methodsFor: 'applying'!timesToApplyIn: aCompiledMethod with: aParseTree 	"Evaluates how many times can the operator be applyied"		|searcher timesToApply|	searcher := RBParseTreeSearcher new.	timesToApply := 0.	searcher matches:self expressionToReplace do:[:node :answer | timesToApply := timesToApply + 1].	searcher executeTree: aParseTree copy.	^timesToApply.	! !!RemoveAtIfAbsentOperator methodsFor: 'printing'!description	^'Remove at:ifAbsent:'! !!RemoveAtIfAbsentOperator methodsFor: 'applying'!expressionToReplace	^ '``@object at: ``@aBlock ifAbsent: ``@anotherBlock'! !!RemoveAtIfAbsentOperator methodsFor: 'applying'!newExpression	^ '``@anotherBlock value'! !!RemoveCaretOperator methodsFor: 'printing'!description	^'Remove ^'! !!RemoveCaretOperator methodsFor: 'applying'!expressionToReplace 	^'^``@object'! !!RemoveCaretOperator methodsFor: 'applying'!newExpression 	^'``@object'! !!RemoveCaretOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByARemoveCaretOperator: aMutation.! !!RemoveCaretOperator methodsFor: 'applying'!timesToApplyIn: aCompiledMethod with: aParseTree 	"ignore methods that contain only ^self"	(aParseTree statements asArray = { RBParseTreeSearcher treeMatching: '^ self' in: aParseTree })		ifTrue: [ ^ 0 ].		^ super timesToApplyIn: aCompiledMethod with: aParseTree ! !!RemoveExceptionHandlerOperator methodsFor: 'printing'!description	^'Remove Exception Handler Operator'! !!RemoveExceptionHandlerOperator methodsFor: 'applying'!expressionToReplace 	^'``@aBlock on: ``@anException do: ``@anotherBlock'! !!RemoveExceptionHandlerOperator methodsFor: 'applying'!newExpression 	^'``@aBlock value'! !!RemoveExceptionHandlerOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByARemoveExceptionHandlerOperator: aMutation.! !!RemoveInjectIntoOperator methodsFor: 'printing'!description	^'Replace inject:aValue into:aBlock with aValue'.! !!RemoveInjectIntoOperator methodsFor: 'applying'!expressionToReplace 	^'``@aCollection inject: ``@aValue into:``@aBlock'! !!RemoveInjectIntoOperator methodsFor: 'applying'!newExpression	^'``@aValue'! !!RemoveNotOperator methodsFor: 'printing'!description	^'Remove #not'.! !!RemoveNotOperator methodsFor: 'applying'!expressionToReplace 	^'``@aBoolean not'! !!RemoveNotOperator methodsFor: 'applying'!newExpression	^'``@aBoolean'! !!ReplaceAndArgumentWithTrueOperator methodsFor: 'printing'!description	^'Replace #and: argument with [true]'.! !!ReplaceAndArgumentWithTrueOperator methodsFor: 'applying'!expressionToReplace 	^'``@object and: ``@aBlock'! !!ReplaceAndArgumentWithTrueOperator methodsFor: 'applying'!newExpression 	^'``@object and: [true]'! !!ReplaceAndArgumentWithTrueOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceAndArgumentWithTrueOperator: aMutation.! !!ReplaceAndWithFalseOperator methodsFor: 'printing'!description	^'Replace #and: with false'.! !!ReplaceAndWithFalseOperator methodsFor: 'applying'!expressionToReplace 	^'``@object and: ``@aBlock'! !!ReplaceAndWithFalseOperator methodsFor: 'applying'!newExpression 	^'false'! !!ReplaceAndWithFalseOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceAndWithFalseOperator: aMutation.! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperator methodsFor: 'printing'!description	^'Replace detect: block with [:each | false] when #detect:ifNone: '! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@object detect: ``@aBlock ifNone: ``@anotherBlock'! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperator methodsFor: 'applying'!newExpression 	^'``@object detect: [:each | false] ifNone: ``@anotherBlock'! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperator methodsFor: 'printing'!description	^'Replace detect: block with [:each | true] when #detect:ifNone: '! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@object detect: ``@aBlock ifNone: ``@anotherBlock'! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!newExpression 	^'``@object detect: [:each | true] ifNone: ``@anotherBlock'! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperator methodsFor: 'printing'!description	^'Replace ifNone: block with [] when #detect:ifNone:'! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@object detect: ``@aBlock ifNone: ``@anotherBlock'! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperator methodsFor: 'applying'!newExpression 	^'``@object detect: ``@aBlock ifNone: []'! !!ReplaceDoBlockWithEmptyBlockOperator methodsFor: 'printing'!description	^'Replace do block with [:each |]'.! !!ReplaceDoBlockWithEmptyBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@collection do: ``@aBlock'! !!ReplaceDoBlockWithEmptyBlockOperator methodsFor: 'applying'!newExpression	^'``@collection do: [:each | ]'! !!ReplaceDoBlockWithEmptyBlockOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByADoBlockWithEmptyBlockOperator: aMutation.! !!ReplaceIdentityWithNegationOfIdentity methodsFor: 'printing'!description	^'Replace a == b with (a == b) not'! !!ReplaceIdentityWithNegationOfIdentity methodsFor: 'applying'!expressionToReplace 	^'``@a == ``@b'! !!ReplaceIdentityWithNegationOfIdentity methodsFor: 'applying'!newExpression 	^'(``@a == ``@b) not'! !!ReplaceLessOrEqualWithTrueOperator methodsFor: 'printing'!description	^'Replace #''<='' with true'! !!ReplaceLessOrEqualWithTrueOperator methodsFor: 'applying'!expressionToReplace 	^'``@object <= ``@aBlock'! !!ReplaceLessOrEqualWithTrueOperator methodsFor: 'applying'!newExpression 	^'true'! !!ReplaceLessOrEqualWithTrueOperator methodsFor: 'applying'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceLessOrEqualWithTrueOperator: aMutation.! !!ReplaceOrArgumentWithFalseOperator methodsFor: 'printing'!description	^'Replace #or: argument with [false]'! !!ReplaceOrArgumentWithFalseOperator methodsFor: 'applying'!expressionToReplace 	^'``@object or: ``@aBlock'! !!ReplaceOrArgumentWithFalseOperator methodsFor: 'applying'!newExpression	^'``@object or: [false]'! !!ReplaceOrArgumentWithFalseOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceOrArgumentWithFalseOperator: aMutation.! !!ReplaceOrWithTrueOperator methodsFor: 'printing'!description	^'Replace #or: with true'.! !!ReplaceOrWithTrueOperator methodsFor: 'applying'!expressionToReplace 	^'``@object or: ``@aBlock'! !!ReplaceOrWithTrueOperator methodsFor: 'applying'!newExpression 	^'true'! !!ReplaceOrWithTrueOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceOrWithTrueOperator: aMutation.! !!ReplaceAndReceiverOperator methodsFor: 'applying'!selector	^#and:! !!ReplaceAndReceiverWithTrueOperator methodsFor: 'applying'!newReceiverExpression 	^'true'! !!ReplaceAndReceiverWithTrueOperator methodsFor: 'applying'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceAndReceiverWithTrueMutantOperator: aMutation! !!ReplaceIfFalseIfTrueReceiverOperator methodsFor: 'applying'!selector	^#ifFalse:IfTrue:! !!ReplaceIfFalseIfTrueReceiverWithFalseOperator methodsFor: 'applying'!newReceiverExpression 	^'false'! !!ReplaceIfFalseIfTrueReceiverWithTrueOperator methodsFor: 'applying'!newReceiverExpression 	^'true'! !!ReplaceIfFalseReceiverOperator methodsFor: 'applying'!selector	^#ifFalse:! !!ReplaceIfFalseReceiverWithFalseOperator methodsFor: 'applying'!newReceiverExpression	^'false'! !!ReplaceIfFalseReceiverWithFalseOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceIfFalseReceiverWithFalseOperator: aMutation.! !!ReplaceIfFalseReceiverWithTrueOperator methodsFor: 'applying'!newReceiverExpression	^'true'! !!ReplaceIfFalseReceiverWithTrueOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceIfFalseReceiverWithTrueOperator: aMutation.! !!ReplaceIfTrueIfFalseReceiverOperator methodsFor: 'applying'!selector	^#ifTrue:ifFalse:! !!ReplaceIfTrueIfFalseReceiverWithFalseOperator methodsFor: 'applying'!newReceiverExpression 	^'false'! !!ReplaceIfTrueIfFalseReceiverWithFalseOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceIfTrueIfFalseReceiverWithFalseOperator: aMutation.! !!ReplaceIfTrueIfFalseReceiverWithTrueOperator methodsFor: 'applying'!newReceiverExpression 	^'true'! !!ReplaceIfTrueIfFalseReceiverWithTrueOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceIfTrueIfFalseReceiverWithTrueOperator: aMutation.! !!ReplaceIfTrueReceiverOperator methodsFor: 'applying'!selector	^#ifTrue:! !!ReplaceIfTrueReceiverWithFalseOperator methodsFor: 'applying'!newReceiverExpression	^'false'! !!ReplaceIfTrueReceiverWithFalseOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceIfTrueReceiverWithFalseOperator: aMutation.! !!ReplaceIfTrueReceiverWithTrueOperator methodsFor: 'applying'!newReceiverExpression	^'true'! !!ReplaceIfTrueReceiverWithTrueOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceIfTrueReceiverWithTrueOperator: aMutation.! !!ReplaceOrReceiverOperator methodsFor: 'applying'!selector	^#or:! !!ReplaceOrReceiverWithFalseOperator methodsFor: 'applying'!newReceiverExpression 	^'false'! !!ReplaceOrReceiverWithFalseOperator methodsFor: 'applying'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator	^aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceOrReceiverWithFalseOperator: aMutation.! !!ReplaceReceiverOperator methodsFor: 'printing'!description	^'Replace ', self selector printString,' receiver with ', self newReceiverExpression.! !!ReplaceReceiverOperator methodsFor: 'applying'!expressionToReplace 	^'``@receiver', ' ', self messageSendExpression.! !!ReplaceReceiverOperator methodsFor: 'applying'!messageSendExpression	| numberOfArgument |	numberOfArgument := 0.	^ self selector keywords		inject: ''		into: [:expression :keyword | 			numberOfArgument := numberOfArgument + 1.			expression , keyword , ' ``@arg' , numberOfArgument asString , ' ']! !!ReplaceReceiverOperator methodsFor: 'applying'!newExpression	^self newReceiverExpression, ' ', self messageSendExpression.! !!ReplaceReceiverOperator methodsFor: 'applying'!newReceiverExpression	self subclassResponsibility! !!ReplaceReceiverOperator methodsFor: 'applying'!selector	self subclassResponsibility! !!ReplaceRejectBlockWithAlwaysFalseBlockOperator methodsFor: 'printing'!description	^'Replace Reject block with [:each | false]'.! !!ReplaceRejectBlockWithAlwaysFalseBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@collection reject: ``@aBlock'! !!ReplaceRejectBlockWithAlwaysFalseBlockOperator methodsFor: 'applying'!newExpression	^'``@collection reject: [:each | false]'! !!ReplaceRejectBlockWithAlwaysTrueBlockOperator methodsFor: 'printing'!description	^'Replace Reject block with [:each | true]'.! !!ReplaceRejectBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@collection reject: ``@aBlock'! !!ReplaceRejectBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!newExpression	^'``@collection reject: [:each | true]'! !!ReplaceSelectBlockWithAlwaysFalseBlockOperator methodsFor: 'printing'!description	^'Replace Select block with [:each | false]'.! !!ReplaceSelectBlockWithAlwaysFalseBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@collection select: ``@aBlock'! !!ReplaceSelectBlockWithAlwaysFalseBlockOperator methodsFor: 'applying'!newExpression	^'``@collection select: [:each | false]'! !!ReplaceSelectBlockWithAlwaysTrueBlockOperator methodsFor: 'printing'!description	^'Replace Select block with [:each | true]'.! !!ReplaceSelectBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@collection select: ``@aBlock'! !!ReplaceSelectBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!newExpression	^'``@collection select: [:each | true]'! !!ReplaceSortBlockWithAlwaysTrueBlockOperator methodsFor: 'printing'!description	^'Replace sortBlock:aBlock with sortBlock:[:a :b| true]'.! !!ReplaceSortBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!expressionToReplace 	^'``@sortedCollection sortBlock: ``@aBlock'! !!ReplaceSortBlockWithAlwaysTrueBlockOperator methodsFor: 'applying'!newExpression	^'``@sortedCollection sortBlock: [:a :b| true]'.! !!ReplaceAndWithEqvMutantOperator methodsFor: 'accessing'!newSelector	^#bEqv:! !!ReplaceAndWithEqvMutantOperator methodsFor: 'accessing'!oldSelector	^#and:! !!ReplaceAndWithEqvMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceAndWithEqvMutantOperator: aMutation! !!ReplaceAndWithNandMutantOperator methodsFor: 'accessing'!newSelector	^#nand:! !!ReplaceAndWithNandMutantOperator methodsFor: 'accessing'!oldSelector	^#and:! !!ReplaceAndWithOrMutantOperator methodsFor: 'accessing'!newSelector	^#or:! !!ReplaceAndWithOrMutantOperator methodsFor: 'accessing'!oldSelector	^#and:! !!ReplaceAndWithOrMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceAndWithOrMutantOperator: aMutation! !!ReplaceDivisionWithMultiplicationMutantOperator methodsFor: 'accessing'!newSelector	^#*! !!ReplaceDivisionWithMultiplicationMutantOperator methodsFor: 'accessing'!oldSelector	^#/! !!ReplaceEqualWithNotEqualOperator methodsFor: 'accessing'!newSelector	^#~=! !!ReplaceEqualWithNotEqualOperator methodsFor: 'accessing'!oldSelector	^#=! !!ReplaceGreaterOrEqualWithEqualMutantOperator methodsFor: 'accessing'!newSelector	^#=! !!ReplaceGreaterOrEqualWithEqualMutantOperator methodsFor: 'accessing'!oldSelector	^#>=! !!ReplaceGreaterOrEqualWithEqualMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceGreaterOrEqualWithEqualMutantOperator: aMutation! !!ReplaceGreaterOrEqualWithGreaterMutantOperator methodsFor: 'accessing'!newSelector	^#>! !!ReplaceGreaterOrEqualWithGreaterMutantOperator methodsFor: 'accessing'!oldSelector	^#>=! !!ReplaceGreaterOrEqualWithGreaterMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceGreaterOrEqualWithGreaterMutantOperator: aMutation! !!ReplaceGreaterWithLessMutantOperator methodsFor: 'accessing'!newSelector	^#<! !!ReplaceGreaterWithLessMutantOperator methodsFor: 'accessing'!oldSelector	^#>! !!ReplaceIfFalseWithIfTrueMutantOperator methodsFor: 'accessing'!newSelector	^#ifTrue:! !!ReplaceIfFalseWithIfTrueMutantOperator methodsFor: 'accessing'!oldSelector	^#ifFalse:! !!ReplaceIfTrueWithIfFalseMutantOperator methodsFor: 'accessing'!newSelector	^#ifFalse:! !!ReplaceIfTrueWithIfFalseMutantOperator methodsFor: 'accessing'!oldSelector	^#ifTrue:! !!ReplaceIsEmptyWithNotEmptyMutantOperator methodsFor: 'accessing'!newSelector	^#notEmpty! !!ReplaceIsEmptyWithNotEmptyMutantOperator methodsFor: 'accessing'!oldSelector	^#isEmpty! !!ReplaceLessOrEqualWithEqualMutantOperator methodsFor: 'accessing'!newSelector 	^#=! !!ReplaceLessOrEqualWithEqualMutantOperator methodsFor: 'accessing'!oldSelector	^#<=! !!ReplaceLessOrEqualWithEqualMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceLessOrEqualWithEqualMutantOperator: aMutation! !!ReplaceLessOrEqualWithGreaterMutantOperator methodsFor: 'accessing'!newSelector	^#>! !!ReplaceLessOrEqualWithGreaterMutantOperator methodsFor: 'accessing'!oldSelector	^#<=! !!ReplaceLessOrEqualWithLessMutantOperator methodsFor: 'accessing'!newSelector	^#<! !!ReplaceLessOrEqualWithLessMutantOperator methodsFor: 'accessing'!oldSelector	^#<=! !!ReplaceLessOrEqualWithLessMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceLessOrEqualWithLessMutantOperator: aMutation! !!ReplaceLessWithGreaterMutantOperator methodsFor: 'accessing'!newSelector	^#>! !!ReplaceLessWithGreaterMutantOperator methodsFor: 'accessing'!oldSelector	^#<! !!ReplaceMaxWithMinMutantOperator methodsFor: 'accessing'!newSelector	^#min:! !!ReplaceMaxWithMinMutantOperator methodsFor: 'accessing'!oldSelector	^#max:! !!ReplaceMinWithMaxMutantOperator methodsFor: 'accessing'!newSelector	^#max:! !!ReplaceMinWithMaxMutantOperator methodsFor: 'accessing'!oldSelector	^#min:! !!ReplaceMinusWithPlusMutantOperator methodsFor: 'accessing'!newSelector	^#+! !!ReplaceMinusWithPlusMutantOperator methodsFor: 'accessing'!oldSelector	^#-! !!ReplaceMultiplicationWithDivisionMutantOperator methodsFor: 'accessing'!newSelector	^#/! !!ReplaceMultiplicationWithDivisionMutantOperator methodsFor: 'accessing'!oldSelector	^#*! !!ReplaceNotEqualWithEqualOperator methodsFor: 'accessing'!newSelector	^#=! !!ReplaceNotEqualWithEqualOperator methodsFor: 'accessing'!oldSelector	^#~=! !!ReplaceOrWithAndMutantOperator methodsFor: 'accessing'!newSelector	^#and:! !!ReplaceOrWithAndMutantOperator methodsFor: 'accessing'!oldSelector	^#or:! !!ReplaceOrWithAndMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceOrWithAndMutantOperator: aMutation! !!ReplaceOrWithXorMutantOperator methodsFor: 'accessing'!newSelector	^#bXor:! !!ReplaceOrWithXorMutantOperator methodsFor: 'accessing'!oldSelector	^#or:! !!ReplaceOrWithXorMutantOperator methodsFor: 'suggestions'!suggestionFor: aMutation using: aMutantKillingSuggestionGenerator 	^ aMutantKillingSuggestionGenerator suggestionForMutationProducedByAReplaceOrWithXorMutantOperator: aMutation! !!ReplacePlusWithMinusMutantOperator methodsFor: 'accessing'!newSelector	^#-! !!ReplacePlusWithMinusMutantOperator methodsFor: 'accessing'!oldSelector	^#+! !!ReplaceRejectWithSelectMutantOperator methodsFor: 'accessing'!newSelector	^#select:! !!ReplaceRejectWithSelectMutantOperator methodsFor: 'accessing'!oldSelector	^#reject:! !!ReplaceSelectWithRejectMutantOperator methodsFor: 'accessing'!newSelector	^#reject:! !!ReplaceSelectWithRejectMutantOperator methodsFor: 'accessing'!oldSelector	^#select:! !!SelectorReplacementMutantOperator methodsFor: 'printing'!description	^ 'Replace ' , self oldSelector printString , ' with ' , self newSelector printString! !!SelectorReplacementMutantOperator methodsFor: 'applying'!expressionToReplace 	| oldString |	oldString := RBParseTreeSearcher buildSelectorString: self oldSelector.	^'``@object ' , oldString	! !!SelectorReplacementMutantOperator methodsFor: 'applying'!newExpression 	| newString |	newString := RBParseTreeSearcher buildSelectorString: self newSelector.	^'``@object ' , newString! !!SelectorReplacementMutantOperator methodsFor: 'accessing'!newSelector	self subclassResponsibility! !!SelectorReplacementMutantOperator methodsFor: 'accessing'!oldSelector	self subclassResponsibility! !!MutantReporter class methodsFor: 'instance creation'!for: aMutantEvaluationResult 	^self new 		initializeFor: aMutantEvaluationResult;		yourself ! !!MutantReporter methodsFor: 'initialize-release'!initializeFor: aMutantEvaluationResult 	mutantEvaluationResult := aMutantEvaluationResult ! !!MutantReporter methodsFor: 'evaluating'!value	| stream |	stream := String		streamContents: [ :str | 			str				nextPutAll: '----------------';				cr.			str				nextPutAll: 'Mutant Generated: ';				nextPutAll: mutantEvaluationResult printString;				cr.			str				nextPutAll: '----------------';				cr.			str				nextPutAll: 'Result --> ';				nextPutAll: mutantEvaluationResult resultString;				cr.			mutantEvaluationResult printDetailedResultOn: str.			str cr ].	^ stream contents! !!MutationAcceptableScore class methodsFor: 'instance creation'!canHandle: aMutationTestingGeneralResult 	^aMutationTestingGeneralResult mutationScore > 80! !!MutationAcceptableScore methodsFor: 'accessing'!color	 ^ Color green ! !!MutationAcceptableScore methodsFor: 'testing'!isAcceptableScore	^true! !!MutationAcceptableScore methodsFor: 'testing'!isAlmostAcceptableScore	^false! !!MutationAcceptableScore methodsFor: 'testing'!isNonAcceptableScore	^false! !!MutationAlmostAcceptableScore class methodsFor: 'instance creation'!canHandle: aMutationTestingGeneralResult	| score |	score := aMutationTestingGeneralResult mutationScore.	^ score between: 50 and: 80! !!MutationAlmostAcceptableScore methodsFor: 'accessing'!color	^Color yellow! !!MutationAlmostAcceptableScore methodsFor: 'testing'!isAcceptableScore	^false! !!MutationAlmostAcceptableScore methodsFor: 'testing'!isAlmostAcceptableScore	^true! !!MutationAlmostAcceptableScore methodsFor: 'testing'!isNonAcceptableScore	^false! !!MutationNonAcceptableScore class methodsFor: 'instance creation'!canHandle: aMutationTestingGeneralResult 	^aMutationTestingGeneralResult mutationScore < 50! !!MutationNonAcceptableScore methodsFor: 'accessing'!color	^Color red! !!MutationNonAcceptableScore methodsFor: 'testing'!isAcceptableScore	^false! !!MutationNonAcceptableScore methodsFor: 'testing'!isAlmostAcceptableScore	^false! !!MutationNonAcceptableScore methodsFor: 'testing'!isNonAcceptableScore	^true! !!MutationScoreBehavior class methodsFor: 'instance creation'!buildFor: aMutationGeneralResult	|handler|	handler := self allSubclasses detect: [:class | class canHandle: aMutationGeneralResult] ifNone: [].	^handler scoreFor: aMutationGeneralResult	! !!MutationScoreBehavior class methodsFor: 'instance creation'!scoreFor: aMutationGeneralResult	^(self new) initializeFor: aMutationGeneralResult; yourself	! !!MutationScoreBehavior methodsFor: 'accessing'!generalResult	^ generalResult! !!MutationScoreBehavior methodsFor: 'initialization'!initializeFor: aMutationGeneralResult	generalResult := aMutationGeneralResult.! !!MutationTestingAnalysis class methodsFor: 'defaults'!defaultLogger	^NullMutationTestingAnalysisLogger new.! !!MutationTestingAnalysis class methodsFor: 'defaults'!defaultMutantsEvaluationStrategy	^ AllTestsMethodsRunningMutantEvaluationStrategy new! !!MutationTestingAnalysis class methodsFor: 'defaults'!defaultMutationsGenerationStrategy	^ AllMutationsGenerationStrategy new.! !!MutationTestingAnalysis class methodsFor: 'instance creation'!for: testCases mutating: classes using: operatorCollection 		^ self 		for: testCases		mutating: classes		using: operatorCollection		with: self defaultMutantsEvaluationStrategy		with: self defaultMutationsGenerationStrategy! !!MutationTestingAnalysis class methodsFor: 'instance creation'!for: testCases mutating: classes using: operatorCollection loggingIn: aLogger 	^ self 		for: testCases		mutating: classes		using: operatorCollection		with: self defaultMutantsEvaluationStrategy		with: self defaultMutationsGenerationStrategy		loggingIn: aLogger! !!MutationTestingAnalysis class methodsFor: 'instance creation'!for: testCases mutating: classes using: operatorCollection with: aMutantEvaluationStrategy		^ self 		for: testCases		mutating: classes		using: operatorCollection		with: aMutantEvaluationStrategy		with: self defaultMutationsGenerationStrategy! !!MutationTestingAnalysis class methodsFor: 'instance creation'!for: testCases mutating: classes using: operatorCollection with: aMutantEvaluationStrategy loggingIn: aLogger		^ self 		for: testCases		mutating: classes		using: operatorCollection		with: aMutantEvaluationStrategy		with: self defaultMutationsGenerationStrategy		loggingIn: aLogger! !!MutationTestingAnalysis class methodsFor: 'instance creation'!for: testCases mutating: classes using: operatorCollection with: aMutantsEvaluationStrategy with: aMutationsGenerationStrategy 	^ self 		for: testCases		mutating: classes		using: operatorCollection		with: aMutantsEvaluationStrategy		with: aMutationsGenerationStrategy		loggingIn: self defaultLogger! !!MutationTestingAnalysis class methodsFor: 'instance creation'!for: testCases mutating: classes using: operatorCollection with: aMutantsEvaluationStrategy with: aMutationsGenerationStrategy loggingIn: aLogger 	^ self new		initializeFor: testCases			mutating: classes			using: operatorCollection			with: aMutantsEvaluationStrategy			with: aMutationsGenerationStrategy			loggingIn: aLogger;		yourself! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesFrom: testClasses 	^ testClasses		inject: OrderedCollection new		into: [:testCases :testClass | 			((testClass isKindOf: TestCase class)					and: [testClass isAbstract not])				ifTrue: [testCases						addAll: (self testCasesReferencesFrom: testClass)].			testCases]! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesFrom: testClasses mutating: classes using: operatorCollection 		^ self 		for: (self testCasesFrom: testClasses)		mutating: classes		using: operatorCollection.! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesFrom: testClasses mutating: classes using: operatorCollection logginIn: aLogger 	^ self 		for: (self testCasesFrom: testClasses)		mutating: classes		using: operatorCollection		loggingIn: aLogger! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesFrom: testClasses mutating: classes using: operatorCollection with: anEvaluationStrategy		^ self 		for: (self testCasesFrom: testClasses)		mutating: classes		using: operatorCollection		with: anEvaluationStrategy.! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesFrom: testClasses mutating: classes using: operatorCollection with: anEvaluationStrategy loggingIn: aLogger		^ self 		for: (self testCasesFrom: testClasses)		mutating: classes		using: operatorCollection		with: anEvaluationStrategy 		loggingIn: aLogger.! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesFrom: testClasses mutating: classes using: operatorCollection with: anEvaluationStrategy with: aGenerationStrategy		^ self 		for: (self testCasesFrom: testClasses)		mutating: classes		using: operatorCollection		with: anEvaluationStrategy		with: aGenerationStrategy.! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesFrom: testClasses mutating: classes using: operatorCollection with: anEvaluationStrategy with: aGenerationStrategy loggingIn: aLogger 	^ self 		for: (self testCasesFrom: testClasses)		mutating: classes		using: operatorCollection		with: anEvaluationStrategy		with: aGenerationStrategy		loggingIn: aLogger! !!MutationTestingAnalysis class methodsFor: 'instance creation'!testCasesReferencesFrom: testClass 	^ testClass allTestSelectors collect: 		[ :each | 		TestCaseReference 			for: each			in: testClass ]! !!MutationTestingAnalysis methodsFor: 'accesing'!coverageAnalysisResult		^coverageAnalysisResult! !!MutationTestingAnalysis methodsFor: 'results'!generalResult	^ MutationTestingGeneralResult		for: particularResults		timed: (Duration nanoSeconds: (Duration milliSeconds: elapsedTime) nanoSeconds)! !!MutationTestingAnalysis methodsFor: 'running'!generateCoverageAnalysis	coverageAnalysisResult := (CoverageAnalysis for: self modelClasses running: testCases) run; result! !!MutationTestingAnalysis methodsFor: 'running'!generateMutations	mutations := mutationsGenerationStrategy 		mutationsFor: self		loggingIn: logger! !!MutationTestingAnalysis methodsFor: 'running'!generateResults	particularResults := OrderedCollection new.	mutations		do: [:aMutation | logger logStartEvaluating: aMutation. 			particularResults add: (MutantEvaluation					for: aMutation					using: testCases					following: mutantsEvaluationStrategy					andConsidering: self coverageAnalysisResult) value]		displayingProgress: 'Evaluating mutants'.	^ particularResults! !!MutationTestingAnalysis methodsFor: 'initialize-release'!initializeFor: someTestCasesReferences mutating: someModelClasses using: operatorCollection with: aMutantsEvaluationStrategy with: aMutationsGenerationStrategy loggingIn: aLogger 	modelClasses := someModelClasses.	testCases := someTestCasesReferences.	operators := operatorCollection.	mutationsGenerationStrategy := aMutationsGenerationStrategy.	mutantsEvaluationStrategy := aMutantsEvaluationStrategy.	particularResults := OrderedCollection new.	elapsedTime := 0.	logger := aLogger! !!MutationTestingAnalysis methodsFor: 'accesing'!modelClasses	"Filter tests and testsResources"	^ modelClasses		reject: [:class | self testBaseClasses				anySatisfy: [:classToFilter | class includesBehavior: classToFilter]]! !!MutationTestingAnalysis methodsFor: 'accesing'!mutations	^mutations! !!MutationTestingAnalysis methodsFor: 'accesing'!operators	^operators ! !!MutationTestingAnalysis methodsFor: 'results'!particularResults	^ particularResults! !!MutationTestingAnalysis methodsFor: 'running'!run	"Obtain mutants applying the operators in the classes (or	methods of	those classes) and execute all mutants in the set of testClases.	We obtain a result for each mutant generated"	^[testCases do: [ :aTestCase | aTestCase run ].	logger logAnalysisStartFor:self.	elapsedTime := Time millisecondsToRun: [					self generateCoverageAnalysis.					self generateMutations.					self generateResults.].					true]						on: TestsWithErrorsException						do: [:ex | 							self inform: 'Your tests have Errors or Failures. Please correct them.'.							ex return: false]! !!MutationTestingAnalysis methodsFor: 'accesing'!testBaseClasses	^OrderedCollection with: TestCase with: TestResource! !!MutationTestingAnalysis methodsFor: 'accesing'!testCases	^testCases! !!MutationTestingAnalysisFileLogger class methodsFor: 'instance creation'!toFileNamed: aString	^self new initializeToFileNamed: aString.! !!MutationTestingAnalysisFileLogger methodsFor: 'initialize-release'!initializeToFileNamed: aString	fileStream := FileStream forceNewFileNamed: aString.! !!MutationTestingAnalysisFileLogger methodsFor: 'logging'!logAnalysisStartFor: aMutationTestingAnalysis 	self writeLineToFile: 'The analysis is starting...'.! !!MutationTestingAnalysisFileLogger methodsFor: 'logging'!logStartBuildingMutantionsFor: aCompiledMethod using: aMutantOperator 	self writeLineToFile: 'Generating mutations for '			, (self methodNameOf: aCompiledMethod) , '  With operator:' , aMutantOperator description! !!MutationTestingAnalysisFileLogger methodsFor: 'logging'!logStartEvaluating: aMethodMutation	| logStream |	logStream := WriteStream on: String new.	logStream		nextPutAll: 'Evaluating mutant of method ';		nextPutAll: (self methodNameOf: aMethodMutation originalMethod);		nextPutAll: '  With source:'.	logStream cr.	logStream nextPutAll: aMethodMutation modifiedSource.	self writeLineToFile: logStream contents! !!MutationTestingAnalysisFileLogger methodsFor: 'private'!methodNameOf: aCompiledMethod 	^aCompiledMethod methodClass name asString , '>>' , aCompiledMethod selector printString ! !!MutationTestingAnalysisFileLogger methodsFor: 'private'!writeLineToFile: aString 	[fileStream closed		ifTrue: [fileStream open].	fileStream setToEnd; nextPutAll: aString; cr]		ensure: [fileStream close]! !!MutationTestingAnalysisLogger methodsFor: 'logging'!logAnalysisStartFor: aMutationTestingAnalysis 	self subclassResponsibility ! !!MutationTestingAnalysisLogger methodsFor: 'logging'!logStartBuildingMutantionsFor: aCompiledMethod using: aMutantOperator	self subclassResponsibility ! !!MutationTestingAnalysisLogger methodsFor: 'logging'!logStartEvaluating: aMethodMutation 	self subclassResponsibility! !!NullMutationTestingAnalysisLogger class methodsFor: 'instance creation'!new	instance ifNil:[instance := super new.].	^instance.! !!NullMutationTestingAnalysisLogger methodsFor: 'logging'!logAnalysisStartFor: aMutationTestingAnalysis ! !!NullMutationTestingAnalysisLogger methodsFor: 'logging'!logStartBuildingMutantionsFor: aCompiledMethod using: aMutantOperator! !!NullMutationTestingAnalysisLogger methodsFor: 'logging'!logStartEvaluating: aMethodMutation ! !!MutationTestingGeneralResult class methodsFor: 'instance creation'!empty	^ self for: OrderedCollection new! !!MutationTestingGeneralResult class methodsFor: 'instance creation'!for: mutantsEvaluationsResults 	^self for: mutantsEvaluationsResults timed: Duration new! !!MutationTestingGeneralResult class methodsFor: 'instance creation'!for: mutantsEvaluationsResults timed: anElapsedTime 	^ self new initializeFor: mutantsEvaluationsResults timed: anElapsedTime;		 yourself! !!MutationTestingGeneralResult methodsFor: 'accessing'!aliveMutants	^ particularResults select: [ :evaluationResult | evaluationResult survived ]! !!MutationTestingGeneralResult methodsFor: 'testing'!elapsedTime	^ elapsedTime! !!MutationTestingGeneralResult methodsFor: 'initialize'!initializeFor: mutantsEvaluationsResults timed: anElapsedTime	particularResults := mutantsEvaluationsResults.	elapsedTime := anElapsedTime! !!MutationTestingGeneralResult methodsFor: 'testing'!isAcceptableScore	^ self mutationScore > 80! !!MutationTestingGeneralResult methodsFor: 'testing'!isNonAcceptableScore	^ self mutationScore < 50! !!MutationTestingGeneralResult methodsFor: 'accessing'!killedMutants	^ particularResults select: [ :evaluationResult | evaluationResult killed ]! !!MutationTestingGeneralResult methodsFor: 'accessing'!killedOrTerminatedMutants	^ particularResults select: [ :evaluationResult | evaluationResult killed or: [ evaluationResult terminated ] ]! !!MutationTestingGeneralResult methodsFor: 'details'!mutationScore	"Returns the mutation Score of this general result. A mutation score is the	killedOrTerminatedMutants / numberOfEvaluatedMutants"	self numberOfEvaluatedMutants = 0 ifTrue: [ ^ 0 ].	^ (self numberOfKilledOrTerminatedMutants * 100 / self numberOfEvaluatedMutants) asInteger! !!MutationTestingGeneralResult methodsFor: 'details'!mutationScoreModel	^MutationScoreBehavior buildFor: self! !!MutationTestingGeneralResult methodsFor: 'details'!numberOfAliveMutants	"Returns the number of survived Mutants of this result"	^ self aliveMutants size! !!MutationTestingGeneralResult methodsFor: 'details'!numberOfEvaluatedMutants	"Returns the number of Mutants Evaluated"	^ particularResults size! !!MutationTestingGeneralResult methodsFor: 'details'!numberOfKilledMutants	"Returns the number of killed Mutants of this result"	^ self killedMutants size! !!MutationTestingGeneralResult methodsFor: 'details'!numberOfKilledOrTerminatedMutants	"Returns the number of killed or terminated Mutants of this result"	^ self killedOrTerminatedMutants size! !!MutationTestingGeneralResult methodsFor: 'details'!numberOfTerminatedMutants	"Returns the number of Mutants terminated"	^ self terminatedMutants size! !!MutationTestingGeneralResult methodsFor: 'printing'!printDetailedInfoOn: aStream 		(particularResults 		groupBy:  [:result | result mutant operator]		having: [:g | true]) 			keysAndValuesDo: [:key :value | 				aStream nextPutAll: key description.				aStream nextPutAll: ' - '.				aStream nextPutAll: value size printString; cr.			]! !!MutationTestingGeneralResult methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self numberOfEvaluatedMutants printString;		nextPutAll: ' mutants, ';		nextPutAll: self numberOfKilledMutants printString;		nextPutAll: ' killed, ';		nextPutAll: self numberOfAliveMutants printString;		nextPutAll: ' alive, ';		nextPutAll: self numberOfTerminatedMutants printString;		nextPutAll: ' terminated. Mutation Score: ';		nextPutAll: self mutationScore printString;		nextPutAll: '%.'! !!MutationTestingGeneralResult methodsFor: 'accessing'!terminatedMutants	^ particularResults select: [ :evaluationResult | evaluationResult terminated ]! !!MutationTestingGeneralResultReporter class methodsFor: 'instance creation'!for: aMutationGeneralResut in: aFileReference with: aPackagesNames	^self new 		initializeFor: aMutationGeneralResut in: aFileReference asFileReference with: aPackagesNames;		yourself! !!MutationTestingGeneralResultReporter methodsFor: 'evaluating'!detailedInfo	|stream|	stream := String streamContents: [:str|		str nextPutAll: mutationGeneralResult printString; cr.		str nextPutAll: '----------------------------------'; cr.		str nextPutAll: mutationGeneralResult elapsedTime printString; cr.		str nextPutAll: '----------------------------------'; cr.		mutationGeneralResult printDetailedInfoOn: str].	^stream contents		! !!MutationTestingGeneralResultReporter methodsFor: 'initialize-release'!initializeFor: aMutationGeneralResut in: aFileReference with: aPackagesNames	mutationGeneralResult := aMutationGeneralResut.	fileReference := aFileReference.	packagesNames := aPackagesNames! !!MutationTestingGeneralResultReporter methodsFor: 'evaluating'!resumedInfo	|stream|	stream := String streamContents: [:str|		str nextPutAll: mutationGeneralResult numberOfEvaluatedMutants printString; tab.		str nextPutAll: mutationGeneralResult numberOfKilledMutants printString; tab.		str nextPutAll: mutationGeneralResult numberOfAliveMutants printString; tab.		str nextPutAll: mutationGeneralResult numberOfTerminatedMutants printString; tab.		str nextPutAll: mutationGeneralResult mutationScore printString; tab.		str nextPutAll: mutationGeneralResult elapsedTime asMilliSeconds printString; tab.		packagesNames do: [:packageName | str nextPutAll: packageName printString; tab].		str cr.		].	^stream contents		! !!MutationTestingGeneralResultReporter methodsFor: 'evaluating'!value	|file|		file := fileReference writeStream.	file setToEnd; nextPutAll: self resumedInfo; close.		! !!AllMutationsGenerationStrategy methodsFor: 'generating'!classesAndMetaclassesFrom: modelClasses 	^ modelClasses		inject: OrderedCollection new		into: [:classes :aClass | 			classes add: aClass;				 add: aClass class.			classes]! !!AllMutationsGenerationStrategy methodsFor: 'generating'!methodsToMutateFrom: aMutationTestingAnalysis 	^ (self classesAndMetaclassesFrom: aMutationTestingAnalysis modelClasses)		inject: OrderedCollection new		into: [:methods :aClass | 			methods addAll: aClass methods.			methods]! !!MutationsGenerationStrategy methodsFor: 'generating'!methodsToMutateFrom:aMutationTestingAnalysis	self subclassResponsibility.! !!MutationsGenerationStrategy methodsFor: 'generating'!mutationsFor: aMutationTestingAnalysis 	^ self 		mutationsFor: aMutationTestingAnalysis		loggingIn: self nullLogger! !!MutationsGenerationStrategy methodsFor: 'generating'!mutationsFor: aMutationTestingAnalysis loggingIn: aLogger 	| mutations |	mutations := OrderedCollection new.	(self methodsToMutateFrom: aMutationTestingAnalysis) 		do: 			[ :aMethod | 			mutations addAll: (self 					mutationsFor: aMethod					usingAll: aMutationTestingAnalysis operators					logginIn: aLogger) ]		displayingProgress: 'Building Mutants'.	^ mutations! !!MutationsGenerationStrategy methodsFor: 'generating'!mutationsFor: aMethod usingAll: aCollectionOfMutantOperators logginIn: aLogger 	| parseTree |	parseTree := aMethod parseTree.	^ aCollectionOfMutantOperators		inject: OrderedCollection new		into: [:mutations :anOperator | 			aLogger logStartBuildingMutantionsFor: aMethod using: anOperator.			(aMethod ignoredMutationOperators includes: anOperator class) 				ifFalse: [ mutations addAll: (anOperator mutationsFor: aMethod with: parseTree) ].			mutations ]! !!MutationsGenerationStrategy methodsFor: 'logging'!nullLogger	^ NullMutationTestingAnalysisLogger new.! !!SelectingFromCoverageMutationsGenerationStrategy methodsFor: 'generating'!methodsToMutateFrom: aMutationTestingAnalysis	^aMutationTestingAnalysis coverageAnalysisResult coveredMethods.! !!TestCaseReference class methodsFor: 'instance creation'!for: aSelector in: aClass 	^self new initializeFor: aSelector in: aClass! !!TestCaseReference class methodsFor: 'instance creation'!forTestCase: aTestCase 	^self for: aTestCase selector in: aTestCase class! !!TestCaseReference methodsFor: 'initialize'!initializeFor: aSelector in: aClass	class := aClass.	selector := aSelector.! !!TestCaseReference methodsFor: 'evaluating'!resources	^self testCase resources! !!TestCaseReference methodsFor: 'evaluating'!run	| result |	result := self testCase run.	(result failuresSize > 0 or: [ result errorsSize > 0])		ifTrue: [TestsWithErrorsException signal].	^ result! !!TestCaseReference methodsFor: 'evaluating'!run: aTestResult	^self testCase run: aTestResult! !!TestCaseReference methodsFor: 'evaluating'!testCase	^class selector: selector.! !!ClassTestCasesSelectionStrategy methodsFor: 'printing'!description	^'Tests in Same Clases'! !!ClassTestCasesSelectionStrategy methodsFor: 'selecting'!testCasesFor: aTestCollection 	"Returns all tests in testClases from a collection of tests."		| testClasses |	testClasses := self testClassesFrom: aTestCollection.	^ testClasses 		inject: OrderedCollection new		into: 			[ :resultTests :testClass | 			resultTests addAll: testClass suite tests.			resultTests ]! !!ClassTestCasesSelectionStrategy methodsFor: 'selecting'!testClassesFrom: aTestCollection 	^ (aTestCollection collect: [ :testCase | testCase class ]) asSet! !!NoneTestCasesSelectionStrategy methodsFor: 'printing'!description	^'Same Tests'! !!NoneTestCasesSelectionStrategy methodsFor: 'selecting'!testCasesFor: aTestCollection 	"It returns all same tests from a collection of tests received."	^aTestCollection! !!PackageTestCasesSelectionStrategy methodsFor: 'printing'!description	^'All tests in same packages'! !!PackageTestCasesSelectionStrategy methodsFor: 'selecting'!isClassTest: aClass 	^ self testBaseClasses		anySatisfy: [:class | aClass includesBehavior: class]! !!PackageTestCasesSelectionStrategy methodsFor: 'selecting'!testBaseClasses	^Array with: TestCase! !!PackageTestCasesSelectionStrategy methodsFor: 'selecting'!testCasesFor: aTestCollection 	| testsPackage |	testsPackage := self testPackageFrom: aTestCollection.	^ testsPackage 		inject: OrderedCollection new		into: 			[ :resultTests :testPackage | 			(self testClassesFromPackage: testPackage) do: [ :testClass | resultTests addAll: testClass suite tests ].			resultTests ]! !!PackageTestCasesSelectionStrategy methodsFor: 'selecting'!testClassesFromPackage: aPackageName 	^ (aPackageName asPackage) classes select: [ :class | self isClassTest: class ]! !!PackageTestCasesSelectionStrategy methodsFor: 'selecting'!testPackageFrom: aTestCollection	^(aTestCollection collect: [:testCase | testCase class package name]) asSet! !!TestCasesSelectionStrategy methodsFor: 'printing'!description	self subclassResponsibility! !!TestCasesSelectionStrategy methodsFor: 'selecting'!testCasesFor: aTestCollection 	self subclassResponsibility! !!TestCasesSelectionStrategy methodsFor: 'selecting'!testCasesFromReferencies: aTestReferenceCollection 	"Applies the testCase Selection from a collection of TestCaseReferences and return a collection of TestCaseRefereces."		|testCases selectedTestCases|	testCases := aTestReferenceCollection collect: [:testReference | testReference testCase].	selectedTestCases := self testCasesFor: testCases.	^selectedTestCases collect: [:testCase | TestCaseReference forTestCase: testCase]  	! !"MuTalk-Model"!!AuxiliarClassForMutationTestingAnalysisTest methodsFor: 'testing'!testAnotherMethodWithOneIfFalseSender	self assert: AuxiliarClassForMutationTestingAnalysis new anotherMethodWithOneIfFalseSender = 1! !!AuxiliarClassForMutationTestingAnalysisTest methodsFor: 'testing'!testClassMethodThatSendsSelect	self assert: AuxiliarClassForMutationTestingAnalysis classMethodThatSendsSelect notEmpty! !!AuxiliarClassForMutationTestingAnalysisTest methodsFor: 'testing'!testMethodWithOneIfFalseSender	self assert: AuxiliarClassForMutationTestingAnalysis new methodWithOneIfFalseSender = 2! !!AuxiliarClassForMutationTestingAnalysisTest methodsFor: 'testing'!testMethodWithOneIfTrueSender	self assert: AuxiliarClassForMutationTestingAnalysis new methodWithOneIfTrueSender = 1! !!AuxiliarClassForMutationTestingAnalysisTest methodsFor: 'testing'!testMethodWithOnePlusSender	self assert: AuxiliarClassForMutationTestingAnalysis new methodWithOnePlusSender = 3! !!AuxiliarClassForMutationTestingAnalysisTest methodsFor: 'testing'!testMethodWithTwoMinusSenders	self assert: AuxiliarClassForMutationTestingAnalysis new methodWithTwoMinusSenders = -4! !!AuxiliarTestClassForTestingStrategies methodsFor: 'as yet unclassified'!testMethodThatCoverMethod1	self assert: AuxiliarClassForTestingStrategies new method1 = 1. 		! !!AuxiliarTestClassForTestingStrategies methodsFor: 'as yet unclassified'!testMethodThatCoverMethod2	self assert: AuxiliarClassForTestingStrategies new method2 = 2. 		! !!TestClassForTestingCoverage class methodsFor: 'as yet unclassified'!resources	^Array with:TestResourceClassForTestingCoverage ! !!TestClassForTestingCoverage methodsFor: 'testing'!testCase1	self assert: ClassForTestingCoverage new aCoveredMethod.! !!TestClassForTestingCoverage methodsFor: 'testing'!testCase2	self assert: ClassForTestingCoverage new aCoveredMethod.! !!TestClassForTestingCoverage methodsFor: 'testing'!testCase3	self assert: true.! !!TestClassForTestingCoverage methodsFor: 'testing'!testCaseThatCoversAClassMethod	self assert: ClassForTestingCoverage aClassCoveredMethod.! !!AuxiliarClassForMutationTestingAnalysis class methodsFor: 'auxiliar'!classMethodThatSendsSelect	|collection|	collection := OrderedCollection with: 1.	^collection 		select: [:item | item = 1]! !!AuxiliarClassForMutationTestingAnalysis methodsFor: 'auxiliar'!anotherMethodWithOneIfFalseSender	false ifFalse: [^1].	^2! !!AuxiliarClassForMutationTestingAnalysis methodsFor: 'auxiliar'!methodWithOneIfFalseSender	true ifFalse: [^1].	^2! !!AuxiliarClassForMutationTestingAnalysis methodsFor: 'auxiliar'!methodWithOneIfTrueSender	true ifTrue: [ ^ 1 ].	^ 2! !!AuxiliarClassForMutationTestingAnalysis methodsFor: 'auxiliar'!methodWithOnePlusSender	^ 1 + 2! !!AuxiliarClassForMutationTestingAnalysis methodsFor: 'auxiliar'!methodWithTwoMinusSenders	^ 1 - 2 - 3! !!AuxiliarClassForTestingStrategies methodsFor: 'as yet unclassified'!aNotCoveredMethod	true ifTrue: [^2]! !!AuxiliarClassForTestingStrategies methodsFor: 'as yet unclassified'!method1	true ifTrue: [^1]! !!AuxiliarClassForTestingStrategies methodsFor: 'as yet unclassified'!method2	^2! !!ClassForTestingCoverage class methodsFor: 'as yet unclassified'!aClassCoveredMethod	^true.! !!ClassForTestingCoverage class methodsFor: 'instance creation'!new: aSize	" from UUID class>> #new:"	(aSize == 16) ifFalse: [ self error: 'Wrong UUID size' ].		^ super new: aSize! !!ClassForTestingCoverage methodsFor: 'as yet unclassified'!aCoveredMethod	^ true! !!ClassForTestingCoverage methodsFor: 'as yet unclassified'!anUncoveredMethod	^ true! !!TestResourceClassForTestingCoverage methodsFor: 'as yet unclassified'!doSomething	^ClassForTestingCoverage new anUncoveredMethod.! !!TestResourceClassForTestingCoverage methodsFor: 'as yet unclassified'!setUp	self doSomething! !"MuTalk-TestResources"!!MethodInstallerTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('MutationTesting-Model')! !!MethodInstallerTest methodsFor: 'test resources'!methodInstalled	"this method is used to test installation,"	^ 3 + 4! !!MethodInstallerTest methodsFor: 'test resources'!methodToUninstall ^self! !!MethodInstallerTest methodsFor: 'accessing'!numberOfMethodVersionsOf: aSelector in: aClass 		| aMethod |		aMethod := aClass>>aSelector.		^ (SourceFiles		changeRecordsFrom: aMethod sourcePointer		className: aMethod origin		isMeta: aMethod origin isClassSide) size! !!MethodInstallerTest methodsFor: 'building'!tearDown	"Unistall methods that should not be istalled and install method that should be installed."			(self class includesSelector: #methodNotInstalled) ifTrue: [		MethodInstaller new uninstall: #methodNotInstalled from: self class.		].	(self class includesSelector: #methodToUninstall) ifFalse: [		MethodInstaller new installFromSource:  'methodToUninstall ^self' in: self class.		].	! !!MethodInstallerTest methodsFor: 'testing'!testInstallMethodException	"Try to install a method that produce an Exception."	| selector aSourceCode |	selector := #methodWithError.	self deny: (self class includesSelector: selector).	aSourceCode := selector asString , '  ^3+'.	self should: 		[ MethodInstaller new installFromSource: aSourceCode in: self class]		raise: MethodInstallerException! !!MethodInstallerTest methodsFor: 'testing'!testInstallMethodOnEmptyClass	"Install a method on Self"	| selector aSourceCode |	selector := #methodNotInstalled.	self deny: (self class includesSelector: selector).	aSourceCode := selector asString , '  ^3+4'.	MethodInstaller new installFromSource: aSourceCode in: self class.	self assert: (self class includesSelector: selector).! !!MethodInstallerTest methodsFor: 'testing'!testInstallerShouldNotAddSourceVersions	"Install a method that produce an Exception. For this. me use an	Anonimous Class."	| selector aSourceCode previousNumberOfVersions previousCompiledMethod|		selector := #methodInstalled.	previousCompiledMethod := self class methodDictionary at: selector.	previousNumberOfVersions := self numberOfMethodVersionsOf: selector 		in: self class.			aSourceCode := selector asString , '  ^3+4'.	[MethodInstaller new installFromSource: aSourceCode in: self class.] 			ensure:[MethodInstaller new install: previousCompiledMethod for: selector in: self class ].		self assert: (self numberOfMethodVersionsOf: selector in: self class) = previousNumberOfVersions 			! !!MethodInstallerTest methodsFor: 'testing'!testUnInstallMethodOnClass	"Uninstall a method from a class that has the method implemented."	|selector|	selector := #methodToUninstall.	self assert: (self class includesSelector: selector).	MethodInstaller new uninstall: selector from: self class.	self deny: (self class includesSelector: selector)		! !!MethodMutationTest methodsFor: 'testing accessing'!testAccessing	| compiledMethod operator modifiedSource methodMutation |	compiledMethod := AuxiliarClassForMutationTestingAnalysis		>> #methodWithOnePlusSender.	operator := ReplacePlusWithMinusMutantOperator new.	modifiedSource := operator		modifiedSourceFor: compiledMethod		number: 1.	methodMutation := MethodMutation		for: compiledMethod		using: operator		result: modifiedSource		ofClass: AuxiliarClassForMutationTestingAnalysis.	self		assert: methodMutation originalSource = compiledMethod sourceCode asString.	self		assert: methodMutation originalClass = AuxiliarClassForMutationTestingAnalysis.	self assert: methodMutation modifiedSource = modifiedSource! !!MethodMutationTest methodsFor: 'testing accessing'!testAccessingToNodes	|compiledMethod operator modifiedSource methodMutation|		compiledMethod := AuxiliarClassForMutationTestingAnalysis >> #methodWithOnePlusSender.	operator := ReplacePlusWithMinusMutantOperator new.	modifiedSource := operator modifiedSourceFor: compiledMethod number: 1. 	methodMutation := MethodMutation 		for: compiledMethod 		using: operator 		result: modifiedSource 		ofClass: AuxiliarClassForMutationTestingAnalysis.			self assert: methodMutation nodeToMutate formattedCode = '1 + 2'.	self assert: methodMutation mutatedNode formattedCode = '1 - 2'.! !!MethodMutationTest methodsFor: 'tests'!testMutatedNodeBugFix	| method m |	method := ClassForTestingCoverage class>>#new:.	m := (ReplaceIdentityWithNegationOfIdentity new mutationsFor: method) first.	self shouldnt: [ m mutatedNode ] raise:  SubscriptOutOfBounds 	! !!MutantEvaluationResultTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('MutationTesting-Model')! !!MutantEvaluationResultTest class methodsFor: 'accessing'!resources	^ {MutationTestingResource}! !!MutantEvaluationResultTest methodsFor: 'testing - printing'!mutantPrintString	"printing the mutation used in this tests."	^ resource mutation printString! !!MutantEvaluationResultTest methodsFor: 'testing'!setUp	resource := MutationTestingResource current! !!MutantEvaluationResultTest methodsFor: 'testing'!testMutationResultEmpty	"Test the creation of a Mutant Result Empty."	| result |	result := resource evaluationResultEmpty.	self deny: result killed.	self assert: result survived.	self deny: result terminated.	self assert: result runCount = 0! !!MutantEvaluationResultTest methodsFor: 'testing'!testMutationResultKilledByError	| result |	result := resource evaluationResultForKilledMutantByError.	self assert: result killed.	self deny: result survived.	self deny: result terminated.	self assert: result runCount = 1! !!MutantEvaluationResultTest methodsFor: 'testing'!testMutationResultKilledByFailure	| result |	result := resource evaluationResultForKilledMutantByFailure.	self assert: result killed.	self deny: result survived.	self deny: result terminated.	self assert: result runCount = 1! !!MutantEvaluationResultTest methodsFor: 'testing'!testMutationResultSurvived	"Test the creation of a Mutant Result that survived"	| result |	result := resource evaluationResultForAliveMutant.	self deny: result killed.	self assert: result survived.	self deny: result terminated.	self assert: result runCount = 1! !!MutantEvaluationResultTest methodsFor: 'testing'!testMutationResultTerminated	| result |	result := resource evaluationResultForTerminatedMutant.	self deny: result killed.	self deny: result survived.	self assert: result terminated.	self assert: result runCount = 0! !!MutantEvaluationResultTest methodsFor: 'testing - printing'!testPrintingMutationResultEmpty	"printing a mutation result empty."	| result stream |	result := resource evaluationResultEmpty.	stream := WriteStream with: self mutantPrintString.	self assert: result printString = stream contents! !!MutantEvaluationResultTest methodsFor: 'testing - printing'!testPrintingMutationResultKilledByError	"printing a mutation result killed by error."	| result stream |	result := resource evaluationResultForKilledMutantByError.	stream := WriteStream with: self mutantPrintString.	self assert: result printString = stream contents! !!MutantEvaluationResultTest methodsFor: 'testing - printing'!testPrintingMutationResultKilledByFailure	"printing a mutation result killed by failure."	| result stream |	result := resource evaluationResultForKilledMutantByFailure.	stream := WriteStream with: self mutantPrintString.	self assert: result printString = stream contents! !!MutantEvaluationResultTest methodsFor: 'testing - printing'!testPrintingMutationResultSurvived	"printing a mutation result alive."	| result stream |	result := resource evaluationResultForAliveMutant.	stream := WriteStream with: self mutantPrintString.	self assert: result printString = stream contents! !!MutantEvaluationResultTest methodsFor: 'testing - printing'!testPrintingMutationResultTerminated	"printing a mutation result terminated."	| result stream |	result := resource evaluationResultForTerminatedMutant.	stream := WriteStream with: self mutantPrintString.	self assert: result printString = stream contents! !!MutantEvaluationStrategyTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('MutationTesting-Model')! !!MutantEvaluationStrategyTest class methodsFor: 'accessing'!resources	^ {MutationTestingResource}! !!MutantEvaluationStrategyTest methodsFor: 'building'!setUp	resource := MutationTestingResource current! !!MutantEvaluationStrategyTest methodsFor: 'testing'!testSelectingFromCoverageEvaluationStrategyShouldOnlyEvaluateSpecificTestCases	"tests that the message #testCasesToEvaluateFrom: returns only the test cases that cover the mutated code"	| classes mutationTestingAnalysis testCases mutation operator evaluationStrategy |	classes := OrderedCollection with: AuxiliarClassForTestingStrategies.	operator := ReplaceIfTrueWithIfFalseMutantOperator new.	evaluationStrategy := SelectingFromCoverageMutantEvaluationStrategy new.	mutationTestingAnalysis := MutationTestingAnalysis 		for: AuxiliarTestClassForTestingStrategies suite tests		mutating: classes		using: (Set with: operator)		with: evaluationStrategy		with: AllMutationsGenerationStrategy new.	mutationTestingAnalysis generateCoverageAnalysis.	mutation := (operator mutationsFor: AuxiliarClassForTestingStrategies >> #method1) asOrderedCollection first.	testCases := evaluationStrategy 		testCasesToEvaluate: mutation		for: mutationTestingAnalysis.	self assert: ((testCases collect: [ :each | each selector ]) includes: #testMethodThatCoverMethod1).	self deny: ((testCases collect: [ :each | each selector ]) includes: #testMethodThatCoverMethod2)! !!MutantGenerationStrategyTest methodsFor: 'testing'!testSelectingFromCoverageMutationsGenerationShouldOnlyMutateCoveredMethods	| classes mutationTestingAnalysis operator |	classes := OrderedCollection with: AuxiliarClassForTestingStrategies.	operator := ReplaceIfTrueWithIfFalseMutantOperator new.	mutationTestingAnalysis := MutationTestingAnalysis 		for: (MutationTestingAnalysis testCasesReferencesFrom: AuxiliarTestClassForTestingStrategies)		mutating: classes		using: (Set with: operator)		with: AllTestsMethodsRunningMutantEvaluationStrategy new		with: SelectingFromCoverageMutationsGenerationStrategy new.	mutationTestingAnalysis run.	self assert: ((mutationTestingAnalysis mutations collect: [ :each | each originalMethod selector ]) includes: #method1).	self deny: ((mutationTestingAnalysis mutations collect: [ :each | each originalMethod selector ]) includes: #aNotCoveredMethod)! !!MutantKillingSuggesionTest class methodsFor: 'accessing'!resources	^ {MutationTestingResource}! !!MutantKillingSuggesionTest methodsFor: 'accessing'!killedMutant	^resource evaluationResultForKilledMutantByError! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillRAO	^2 = (1 + 1) and: [ Set new isEmpty ].! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillRAOWithAssignments	|firstCondition secondCondition|	firstCondition := 2 = (1 + 1).	secondCondition := Set new isEmpty.	^firstCondition and: [secondCondition ]! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillRCOWithAssignments	|aValue anotherValue|	aValue := 1.	anotherValue :=2.	^aValue + anotherValue.! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillROA	^2 = (1 + 1) or: [ Set new isEmpty ].! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillROAWithAssignments	|firstCondition secondCondition|	firstCondition := 2 = (1 + 1).	secondCondition := Set new isEmpty.	^firstCondition or: [secondCondition ]! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillRemoveExceptionHandler	[1/0] on:Exception do:[:ex | Transcript show:'error'].! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillReplaceDoBlockWithEmptyBlock	OrderedCollection new do: [:each | Transcript show: each]! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillReplaceIfFalseReceiver	^ 1 = 1 ifFalse: [ 8 ]! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillReplaceIfTrueIfFalseReceiver	^ 1 = 1		ifTrue: [1]		ifFalse: [8]! !!MutantKillingSuggesionTest methodsFor: 'accessing'!methodToTestSuggestionToKillReplaceIfTrueReceiver	^ 1 = 1 ifTrue: [ 8 ]! !!MutantKillingSuggesionTest methodsFor: 'running'!setUp	resource := MutationTestingResource current! !!MutantKillingSuggesionTest methodsFor: 'accessing'!survivedMutant	^resource evaluationResultForAliveMutant! !!MutantKillingSuggesionTest methodsFor: 'accessing'!terminatedMutant	^resource evaluationResultForTerminatedMutant! !!MutantKillingSuggesionTest methodsFor: 'testing-results'!testSuggestionForKilledMutant	self assert: self killedMutant killingSuggestions = 'MUTANT KILLED'! !!MutantKillingSuggesionTest methodsFor: 'testing-results'!testSuggestionForSurvivedMutant	self assert: self survivedMutant killingSuggestions			= (MutantKillingSuggestionGenerator new suggestionFor: self survivedMutant mutant)! !!MutantKillingSuggesionTest methodsFor: 'testing-results'!testSuggestionForTerminatedMutant	self assert: self terminatedMutant killingSuggestions = 'MUTANT KILLED'! !!MutantKillingSuggesionTest methodsFor: 'testing-operators'!testSuggestionToKillRemoveCaret	| operator mutation |	operator := RemoveCaretOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillRCOWithAssignments) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) = 'It is missing a test case to check that the method is returning aValue + anotherValue'! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillRemoveExceptionHandler	| operator mutation |	operator := RemoveExceptionHandlerOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillRemoveExceptionHandler) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that when an exception of kind Exception is signaled, it is handled evaluating the block [ :ex | Transcript show: ''error'' ]'.! !!MutantKillingSuggesionTest methodsFor: 'testing-operators'!testSuggestionToKillReplaceAndForOr	| operator mutation mutationWithAssignment |	operator := ReplaceAndWithOrMutantOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillRAO) first.	mutationWithAssignment := (operator mutationsFor: self class >> #methodToTestSuggestionToKillRAOWithAssignments) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) = 'It is missing a test case where only one of the conditions 2 = (1 + 1) and [ Set new isEmpty ] is True.'.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutationWithAssignment) = 'It is missing a test case where only one of the conditions firstCondition and [ secondCondition ] is True.'! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillReplaceDoBlockWithEmptyBlock	| operator mutation |	operator := ReplaceDoBlockWithEmptyBlockOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillReplaceDoBlockWithEmptyBlock) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that there is an iteration doing [ :each | Transcript show: each ] on each element of OrderedCollection new'.! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillReplaceIfFalseReceiverWithFalse	| operator mutation |	operator := ReplaceIfFalseReceiverWithFalseOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillReplaceIfFalseReceiver) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that when 1 = 1 is true, [ 8 ] is not evaluated'.! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillReplaceIfFalseReceiverWithTrue	| operator mutation |	operator := ReplaceIfFalseReceiverWithTrueOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillReplaceIfFalseReceiver) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that when 1 = 1 is false, [ 8 ] is evaluated'.! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillReplaceIfTrueReceiverWithFalse	| operator mutation |	operator := ReplaceIfTrueReceiverWithFalseOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillReplaceIfTrueReceiver) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that when 1 = 1 is true, [ 8 ] is evaluated'.! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillReplaceIfTrueReceiverWithTrue	| operator mutation |	operator := ReplaceIfTrueReceiverWithTrueOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillReplaceIfTrueReceiver) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that when 1 = 1 is false, [ 8 ] is not evaluated'.! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillReplaceIfTrueifFalseReceiverWithFalse	| operator mutation |	operator := ReplaceIfTrueIfFalseReceiverWithFalseOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillReplaceIfTrueIfFalseReceiver) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that when 1 = 1 is true, [ 1 ] is evaluated and [ 8 ] is not'.! !!MutantKillingSuggesionTest methodsFor: 'testing'!testSuggestionToKillReplaceIfTrueifFalseReceiverWithTrue	| operator mutation |	operator := ReplaceIfTrueIfFalseReceiverWithTrueOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillReplaceIfTrueIfFalseReceiver) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) string = 'It is missing a test case to check that when 1 = 1 is false, [ 8 ] is evaluated and [ 1 ] is not'.! !!MutantKillingSuggesionTest methodsFor: 'testing-operators'!testSuggestionToKillReplaceOrForAnd	| operator mutation mutationWithAssignment |	operator := ReplaceOrWithAndMutantOperator new.	mutation := (operator mutationsFor: self class >> #methodToTestSuggestionToKillROA) first.	mutationWithAssignment := (operator mutationsFor: self class >> #methodToTestSuggestionToKillROAWithAssignments) first.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutation) = 'It is missing a test case where only one of the conditions 2 = (1 + 1) and [ Set new isEmpty ] is True.'.	self assert: (MutantKillingSuggestionGenerator new suggestionFor: mutationWithAssignment) = 'It is missing a test case where only one of the conditions firstCondition and [ secondCondition ] is True.'! !!MutantOperatorTest class methodsFor: 'testing'!isAbstract	^ self name = #MutantOperatorTest! !!MutantOperatorTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('MutationTesting-Model')! !!MutantOperatorTest methodsFor: 'asserts'!assertApplyingMutantToFirstSenderInOneSenderMethod	^ self compareSource: 				(self operator 						modifiedSourceFor: self class >> #methodWithOneSender						number: 1) 			withSourceInMethod: self class >> #methodWithOneSenderModified			replacingSelector: #methodWithOneSender! !!MutantOperatorTest methodsFor: 'asserts'!assertApplyingMutantToFirstSenderInTwoSendersMethod	^self 		compareSource: 			(self operator 					modifiedSourceFor: self class >> #methodWithTwoSenders					number: 1) 		withSourceInMethod: self class >> #methodWithTwoSendersModifiedFirst		replacingSelector: #methodWithTwoSenders! !!MutantOperatorTest methodsFor: 'asserts'!assertApplyingMutantToNonSenderMethod	^self 		compareSource: 			(self operator 					modifiedSourceFor: self class >> #methodWithNoSenders					number: 1) 		withSourceInMethod: self class >> #methodWithNoSenders		replacingSelector: #methodWithNoSenders! !!MutantOperatorTest methodsFor: 'asserts'!assertApplyingMutantToSecondSenderInTwoSendersMethod	^self 		compareSource: 			(self operator 					modifiedSourceFor: self class >> #methodWithTwoSenders					number: 2) 		withSourceInMethod: self class >> #methodWithTwoSendersModifiedSecond		replacingSelector: #methodWithTwoSenders! !!MutantOperatorTest methodsFor: 'asserts'!assertNumberMutantsGeneratedForNonSenderMethod	|mutationsGenerated|	mutationsGenerated := self operator mutationsFor: self class >> #methodWithNoSenders.	^mutationsGenerated size = 0.! !!MutantOperatorTest methodsFor: 'asserts'!assertNumberMutantsGeneratedForOneSenderMethod	|mutationsGenerated|	mutationsGenerated := self operator mutationsFor: self class >> #methodWithOneSender.	^mutationsGenerated size = 1.! !!MutantOperatorTest methodsFor: 'asserts'!assertNumberMutantsGeneratedForTwoSendersMethod	|mutationsGenerated|	mutationsGenerated := self operator mutationsFor: self class >> #methodWithTwoSenders.	^mutationsGenerated size = 2.! !!MutantOperatorTest methodsFor: 'asserts'!assertTimesToApplyOperatorInTwoSendersMethod	^ (self operator timesToApplyIn: self class >> #methodWithTwoSenders) = 2! !!MutantOperatorTest methodsFor: 'asserts'!assertTimesToApplyOperatorToNonSenderMethod	^ (self operator timesToApplyIn: self class >> #methodWithNoSenders) = 0! !!MutantOperatorTest methodsFor: 'asserts'!assertTimesToApplyOperatorToOneSenderMethod	^ (self operator timesToApplyIn: self class >> #methodWithOneSender) = 1! !!MutantOperatorTest methodsFor: 'formatting'!compareSource: aSource withSourceInMethod: aCompiledMethod replacingSelector: aSelector	"Compare both source replacing the selector of CompiledMethod for aSelector (to make then equal) 	and formatting both sources equally."	| sourceSelector secondString methodSelectorString secondStringModified |	sourceSelector := aSelector asString.	secondString := aCompiledMethod sourceCode asString.	methodSelectorString := aCompiledMethod selector asString.	secondStringModified := secondString		copyReplaceAll: methodSelectorString		with: sourceSelector.	^ (self formattedStringFor: aSource)		= (self formattedStringFor: secondStringModified)! !!MutantOperatorTest methodsFor: 'formatting'!formattedStringFor: aMethodString 	^ (RBParser parseMethod: aMethodString) formattedCode! !!MutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders	self subclassResponsibility! !!MutantOperatorTest methodsFor: 'accessing'!methodWithOneSender	self subclassResponsibility! !!MutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	self subclassResponsibility! !!MutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	self subclassResponsibility! !!MutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	self subclassResponsibility! !!MutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	self subclassResponsibility! !!MutantOperatorTest methodsFor: 'accessing'!operator	self subclassResponsibility! !!MutantOperatorTest methodsFor: 'testing'!operatorDescription	self subclassResponsibility ! !!MutantOperatorTest methodsFor: 'testing'!testApplyMutantToMethod	self assert: self assertApplyingMutantToNonSenderMethod.	self assert: self assertApplyingMutantToFirstSenderInOneSenderMethod.	self assert: self assertApplyingMutantToFirstSenderInTwoSendersMethod.	self assert: self assertApplyingMutantToSecondSenderInTwoSendersMethod! !!MutantOperatorTest methodsFor: 'testing'!testNumberMutantsGenerated	self assert: self assertNumberMutantsGeneratedForNonSenderMethod.	self assert: self assertNumberMutantsGeneratedForOneSenderMethod.	self assert: self assertNumberMutantsGeneratedForTwoSendersMethod! !!MutantOperatorTest methodsFor: 'testing'!testPrintingAccessors	self assert: self operator description = self operatorDescription.! !!MutantOperatorTest methodsFor: 'testing'!testTimesToApplyMutantToMethod	self assert: self assertTimesToApplyOperatorToNonSenderMethod.	self assert: self assertTimesToApplyOperatorToOneSenderMethod.	self assert: self assertTimesToApplyOperatorInTwoSendersMethod! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 + 2! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^Dictionary new 		at: 1 		ifAbsent: [2]! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^[2] value! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^Dictionary new 		at: 1 		ifAbsent: [Dictionary new 						at: 2 						ifAbsent: [3]]! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^[Dictionary new 		at: 2 		ifAbsent: [3]] value! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^Dictionary new 		at: 1 		ifAbsent: [[3] value]! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!operator	^ RemoveAtIfAbsentOperator new! !!RemoveAtIfAbsentMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^ 'Remove at:ifAbsent:' ! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	"a string that has ^ inside"	OrderedCollection new do: [:elem | elem notNil]! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^1 + 2! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	1 + 2! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	true 		ifTrue: [^1] 		ifFalse: [^2]! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	true 		ifTrue: [1] 		ifFalse: [^2]! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	true 		ifTrue: [^1] 		ifFalse: [2]! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!operator	^ RemoveCaretOperator new! !!RemoveCaretMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^ 'Remove ^' ! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	"[x y] on:E do:[:e| b] "	OrderedCollection new do: [:elem | elem notNil]! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^[1 /0] on:Exception do:[:ex | Transcript show: 'error'].! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^[1 /0] value ! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	[self error:'an error'] on:Exception do:[:ex | Transcript show: 'error'].	^[1 /0] on:Exception do:[:ex | Transcript show: 'error'].! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	[self error:'an error'.] value.	^[1 /0] on:Exception do:[:ex | Transcript show: 'error'].! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	[self error:'an error'] on:Exception do:[:ex | Transcript show: 'error'].	^[1 /0] value! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!operator	^ RemoveExceptionHandlerOperator new! !!RemoveExceptionHandlerOperatorTest methodsFor: 'accessing'!operatorDescription	^ 'Remove Exception Handler Operator'! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[false].! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSender	^1 = 2		and: [2 = 2]! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^1=2		and: [true]! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^1 = 2		and: [2 = 2 and: [3 = 3]]	! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^1=2		and: [true]! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^1 = 2		and: [2 = 2 and: [true]]! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!operator	^ ReplaceAndArgumentWithTrueOperator new.! !!ReplaceAndArgumentWithTrueOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #and: argument with [true]'! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1].! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSender	^1 = 2		and: [2 = 2]! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^true		and: [2 = 2]! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^1 = 2		and: [2 = 2 and: [3 = 3]]	! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^true		and: [2 = 2 and: [3 = 3]]! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^1 = 2		and: [true and: [3 = 3]]! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!operator	^ ReplaceAndReceiverWithTrueOperator new! !!ReplaceAndReceiverWithTrueOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #and: receiver with true'! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true or: [false]! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true and: [false]! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ true bEqv: [false]! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true and: [true and: [false]]! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ true bEqv: [true and: [false]]! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true and: [true bEqv: [false]]! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceAndWithEqvMutantOperator new! !!ReplaceAndWithEqvMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #and: with #bEqv:'! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true or: [false]! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true and: [false]! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ false! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true and: [true and: [false]]! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ false! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true and: [false]! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceAndWithFalseOperator new! !!ReplaceAndWithFalseMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #and: with false'! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true or: [false]! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true and: [false]! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ true nand: [false]! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true and: [true and: [false]]! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ true nand: [true and: [false]]! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true and: [true nand: [false]]! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceAndWithNandMutantOperator new! !!ReplaceAndWithNandMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #and: with #nand:'! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true or: [false]! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true and: [false]! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ true or: [false]! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true and: [true and: [false]]! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ true or: [true and: [false]]! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true and: [true or: [false]]! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceAndWithOrMutantOperator new! !!ReplaceAndWithOrMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #and: with #or:'! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^#(1) detect:[:each | true]  ! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^OrderedCollection new 		detect: [:each | each notNil] 		ifNone: [true]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified		^OrderedCollection new 		detect: [:each | false] 		ifNone: [true]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:number | 			|anotherNumber|			anotherNumber := collection 							detect: [:otherNumber | number > otherNumber] 							ifNone: [3].			anotherNumber = 1] 		ifNone: [0]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:each | false] 		ifNone: [0]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:number | 			|anotherNumber|			anotherNumber := collection 							detect: [:each | false] 							ifNone: [3].			anotherNumber = 1] 		ifNone: [0]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!operator	^ ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperator new! !!ReplaceDetectIfNoneFirstBlockWithAlwaysFalseBlockOperatorTest methodsFor: 'accessing'!operatorDescription 	^'Replace detect: block with [:each | false] when #detect:ifNone: ' ! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^#(1) detect:[:each | true]  ! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^OrderedCollection new 		detect: [:each | each notNil] 		ifNone: [true]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified		^OrderedCollection new 		detect: [:each | true] 		ifNone: [true]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:number | 			|anotherNumber|			anotherNumber := collection 							detect: [:otherNumber | number > otherNumber] 							ifNone: [3].			anotherNumber = 1] 		ifNone: [0]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:each | true] 		ifNone: [0]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:number | 			|anotherNumber|			anotherNumber := collection 							detect: [:each | true] 							ifNone: [3].			anotherNumber = 1] 		ifNone: [0]! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!operator	^ ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperator new! !!ReplaceDetectIfNoneFirstBlockWithAlwaysTrueBlockOperatorTest methodsFor: 'accessing'!operatorDescription 	^'Replace detect: block with [:each | true] when #detect:ifNone: ' ! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^#(1) detect:[:each | true]  ! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^OrderedCollection new 		detect: [:each | each notNil] 		ifNone: [true]! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^OrderedCollection new 		detect: [:each | each notNil] 		ifNone: []! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:number | 			|anotherNumber|			anotherNumber := collection 							detect: [:otherNumber | number > otherNumber] 							ifNone: [3].			anotherNumber = 1] 		ifNone: [0]! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:number | 			|anotherNumber|			anotherNumber := collection 							detect: [:otherNumber | number > otherNumber] 							ifNone: [3].			anotherNumber = 1] 		ifNone: []! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	|collection|	collection := OrderedCollection with: 1 with: 2.	^collection 		detect: [:number | 			|anotherNumber|			anotherNumber := collection 							detect: [:otherNumber | number > otherNumber] 							ifNone: [].			anotherNumber = 1] 		ifNone: [0]! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!operator	^ ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperator new! !!ReplaceDetectIfNoneSecondBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!operatorDescription 	^'Replace ifNone: block with [] when #detect:ifNone:'! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 + 2! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^OrderedCollection new 		do: [:element | element notNil]! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^OrderedCollection new 		do: [:each | ]! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	OrderedCollection new 		do: [:element | element notNil].	OrderedCollection new 		do: [:element | element isNil]! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	OrderedCollection new 		do: [:each | ].	OrderedCollection new 		do: [:element | element isNil]! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	OrderedCollection new 		do: [:element | element notNil].	OrderedCollection new 		do: [:each | ]! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!operator	^ ReplaceDoBlockWithEmptyBlockOperator new! !!ReplaceDoBlockWithEmptyBlockOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace do block with [:each |]'.! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 - 2! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ 2 >= 1! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ 2 = 1! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^ 1 >= 2 or: [2 >= 3].! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ 1 = 2 or: [2 >= 3].! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ 1 >= 2 or: [2 = 3].! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceGreaterOrEqualWithEqualMutantOperator new! !!ReplaceGreaterOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #''>='' with #=' ! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 - 2! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ 2 >= 1! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ 2 > 1! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^ 1 >= 2 or: [2 >= 3].! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ 1 > 2 or: [2 >= 3].! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ 1 >= 2 or: [2 > 3].! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceGreaterOrEqualWithGreaterMutantOperator new! !!ReplaceGreaterOrEqualWithGreaterMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #''>='' with #>' ! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1] ifFalse:[2].! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSender  	(1 = 2) ifFalse: [^true]. 	 ^false! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	false ifFalse: [^true]. 	 ^false! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	(1 = 1) ifFalse: [^true].	(1 = 2) ifFalse: [^true].	^false! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	false ifFalse: [^true].	(1 = 2) ifFalse: [^true].	^false! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	(1 = 1) ifFalse: [^true].	false ifFalse: [^true].	^false! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfFalseReceiverWithFalseOperator new! !!ReplaceIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifFalse: receiver with false'! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1] ifFalse:[2].! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSender  	(1 = 2) ifFalse: [^true]. 	 ^false! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	true ifFalse: [^true]. 	 ^false! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	(1 = 1) ifFalse: [^true].	(1 = 2) ifFalse: [^true].	^false! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	true ifFalse: [^true].	(1 = 2) ifFalse: [^true].	^false! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	(1 = 1) ifFalse: [^true].	true ifFalse: [^true].	^false! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfFalseReceiverWithTrueOperator new! !!ReplaceIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifFalse: receiver with true'! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 + 2! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	false ifFalse: [^true].  	^false! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified  	false ifTrue: [^true].  	^false! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	false ifFalse: [^true].	true ifFalse: [^true].	^false! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	false ifTrue: [^true].	true ifFalse: [^true].	^false! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	false ifFalse: [^true].	true ifTrue: [^true].	^false! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfFalseWithIfTrueMutantOperator new! !!ReplaceIfFalseWithIfTrueMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifFalse: with #ifTrue:'! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1].! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSender	1 = 2		ifTrue: [^ 1]		ifFalse: [^ 8]! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	false		ifTrue: [^ 1]		ifFalse: [^ 8]! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	|a|	a := (1 = 1) ifTrue: [1] ifFalse:[8].	^(1 = 2) ifTrue: [a + 1] ifFalse: [a + 8].	! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	|a|	a := false ifTrue: [1] ifFalse:[8].	^(1 = 2) ifTrue: [a + 1] ifFalse: [a + 8].! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	|a|	a := (1 = 1) ifTrue: [1] ifFalse:[8].	^false ifTrue: [a + 1] ifFalse: [a + 8].! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfTrueIfFalseReceiverWithFalseOperator new! !!ReplaceIfTrueIfFalseReceiverWithFalseOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifTrue:ifFalse: receiver with false'! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1].! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSender	1 = 2		ifTrue: [^ 1]		ifFalse: [^ 8]! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	true		ifTrue: [^ 1]		ifFalse: [^ 8]! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	|a|	a := (1 = 1) ifTrue: [1] ifFalse:[8].	^(1 = 2) ifTrue: [a + 1] ifFalse: [a + 8].	! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	|a|	a := true ifTrue: [1] ifFalse:[8].	^(1 = 2) ifTrue: [a + 1] ifFalse: [a + 8].! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	|a|	a := (1 = 1) ifTrue: [1] ifFalse:[8].	^true ifTrue: [a + 1] ifFalse: [a + 8].! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfTrueIfFalseReceiverWithTrueOperator new! !!ReplaceIfTrueIfFalseReceiverWithTrueOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifTrue:ifFalse: receiver with true'! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1] ifFalse:[2].! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSender  	(1 = 2) ifTrue: [^true]. 	 ^false! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	false ifTrue: [^true]. 	 ^false! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	(1 = 1) ifTrue: [^true].	(1 = 2) ifTrue: [^true].	^false! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	false ifTrue: [^true].	(1 = 2) ifTrue: [^true].	^false! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	(1 = 1) ifTrue: [^true].	false ifTrue: [^true].	^false! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfTrueReceiverWithFalseOperator new! !!ReplaceIfTrueReceiverWithFalseOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifTrue: receiver with false'! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1] ifFalse:[2].! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSender  	(1 = 2) ifTrue: [^true]. 	 ^false! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	true ifTrue: [^true]. 	 ^false! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	(1 = 1) ifTrue: [^true].	(1 = 2) ifTrue: [^true].	^false! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	true ifTrue: [^true].	(1 = 2) ifTrue: [^true].	^false! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	(1 = 1) ifTrue: [^true].	true ifTrue: [^true].	^false! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfTrueReceiverWithTrueOperator new! !!ReplaceIfTrueReceiverWithTrueOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifTrue: receiver with true'! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1] ifFalse:[2].! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	true ifTrue: [^true]. 	 ^false! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	true ifFalse: [^true]. 	 ^false! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	true ifTrue: [^true].	false ifTrue: [^true].	^false! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	true ifFalse: [^true].	false ifTrue: [^true].	^false! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	true ifTrue: [^true].	false ifFalse: [^true].	^false! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceIfTrueWithIfFalseMutantOperator new! !!ReplaceIfTrueWithIfFalseMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #ifTrue: with #ifFalse:'! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 + 2! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^OrderedCollection new isEmpty! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^OrderedCollection new notEmpty! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	OrderedCollection new isEmpty.	OrderedCollection new isEmpty! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	OrderedCollection new notEmpty.	OrderedCollection new isEmpty! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	OrderedCollection new isEmpty.	OrderedCollection new notEmpty! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!operator	^ReplaceIsEmptyWithNotEmptyMutantOperator new! !!ReplaceIsEmptyWithNotEmptyMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #isEmpty with #notEmpty'! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 - 2! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ 1 <= 2! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ 1 = 2! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^ 1 <= 2 or: [2 <= 3].! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ 1 = 2 or: [2 <= 3].! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ 1 <= 2 or: [2 = 3].! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceLessOrEqualWithEqualMutantOperator new! !!ReplaceLessOrEqualWithEqualMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #''<='' with #=' ! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 - 2! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ 1 <= 2! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ 1 < 2! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^ 1 <= 2 or: [2 <= 3].! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ 1 < 2 or: [2 <= 3].! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ 1 <= 2 or: [2 < 3].! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceLessOrEqualWithLessMutantOperator new! !!ReplaceLessOrEqualWithLessMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #''<='' with #<' ! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 + 2! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ 1 - 2! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ 1 + 2! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^ 1 - 2 - 3! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ 1 - 2 + 3! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ 1 + 2 - 3! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceMinusWithPlusMutantOperator new! !!ReplaceMinusWithPlusMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #- with #+'! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true and: [false]! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true or: [true]! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ true or: [false]! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true or: [true or: [true]]! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ true or: [false]! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true or: [true or: [false]]! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!operator	^ ReplaceOrArgumentWithFalseOperator new! !!ReplaceOrArgumentWithFalseOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #or: argument with [false]'! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	 1 + 2.	^ true ifTrue:[1].! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSender	^1 = 2		or: [2 = 2]! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^false		or: [2 = 2]! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^1 = 2		or: [2 = 2 or: [3 = 3]]	! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^false		or: [2 = 2 or: [3 = 3]]! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^1 = 2		or: [false or: [3 = 3]]! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!operator	^ ReplaceOrReceiverWithFalseOperator new! !!ReplaceOrReceiverWithFalseOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #or: receiver with false'! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true and: [false]! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true or: [false]! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ true and: [false]! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true or: [true or: [false]]! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ true and: [true or: [false]]! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true or: [true and: [false]]! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceOrWithAndMutantOperator new! !!ReplaceOrWithAndMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #or: with #and:'! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true and: [false]! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true or: [true]! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ true! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true or: [true or: [true]]! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ true! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true or: [true]! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!operator	^ ReplaceOrWithTrueOperator new! !!ReplaceOrWithTrueOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #or: with true'! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ true and: [false]! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ true or: [false]! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ true bXor: [false]! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders  	^ true or: [true or: [false]]! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ true bXor: [true or: [false]]! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ true or: [true bXor: [false]]! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceOrWithXorMutantOperator new! !!ReplaceOrWithXorMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #or: with #bXor:'! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 - 2! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^ 1 + 2! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^ 1 - 2! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	^ 1 + 2 + 3! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	^ 1 + 2 - 3! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	^ 1 - 2 + 3! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplacePlusWithMinusMutantOperator new! !!ReplacePlusWithMinusMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #+ with #-'! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 + 2! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^OrderedCollection new 		reject: [:element | element notNil]! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^OrderedCollection new 		select: [:element | element notNil]! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	OrderedCollection new 		reject: [:element | element notNil].	OrderedCollection new 		reject: [:element | element isNil]! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	OrderedCollection new 		select: [:element | element notNil].	OrderedCollection new 		reject: [:element | element isNil]! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	OrderedCollection new 		reject: [:element | element notNil].	OrderedCollection new 		select: [:element | element isNil]! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceRejectWithSelectMutantOperator new! !!ReplaceRejectWithSelectMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #reject: with #select:'! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!methodWithNoSenders  	^ 1 + 2! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!methodWithOneSender  	^OrderedCollection new 		select: [:element | element notNil]! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!methodWithOneSenderModified	^OrderedCollection new 		reject: [:element | element notNil]! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSenders	OrderedCollection new 		select: [:element | element notNil].	OrderedCollection new 		select: [:element | element isNil]! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedFirst	OrderedCollection new 		reject: [:element | element notNil].	OrderedCollection new 		select: [:element | element isNil]! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!methodWithTwoSendersModifiedSecond	OrderedCollection new 		select: [:element | element notNil].	OrderedCollection new 		reject: [:element | element isNil]! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!operator	^ ReplaceSelectWithRejectMutantOperator new! !!ReplaceSelectWithRejectMutantOperatorTest methodsFor: 'accessing'!operatorDescription	^'Replace #select: with #reject:'! !!MutationScoreTest methodsFor: 'accessing'!mutationResultAcceptable	^MutationTestingGeneralResult for: (OrderedCollection with: resource evaluationResultForKilledMutantByError)! !!MutationScoreTest methodsFor: 'accessing'!mutationResultAlmostAcceptable	^MutationTestingGeneralResult for: (OrderedCollection with: resource evaluationResultForKilledMutantByError with: resource evaluationResultForAliveMutant)! !!MutationScoreTest methodsFor: 'accessing'!mutationResultNonAcceptable	^MutationTestingGeneralResult 		for: (OrderedCollection with: resource evaluationResultForAliveMutant)! !!MutationScoreTest methodsFor: 'testing'!setUp	resource := MutationTestingResource current! !!MutationScoreTest methodsFor: 'testing'!testMutationScoreAcceptable	|score|	score := (MutationAcceptableScore scoreFor: self mutationResultAcceptable).	self assert: score isAcceptableScore.	self deny: score isNonAcceptableScore.	self deny: score isAlmostAcceptableScore.! !!MutationScoreTest methodsFor: 'testing'!testMutationScoreAlmostAcceptable	|score|	score := (MutationAlmostAcceptableScore scoreFor: self mutationResultAlmostAcceptable).	self deny: score isAcceptableScore.	self deny: score isNonAcceptableScore.	self assert: score isAlmostAcceptableScore.! !!MutationScoreTest methodsFor: 'testing'!testMutationScoreColor	|score|	score := (MutationScoreBehavior buildFor: self mutationResultAcceptable).	self assert: score color = Color green.		score := (MutationScoreBehavior buildFor: self mutationResultNonAcceptable).	self assert: score color = Color red.		score := (MutationScoreBehavior buildFor: self mutationResultAlmostAcceptable).	self assert: score color = Color yellow.! !!MutationScoreTest methodsFor: 'testing'!testMutationScoreCreation	|score|	score := (MutationScoreBehavior buildFor: self mutationResultAcceptable).	self assert: score isAcceptableScore.	score := (MutationScoreBehavior buildFor: self mutationResultAlmostAcceptable).	self assert: score isAlmostAcceptableScore.	score := (MutationScoreBehavior buildFor: self mutationResultNonAcceptable).	self assert: score isNonAcceptableScore.! !!MutationScoreTest methodsFor: 'testing'!testMutationScoreNonAcceptable	|score|	score := (MutationNonAcceptableScore scoreFor: self mutationResultNonAcceptable).	self deny: score isAcceptableScore.	self assert: score isNonAcceptableScore.	self deny: score isAlmostAcceptableScore.! !!MutationTestCaseResource class methodsFor: 'accessing'!packageNamesUnderTest	^ #('MutationTesting-Model')! !!MutationTestCaseResource methodsFor: 'accessing'!error	3 zork! !!MutationTestCaseResource methodsFor: 'accessing'!fail	self assert: false.! !!MutationTestCaseResource methodsFor: 'accessing'!pass	self assert: true! !!MutationTestingAnalysisLoggerTest methodsFor: 'testing'!testExecutingSimpleMutation	| analysis logger operator |	logger := MockMutationTestingAnalysisLogger new.	operator := ReplacePlusWithMinusMutantOperator new.	analysis := MutationTestingAnalysis				testCasesFrom: (Array with: AuxiliarClassForMutationTestingAnalysisTest)				mutating: (Array with: AuxiliarClassForMutationTestingAnalysis)				using: (Array with:operator)				logginIn: logger.	analysis run.	self assert: logger loggedStartAnalysis.	self		assert: (logger loggedStartBuildingMutationsFor: AuxiliarClassForMutationTestingAnalysis >> #methodWithOnePlusSender using: operator).	self assert: (logger loggedStartMutantEvaluationForMutationOf: (AuxiliarClassForMutationTestingAnalysis >> #methodWithOnePlusSender))! !!MutationTestingAnalysisTest class methodsFor: 'accessing'!classNamesNotUnderTest	^ #('MutationBrowser' 'MutationTestRunner' )! !!MutationTestingAnalysisTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('MutationTesting-Model')! !!MutationTestingAnalysisTest methodsFor: 'accessing'!ifFalseForIfTrueReplacementMutation	"Return a Collection with a Mutation Operation to be applied to the AuxiliarClass. 	In this case, the operation will be a boolean Replacement (ifFalse for ifTrue)."	| operator |	operator := ReplaceIfFalseWithIfTrueMutantOperator new.	^ OrderedCollection with: operator! !!MutationTestingAnalysisTest methodsFor: 'accessing'!ifTrueForIfFalseReplacementMutation	"Return a Collection with a Mutation Operation to be applied to the	DummyClass. In this case, the operation will be a boolean Replacement (ifTrue for ifFalse)."	| operator |	operator := ReplaceIfTrueWithIfFalseMutantOperator new.	^ OrderedCollection with: operator! !!MutationTestingAnalysisTest methodsFor: 'accessing'!minusForPlusReplacementMutation	"Return a Collection with a Mutation Operation to be applied to the method in MutationTestingAuxiliarClass. 	In this case, the operation will be an Arithmetic Replacement (Minus for Plus)."	| operator |	operator := ReplaceMinusWithPlusMutantOperator new.	^ OrderedCollection with: operator! !!MutationTestingAnalysisTest methodsFor: 'accessing'!plusForMinusReplacementMutation	"Return a Collection with a Mutation Operation to be applied to the	DummyClass. In this case, the operation will be an Arithmetic	Replacement (Plus for Minus)."	| operator |	operator := ReplacePlusWithMinusMutantOperator new.	^ OrderedCollection with: operator! !!MutationTestingAnalysisTest methodsFor: 'accessing'!selectForRejectReplacementMutation	| operator |	operator := ReplaceSelectWithRejectMutantOperator new.	^ OrderedCollection with: operator! !!MutationTestingAnalysisTest methodsFor: 'testing'!testExecutingSimpleMutation	| analysis results generalResult mutationResult |	analysis := MutationTestingAnalysis 		testCasesFrom: (Array with: AuxiliarClassForMutationTestingAnalysisTest)		mutating: (Array with: AuxiliarClassForMutationTestingAnalysis)		using: self plusForMinusReplacementMutation.	analysis run.	generalResult := analysis generalResult.	results := analysis particularResults.	self assert: results size = 1.	mutationResult := results first.	self assert: mutationResult killed.	self assert: generalResult numberOfKilledMutants = 1! !!MutationTestingAnalysisTest methodsFor: 'testing'!testExecutingSimpleMutationForClassMethods	| analysis results generalResult mutationResult |	analysis := MutationTestingAnalysis 		testCasesFrom: (Array with: AuxiliarClassForMutationTestingAnalysisTest)		mutating: (Array with: AuxiliarClassForMutationTestingAnalysis)		using: self selectForRejectReplacementMutation.	analysis run.	generalResult := analysis generalResult.	results := analysis particularResults.	self assert: results size = 1.	mutationResult := results first.	self assert: mutationResult killed.	self assert: generalResult numberOfKilledMutants = 1! !!MutationTestingAnalysisTest methodsFor: 'testing'!testExecutingSimpleMutationWhenNotRunnedAnalysis	| analysis results generalResult |	analysis := MutationTestingAnalysis 		testCasesFrom: (Array with: AuxiliarClassForMutationTestingAnalysisTest)		mutating: (Array with: AuxiliarClassForMutationTestingAnalysis)		using: self plusForMinusReplacementMutation.	"analysis run."	generalResult := analysis generalResult.	results := analysis particularResults.	self assert: results size = 0.	self assert: generalResult numberOfEvaluatedMutants = 0! !!MutationTestingAnalysisTest methodsFor: 'testing'!testExecutingTwoMutantsFromDiferentMethods	"Obtain 2 mutants using ifFalse-->ifTrue replacement in two diferent methods."	| analysis results operatorSelection |	operatorSelection := OrderedCollection new.	operatorSelection addAll: self ifFalseForIfTrueReplacementMutation.	analysis := MutationTestingAnalysis 		testCasesFrom: Array new		mutating: (Array with: AuxiliarClassForMutationTestingAnalysis)		using: operatorSelection.	analysis run.	results := analysis particularResults.	self assert: results size = 2.	results do: [ :mutationResult | self deny: mutationResult killed ]! !!MutationTestingAnalysisTest methodsFor: 'testing'!testExecutingTwoMutantsFromSameMethod	"Obtain 2 mutants using --->+ replacement in only one method."	| analysis results operatorSelection |	operatorSelection := OrderedCollection new.	operatorSelection addAll: self minusForPlusReplacementMutation.	analysis := MutationTestingAnalysis 		testCasesFrom: Array new		mutating: (Array with: AuxiliarClassForMutationTestingAnalysis)		using: operatorSelection.	analysis run.	results := analysis particularResults.	self assert: results size = 2.	results do: [ :mutationResult | self deny: mutationResult killed ]! !!MutationTestingAnalysisTest methodsFor: 'testing'!testExecutingTwoMutations	"Execute 2 diferent mutations #ifTrue-->#ifFalse: and	#+-->#-"	| analysis results generalResult operatorSelection |	operatorSelection := OrderedCollection new.	operatorSelection addAll: self plusForMinusReplacementMutation.	operatorSelection addAll: self ifTrueForIfFalseReplacementMutation.	analysis := MutationTestingAnalysis 		testCasesFrom: (Array with: AuxiliarClassForMutationTestingAnalysisTest)		mutating: (Array with: AuxiliarClassForMutationTestingAnalysis)		using: operatorSelection.	analysis run.	generalResult := analysis generalResult.	results := analysis particularResults.	self assert: results size = 2.	results do: [ :mutationResult | self assert: mutationResult killed ].	self assert: generalResult numberOfKilledMutants = 2! !!MutationTestingGeneralResultTest class methodsFor: 'accessing'!packageNamesUnderTest	^ #('MutationTesting-Model')! !!MutationTestingGeneralResultTest class methodsFor: 'accessing'!resources	^ {MutationTestingResource}! !!MutationTestingGeneralResultTest methodsFor: 'accessing'!mutationEngineGeneralEmptyResult	"Returns an empty Mutant Engine General Result."	^ MutationTestingGeneralResult empty! !!MutationTestingGeneralResultTest methodsFor: 'accessing'!mutationEngineGeneralResultWithOneAliveMutant	"Returns a Mutant Engine General Result with only one mutant survived."	^ MutationTestingGeneralResult for: (OrderedCollection with: resource evaluationResultForAliveMutant)! !!MutationTestingGeneralResultTest methodsFor: 'accessing'!mutationEngineGeneralResultWithOneKilledMutantByError	"Returns a Mutant Engine General Result with only one mutant killed by	error. "	^ MutationTestingGeneralResult for: (OrderedCollection with: resource evaluationResultForKilledMutantByError)! !!MutationTestingGeneralResultTest methodsFor: 'accessing'!mutationEngineGeneralResultWithOneKilledMutantByFailure	"Returns a Mutant Engine General Result with only one mutant killed by	failure."	^ MutationTestingGeneralResult for: (OrderedCollection with: resource evaluationResultForKilledMutantByFailure)! !!MutationTestingGeneralResultTest methodsFor: 'accessing'!mutationEngineGeneralResultWithOneTerminatedMutant	"Returns a Mutant Engine General Result with only one terminated mutant."	^ MutationTestingGeneralResult for: (OrderedCollection with: resource evaluationResultForTerminatedMutant)! !!MutationTestingGeneralResultTest methodsFor: 'building'!setUp	resource := MutationTestingResource current! !!MutationTestingGeneralResultTest methodsFor: 'testing'!testAccessorsOnEmptyResult	"Test the accessors methods for an empty result set"	| emptyResult |	emptyResult := self mutationEngineGeneralEmptyResult.	self assert: emptyResult numberOfEvaluatedMutants = 0.	self assert: emptyResult numberOfKilledMutants = 0.	self assert: emptyResult numberOfAliveMutants = 0.	self assert: emptyResult numberOfTerminatedMutants = 0.	self assert: emptyResult mutationScore = 0.	self assert: emptyResult isNonAcceptableScore.	self deny: emptyResult isAcceptableScore! !!MutationTestingGeneralResultTest methodsFor: 'testing'!testAccessorsWithOnlyOneAliveMutant	"Build a MutationEngineGeneralResult with only 1 alive mutant."	| mutantResult |	mutantResult := self mutationEngineGeneralResultWithOneAliveMutant.	self assert: mutantResult numberOfEvaluatedMutants = 1.	self assert: mutantResult numberOfKilledMutants = 0.	self assert: mutantResult numberOfAliveMutants = 1.	self assert: mutantResult numberOfTerminatedMutants = 0.	self assert: mutantResult mutationScore = 0.	self assert: mutantResult isNonAcceptableScore.	self deny: mutantResult isAcceptableScore! !!MutationTestingGeneralResultTest methodsFor: 'testing'!testAccessorsWithOnlyOneKilledMutantByError	"Build a MutationEngineGeneralResult with only 1 killed mutant by error."	| mutantResult |	mutantResult := self mutationEngineGeneralResultWithOneKilledMutantByError.	self assert: mutantResult numberOfEvaluatedMutants = 1.	self assert: mutantResult numberOfKilledMutants = 1.	self assert: mutantResult numberOfAliveMutants = 0.	self assert: mutantResult numberOfTerminatedMutants = 0.	self assert: mutantResult mutationScore = 100.	self deny: mutantResult isNonAcceptableScore.	self assert: mutantResult isAcceptableScore! !!MutationTestingGeneralResultTest methodsFor: 'testing'!testAccessorsWithOnlyOneKilledMutantByFailure	"Build a MutationEngineGeneralResult with only 1 killed mutant by failure."	| mutantResult |	mutantResult := self mutationEngineGeneralResultWithOneKilledMutantByFailure.	self assert: mutantResult numberOfEvaluatedMutants = 1.	self assert: mutantResult numberOfKilledMutants = 1.	self assert: mutantResult numberOfAliveMutants = 0.	self assert: mutantResult numberOfTerminatedMutants = 0.	self assert: mutantResult mutationScore = 100.	self deny: mutantResult isNonAcceptableScore.	self assert: mutantResult isAcceptableScore! !!MutationTestingGeneralResultTest methodsFor: 'testing'!testAccessorsWithOnlyOneTerminatedMutant	"Build a MutationEngineGeneralResult with only 1 terminated mutant."	| mutantResult |	mutantResult := self mutationEngineGeneralResultWithOneTerminatedMutant.	self assert: mutantResult numberOfEvaluatedMutants = 1.	self assert: mutantResult numberOfKilledMutants = 0.	self assert: mutantResult numberOfAliveMutants = 0.	self assert: mutantResult numberOfTerminatedMutants = 1.	self assert: mutantResult mutationScore = 100.	self assert: mutantResult isAcceptableScore.	self deny: mutantResult isNonAcceptableScore! !!MutationTestingGeneralResultTest methodsFor: 'testing - printing'!testPrintingOnEmptyResult	"Test printing an empty general result"	| emptyResult stream|	emptyResult := self mutationEngineGeneralEmptyResult.	stream := WriteStream with: '0 mutants, 0 killed, 0 alive, 0 terminated. Mutation Score: 0%.'.	self assert: emptyResult printString = stream contents.! !!MutationTestingGeneralResultTest methodsFor: 'testing - printing'!testPrintingWithOnlyOneAliveMutant	"printing a mutation general result with only one alive mutant."	| oneKilledMutantResult stream|	oneKilledMutantResult := self mutationEngineGeneralResultWithOneAliveMutant.	stream := WriteStream with: '1 mutants, 0 killed, 1 alive, 0 terminated. Mutation Score: 0%.'.	self assert: oneKilledMutantResult printString = stream contents.! !!MutationTestingGeneralResultTest methodsFor: 'testing - printing'!testPrintingWithOnlyOneKilledMutantByError	"printing a mutation general result with one mutant killed by error."	| oneKilledMutantResult stream|	oneKilledMutantResult := self mutationEngineGeneralResultWithOneKilledMutantByError.	stream := WriteStream with: '1 mutants, 1 killed, 0 alive, 0 terminated. Mutation Score: 100%.'.	self assert: oneKilledMutantResult printString = stream contents.! !!MutationTestingGeneralResultTest methodsFor: 'testing - printing'!testPrintingWithOnlyOneKilledMutantByFailure	"printing a mutation general result with one mutant killed by failure."	| oneKilledMutantResult stream |	oneKilledMutantResult := self mutationEngineGeneralResultWithOneKilledMutantByFailure.	stream := WriteStream with: '1 mutants, 1 killed, 0 alive, 0 terminated. Mutation Score: 100%.'.	self assert: oneKilledMutantResult printString = stream contents! !!MutationTestingGeneralResultTest methodsFor: 'testing - printing'!testPrintingWithOnlyOneTerminatedMutant	"printing a mutation general result with one mutant terminated."	| oneKilledMutantResult stream |	oneKilledMutantResult := self mutationEngineGeneralResultWithOneTerminatedMutant.	stream := WriteStream with: '1 mutants, 0 killed, 0 alive, 1 terminated. Mutation Score: 100%.'.	self assert: oneKilledMutantResult printString = stream contents! !!TestCaseReferenceTest methodsFor: 'resources'!test1	^self assert: true.! !!TestCaseReferenceTest methodsFor: 'resources'!testATestReferenceResult	| testReference |	testReference := self testReferenceForTest1.	self assert: testReference run errors isEmpty.	! !!TestCaseReferenceTest methodsFor: 'resources'!testReferenceForTest1	^ TestCaseReference 		for: #test1		in: self class! !!TestCasesSelectionStrategyTest methodsFor: 'as yet unclassified'!allTestsFromPackage	^ (OrderedCollection		with: TestClassForTestingCoverage		with: AuxiliarTestClassForTestingStrategies		with: AuxiliarClassForMutationTestingAnalysisTest)		inject: OrderedCollection new		into: [:tests :testClass | 			tests addAll: testClass suite tests.			tests]! !!TestCasesSelectionStrategyTest methodsFor: 'as yet unclassified'!allTestsIn: aCollection areIncludedIn: anotherCollection 	^ ((aCollection			collect: [:testCase | testCase selector])			includesAllOf: (anotherCollection					collect: [:testCase | testCase selector]))		and: [(anotherCollection				collect: [:testCase | testCase selector])				includesAllOf: (aCollection						collect: [:testCase | testCase selector])]! !!TestCasesSelectionStrategyTest methodsFor: 'as yet unclassified'!testClassTestCaseSelectionStrategy	| testCase |	testCase := TestClassForTestingCoverage selector: #testCase1.	self		assert: (self				allTestsIn: (ClassTestCasesSelectionStrategy new						testCasesFor: (OrderedCollection with: testCase))				areIncludedIn: TestClassForTestingCoverage suite tests)! !!TestCasesSelectionStrategyTest methodsFor: 'testing-class'!testClassTestCaseSelectionStrategyForEmptyTestSet	self assert: (ClassTestCasesSelectionStrategy new testCasesFor: OrderedCollection new) isEmpty! !!TestCasesSelectionStrategyTest methodsFor: 'as yet unclassified'!testNoneTestCaseSelectionStrategy	| testCase |	testCase := TestClassForTestingCoverage selector: #testCase1.	self assert: (NoneTestCasesSelectionStrategy new			testCasesFor: (OrderedCollection with: testCase))			= (OrderedCollection with: testCase)! !!TestCasesSelectionStrategyTest methodsFor: 'testing-none'!testNoneTestCaseSelectionStrategyForEmptyTestSet	self assert: (NoneTestCasesSelectionStrategy new testCasesFor: OrderedCollection new ) isEmpty! !!TestCasesSelectionStrategyTest methodsFor: 'as yet unclassified'!testPackageTestCaseSelectionStrategy	| testCase |	testCase := TestClassForTestingCoverage selector: #testCase1.	self		assert: (self				allTestsIn: (PackageTestCasesSelectionStrategy new						testCasesFor: (OrderedCollection with: testCase))				areIncludedIn: (self allTestsFromPackage))! !!TestCasesSelectionStrategyTest methodsFor: 'testing-package'!testPackageTestCaseSelectionStrategyForEmptyTestSet	self assert: (PackageTestCasesSelectionStrategy new testCasesFor: OrderedCollection new ) isEmpty! !!TestCoverageAnalysis methodsFor: 'testing'!testBugWhenHavingATestResourceSendingToOther	"the problem was when sending from a resource a message to another object wich class is going to be considered for coverage"	| analysis testCases|	analysis := CoverageAnalysis		for: (Array with: ClassForTestingCoverage with:TestResourceClassForTestingCoverage)		running: TestClassForTestingCoverage suite tests.	analysis run.	testCases := analysis result testCasesThatCovers: ClassForTestingCoverage class >> #aClassCoveredMethod.		self assert: ((testCases collect: [:each | each selector]) includes:#testCaseThatCoversAClassMethod).! !!TestCoverageAnalysis methodsFor: 'testing'!testCoveredMethods	| analysis |	analysis := CoverageAnalysis 		for: (Array with: ClassForTestingCoverage)		running: TestClassForTestingCoverage suite tests.	analysis run.		self assert: (analysis result coveredMethods includes: ClassForTestingCoverage >> #aCoveredMethod).	self deny: (analysis result coveredMethods includes: ClassForTestingCoverage >> #anUncoveredMethod)! !!TestCoverageAnalysis methodsFor: 'testing'!testGettingTheTestCasesThatCoverAClassMethod	| analysis testCases|	analysis := CoverageAnalysis		for: (Array with: ClassForTestingCoverage)		running: TestClassForTestingCoverage suite tests.	analysis run.	testCases := analysis result testCasesThatCovers: ClassForTestingCoverage class >> #aClassCoveredMethod.		self assert: ((testCases collect: [:each | each selector]) includes:#testCaseThatCoversAClassMethod).! !!TestCoverageAnalysis methodsFor: 'testing'!testGettingTheTestCasesThatCoverAMethod	| analysis testCases|	analysis := CoverageAnalysis 		for: (Array with: ClassForTestingCoverage)		running: TestClassForTestingCoverage suite tests.	analysis run.	testCases := analysis result testCasesThatCovers: ClassForTestingCoverage >> #aCoveredMethod.	self assert: ((testCases collect: [:each | each selector]) includes:#testCase1).	self deny: ((testCases collect: [:each | each selector]) includes:#testCase3).! !!MutationTestingResource methodsFor: 'building'!evaluationResultEmpty	"Build a MutationEvaluationResult empty"	| mutant testResultEmpty |	mutant := self mutation.	testResultEmpty := self testResultEmpty.	^ MutantEvaluationResult 		for: mutant		results: testResultEmpty! !!MutationTestingResource methodsFor: 'building'!evaluationResultForAliveMutant	"Build a MutationEvaluationResult for aMutant with only one survived"	| mutation testResultWithoutErrors |	mutation := self mutation.	testResultWithoutErrors := self testResultWithoutErrorOrFailure.	^ MutantEvaluationResult 		for: mutation		results: testResultWithoutErrors! !!MutationTestingResource methodsFor: 'building'!evaluationResultForKilledMutantByError	"Build a MutationEvaluationResult for aMutant with only one Error"	| mutation testResultWithOneError |	mutation := self mutation.	testResultWithOneError := self testResultWithError.	^ MutantEvaluationResult 		for: mutation		results: testResultWithOneError! !!MutationTestingResource methodsFor: 'building'!evaluationResultForKilledMutantByFailure	"Build a MutationEvaluationResult for aMutant with only one Failure"	| mutation testResultWithOneFailure |	mutation := self mutation.	testResultWithOneFailure := self testResultWithFailure.	^ MutantEvaluationResult 		for: mutation		results: testResultWithOneFailure! !!MutationTestingResource methodsFor: 'building'!evaluationResultForTerminatedMutant	"Build a MutationEvaluationResult for aMutant terminated"	| mutation |	mutation := self mutation.	^ MutantEvaluationResult 		for: mutation		results: nil! !!MutationTestingResource methodsFor: 'building-private'!methodForBuildingMutant	^1+2! !!MutationTestingResource methodsFor: 'building-private'!mutation	"Build Mock Object that simulates a Mutant"	| method |	method := self class >> #methodForBuildingMutant.	^ MethodMutation 		for: method		using: ReplacePlusWithMinusMutantOperator new		result: 'methodForBuildingMutant  ^ 1 - 2'		ofClass: self class! !!MutationTestingResource methodsFor: 'building'!setUp	testResource := MutationTestCaseResource new! !!MutationTestingResource methodsFor: 'building-private'!testResultEmpty	"Build a TestResult empty"	^ TestResult new! !!MutationTestingResource methodsFor: 'building-private'!testResultWithError	"Build a TestResult with error"	| case |	case := testResource class selector: #error.	^ case run! !!MutationTestingResource methodsFor: 'building-private'!testResultWithFailure	"Build a TestResult with failure"	| case |	case := testResource class selector: #fail.	^ case run! !!MutationTestingResource methodsFor: 'building-private'!testResultWithoutErrorOrFailure	"Build a TestResult without errors or failures"	| case |	case := testResource class selector: #pass.	^ case run! !!MockMutationTestingAnalysisLogger class methodsFor: 'instance creation'!new	^super new initialize.! !!MockMutationTestingAnalysisLogger methodsFor: 'initialize-release'!initialize 	loggedStartAnalysis := false.	loggedStartBuildingMutations := OrderedCollection new.	loggedEvaluationMutations := OrderedCollection new.! !!MockMutationTestingAnalysisLogger methodsFor: 'loggin'!logAnalysisStartFor: aMutationTestingAnalysis 	loggedStartAnalysis := true.! !!MockMutationTestingAnalysisLogger methodsFor: 'loggin'!logStartBuildingMutantionsFor: aCompiledMethod using: aMutantOperator	loggedStartBuildingMutations add:(Array with:aCompiledMethod with: aMutantOperator ). 	! !!MockMutationTestingAnalysisLogger methodsFor: 'logging'!logStartEvaluating: aMethodMutation 	loggedEvaluationMutations add: aMethodMutation.! !!MockMutationTestingAnalysisLogger methodsFor: 'testing'!loggedStartAnalysis	^loggedStartAnalysis! !!MockMutationTestingAnalysisLogger methodsFor: 'testing'!loggedStartBuildingMutationsFor: aCompiledMethod using: aMutantOperator	^loggedStartBuildingMutations anySatisfy:[:array | (array at:1 ) = aCompiledMethod and:[(array at:2) = aMutantOperator ]]  	! !!MockMutationTestingAnalysisLogger methodsFor: 'testing'!loggedStartMutantEvaluationForMutationOf: aCompiledMethod 	^ loggedEvaluationMutations		anySatisfy: [:aMutation | aMutation originalMethod = aCompiledMethod]! !"MuTalk-Tests"!!NeoCSVReader commentStamp: '' prior: 0!I am NeoCSVReader.I read a format that- is text based (ASCII, Latin1, Unicode)- consists of records, 1 per line (any line ending convention)- where records consist of fields separated by a delimiter (comma, tab, semicolon)- where every record has the same number of fields- where fields can be quoted should they contain separators or line endingsWithout further configuration, records will become Arrays of Strings.By specifiying a recordClass and fields with optional converters most objects can be read and instanciated correctly.MIT License.!!NeoCSVWriter commentStamp: '' prior: 0!I am NeoCSVWriter.I write a format that- is text based (ASCII, Latin1, Unicode)- consists of records, 1 per line (any line ending convention)- where records consist of fields separated by a delimiter (comma, tab, semicolon)- where every record has the same number of fields- where fields can be quoted should they contain separators or line endingsWithout further configuration, I write record objects whose fields can be enumerated using #do: such as SequenceableCollectionsBy specifiying fields any object can be written converting and/or quoting each field as needed.MIT License.!!NeoNumberParser commentStamp: '' prior: 0!I am NeoNumberParser, an alternative number parser that needs only a minimal read stream protocol. I accept the following syntax:	number	  int	  int frac	  int exp	  int frac exp	int	  digits	  - digits	frac	  . digits	exp	  e digits	digits	  digit	  digit digits	e	  e	  e+	  e-	  E	  E+	  E-where digit depends on the base (2 to 36), 0 .. 9, A-Z, a-z.!!NeoCSVReader class methodsFor: 'instance creation'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoCSVReader methodsFor: 'initialize-release'!addField	"Add the next indexable field with a pass through converter"		self		recordClassIsIndexable: true; 		addFieldAccessor: [ :string | string ]! !!NeoCSVReader methodsFor: 'initialize-release'!addField: accessor	"Add a field based on a mutator accessor accepting a field 	String as argument to be sent to an instance of recordClass.	Accessor can be a Symbol or a Block"		self		recordClassIsIndexable: false; 		addFieldAccessor: [ :object :string |			self applyAccessor: accessor on: object with: string ]! !!NeoCSVReader methodsFor: 'initialize-release'!addField: accessor converter: converter	"Add a field based on a mutator accessor accepting the result of 	applying the converter block on the field String read as argument 	to be sent to an instance of recordClass.	Accessor can be a Symbol or a Block"	self		recordClassIsIndexable: false; 		addFieldAccessor: [ :object :string |			self applyAccessor: accessor on: object with: (converter value: string) ]! !!NeoCSVReader methodsFor: 'private'!addFieldAccessor: block	fieldAccessors 		ifNil: [			fieldAccessors := Array with: block ]		ifNotNil: [			fieldAccessors := fieldAccessors copyWith: block ]! !!NeoCSVReader methodsFor: 'initialize-release'!addFieldAt: key	"Add a field that will be stored under key in recordClass as String"		self		recordClassIsIndexable: false; 		addFieldAccessor: [ :object :string |			object at: key put: string ]! !!NeoCSVReader methodsFor: 'initialize-release'!addFieldAt: key converter: converter	"Add a field that will be stored under key in recordClass as the result of 	applying the converter block on the field String read as argument"	self		recordClassIsIndexable: false; 		addFieldAccessor: [ :object :string |			object at: key put: (converter value: string) ]! !!NeoCSVReader methodsFor: 'initialize-release'!addFieldConverter: converter	"Add the next indexable field with converter block, 	accepting a String and returning a specific object"	self		recordClassIsIndexable: true; 		addFieldAccessor: converter! !!NeoCSVReader methodsFor: 'convenience'!addFields: accessors	"Add fields based on a collection of accessors, not doing any conversions."		accessors do: [ :each |		self addField: each ]! !!NeoCSVReader methodsFor: 'convenience'!addFieldsAt: keys	"Add fields based on a collection of keys for #at:put: not doing any conversions"	keys do: [ :each |		self addFieldAt: each ]! !!NeoCSVReader methodsFor: 'convenience'!addFloatField	"Add a field for indexable records parsed as Float"	self addFieldConverter: [ :string | NeoNumberParser parse: string ]! !!NeoCSVReader methodsFor: 'convenience'!addFloatField: accessor	"Add a field with accessor parsed as Float"	self 		addField: accessor 		converter: [ :string | NeoNumberParser parse: string ]! !!NeoCSVReader methodsFor: 'convenience'!addFloatFieldAt: key	"Add a field for key for #at:put: parsed as Float"	self 		addFieldAt: key 		converter: [ :string | NeoNumberParser parse: string ]! !!NeoCSVReader methodsFor: 'convenience'!addFloatFieldRadixPointComma	"Add a field for indexable records parsed as Float using a comma as radix point"	self addFieldConverter: [ :string | (NeoNumberParser on: string) radixPoint: $, ; next ]! !!NeoCSVReader methodsFor: 'convenience'!addFloatFieldRadixPointCommaAt: key	"Add a field for key for #at:put: parsed as Float using a comma as radix point"	self 		addFieldAt: key 		converter: [ :string | (NeoNumberParser on: string) radixPoint: $, ; next ]! !!NeoCSVReader methodsFor: 'initialize-release'!addIgnoredField	"Add a field that should be ignored, should not become part of the record"	self addFieldAccessor: nil! !!NeoCSVReader methodsFor: 'initialize-release'!addIgnoredFields: count	"Add a count of consecutive ignored fields to receiver."	count timesRepeat: [ self addIgnoredField ]! !!NeoCSVReader methodsFor: 'convenience'!addIntegerField	"Add a field for indexable records parsed as Integer"	self addFieldConverter: [ :string | NeoNumberParser parse: string ]! !!NeoCSVReader methodsFor: 'convenience'!addIntegerField: accessor	"Add a field with accessor parsed as Integer"	self 		addField: accessor 		converter: [ :string | NeoNumberParser parse: string ]! !!NeoCSVReader methodsFor: 'convenience'!addIntegerFieldAt: key	"Add a field for key for #at:put: parsed as Integer"	self 		addFieldAt: key 		converter: [ :string | NeoNumberParser parse: string ]! !!NeoCSVReader methodsFor: 'convenience'!addSymbolField	"Add a field for indexable records read as Symbol"	self addFieldConverter: [ :string | string asSymbol ]! !!NeoCSVReader methodsFor: 'convenience'!addSymbolField: accessor	"Add a field with accessor read as Symbol"	self 		addField: accessor 		converter: [ :string | string asSymbol ]! !!NeoCSVReader methodsFor: 'convenience'!addSymbolFieldAt: key	"Add a field for key for #at:put: read as Symbol"	self 		addFieldAt: key 		converter: [ :string | string asSymbol ]! !!NeoCSVReader methodsFor: 'private'!applyAccessor: accessor on: object with: value	"Use accessor to assign value on a property of object.	Accessor can be a block or mutator symbol."		"If Symbol implemented #value:value: this could be implemented more elegantly."		accessor isBlock		ifTrue: [ accessor value: object value: value ] 		ifFalse: [ object perform: accessor with: value ]! !!NeoCSVReader methodsFor: 'testing'!atEnd	^ charBuffer == nil and: [ readStream atEnd ]! !!NeoCSVReader methodsFor: 'initialize-release'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoCSVReader methodsFor: 'accessing'!do: block	"Execute block for each record until I am at end."		[ self atEnd ]		whileFalse: [ 			block value: self next ]! !!NeoCSVReader methodsFor: 'initialize-release'!emptyFieldValue: object	"Set the value to be used when reading empty or missing fields.	The default is nil. Empty or missing fields are never set 	when the record class is non-indexeabe, nor are they passed to converters.	The special #passNil can be set to force that in the case of 	an empty or missing field nil *is* passed to a converter block	so that per field empty values or specific behavior are possible."		emptyFieldValue := object! !!NeoCSVReader methodsFor: 'initialize-release'!fieldCount: anObject	"Set the field count up front.	This will be used when reading records as Arrays.	This instance variable will be set and used automatically based on the first record seen.	If set, the fieldAccessors collection defines (overrides) the fieldCount."	fieldCount := anObject! !!NeoCSVReader methodsFor: 'initialize-release'!initialize	super initialize.	recordClass := Array.	recordClassIsIndexable := true.	separator := $,! !!NeoCSVReader methodsFor: 'convenience'!namedColumnsConfiguration	"Assuming there is a header row that has not yet been read,	configure the receiver to read each row as a Dictionary where	each field is stored under a column name.	Note that each field is read as a string."		self recordClass: Dictionary.	self addFieldsAt: (self readHeader collect: [ :each | each asSymbol ])! !!NeoCSVReader methodsFor: 'accessing'!next	"Read the next record.	I will return an instance of recordClass."		^ recordClassIsIndexable		ifTrue: [ self readNextRecordAsArray ] 		ifFalse: [ self readNextRecordAsObject ]! !!NeoCSVReader methodsFor: 'private'!nextChar	^ charBuffer 		ifNil: [ 			readStream next ]		ifNotNil: [ | char |			char := charBuffer.			charBuffer := nil.			^ char ]! !!NeoCSVReader methodsFor: 'initialize-release'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoCSVReader methodsFor: 'private'!peekChar	^ charBuffer 		ifNil: [ 			charBuffer := readStream next ]! !!NeoCSVReader methodsFor: 'private'!peekEndOfLine	| char |	char := self peekChar codePoint.	^ (char == 10 "Character lf" ) or: [ char == 13 "Character cr" ]! !!NeoCSVReader methodsFor: 'private'!peekFor: character	self peekChar == character		ifTrue: [ 			self nextChar. 			^ true ].	^ false! !!NeoCSVReader methodsFor: 'private'!peekQuote	^ self peekChar == $"! !!NeoCSVReader methodsFor: 'private'!peekSeparator	^ self peekChar == separator! !!NeoCSVReader methodsFor: 'private'!readAtEndOrEndOfLine	^ self atEnd or: [ self readEndOfLine ]! !!NeoCSVReader methodsFor: 'private'!readEndOfLine	| char |	char := self peekChar codePoint.	char == 10 "Character lf"		ifTrue: [ 			self nextChar. 			^ true ].	char == 13 "Character cr"		ifTrue: [			self nextChar.			(self atEnd not and: [ self peekChar codePoint == 10 "Character lf" ])				ifTrue: [ 					self nextChar ]. 			^ true  ].	^ false! !!NeoCSVReader methodsFor: 'private'!readEndOfQuotedField		"A double quote inside a quoted field is an embedded quote (escaped)"		^ self readQuote and: [ self peekQuote not ]! !!NeoCSVReader methodsFor: 'private - reading'!readField	^ self peekQuote		ifTrue: [			self readQuotedField ]		ifFalse: [			self readUnquotedField ]! !!NeoCSVReader methodsFor: 'private - reading'!readFieldAndSeparator	| field |	field := self readField.	self readSeparator.	^ field! !!NeoCSVReader methodsFor: 'private - reading'!readFirstRecord 	"This is only used for array based records when there are no field accessors or 	when there is no field count, to obtain a field count based on the first record"		^ recordClass streamContents: [ :stream |		[ self readAtEndOrEndOfLine ]			whileFalse: [ 				stream nextPut: self readField.				(self readSeparator and: [ self atEnd or: [ self peekEndOfLine ] ])					ifTrue: [ stream nextPut: emptyFieldValue ] ] ]! !!NeoCSVReader methodsFor: 'accessing'!readHeader	"Read a record, presumably a header and return the header field names.	This should normally be called only at the beginning and only once.	This sets the fieldCount (but fieldAccessors overrides fieldCount)."	| names |	names := Array streamContents: [ :out |		 [ self readAtEndOrEndOfLine ]			whileFalse: [ 				out nextPut: self readField.				(self readSeparator and: [ self atEnd or: [ self peekEndOfLine ] ])					ifTrue: [ out nextPut: emptyFieldValue ] ] ].	fieldCount := names size.	^ names! !!NeoCSVReader methodsFor: 'private - reading'!readNextRecord	| record |	record := recordClass new: fieldCount.	fieldAccessors		ifNil: [ self readNextRecordWithoutFieldAccessors: record ]		ifNotNil: [ self readNextRecordWithFieldAccessors: record ].	self readAtEndOrEndOfLine.	^ record! !!NeoCSVReader methodsFor: 'private - reading'!readNextRecordAsArray	fieldAccessors ifNotNil: [ 		fieldCount := fieldAccessors count: [ :each | each notNil ] ].	^ fieldCount 		ifNil: [ | record |			record := self readFirstRecord.			fieldCount := record size.			record ] 		ifNotNil: [			self readNextRecord ]! !!NeoCSVReader methodsFor: 'private - reading'!readNextRecordAsObject	| object |	object := recordClass new.	fieldAccessors do: [ :each | | rawValue |		rawValue := self readFieldAndSeparator.		"nil field accessors are used to ignore fields"		each 			ifNotNil: [  				rawValue = emptyFieldValue					ifTrue: [ 						emptyFieldValue = #passNil 							ifTrue: [ each value: object value: nil ] ]					ifFalse: [ each value: object value: rawValue ] ] ].	self readAtEndOrEndOfLine.	^ object! !!NeoCSVReader methodsFor: 'private - reading'!readNextRecordWithFieldAccessors: record	| fieldIndex |	fieldIndex := 1.	fieldAccessors do: [ :each | | rawValue |		rawValue := self readFieldAndSeparator.		"nil field accessors are used to ignore fields"		each			ifNotNil: [ 				rawValue = emptyFieldValue					ifTrue: [ 						emptyFieldValue = #passNil							ifTrue: [ record at: fieldIndex put: (each value: nil) ]							ifFalse: [ record at: fieldIndex put: emptyFieldValue ] ]					ifFalse: [ record at: fieldIndex put: (each value: rawValue) ].				fieldIndex := fieldIndex + 1 ] ]! !!NeoCSVReader methodsFor: 'private - reading'!readNextRecordWithoutFieldAccessors: record	1 to: fieldCount do: [ :each |		record at: each put: self readFieldAndSeparator ]! !!NeoCSVReader methodsFor: 'private'!readQuote	^ self peekFor: $"! !!NeoCSVReader methodsFor: 'private - reading'!readQuotedField	| field |	self readQuote.	field := self stringStreamContents: [ :stream |		[ self atEnd or: [ self readEndOfQuotedField ] ]			whileFalse: [				stream nextPut: self nextChar ] ].	^ field isEmpty		ifTrue: [ emptyFieldValue ]		ifFalse: [ field ]! !!NeoCSVReader methodsFor: 'private'!readSeparator	^ self peekFor: separator! !!NeoCSVReader methodsFor: 'private - reading'!readUnquotedField	(self atEnd or: [ self peekSeparator or: [ self peekEndOfLine ] ])		ifTrue: [ ^ emptyFieldValue ].	^ self stringStreamContents: [ :stream |		[ self atEnd or: [ self peekSeparator or: [ self peekEndOfLine ] ] ]			whileFalse: [ 				stream nextPut: self nextChar ] ]! !!NeoCSVReader methodsFor: 'initialize-release'!recordClass: anObject	"Set the object class to instanciate while reading records.	Unless the objets are integer indexable, you have to specify fields as well."		recordClass := anObject! !!NeoCSVReader methodsFor: 'initialize-release'!recordClassIsIndexable: boolean	"Set whether recordClass should be treated as an indexable sequenceable collection	class that implements #new: and #streamContents and whose instances implement #at:put: 	If false, fields accessors have to be provided. The default is true.	Will be set automatically when field accessors or converters are set."		recordClassIsIndexable := boolean ! !!NeoCSVReader methodsFor: 'accessing'!select: filter	"Read and collect records that satisfy filter into an Array until there are none left.	Return the array."	^ Array streamContents: [ :stream | 		self 			select: filter 			thenDo: [ :each | stream nextPut: each ] ]! !!NeoCSVReader methodsFor: 'accessing'!select: filter thenDo: block	"Execute block for each record that satisfies filter until I am at end."	[ self atEnd ]		whileFalse: [ 			| record |			record := self next.			(filter value: record)				ifTrue: [ block value: record ] ]! !!NeoCSVReader methodsFor: 'initialize-release'!separator: character	"Set the field separator character to use, defaults to comma"		self assert: character isCharacter.	separator := character ! !!NeoCSVReader methodsFor: 'accessing'!skip	"Skip one record by reading until end of line.	This is faster than #next and has no side effects."		[ self readAtEndOrEndOfLine ] whileFalse: [ self nextChar ]! !!NeoCSVReader methodsFor: 'convenience'!skip: count	"Skip count records by reading until end of line.	This is faster than #next and has no side effects."	count timesRepeat: [ self skip ]! !!NeoCSVReader methodsFor: 'convenience'!skipHeader	"Read a record, presumably a header, with the intention of skipping it.	This should normally be called only at the beginning and only once.	This sets the fieldCount (but fieldAccessors overrides fieldCount)."	self readHeader! !!NeoCSVReader methodsFor: 'private'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"		stringStream 		ifNil: [ 			stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoCSVReader methodsFor: 'accessing'!upToEnd 	"Read and collect records into an Array until there are none left.	Return the array."		^ Array streamContents: [ :stream |		self do: [ :each | stream nextPut: each ] ]! !!NeoCSVWriter class methodsFor: 'instance creation'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoCSVWriter methodsFor: 'initialize-release'!addConstantField: string	"Add a constant field to be written using fieldWriter"	self addFieldAccessor: [ :object |		self writeField: string ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addEmptyField	"Add an empty field to be written using fieldWriter"	self addFieldAccessor: [ :object |		self writeField: '' ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addField: accessor	"Add a field based on an accessor to be written using fieldWriter.	Accessor can be a Symbol or a Block"	self addFieldAccessor: [ :object |		self writeField: (accessor value: object) ]! !!NeoCSVWriter methodsFor: 'private'!addFieldAccessor: block	fieldAccessors 		ifNil: [			fieldAccessors := Array with: block ]		ifNotNil: [			fieldAccessors := fieldAccessors copyWith: block ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addFieldAt: key	"Add a field based on a key to be written using fieldWriter"	self addFieldAccessor: [ :object |		self writeField: (object at: key ifAbsent: [ '' ]) ]! !!NeoCSVWriter methodsFor: 'convenience'!addFields: accessors	accessors do: [ :each |		self addField: each ]! !!NeoCSVWriter methodsFor: 'convenience'!addFieldsAt: keys	keys do: [ :each |		self addFieldAt: each ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addObjectField: accessor	"Add a field based on an accessor to be written as an #object field.	Accessor can be a Symbol or a Block"	self addFieldAccessor: [ :object |		self writeObjectField: (accessor value: object) ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addObjectFieldAt: key	"Add a field based on a key to be written as an #object field"	self addFieldAccessor: [ :object |		self writeObjectField: (object at: key) ]! !!NeoCSVWriter methodsFor: 'convenience'!addObjectFields: accessors	accessors do: [ :each |		self addObjectField: each ]! !!NeoCSVWriter methodsFor: 'convenience'!addObjectFieldsAt: keys	keys do: [ :each |		self addObjectFieldAt: each ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addOptionalQuotedField: accessor	"Add a field based on an accessor to be written as a #optionalQuoted field.	Accessor can be a Symbol or a Block"	self addFieldAccessor: [ :object |		self writeOptionalQuotedField: (accessor value: object) ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addOptionalQuotedFieldAt: key	"Add a field based on a key to be written as a #optionalQuoted field"	self addFieldAccessor: [ :object |		self writeOptionalQuotedField: (object at: key) ]! !!NeoCSVWriter methodsFor: 'convenience'!addOptionalQuotedFields: accessors	accessors do: [ :each |		self addOptionalQuotedField: each ]! !!NeoCSVWriter methodsFor: 'convenience'!addOptionalQuotedFieldsAt: keys	keys do: [ :each |		self addOptionalQuotedFieldAt: each ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addQuotedField: accessor	"Add a field based on an accessor to be written as a #quoted field.	Accessor can be a Symbol or a Block"	self addFieldAccessor: [ :object |		self writeQuotedField: (accessor value: object) ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addQuotedFieldAt: key	"Add a field based on a key to be written as a #quoted field"	self addFieldAccessor: [ :object |		self writeQuotedField: (object at: key) ]! !!NeoCSVWriter methodsFor: 'convenience'!addQuotedFields: accessors	accessors do: [ :each |		self addQuotedField: each ]! !!NeoCSVWriter methodsFor: 'convenience'!addQuotedFieldsAt: keys	keys do: [ :each |		self addQuotedFieldAt: each ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addRawField: accessor	"Add a field based on an accessor to be written as a #raw field.	Accessor can be a Symbol or a Block"	self addFieldAccessor: [ :object |		self writeRawField: (accessor value: object) ]! !!NeoCSVWriter methodsFor: 'initialize-release'!addRawFieldAt: key	"Add a field based on a key to be written as a #raw field"	self addFieldAccessor: [ :object |		self writeRawField: (object at: key) ]! !!NeoCSVWriter methodsFor: 'convenience'!addRawFields: accessors	accessors do: [ :each |		self addRawField: each ]! !!NeoCSVWriter methodsFor: 'convenience'!addRawFieldsAt: keys	keys do: [ :each |		self addRawFieldAt: each ]! !!NeoCSVWriter methodsFor: 'initialize-release'!close	writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoCSVWriter methodsFor: 'initialize-release'!emptyFieldValue: object	"Set the empty field value to object.	When reading fields from records to be written out, 	if the field value equals the emptyFieldValue,	it will be considered an empty field and written as such."		emptyFieldValue := object! !!NeoCSVWriter methodsFor: 'accessing'!fieldWriter: symbol	"Set the field write to be used, either #quoted (the default), #raw or #object.	This determines how field values will be written in the general case.	#quoted will wrap fields #asString in double quotes and escape embedded double quotes	#raw will write fields #asString as such (no separator, double quote or end of line chars allowed)	#optionalQuoted will write fields using #raw if possible (no separators, ...), and #quoted otherwise	#object will #print: fields (no separator, double quote or end of line chars allowed)"		self assert: (#(quoted raw object optionalQuoted) includes: symbol).	fieldWriter := ('write', symbol capitalized, 'Field:') asSymbol	! !!NeoCSVWriter methodsFor: 'accessing'!flush	writeStream flush! !!NeoCSVWriter methodsFor: 'initialize-release'!initialize 	super initialize.	lineEnd := String crlf.	separator := $, .	fieldWriter := #writeQuotedField: ! !!NeoCSVWriter methodsFor: 'initialize-release'!lineEndConvention: symbol	"Set the end of line convention to be used.	Either #cr, #lf or #crlf (the default)."		self assert: (#(cr lf crlf) includes: symbol).	lineEnd := String perform: symbol! !!NeoCSVWriter methodsFor: 'convenience'!namedColumnsConfiguration: columns	"Configure the receiver to output the named columns as keyed properties.	The objects to be written should respond to #at: like a Dictionary.	Writes a header first. Uses the configured field writer."		self writeHeader: columns.	self addFieldsAt: columns! !!NeoCSVWriter methodsFor: 'accessing'!nextPut: anObject	"Write anObject as single record.	Depending on configuration fieldAccessors or a #do: enumeration will be used."		fieldAccessors 		ifNil: [			self writeFieldsUsingDo: anObject ]		ifNotNil: [			self writeFieldsUsingAccessors: anObject ].	self writeEndOfLine ! !!NeoCSVWriter methodsFor: 'accessing'!nextPutAll: collection	"Write a collection of objects as records"		collection do: [ :each | 		self nextPut: each ]! !!NeoCSVWriter methodsFor: 'initialize-release'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoCSVWriter methodsFor: 'initialize-release'!separator: character	"Set character to be used as separator"		self assert: character isCharacter.	separator := character ! !!NeoCSVWriter methodsFor: 'private'!writeEndOfLine	writeStream nextPutAll: lineEnd ! !!NeoCSVWriter methodsFor: 'private'!writeField: object	self perform: fieldWriter with: object! !!NeoCSVWriter methodsFor: 'private'!writeFieldsUsingAccessors: anObject	| first |	first := true.	fieldAccessors do: [ :each | | fieldValue | 		first ifTrue: [ first := false ] ifFalse: [ self writeSeparator ].		fieldValue := each value: anObject ]! !!NeoCSVWriter methodsFor: 'private'!writeFieldsUsingDo: anObject	| first |	first := true.	anObject do: [ :each |		first ifTrue: [ first := false ] ifFalse: [ self writeSeparator ].		self writeField: each ]! !!NeoCSVWriter methodsFor: 'accessing'!writeHeader: fieldNames	"Write the header, a collection of field names.	This should normally be called only at the beginning and only once."		fieldNames 		do: [ :each | self writeQuotedField: each ]		separatedBy: [ self writeSeparator ].	self writeEndOfLine! !!NeoCSVWriter methodsFor: 'private'!writeObjectField: object	object = emptyFieldValue		ifFalse: [ object printOn: writeStream ]! !!NeoCSVWriter methodsFor: 'writing'!writeOptionalQuotedField: object	| string |	object = emptyFieldValue		ifTrue: [ ^ self ].	string := object asString.	({lineEnd asString.	separator asString.	'"'} anySatisfy: [ :each | string includesSubstring: each ])		ifTrue: [ self writeQuotedField: object ]		ifFalse: [ self writeRawField: object ]! !!NeoCSVWriter methodsFor: 'private'!writeQuotedField: object	object = emptyFieldValue		ifTrue: [ writeStream nextPut: $" ; nextPut: $" ]		ifFalse: [ | string |			string := object asString.			writeStream nextPut: $".			string do: [ :each |				each == $" 					ifTrue: [ writeStream nextPut: $"; nextPut: $" ]					ifFalse: [ writeStream nextPut: each ] ].			writeStream nextPut: $" ]! !!NeoCSVWriter methodsFor: 'private'!writeRawField: object	object = emptyFieldValue 		ifFalse: [ writeStream nextPutAll: object asString ]! !!NeoCSVWriter methodsFor: 'private'!writeSeparator	writeStream nextPut: separator ! !!NeoNumberParser class methodsFor: 'instance creation'!on: stringOrStream	| stream |	stream := stringOrStream isString		ifTrue: [ stringOrStream readStream ]		ifFalse: [ stringOrStream ].	^ self new		on: stream;		yourself! !!NeoNumberParser class methodsFor: 'queries'!parse: stringOrStream	^ (self on: stringOrStream) next! !!NeoNumberParser class methodsFor: 'queries'!parse: stringOrStream base: base	^ (self on: stringOrStream)		base: base;		next! !!NeoNumberParser class methodsFor: 'queries'!parse: stringOrStream base: base ifFail: block	^ [ self parse: stringOrStream base: base ]		on: Error		do: block! !!NeoNumberParser class methodsFor: 'queries'!parse: stringOrStream ifFail: block	^ [ self parse: stringOrStream ]		on: Error		do: block! !!NeoNumberParser methodsFor: 'testing'!atEnd	^ stream atEnd! !!NeoNumberParser methodsFor: 'initialize-release'!base: integer	self assert: (integer between: 2 and: 36) description: 'Number base must be between 2 and 36'.	base := integer! !!NeoNumberParser methodsFor: 'parsing'!consumeWhitespace	"Strip whitespaces from the input stream."	[ stream atEnd not and: [ stream peek isSeparator ] ] 		whileTrue: [ stream next ]! !!NeoNumberParser methodsFor: 'parsing'!failIfNotAtEnd	self atEnd		ifFalse: [ self error: 'extraneous input detected' ]! !!NeoNumberParser methodsFor: 'initialize-release'!initialize	super initialize.	self base: 10.	self radixPoint: $.! !!NeoNumberParser methodsFor: 'accessing'!next	^ self parseNumber! !!NeoNumberParser methodsFor: 'initialize-release'!on: readStream	stream := readStream ! !!NeoNumberParser methodsFor: 'parsing'!parseNumber	| negated number |	negated := stream peekFor: $-.	number := self parseNumberInteger.	(stream peekFor: radixPoint)		ifTrue: [ number := number + self parseNumberFraction ].	((stream peekFor: $e) or: [ stream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	negated		ifTrue: [ number := number negated ].	^ number! !!NeoNumberParser methodsFor: 'parsing'!parseNumberExponent	| number negated x |	number := 0.	(negated := stream peekFor: $-)		ifFalse: [ stream peekFor: $+ ].	[ (x := stream peek) notNil and: [ (x := x digitValue) >= 0 and: [ x < base ] ] ]		whileTrue: [ 			number := base * number + x. 			stream next ].	negated		ifTrue: [ number := number negated ].	^ base raisedTo: number! !!NeoNumberParser methodsFor: 'parsing'!parseNumberFraction	| number power x |	number := 0.	power := 1.0.	[ (x := stream peek) notNil and: [ (x := x digitValue) >= 0 and: [ x < base ] ] ]		whileTrue: [ 			number := base * number + x.			power := power * base.			stream next ].	^ number / power! !!NeoNumberParser methodsFor: 'parsing'!parseNumberInteger	| number x found |	number := 0.	found := false.	[ (x := stream peek) notNil and: [ (x := x digitValue) >= 0 and: [ x < base ] ] ]		whileTrue: [ 			found := true.			number := base * number + x.			stream next ].	found 		ifFalse: [ self error: 'Integer digit expected' ].	^ number! !!NeoNumberParser methodsFor: 'initialize-release'!radixPoint: radixCharacter	radixPoint := radixCharacter ! !"Neo-CSV-Core"!!NeoCSVReaderTests commentStamp: '' prior: 0!I am NeoCSVReaderTests, a suite of unit tests for NeoCSVReader.!!NeoCSVWriterTests commentStamp: '' prior: 0!I am NeoCSVWriterTests, a suite of unit tests for NeoCSVWriter.!!NeoNumberParserTests commentStamp: '' prior: 0!I am NeoNumberParserTests the unit test suite for NeoNumberParser.!!NeoCSVBenchmark commentStamp: '' prior: 0!I am NeoCSVBenchmark.| benchmark |benchmark := NeoCSVBenchmark new.benchmark cleanup.[ benchmark write1 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.[ benchmark read0 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.[ benchmark read1 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.benchmark cleanup.[ benchmark write2 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.benchmark cleanup.[ benchmark write3 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.benchmark cleanup.[ benchmark write4 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.benchmark cleanup.[ benchmark write5 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.[ benchmark read2 ] timeToRun.| benchmark |benchmark := NeoCSVBenchmark new.[ benchmark read3 ] timeToRun.!!NeoCSVTestObject commentStamp: '' prior: 0!I am NeoCSVTestObject.!!NeoCSVTestObject2 commentStamp: '' prior: 0!I am NeoCSVTestObject2. I am a NeoCSVTestObject.I initialize my fields to specific values.!!NeoCSVReaderTests methodsFor: 'testing'!testEmbeddedQuotes	self 		assert: (NeoCSVReader on: '1,"x""y""z",3' readStream) upToEnd		equals: #(('1' 'x"y"z' '3'))! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyConversions	| input |	input := (String crlf join: #( '1,2.5,foo' ',,' )).	self 		assert: ((NeoCSVReader on: input readStream) 					addIntegerField;					addFloatField;					addField;					upToEnd)		equals: { 					#( 1 2.5 'foo' ). 					#( nil nil nil ) }! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyConversionsTestObject	| input |	input := (String crlf join: #( '1,2.5,foo' ',,' )).	self 		assert: ((NeoCSVReader on: input readStream) 					recordClass: NeoCSVTestObject;					addIntegerField: #x: ;					addFloatField: #y: ;					addField: #z: ;					upToEnd)		equals: { 					NeoCSVTestObject x: 1 y: 2.5 z: 'foo'. 					NeoCSVTestObject new }! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyFieldQuoted	self 		assert: (NeoCSVReader on: '"1",,"3"' readStream) upToEnd		equals: #(('1' nil '3'))! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyFieldSecondRecordQuoted	self 		assert: (NeoCSVReader on: '"foo","bar"\"100",' withCRs readStream) upToEnd		equals: #(('foo' 'bar')('100' nil))! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyFieldSecondRecordUnquoted	self 		assert: (NeoCSVReader on: 'foo,bar\100,' withCRs readStream) upToEnd		equals: #(('foo' 'bar')('100' nil))! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyFieldUnquoted	self 		assert: (NeoCSVReader on: '1,,3' readStream) upToEnd		equals: #(('1' nil '3'))! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyFieldValue	self 		assert: ((NeoCSVReader on: '"1",,3,"","5"' readStream) 						emptyFieldValue: #empty; 						upToEnd)		equals: #(('1' empty '3' empty '5')).	self 		assert: ((NeoCSVReader on: '"1",,3,"","5"' readStream) 						emptyFieldValue: ''; 						upToEnd)		equals: #(('1' '' '3' '' '5')).	self 		assert: ((NeoCSVReader on: 'a,b,c\,,\"","",""\1,2,3\' withCRs readStream)						emptyFieldValue: #empty;						upToEnd)		equals: #(('a' 'b' 'c')(empty empty empty)(empty empty empty)('1' '2' '3'))! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyFieldValuePassNil	| date1 date2 |	date1 := '1900-01-01' asDate.	date2 := '2000-12-31' asDate.	self 		assert: ((NeoCSVReader on: 							'date1,date2\2018-01-01,2018-02-01\2018-01-01,\,2018-02-01\\' withCRs readStream) 						emptyFieldValue: #passNil;						addFieldConverter: [ :input | input ifNil: [ date1 ] ifNotNil: [ input asDate ] ];						addFieldConverter: [ :input | input ifNil: [ date2 ] ifNotNil: [ input asDate ] ];						skipHeader; 						upToEnd)		equals: (Array 							with: (Array with: '2018-01-01' asDate with: '2018-02-01' asDate)							with: (Array with: '2018-01-01' asDate with: date2)							with: (Array with: date1 with: '2018-02-01' asDate)							with: (Array with: date1 with: date2)).! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyLastFieldQuoted	self 		assert: (NeoCSVReader on: '"1","2",""' readStream) upToEnd		equals: #(('1' '2' nil))! !!NeoCSVReaderTests methodsFor: 'testing'!testEmptyLastFieldUnquoted	self 		assert: (NeoCSVReader on: '1,2,' readStream) upToEnd		equals: #(('1' '2' nil))! !!NeoCSVReaderTests methodsFor: 'testing'!testOneLineEmpty	self 		assert: (NeoCSVReader on: '' readStream) upToEnd		equals: #()! !!NeoCSVReaderTests methodsFor: 'testing'!testOneLineOneFieldQuoted	self 		assert: (NeoCSVReader on: '"1"' readStream) upToEnd		equals: #(('1'))! !!NeoCSVReaderTests methodsFor: 'testing'!testOneLineOneFieldUnquoted	self 		assert: (NeoCSVReader on: '1' readStream) upToEnd		equals: #(('1'))! !!NeoCSVReaderTests methodsFor: 'testing'!testOneLineQuoted	self 		assert: (NeoCSVReader on: '"1","2","3"' readStream) upToEnd		equals: #(('1' '2' '3'))! !!NeoCSVReaderTests methodsFor: 'testing'!testOneLineUnquoted	self 		assert: (NeoCSVReader on: '1,2,3' readStream) upToEnd		equals: #(('1' '2' '3'))! !!NeoCSVReaderTests methodsFor: 'testing'!testReadAsByteArrays	| input |	input := (String crlf join: #( '1,2,3' '1,2,3' '1,2,3' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					recordClass: ByteArray;					addIntegerField;					addIntegerField ;					addIntegerField;					upToEnd)		equals: {			#[1 2 3].			#[1 2 3].			#[1 2 3].}! !!NeoCSVReaderTests methodsFor: 'testing'!testReadAsIntegerArrays	| input |	input := (String crlf join: #( '100,200,300' '100,200,300' '100,200,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					recordClass: IntegerArray;					addIntegerField;					addIntegerField ;					addIntegerField;					upToEnd)		equals: {			#(100 200 300) asIntegerArray.			#(100 200 300) asIntegerArray.			#(100 200 300) asIntegerArray }! !!NeoCSVReaderTests methodsFor: 'testing'!testReadDictionaries	| input |	input := (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					skipHeader;					recordClass: Dictionary;					addIntegerFieldAt: #x ;					addIntegerFieldAt: #y ;					addIntegerFieldAt: #z ;					upToEnd)		equals: { 					Dictionary newFromPairs: #(x 100 y 200 z 300). 					Dictionary newFromPairs: #(x 100 y 200 z 300). 					Dictionary newFromPairs: #(x 100 y 200 z 300) }! !!NeoCSVReaderTests methodsFor: 'testing'!testReadFloatsRadixPointComma	| input output |	input := (String lf join: #( '"x";"y";"z"' '10,0;20,123;-30,5' '10,0;20,123;-30,5' '10,0;20,123;-30,5' '')).	output := (NeoCSVReader on: input readStream) 		separator: $; ;		skipHeader;		addFloatFieldRadixPointComma;		addFloatFieldRadixPointComma;		addFloatFieldRadixPointComma;		upToEnd.	output do: [ :record |		#(10.0 20.123 -30.5) with: record do: [ :x :y | 			self assert: (x closeTo: y) ] ]! !!NeoCSVReaderTests methodsFor: 'testing'!testReadHeader	| input |	input := (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' '')).	self 		assert: (NeoCSVReader on: input readStream) readHeader		equals: #('x' 'y' 'z')! !!NeoCSVReaderTests methodsFor: 'testing'!testReadIntegers	| input |	input := (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					skipHeader;					addIntegerField;					addIntegerField ;					addIntegerField;					upToEnd)		equals: #((100 200 300)(100 200 300)(100 200 300))! !!NeoCSVReaderTests methodsFor: 'testing'!testReadIntegersReadingHeaderAfterFieldDefinitions	| input |	input := (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					addIntegerField;					addIntegerField ;					addIntegerField;					skipHeader;					upToEnd)		equals: #((100 200 300)(100 200 300)(100 200 300))! !!NeoCSVReaderTests methodsFor: 'testing'!testReadTestsObjects	| input |	input := (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					skipHeader;					recordClass: NeoCSVTestObject;					addIntegerField: #x: ;					addIntegerField: #y: ;					addIntegerField: #z: ;					upToEnd)		equals: { 					NeoCSVTestObject example. 					NeoCSVTestObject example. 					NeoCSVTestObject example }! !!NeoCSVReaderTests methodsFor: 'testing'!testReadTestsObjectsUsingBlockAccessors	| input |	input := (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					skipHeader;					recordClass: NeoCSVTestObject;					addIntegerField: [ :object :value | object x: value ];					addIntegerField: [ :object :value | object y: value ];					addIntegerField: [ :object :value | object z: value ];					upToEnd)		equals: { 					NeoCSVTestObject example. 					NeoCSVTestObject example. 					NeoCSVTestObject example }! !!NeoCSVReaderTests methodsFor: 'testing'!testReadTestsObjectsWithEmptyFieldValue	| input |	input := (String crlf join: #( '"x","y","z"' '100,200,300' '1,,3' '100,200,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					skipHeader;					recordClass: NeoCSVTestObject2;					emptyFieldValue: #empty;					addIntegerField: #x: ;					addIntegerField: #y: ;					addIntegerField: #z: ;					upToEnd)		equals: { 					NeoCSVTestObject2 example. 					NeoCSVTestObject2 new x: 1; z: 3; yourself. "Note that y contains #y from #initialize and was NOT touched" 					NeoCSVTestObject2 example }.	self 		assert: ((NeoCSVReader on: input readStream) 					skipHeader;					recordClass: NeoCSVTestObject2;					addIntegerField: #x: ;					addIntegerField: #y: ;					addIntegerField: #z: ;					upToEnd)		equals: { 					NeoCSVTestObject2 example. 					NeoCSVTestObject2 new x: 1; z: 3; yourself. "Note that y contains #y from #initialize and was NOT touched" 					NeoCSVTestObject2 example }! !!NeoCSVReaderTests methodsFor: 'testing'!testReadTestsObjectsWithIgnoredField	| input |	input := (String crlf join: #( '"x","y",''-'',"z"' '100,200,a,300' '100,200,b,300' '100,200,c,300' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					skipHeader;					recordClass: NeoCSVTestObject;					addIntegerField: #x: ;					addIntegerField: #y: ;					addIgnoredField;					addIntegerField: #z: ;					upToEnd)		equals: { 					NeoCSVTestObject example. 					NeoCSVTestObject example. 					NeoCSVTestObject example }! !!NeoCSVReaderTests methodsFor: 'testing'!testReadWithIgnoredField	| input |	input := (String crlf join: #( '1,2,a,3' '1,2,b,3' '1,2,c,3' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					addIntegerField;					addIntegerField;					addIgnoredField;					addIntegerField;					upToEnd)		equals: {			#(1 2 3).			#(1 2 3).			#(1 2 3).}! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleCrLfQuoted	| input |	input := (String crlf join: #('"1","2","3"' '"4","5","6"' '"7","8","9"' '')).	self 		assert: (NeoCSVReader on: input readStream) upToEnd		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleCrLfUnquoted	| input |	input := (String crlf join: #('1,2,3' '4,5,6' '7,8,9' '')).	self 		assert: (NeoCSVReader on: input readStream) upToEnd		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleCrQuoted	| input |	input := (String cr join: #('"1","2","3"' '"4","5","6"' '"7","8","9"' '')).	self 		assert: (NeoCSVReader on: input readStream) upToEnd		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleCrUnquoted	| input |	input := (String cr join: #('1,2,3' '4,5,6' '7,8,9' '')).	self 		assert: (NeoCSVReader on: input readStream) upToEnd		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleLfQuoted	| input |	input := (String lf join: #('"1","2","3"' '"4","5","6"' '"7","8","9"' '')).	self 		assert: (NeoCSVReader on: input readStream) upToEnd		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleLfUnquoted	| input |	input := (String lf join: #('1,2,3' '4,5,6' '7,8,9' '')).	self 		assert: (NeoCSVReader on: input readStream) upToEnd		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleSemiColonDelimited	| input |	input := (String crlf join: #('1;2;3' '4;5;6' '7;8;9' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					separator: $; ;					upToEnd)		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSimpleTabDelimited	| input |	input := (String crlf join: #('1	2	3' '4	5	6' '7	8	9' '')).	self 		assert: ((NeoCSVReader on: input readStream) 					separator: Character tab ;					upToEnd)		equals: #(('1' '2' '3')('4' '5' '6')('7' '8' '9'))! !!NeoCSVReaderTests methodsFor: 'testing'!testSkipping	| reader |	reader := NeoCSVReader on: 'A,1\B,2\C,3\D,4\E,5\F,6' withCRs readStream.	reader skip.	self assert: reader next equals: #('B' '2').	reader skip: 2.	self assert: reader next equals: #('E' '5').	reader skip.	self assert: reader atEnd.	reader skip.	self assert: reader atEnd.	reader := NeoCSVReader on: 'LETTER,DIGIT\A,1\B,2\C,3\D,4\E,5\F,6' withCRs readStream.	reader skipHeader.	reader skip.	self assert: reader next equals: #('B' '2').	reader skip: 2.	self assert: reader next equals: #('E' '5').	reader skip.	self assert: reader atEnd.! !!NeoCSVReaderTests methodsFor: 'testing'!testSkippingEmptyRecords	| input output |	input := '1,2,3\\4,5,6\,,\7,8,9' withCRs.	output := (NeoCSVReader on: input readStream) 		select: [ :each | each notEmpty and: [ (each allSatisfy: #isNil) not ] ].	self assert: output equals: #(#('1' '2' '3') #('4' '5' '6') #('7' '8' '9')).	output := (NeoCSVReader on: input readStream) 		emptyFieldValue: '';		select: [ :each | each notEmpty and: [ (each allSatisfy: #isEmpty) not ] ].	self assert: output equals: #(#('1' '2' '3') #('4' '5' '6') #('7' '8' '9'))! !!NeoCSVWriterTests methodsFor: 'testing'!testEmptyFieldValue	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						nextPut: #(one two three);						nextPutAll: #( (1 2 nil) (4 nil 6) (nil 8 9)) ])		equals: (String crlf join: #( '"one","two","three"' '"1","2",""' '"4","","6"' '"","8","9"' '')).	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						emptyFieldValue: #empty;						nextPut: #(one two three);						nextPutAll: #( (1 2 empty) (4 empty 6) (empty 8 9)) ])		equals: (String crlf join: #( '"one","two","three"' '"1","2",""' '"4","","6"' '"","8","9"' '')).	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						emptyFieldValue: Object new;						nextPut: #(one two three);						nextPutAll: #( (1 2 nil) (4 nil 6) (nil 8 9)) ])		equals: (String crlf join: #( '"one","two","three"' '"1","2","nil"' '"4","nil","6"' '"nil","8","9"' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testObjectFieldsTestObjects	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						nextPut: #(x y z);						addObjectFields: #(x y z); 						nextPutAll: { 							NeoCSVTestObject example. 							NeoCSVTestObject example. 							NeoCSVTestObject example } ])		equals: (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testObjectFieldsTestObjectsExtra	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						fieldWriter: #raw;						nextPut: #(x empty y constant z);						addObjectField: #x;						addEmptyField;						addObjectField: #y;						addConstantField: 'X';						addObjectField: #z; 						nextPutAll: { 							NeoCSVTestObject example. 							NeoCSVTestObject example. 							NeoCSVTestObject example } ])		equals: (String crlf join: #( 					'x,empty,y,constant,z' 					'100,,200,X,300' 					'100,,200,X,300' 					'100,,200,X,300' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testObjectFieldsTestObjectsUsingBlockAccessors	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						nextPut: #(x y z);						addObjectFields: { 							[ :object | object x ].							[ :object | object y ].							[ :object | object z ] }; 						nextPutAll: { 							NeoCSVTestObject example. 							NeoCSVTestObject example. 							NeoCSVTestObject example } ])		equals: (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testOptionalQuotedFields	self		assert:			(String				streamContents: [ :stream | 					(NeoCSVWriter on: stream)						fieldWriter: #optionalQuoted;						nextPut:							{'one'.							't,wo'.							't"hree'.							'fo' , String crlf , 'ur'} ])		equals: 'one,"t,wo","t""hree","fo' , String crlf , 'ur"', String crlf! !!NeoCSVWriterTests methodsFor: 'testing'!testRawFieldsDictionaries	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						nextPut: #(x y z);						addRawFieldsAt: #(x y z); 						nextPutAll: { 							Dictionary newFromPairs: #(x 100 y 200 z 300).							Dictionary newFromPairs: #(x 400 y 500 z 600). 							Dictionary newFromPairs: #(x 700 y 800 z 900) } ])		equals: (String crlf join: #( '"x","y","z"' '100,200,300' '400,500,600' '700,800,900' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testRawFieldsTestObjects	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						nextPut: #(x y z);						addRawFields: #(x y z); 						nextPutAll: { 							NeoCSVTestObject example. 							NeoCSVTestObject example. 							NeoCSVTestObject example } ])		equals: (String crlf join: #( '"x","y","z"' '100,200,300' '100,200,300' '100,200,300' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testSimple	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						nextPut: #(one two three);						nextPutAll: #( (1 2 3) (4 5 6) (7 8 9)) ])		equals: (String crlf join: #( '"one","two","three"' '"1","2","3"' '"4","5","6"' '"7","8","9"' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testSimpleOptionalQuoted	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						fieldWriter: #optionalQuoted;						nextPut: #(one two 'thr,ee');						nextPutAll: #( (1 2 3) (4 5 6) (7 8 9)) ])		equals: (String crlf join: #( 'one,two,"thr,ee"' '1,2,3' '4,5,6' '7,8,9' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testSimpleRaw	self		assert: (String streamContents: [ :stream |					(NeoCSVWriter on: stream)						fieldWriter: #raw;						nextPut: #(one two three);						nextPutAll: #( (1 2 3) (4 5 6) (7 8 9)) ])		equals: (String crlf join: #( 'one,two,three' '1,2,3' '4,5,6' '7,8,9' ''))! !!NeoCSVWriterTests methodsFor: 'testing'!testWideOptionalQuoted	self		assert: (String streamContents: [ :out |			(NeoCSVWriter on: out) 				fieldWriter: #optionalQuoted; 				nextPut: { 1. 'foo "1" ', Character euro asString. true} ])		equals: ('1,"foo ""1"" ', Character euro asString, '",true', String crlf)! !!NeoCSVWriterTests methodsFor: 'testing'!testWriteEmbeddedQuote	| header |	header := String streamContents: [ :out |		(NeoCSVWriter on: out)			nextPut: #(foo 'x"y"z') ].	self assert: header equals: '"foo","x""y""z"', String crlf! !!NeoCSVWriterTests methodsFor: 'testing'!testWriteHeader	| header |	header := String streamContents: [ :out |		(NeoCSVWriter on: out)			writeHeader: #(foo bar) ].	self assert: header equals: '"foo","bar"', String crlf! !!NeoNumberParserTests methodsFor: 'testing'!testBinaryIntegers	self assert: (NeoNumberParser parse: '1111011' base: 2) equals: 123.	self assert: (NeoNumberParser parse: '-1111011' base: 2) equals: -123.	self assert: (NeoNumberParser parse: '0' base: 2) equals: 0.! !!NeoNumberParserTests methodsFor: 'testing'!testDecimalIntegers	self assert: (NeoNumberParser parse: '123') equals: 123.	self assert: (NeoNumberParser parse: '-123') equals: -123.	self assert: (NeoNumberParser parse: '0') equals: 0.	self assert: (NeoNumberParser parse: '12345678901234567890') equals: 12345678901234567890.	self 		assert: (NeoNumberParser parse: '12345678901234567890123456789012345678901234567890123456789012345678901234567890') 		equals: 12345678901234567890123456789012345678901234567890123456789012345678901234567890.			self assert: (NeoNumberParser parse: '00123ABC') equals: 123.	self assert: (NeoNumberParser parse: '-0') equals: 0.! !!NeoNumberParserTests methodsFor: 'testing'!testErrors	self should: [ NeoNumberParser parse: nil ] raise: Error.	self should: [ NeoNumberParser parse: '' ] raise: Error.	self should: [ NeoNumberParser parse: '.5' ] raise: Error.		self should: [ NeoNumberParser parse: '-' ] raise: Error.	self should: [ NeoNumberParser parse: '+' ] raise: Error.	self should: [ NeoNumberParser parse: 'x' ] raise: Error.		self should: [ NeoNumberParser parse: '-a' ] raise: Error.	self should: [ NeoNumberParser parse: '_' ] raise: Error.! !!NeoNumberParserTests methodsFor: 'testing'!testFloats	#('1.5' 1.5 '-1.5' -1.5 '0.0' 0.0 '3.14159' 3.14159 '1e3' 1000.0 '1e-2' 0.01)		pairsDo: [ :string :float | 			self assert: ((NeoNumberParser parse: string) closeTo: float) ]! !!NeoNumberParserTests methodsFor: 'testing'!testFloatsRadixPoint	#('1,5' 1.5 '-1,5' -1.5 '0,0' 0.0 '3,14159' 3.14159 '1e3' 1000.0 '1e-2' 0.01)		pairsDo: [ :string :float | 			self assert: (((NeoNumberParser on: string) radixPoint: $,; next) closeTo: float) ]! !!NeoNumberParserTests methodsFor: 'testing'!testHexadecimalIntegers	self assert: (NeoNumberParser parse: '7B' base: 16) equals: 123.	self assert: (NeoNumberParser parse: '-7B' base: 16) equals: -123.	self assert: (NeoNumberParser parse: '0' base: 16) equals: 0.	"On some platforms Character>>#digitValue only handles uppercase,	then NeoNumberParser cannot deal with lowercase hex characters"	$a digitValue = 10 ifFalse: [ ^ self ].	self assert: (NeoNumberParser parse: '7b' base: 16) equals: 123.	self assert: (NeoNumberParser parse: '-7b' base: 16) equals: -123! !!NeoNumberParserTests methodsFor: 'testing'!testNumberExtraction	self assert: (NeoNumberParser parse: '00123ABC') equals: 123.	self assert: ((NeoNumberParser on: '  123ABC') consumeWhitespace; next) equals: 123.	self should: [ (NeoNumberParser on: '  123ABC') consumeWhitespace; next; failIfNotAtEnd ] raise: Error.! !!NeoNumberParserTests methodsFor: 'testing'!testOctalIntegers	self assert: (NeoNumberParser parse: '173' base: 8) equals: 123.	self assert: (NeoNumberParser parse: '-173' base: 8) equals: -123.	self assert: (NeoNumberParser parse: '0' base: 8) equals: 0.! !!NeoCSVBenchmark methodsFor: 'public'!cleanup	self filename ensureDeleted	! !!NeoCSVBenchmark methodsFor: 'accessing'!filename	^ 'NeoCSVBenchmark.csv' asFileReference! !!NeoCSVBenchmark methodsFor: 'initialize-release'!initialize 	data := Array new: 100000 streamContents: [ :stream |		1 to: 100000 do: [ :each |			stream nextPut: (Array with: each with: each negated with: (100000 - each)) ] ]! !!NeoCSVBenchmark methodsFor: 'public'!read0	self filename readStreamDo: [ :stream | 		(NeoCSVReader on: stream)			upToEnd ]! !!NeoCSVBenchmark methodsFor: 'public'!read1	self filename readStreamDo: [ :stream | 		(NeoCSVReader on: (ZnBufferedReadStream on: stream))			upToEnd ]! !!NeoCSVBenchmark methodsFor: 'public'!read2	self filename readStreamDo: [ :stream | 		(NeoCSVReader on: stream)			recordClass: NeoCSVTestObject;			addIntegerField: #x: ;			addIntegerField: #y: ;			addIntegerField: #z: ;			upToEnd ]! !!NeoCSVBenchmark methodsFor: 'public'!read3	self filename readStreamDo: [ :stream | 		(NeoCSVReader on: (ZnBufferedReadStream on: stream))			recordClass: NeoCSVTestObject;			addIntegerField: #x: ;			addIntegerField: #y: ;			addIntegerField: #z: ;			upToEnd ]! !!NeoCSVBenchmark methodsFor: 'public'!write0	self filename writeStreamDo: [ :stream | 		(NeoCSVWriter on: stream)			nextPutAll: data ]! !!NeoCSVBenchmark methodsFor: 'public'!write1	self filename writeStreamDo: [ :stream | 		(NeoCSVWriter on: (ZnBufferedWriteStream on: stream))			nextPutAll: data;			flush ]! !!NeoCSVBenchmark methodsFor: 'public'!write2	self filename writeStreamDo: [ :stream | 		(NeoCSVWriter on: (ZnBufferedWriteStream on: stream))			addRawFields: #(first second third);			nextPutAll: data;			flush ]! !!NeoCSVBenchmark methodsFor: 'public'!write3	self filename writeStreamDo: [ :stream | 		(NeoCSVWriter on: (ZnBufferedWriteStream on: stream))			addObjectFields: #(first second third);			nextPutAll: data;			flush ]! !!NeoCSVBenchmark methodsFor: 'public'!write4	self filename writeStreamDo: [ :stream | 		(NeoCSVWriter on: (ZnBufferedWriteStream on: stream))			fieldWriter: #raw;			nextPutAll: data;			flush ]! !!NeoCSVBenchmark methodsFor: 'public'!write5	self filename writeStreamDo: [ :stream | 		(NeoCSVWriter on: (ZnBufferedWriteStream on: stream))			fieldWriter: #object;			nextPutAll: data;			flush ]! !!NeoCSVTestObject class methodsFor: 'instance creation'!example	^ self x: 100 y: 200 z: 300! !!NeoCSVTestObject class methodsFor: 'instance creation'!x: x y: y z: z	^ self new		x: x;		y: y;		z: z;		yourself! !!NeoCSVTestObject methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ x = anObject x		and: [			y = anObject y				and: [					z = anObject z ] ]! !!NeoCSVTestObject methodsFor: 'comparing'!hash	^ x hash bitXor: (y hash bitXor: z)! !!NeoCSVTestObject methodsFor: 'accessing'!x	^ x! !!NeoCSVTestObject methodsFor: 'accessing'!x: anObject	x := anObject! !!NeoCSVTestObject methodsFor: 'accessing'!y	^ y! !!NeoCSVTestObject methodsFor: 'accessing'!y: anObject	y := anObject! !!NeoCSVTestObject methodsFor: 'accessing'!z	^ z! !!NeoCSVTestObject methodsFor: 'accessing'!z: anObject	z := anObject! !!NeoCSVTestObject2 methodsFor: 'initalize'!initialize	super initialize.	x := #x.	y := #y.	z := #z! !"Neo-CSV-Tests"!!Any commentStamp: '' prior: 0!I specify any posslble object. I should be used directly as class to successfully validate any object.	(Any matches:  nil) = true	(Any matches:  Object new) = true!!SpecOfObjectState commentStamp: '' prior: 0!I am root of hierarchy of object state specifications.I provide two methods to check objects. One is #matches: which returns true or false. And other is #validate: which returns object validation result with detailed information about failure (if object not satisfies spec).My subclasses should define at least #basicMatches: method to check if given object satisfied specification or not.I has denial variable which used to mark me as opposite specification to my original purpose. Method #matches: take it into account. And implementors of basicMatches: should not think about it. Also subclasses can override #validate: method to retrive more specific  information about given objects. Public API and Key Messages- matches: anObject it checks if anObject matches specification or not.   It returns true or false.- validate: anObject it checks if anObject matches specification or not.   It returns SpecOfValidationResult instance which can be success or failure.-notIt creates my copy with negation behaviour-&It creates SpecOfAndConjunction instance with me and my argument-| It cretes SpecOfOrDisjunction instance with me and my argument-title:It sets special name of me. There is defaultTitle by default-failureDescription:It sets special description for validation failure   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	denial:		<Boolean>	title:		<String>	failureDescription:		<String>!!SpecOfBlockFailure commentStamp: '' prior: 0!I describe blocks which raise specific kind of exceptions.	[ 1 /0 ] should raise: ZeroDivideMy instances can be created by: 	SpecOfBlockFailure requiredFailure: ZeroDivide.I also support using specs for required failure:	SpecOfBlockFailure requiredFailure: (Instance of: Error).					By default I implement special logic to catch unexpected exceptions and return it as special kind of validation falure. For example:	[ #() at: 1 ] should raise: ZeroDivide This code will not show debugger at point of SubscriptOutOfBounds error.  But it will show that specification is failed and SubscriptOutOfBounds was thrown instead of ZeroDivide. Pressing proceed in debugger will move it to original failure. To disable this behaviour I have variable shouldPassUnexpectedFailure.Also I have array of special failures which should be always passed without validation logic. It is Halt, MessageNotUnderstood and SpecOfFailed. Usually this errors should be thrown immediatly in debugger. 	[ 1 someMessage ] should raise: ErrorThis code will open debugger at DNU method where absent message can be created.But if errors are explicitly expected failures then they will be checked by validation logic:	[ 1 someMessage ] should raise: MessageNotUnderstood This code will not open debugger because validation is succeed.In addition I return special success validation result (SpecOfFailureValidationSuccess) which holds signaled exception instance: 	errorValidation := [ self error: 'my test error' ] should fail.	errorValidation signaledFailure "==> Error: my test error"It allows to perform additional validation over caught failure: 	errorValidation should beInstanceOf: Error.	errorValidation where description should includesSubstring: 'my test'.	Internal Representation and Key Implementation Points.    Instance Variables	requiredFailure:		<SpecOfObjectState>	passingFailures:		<Collection of<Exception>>	shouldPassUnexpectedFailures:		<Boolean>!!SpecOfBooleanProperty commentStamp: '' prior: 0!I describe objects which propertyMessage returns true.	#() should be isEmpty	10 should be beetween: 1 and: 100My instances can be created by: 	SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty) Internal Representation and Key Implementation Points.    Instance Variables	propertyMessage:		<Message>!!SpecOfCollection commentStamp: '' prior: 0!I am root of hierarchy of collection specifications!!SpecOfCollectionContents commentStamp: '' prior: 0!I describe collections which include particular item.	#(1 2 3) should include: 2My instance can be created by:	SpecOfCollectionContents requiredItem: 2	Required item can be a simple object like in example or it can be full specification:	#(1 2 3) should include: (Kind of: String)Also you can use a block: 	#(1 2 3) should include: [:item | item > 10]Block is converted to predicate specification.Internal Representation and Key Implementation Points.    Instance Variables	requiredItem:		<SpecOfObjectState>!!SpecOfCollectionItem commentStamp: '' prior: 0!I describe collection item at concrete collection index or dictionary key. 	#(one two) should include: #one at: 1My instance can be created by:	SpecOfCollectionItem at: 1 requiredItem: #one.	Required item can be a simple object like in example or it can be full specification:	#(one two) should include: (Kind of: String ) at: 1		Also you can use a block: 	#(one two) should include: [:item | item isAllDigits] at: 1Block is converted to predicate specification.			 Internal Representation and Key Implementation Points.    Instance Variables	containingKey:		<Object>	requiredItem:		<SpecOfObjectState>!!SpecOfCollectionSize commentStamp: '' prior: 0!I describe collections of particular size.	#(1 2) should haveSize: 2My instances can be created by: 	SpecOfCollectionSize requiredSize: 2Internal Representation and Key Implementation Points.	    Instance Variables	requiredSize:		<Integer>!!SpecOfDictionaryKeys commentStamp: '' prior: 0!I describe any dictionare which contains particular key.	(Dictionary newFromPairs: #(key value)) should includeKey: #keyMy instances can be created by 	SpecOfDictionaryKeys requiredKey: #key Internal Representation and Key Implementation Points.    Instance Variables	requiredKey:		<Object>!!SpecOfComplexState commentStamp: '' prior: 0!I am root of hierarchy of composite specifications.My instance can be created by binary messages to spec instances:	(Instance of: String) & (Satisfying for: [:o | true])	(Instance of: String) | (Satisfying for: [:o | true])Internal Representation and Key Implementation Points.    Instance Variables	specs:		<Collection of: <SpecOfObjectState>>!!SpecOfAndConjunction commentStamp: '' prior: 0!I implement conjunction of specifications.I can be created by & message to spec:		(Instance of: String) & (Satisfying for: [:o | true])!!SpecOfNegation commentStamp: '' prior: 0!I implement negation of specifications.I can be created by:		SpecOfNegation of: (Instance of: String) and: (Instance of: Integer)!!SpecOfOrDisjunction commentStamp: '' prior: 0!I implement disjunction of specifications.I can be created by | message to spec:		(Instance of: String) | (Instance of: Integer)!!SpecOfObjectRelationship commentStamp: '' prior: 0!I am root of hierarchy of specifications for objects relationshipMy instances can be created by 	SpecOfObjectRelationship requiredClass: StringInternal Representation and Key Implementation Points.    Instance Variables	requiredClass:		<Class>!!SpecOfObjectClass commentStamp: '' prior: 0!I describe all objects of particular class.	(10@30) should beInstanceOf: Point!!SpecOfObjectSuperclass commentStamp: '' prior: 0!I describe all objects which are kind of particular class.	#string should beKindOf: String!!SpecOfObjectResponsibility commentStamp: '' prior: 0!I describe all objects which responds to particular message.	(10@230) should respondTo: #xMy instances can be created by 	SpecOfObjectResponsibility requiredMessage: #x  Internal Representation and Key Implementation Points.    Instance Variables	requiredMessage:		<Symbol>!!SpecOfObjectStateByPredicate commentStamp: '' prior: 0!I describe all objects which satisfy particular predicate.	10 should satisfy: [ :num | num > 2 ] My instances can be created by: 		SpecOfObjectStateByPredicate from:  [ :num | num > 2 ] 	 Internal Representation and Key Implementation Points.    Instance Variables	predicate:		<BlockClosure>!!SpecOfObjectValue commentStamp: '' prior: 0!I am root of hierarchy to object value itself. Internal Representation and Key Implementation Points.    Instance Variables	requiredValue:		<Object>!!SpecOfApproxEquality commentStamp: '' prior: 0!I describe objects (numbers) which are equal to my required value with particular accuracy.	1.1 should equal: 1 within: 0.2My instances can be created by 	SpecOfApproxEquality to: 1 within: 0.2		Internal Representation and Key Implementation Points.    Instance Variables	accuracy:		<Number>!!SpecOfCollectionOrderedEquality commentStamp: '' prior: 0!I describe all collections which contains equal elements in same order.	#(1 2) should equalInOrder: #(1 2)My instances can be created by 	SpecOfCollectionOrderedEquality to: #(1).	To compare collections I use message 	collection checkStateSpecsOrderedEqualityTo: anotherCollectionCollection items compared by 	eachItem checkStateSpecsEqualityTo: anotherItem!!SpecOfEquality commentStamp: '' prior: 0!I describe all objects which are equal to my required value.	'object' should equal: 'another object'My instances can be created by 	SpecOfEquality to: 1.	I am supposed to check logical equalence between two objects. In case of collections it means that I not check order of elements. I only check that both collection contains equal  elements. To describe ordered equality of collections use SpecOfCollectionOrderedEquality (look at it comment).I use special message to compared objects:	eachObject checkStateSpecsEqualityTo: anotherObject!!SpecOfIdentity commentStamp: '' prior: 0!I describe all objects which are identical to my required value.	1 should be: 1My instances can be created by 	SpecOfIdentity to: 1!!SpecOfMagnitudeOrder commentStamp: '' prior: 0!I am root of hierrarchy of magnitude order specifications.Variable isStrong specifes strong comparison for order check  Internal Representation and Key Implementation Points.    Instance Variables	isStrong:		<Boolean>!!SpecOfGreaterMagnitude commentStamp: '' prior: 0!I describe magnitudes which are greater than my required value.	10 should beGreaterThan: 1My instances can be created by 	SpecOfGreaterMagnitude than: 1!!SpecOfLesserMagnitude commentStamp: '' prior: 0!I describe magnitudes which are less than my required value.	1 should beLessThan: 10My instances can be created by 	SpecOfLesserMagnitude than: 10!!SpecOfString commentStamp: '' prior: 0!I am root of hierarchy of string specifications.I provide requiredSubstring and caseSensitive properties. And my subclasses should use them accordingly their logic. Instance should be created using following messages: 	SpecOfString requiredSubstring: 'test'.	SpecOfString requiredSubstring: 'test' caseSensitive: falseMy default I am not case sensitive. Internal Representation and Key Implementation Points.    Instance Variables	caseSensitive:		<Boolean>	requiredSubstring:		<String>!!SpecOfStringBeginning commentStamp: '' prior: 0!I describe strings which begin with particular substring.	'some test string' should beginWith: 'some'.	'some test string' should beginWith: 'Some' caseSensitive: true!!SpecOfStringEnding commentStamp: '' prior: 0!I describe strings which end with particular substring.	'some string for test' should endWith: 'test'.	'some string for test' should endWith: 'Test' caseSensitive: true!!SpecOfStringRegex commentStamp: '' prior: 0!I describe strings which match particular regex expression.	'some test string' should matchRegex: '^some'.	'some test string' should matchRegex: '^Some' caseSensitive: true!!SpecOfSubstring commentStamp: '' prior: 0!I describe strings which include particular substring.	'some test string' should includeSubstring: 'test'.	'some test string' should includeSubstring: 'Test' caseSensitive: true!!SpecOfValidationResult commentStamp: '' prior: 0!I am root of hierarchy of spec validation results.My subclasses should implement method #raise to signal failures.I define successful validation result as singleton.		SpecOfValidationResult success  Public API and Key Messages- isSuccess   - isFailure - raise!!SpecOfValidationFailure commentStamp: '' prior: 0!I represent spec validation failure.My instances can be created by 		SpecOfValidationFailure spec: aSpecOfObjectState for: anObject or	SpecOfValidationResult failed: aSpecOfObjectState for: anObjectI implement #description method to provide detailed information about validation failure.In case of internal property validation of some object I need information about it to correctly describe that wrong property belongs to given owner. For this I use variable subjectOwner to build more clever description of validation failurePublic API and Key Messages- description- raise  Internal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfObjectState>	subject:		<Object>	subjectOwner:		<Object>    Implementation Points!!SpecOfBlockValidationFailure commentStamp: '' prior: 0!I represent block validation failure for expected exception. I am implemented to support passing errors logic which described in SpecOfBlockFailure comment. Internal Representation and Key Implementation Points.    Instance Variables	errorValidationResult:		<SpecOfValidationFailure>!!SpecOfBooleanPropertyValidationFailure commentStamp: '' prior: 0!I represent object validation failure for boolean property.I provide suitable description for incorrect property!!SpecOfCollectionItemValidationFailure commentStamp: '' prior: 0!I represent collection validation failure for expected item. I provide more suitable description about wrong collection item.Internal Representation and Key Implementation Points.    Instance Variables	wrongItem:		<Object>!!SpecOfValidationSuccess commentStamp: '' prior: 0!I represent successful spec validation.My superclass define singleton for me 	SpecOfValidationResult success!!SpecOfFailureValidationSuccess commentStamp: '' prior: 0!I represent successful result of failure validation during block execution by SpecOfBlockFailure spec.I was introduced to not loose caught exception instance and allow extra validation using should expressions: 	error := [ self error: 'some error' ] should raise: Error.	error should beInstanceOf: Error.	error where description should includeSubstring: 'some'Create my instances with following expression: 	SpecOfFailureValidationSuccess with: anError	Internal Representation and Key Implementation Points.    Instance Variables	signaledFailure:		<Exception>!!SpecOfFailed commentStamp: '' prior: 0!I am exception to signal specification failure.SpecOfValidationFailure signals me by #raise method.	validationResult raise	Internal Representation and Key Implementation Points.    Instance Variables	reason:		<SpecOfValidationFailure>!!Any class methodsFor: 'converting'!asSimpleValue	^self name! !!Any class methodsFor: 'converting'!asStateSpec	^self! !!Any class methodsFor: 'validation'!basicMatches: anObject 	^true! !!Any class methodsFor: 'accessing'!denial: aBoolean 	^self! !!Any class methodsFor: 'testing'!isSimpleValue	^true! !!Any class methodsFor: 'testing'!isStateSpec	^true! !!Any class methodsFor: 'validation'!matches: anObject 	^true! !!Any class methodsFor: 'validation'!validate: anObject 	^SpecOfValidationResult success! !!Object methodsFor: '*StateSpecs-Specs'!asStateSpec	^SpecOfEquality requiredValue: self! !!Object methodsFor: '*StateSpecs-Specs'!checkStateSpecsEqualityTo: anObject	self class == anObject retriveClassForStateSpecs ifFalse: [ ^false ].		^self = anObject! !!Object methodsFor: '*StateSpecs-Specs'!isStateSpec	^false! !!Object methodsFor: '*StateSpecs-Specs'!retriveClassForStateSpecs	^self class! !!Object methodsFor: '*StateSpecs-Specs'!stringForSpecTitle	^self printString! !!Object methodsFor: '*StateSpecs-Specs'!stringForSpecValidation	^self stringForSpecTitle! !!Object methodsFor: '*StateSpecs-Specs'!valueForFutureStateValidation	^self! !!SpecOfBlockFailure class methodsFor: 'instance creation'!requiredFailure: anExceptionClass 	^self new requiredFailure: anExceptionClass! !!SpecOfBlockFailure methodsFor: 'testing'!basicMatches: aBlockContext 	^	[aBlockContext value.	false] on: Exception			do: 				[:ex | 				(self shouldAlwaysPassFailure: ex) ifTrue: [ex pass].				(requiredFailure matches: ex) ifTrue: [true] ifFalse: [					shouldPassUnexpectedFailures ifTrue: [ ex pass] ifFalse: [false] ]]! !!SpecOfBlockFailure methodsFor: 'displaying'!defaultTitle	^requiredFailure title! !!SpecOfBlockFailure methodsFor: 'initialization'!initialize	super initialize.		shouldPassUnexpectedFailures := false.	passingFailures := {SpecOfFailed. Halt. MessageNotUnderstood. Deprecation} asOrderedCollection! !!SpecOfBlockFailure methodsFor: 'accessing'!invertChildren	super invertChildren.	requiredFailure invert! !!SpecOfBlockFailure methodsFor: 'accessing'!passUnexpectedFailures	shouldPassUnexpectedFailures := true! !!SpecOfBlockFailure methodsFor: 'accessing'!requiredFailure	^requiredFailure! !!SpecOfBlockFailure methodsFor: 'accessing'!requiredFailure: exceptionClassOrSpec	passingFailures remove: exceptionClassOrSpec ifAbsent: [  ]. "if this spec explicitly about passing failure then we should not pass it during validation"		requiredFailure := self specForFailure: exceptionClassOrSpec! !!SpecOfBlockFailure methodsFor: 'testing'!shouldAlwaysPassFailure: anException		^passingFailures anySatisfy: [ :each | 		anException isKindOf: each]! !!SpecOfBlockFailure methodsFor: 'accessing'!shouldPassUnexpectedFailures	^ shouldPassUnexpectedFailures! !!SpecOfBlockFailure methodsFor: 'accessing'!shouldPassUnexpectedFailures: anObject	shouldPassUnexpectedFailures := anObject! !!SpecOfBlockFailure methodsFor: 'accessing'!specForFailure: exceptionClassOrSpec	^exceptionClassOrSpec isClass & (exceptionClassOrSpec ~= Any)		ifTrue: [ SpecOfObjectSuperclass requiredClass: exceptionClassOrSpec ]		ifFalse: [ exceptionClassOrSpec asStateSpec ]! !!SpecOfBlockFailure methodsFor: 'validation'!validate: aBlock	| result |	^[aBlock value.	(requiredFailure matches: Any) 		ifTrue: [ SpecOfValidationResult success ]		ifFalse: [ SpecOfBlockValidationFailure noErrorIn: aBlock butShouldBe: self]]			on: Exception do: [:ex | 				(self shouldAlwaysPassFailure: ex) ifTrue: [ex pass]. "we want to pass by default DNU, Halt and internal SpecOfFailed failures"							requiredFailure denial: denial. 				result := requiredFailure validate: ex.							result isSuccess 					ifTrue: [ SpecOfFailureValidationSuccess with: ex ] 					ifFalse: [ 						shouldPassUnexpectedFailures							ifTrue: [ ex pass ]							ifFalse: [ SpecOfBlockValidationFailure unexpectedError: result in: aBlock butShouldBe: self]]		]! !!SpecOfBooleanProperty class methodsFor: 'instance creation'!fromMessage: aMessage	^self new 		propertyMessage: aMessage ! !!SpecOfBooleanProperty methodsFor: 'testing'!basicMatches: anObject	| result |	result := propertyMessage sendTo: anObject.	^result == true! !!SpecOfBooleanProperty methodsFor: 'printing'!defaultTitle 	^'be ', propertyMessage printString! !!SpecOfBooleanProperty methodsFor: 'accessing'!propertyMessage	^ propertyMessage! !!SpecOfBooleanProperty methodsFor: 'accessing'!propertyMessage: anObject	propertyMessage := anObject! !!SpecOfBooleanProperty methodsFor: 'validation'!validationFailureFor: anObject	^SpecOfBooleanPropertyValidationFailure spec: self for: anObject! !!SpecOfCollectionContents class methodsFor: 'instance creation'!requiredItem: anObjectOrSpec 	^self new requiredItem: anObjectOrSpec! !!SpecOfCollectionContents methodsFor: 'testing'!basicMatches: aCollection 	^aCollection anySatisfy: [ :each | requiredItem matches: each]! !!SpecOfCollectionContents methodsFor: 'displaying'!defaultTitle	^'include ' , requiredItem printSimpleValue! !!SpecOfCollectionContents methodsFor: 'accessing'!requiredItem	^requiredItem! !!SpecOfCollectionContents methodsFor: 'accessing'!requiredItem: anObject	requiredItem := anObject asStateSpec! !!SpecOfCollectionItem class methodsFor: 'instance creation'!at: keyObject requiredItem: itemObject	^self new		containingKey: keyObject;		requiredItem: itemObject ! !!SpecOfCollectionItem methodsFor: 'testing'!basicMatches: aCollection	| actualItem |	actualItem := aCollection at: containingKey ifAbsent: [^false].	^requiredItem matches: actualItem! !!SpecOfCollectionItem methodsFor: 'accessing'!containingKey	^ containingKey! !!SpecOfCollectionItem methodsFor: 'accessing'!containingKey: anObject	containingKey := anObject! !!SpecOfCollectionItem methodsFor: 'accessing'!defaultTitle	^'include ', requiredItem printSimpleValue, ' at ' , containingKey stringForSpecTitle! !!SpecOfCollectionItem methodsFor: 'accessing'!invertChildren	super invertChildren.		requiredItem invert! !!SpecOfCollectionItem methodsFor: 'printing'!itemDescription	^requiredItem description! !!SpecOfCollectionItem methodsFor: 'accessing'!requiredItem	^ requiredItem! !!SpecOfCollectionItem methodsFor: 'accessing'!requiredItem: anObject	requiredItem := anObject asStateSpec! !!SpecOfCollectionItem methodsFor: 'validation'!validate: aCollection	| actualItem result |		actualItem := aCollection at: containingKey ifAbsent: [		^SpecOfCollectionItemValidationFailure noItemIn: aCollection butShouldBe: self ].		result := requiredItem validate: actualItem.	^result isSuccess 		ifTrue: [ result ] 		ifFalse: [ ^SpecOfCollectionItemValidationFailure unexpectedItem: actualItem in: aCollection butShouldBe: self ] ! !!SpecOfCollectionSize class methodsFor: 'instance creation'!requiredSize: anInteger 	^self new requiredSize: anInteger! !!SpecOfCollectionSize methodsFor: 'testing'!basicMatches: aCollection 	^aCollection size = requiredSize! !!SpecOfCollectionSize methodsFor: 'displaying'!defaultTitle	^'have ' , requiredSize printString , ' elements'! !!SpecOfCollectionSize methodsFor: 'accessing'!requiredSize	^requiredSize! !!SpecOfCollectionSize methodsFor: 'accessing'!requiredSize: anInteger 	requiredSize := anInteger! !!SpecOfCollectionSize methodsFor: 'accessing'!requiredValue	^requiredSize! !!SpecOfDictionaryKeys class methodsFor: 'instance creation'!requiredKey: anObject 	^self new requiredKey: anObject! !!SpecOfDictionaryKeys methodsFor: 'testing'!basicMatches: aCollection 	^aCollection includesKey: requiredKey! !!SpecOfDictionaryKeys methodsFor: 'displaying'!defaultTitle	^'include key ' , requiredKey stringForSpecTitle! !!SpecOfDictionaryKeys methodsFor: 'accessing'!requiredKey	^requiredKey! !!SpecOfDictionaryKeys methodsFor: 'accessing'!requiredKey: anObject 	requiredKey := anObject! !!SpecOfAndConjunction methodsFor: 'testing'!basicMatches: anObject	^specs allSatisfy: [ :each | 		each matches: anObject ]! !!SpecOfAndConjunction methodsFor: 'printing'!operatorName	^'and'! !!SpecOfAndConjunction methodsFor: 'validation'!validate: anObject 	| result |	specs do: [:eachSpec |		result := eachSpec validate: anObject.		result isFailure ifTrue: [^result]].		^SpecOfValidationResult success! !!SpecOfComplexState class methodsFor: 'instance creation'!of: arrayOfPatterns 	^self new specs: (arrayOfPatterns collect: [:each | each asStateSpec])! !!SpecOfComplexState class methodsFor: 'instance creation'!of: pattern1 and: pattern2 	^self of: (Array with: pattern1 with: pattern2)! !!SpecOfComplexState class methodsFor: 'instance creation'!of: pattern1 and: pattern2 and: pattern3 	^self of: (Array 				with: pattern1				with: pattern2				with: pattern3)! !!SpecOfComplexState methodsFor: 'accessing'!addSpec: aStateSpec	specs add: aStateSpec ! !!SpecOfComplexState methodsFor: 'accessing'!addSpecs: aCollectionOfSpecs	specs addAll: aCollectionOfSpecs ! !!SpecOfComplexState methodsFor: 'copying'!copy	| result |	result := super copy.		result specs: (specs collect: [:each | each copy]).		^result! !!SpecOfComplexState methodsFor: 'printing'!defaultTitle	^String streamContents: [ :s |		specs do: [ :each |			s << each title.			each == specs last ifFalse: [ s << ' ' << self operatorName << ' ' ]]	]! !!SpecOfComplexState methodsFor: 'initialization'!initialize	super initialize.		specs := OrderedCollection new! !!SpecOfComplexState methodsFor: 'accessing'!invertChildren	super invertChildren.		specs do: #invert! !!SpecOfComplexState methodsFor: 'printing'!operatorName	self subclassResponsibility ! !!SpecOfComplexState methodsFor: 'accessing'!specs	^specs! !!SpecOfComplexState methodsFor: 'accessing'!specs: anArray	specs := anArray! !!SpecOfNegation methodsFor: 'testing'!basicMatches: anObject	^specs allSatisfy: [ :each | 		each denial: denial not.		each matches: anObject ]! !!SpecOfNegation methodsFor: 'printing'!operatorName	^'or'! !!SpecOfNegation methodsFor: 'validation'!validate: anObject 	| result |	specs do: [:spec | 			result := spec denial: denial not; validate: anObject.			result isFailure ifTrue: [^result]].	^SpecOfValidationResult success! !!SpecOfOrDisjunction methodsFor: 'testing'!basicMatches: anObject	^specs anySatisfy: [ :each | 		each matches: anObject ]! !!SpecOfOrDisjunction methodsFor: 'printing'!operatorName	^'or'! !!SpecOfOrDisjunction methodsFor: 'validation'!validate: anObject 	| result |		specs do: [:eachSpec | 		result := eachSpec validate: anObject.		result isSuccess ifTrue: [^result]].		^SpecOfValidationResult failed: self for: anObject! !!SpecOfObjectClass methodsFor: 'testing'!basicMatches: anObject 	^anObject retriveClassForStateSpecs = requiredClass! !!SpecOfObjectClass methodsFor: 'displaying'!clauseKeyword	^'be an instance of'! !!SpecOfObjectRelationship class methodsFor: 'instance creation'!requiredClass: aClass 	^self new requiredClass: aClass! !!SpecOfObjectRelationship methodsFor: 'displaying'!clauseKeyword	self subclassResponsibility! !!SpecOfObjectRelationship methodsFor: 'displaying'!defaultTitle	^self clauseKeyword , ' ' , requiredClass name! !!SpecOfObjectRelationship methodsFor: 'accessing'!requiredClass	^requiredClass! !!SpecOfObjectRelationship methodsFor: 'accessing'!requiredClass: aClass 	requiredClass := aClass! !!SpecOfObjectSuperclass methodsFor: 'testing'!basicMatches: anObject 	| objectClass |	objectClass := anObject retriveClassForStateSpecs.	^objectClass == requiredClass or: [objectClass inheritsFrom: requiredClass]! !!SpecOfObjectSuperclass methodsFor: 'testing'!clauseKeyword	^'be a kind of'! !!SpecOfObjectResponsibility class methodsFor: 'instance creation'!for: aSelector 	^self new requiredMessage: aSelector! !!SpecOfObjectResponsibility methodsFor: 'testing'!basicMatches: anObject 	^anObject respondsTo: requiredMessage! !!SpecOfObjectResponsibility methodsFor: 'displaying'!defaultTitle	^'respond to ' , requiredMessage stringForSpecTitle ! !!SpecOfObjectResponsibility methodsFor: 'accessing'!requiredMessage	^requiredMessage! !!SpecOfObjectResponsibility methodsFor: 'accessing'!requiredMessage: aSymbol 	requiredMessage := aSymbol! !!SpecOfObjectState methodsFor: 'specs composition'!& aStateSpec 	^SpecOfAndConjunction of: self and: aStateSpec! !!SpecOfObjectState methodsFor: 'converting'!asStateSpec	^self! !!SpecOfObjectState methodsFor: 'testing'!basicMatches: anObject 	self subclassResponsibility! !!SpecOfObjectState methodsFor: 'debugging'!debugValidationFailingOver: aSpecFailed	UnhandledError signalForException: aSpecFailed! !!SpecOfObjectState methodsFor: 'printing'!defaultTitle	^'satisfy for ' , self class name! !!SpecOfObjectState methodsFor: 'accessing'!denial	^denial! !!SpecOfObjectState methodsFor: 'accessing'!denial: aBoolean 	denial == aBoolean ifTrue: [ ^self ].	self invert! !!SpecOfObjectState methodsFor: 'printing'!description	^self shouldPrefixPhrase , ' ' , self title! !!SpecOfObjectState methodsFor: 'accessing'!failureDescription	^ failureDescription! !!SpecOfObjectState methodsFor: 'accessing'!failureDescription: anObject	failureDescription := anObject! !!SpecOfObjectState methodsFor: 'initialize-release'!initialize	denial := false! !!SpecOfObjectState methodsFor: 'accessing'!invert	denial := denial not.	self invertChildren! !!SpecOfObjectState methodsFor: 'accessing'!invertChildren! !!SpecOfObjectState methodsFor: 'testing'!isSimpleValue	^false! !!SpecOfObjectState methodsFor: 'testing'!isStateSpec	^true! !!SpecOfObjectState methodsFor: 'testing'!matches: anObject 	^(self basicMatches: anObject) ~= denial! !!SpecOfObjectState methodsFor: 'specs composition'!not	^self copy invert; yourself! !!SpecOfObjectState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream << $( << self description << $)! !!SpecOfObjectState methodsFor: 'printing'!printSimpleValue	^self isSimpleValue 			ifTrue: [ self asSimpleValue stringForSpecTitle ]			ifFalse: [ '(', self title , ')' ]! !!SpecOfObjectState methodsFor: 'printing'!shouldPrefixPhrase	^'should' , (denial ifTrue: [' not'] ifFalse: [''])! !!SpecOfObjectState methodsFor: 'accessing'!title	^title ifNil: [title := self defaultTitle]! !!SpecOfObjectState methodsFor: 'accessing'!title: aString 	title := aString! !!SpecOfObjectState methodsFor: 'validation'!validate: anObject 	(self matches: anObject) ifTrue: [^SpecOfValidationResult success].	^self validationFailureFor: anObject! !!SpecOfObjectState methodsFor: 'validation'!validationFailureFor: anObject	^SpecOfValidationResult failed: self for: anObject ! !!SpecOfObjectState methodsFor: 'specs composition'!| aStateSpec 	^SpecOfOrDisjunction of: self and: aStateSpec! !!SpecOfObjectStateByPredicate class methodsFor: 'instance creation'!from: valuablelWithOneArg 	^self new predicate: valuablelWithOneArg! !!SpecOfObjectStateByPredicate methodsFor: 'testing'!basicMatches: anObject 	^predicate value: anObject! !!SpecOfObjectStateByPredicate methodsFor: 'accessing'!debugValidationFailingOver: aSpecFailed	"	[SpecDSLAcceptanceTests new customTestForArbitraryBlock] fork	"	| mainProcess |	aSpecFailed allowExtraDebugging.	UnhandledError signalForException: aSpecFailed.	mainProcess := Processor activeProcess.	[	mainProcess 		completeTo: aSpecFailed signalerContext sender; 		restartTop;			stepToHome: predicate asContext;		debug] forkAt: mainProcess priority.	mainProcess suspend! !!SpecOfObjectStateByPredicate methodsFor: 'displaying'!defaultTitle	^'satisfy: ' , predicate stringForSpecTitle! !!SpecOfObjectStateByPredicate methodsFor: 'accessing'!predicate	^predicate! !!SpecOfObjectStateByPredicate methodsFor: 'accessing'!predicate: aBlockContext 	predicate := aBlockContext! !!SpecOfApproxEquality class methodsFor: 'instance creation'!to: aNumber within: accuracyNumber 	^(self requiredValue: aNumber) accuracy: accuracyNumber ! !!SpecOfApproxEquality methodsFor: 'accessing'!accuracy	^accuracy! !!SpecOfApproxEquality methodsFor: 'accessing'!accuracy: anObject	accuracy := anObject! !!SpecOfApproxEquality methodsFor: 'testing'!basicMatches: aNumber 	^aNumber isEqual: requiredValue within: accuracy! !!SpecOfApproxEquality methodsFor: 'displaying'!defaultTitle	^'be within ' , accuracy stringForSpecTitle , ' of ' , requiredValue stringForSpecTitle! !!SpecOfCollectionOrderedEquality methodsFor: 'testing'!basicMatches: aCollection	^aCollection checkStateSpecsOrderedEqualityTo: requiredValue ! !!SpecOfCollectionOrderedEquality methodsFor: 'displaying'!clauseKeyword	^'equal in order to'! !!SpecOfEquality methodsFor: 'converting'!asSimpleValue 	^requiredValue! !!SpecOfEquality methodsFor: 'testing'!basicMatches: anObject 	^anObject checkStateSpecsEqualityTo: requiredValue ! !!SpecOfEquality methodsFor: 'displaying'!clauseKeyword	^'equal'! !!SpecOfEquality methodsFor: 'testing'!isSimpleValue 	^true! !!SpecOfIdentity class methodsFor: 'accessing'!to: requiredValue	^self requiredValue: requiredValue! !!SpecOfIdentity methodsFor: 'converting'!asSimpleValue 	^requiredValue! !!SpecOfIdentity methodsFor: 'testing'!basicMatches: anObject 	^requiredValue == anObject! !!SpecOfIdentity methodsFor: 'displaying'!clauseKeyword	^'be'! !!SpecOfIdentity methodsFor: 'testing'!isSimpleValue	^true! !!SpecOfGreaterMagnitude methodsFor: 'testing'!basicMatches: anObject 	isStrong ifTrue: [^anObject > requiredValue].		^anObject >= requiredValue ! !!SpecOfGreaterMagnitude methodsFor: 'displaying'!clauseKeyword	^self isStrong ifTrue: [ '>' ] ifFalse: [ '>=' ]! !!SpecOfLesserMagnitude methodsFor: 'testing'!basicMatches: anObject 	isStrong ifTrue: [^anObject < requiredValue].		^anObject <= requiredValue ! !!SpecOfLesserMagnitude methodsFor: 'displaying'!clauseKeyword	^self isStrong ifTrue: [ '<' ] ifFalse: [ '<=' ]! !!SpecOfMagnitudeOrder class methodsFor: 'instance creation'!than: aMagnidude strong: aBoolean	^self new 		isStrong: aBoolean;		requiredValue: aMagnidude;		yourself ! !!SpecOfMagnitudeOrder methodsFor: 'initialize-release'!initialize 	super initialize.	isStrong := false.! !!SpecOfMagnitudeOrder methodsFor: 'accessing'!isStrong	^ isStrong! !!SpecOfMagnitudeOrder methodsFor: 'accessing'!isStrong: anObject	isStrong := anObject! !!SpecOfObjectValue class methodsFor: 'instance creation'!requiredValue: anObject 	^self new requiredValue: anObject! !!SpecOfObjectValue methodsFor: 'displaying'!clauseKeyword	self subclassResponsibility! !!SpecOfObjectValue methodsFor: 'displaying'!defaultTitle	^self clauseKeyword , ' ' , requiredValue stringForSpecTitle! !!SpecOfObjectValue methodsFor: 'accessing'!requiredValue	^requiredValue! !!SpecOfObjectValue methodsFor: 'accessing'!requiredValue: anObject 	requiredValue := anObject! !!SpecOfString class methodsFor: 'instance creation'!requiredValue: aString caseSensitive: aBool	^(self requiredValue: aString)		caseSensitive: aBool! !!SpecOfString methodsFor: 'accessing'!caseSensitive	^ caseSensitive! !!SpecOfString methodsFor: 'accessing'!caseSensitive: anObject	caseSensitive := anObject! !!SpecOfString methodsFor: 'accessing'!defaultTitle	^caseSensitive		ifFalse: [ super defaultTitle ]		ifTrue: [ super defaultTitle , ' case sensitive' ] ! !!SpecOfString methodsFor: 'initialize-release'!initialize	super initialize.		caseSensitive := false! !!SpecOfStringBeginning methodsFor: 'testing'!basicMatches: aString		^caseSensitive 		ifTrue: [ aString beginsWith: requiredValue]		ifFalse: [ aString asLowercase beginsWith: requiredValue asLowercase ]! !!SpecOfStringBeginning methodsFor: 'displaying'!clauseKeyword	^'begin with'! !!SpecOfStringEnding methodsFor: 'testing'!basicMatches: aString		^caseSensitive 		ifTrue: [ aString endsWith: requiredValue]		ifFalse: [ aString asLowercase endsWith: requiredValue asLowercase ]! !!SpecOfStringEnding methodsFor: 'displaying'!clauseKeyword	^'end with'! !!SpecOfStringRegex methodsFor: 'testing'!basicMatches: aString		^caseSensitive 		ifTrue: [ requiredValue asRegex search: aString]		ifFalse: [ requiredValue asRegexIgnoringCase search: aString]! !!SpecOfStringRegex methodsFor: 'displaying'!clauseKeyword	^'match regex'! !!SpecOfSubstring methodsFor: 'testing'!basicMatches: aString	^aString includesSubstring: requiredValue caseSensitive: caseSensitive ! !!SpecOfSubstring methodsFor: 'displaying'!clauseKeyword	^'include substring'! !!SpecOfBlockValidationFailure class methodsFor: 'instance creation'!noErrorIn: aBlock butShouldBe: aSpecOfBlockFailure	^self spec: aSpecOfBlockFailure for: aBlock	! !!SpecOfBlockValidationFailure class methodsFor: 'instance creation'!unexpectedError: errorValidationResult in: aBlock butShouldBe: aSpecOfBlockFailure	^(self spec: aSpecOfBlockFailure for: aBlock)		errorValidationResult: errorValidationResult	! !!SpecOfBlockValidationFailure methodsFor: 'debugging'!debugSpecOver: aSpecFailed	errorValidationResult ifNil: [ ^super debugSpecOver: aSpecFailed ].		aSpecFailed allowExtraDebugging.	super debugSpecOver: aSpecFailed.			spec passUnexpectedFailures.	(spec validate: subject) raise! !!SpecOfBlockValidationFailure methodsFor: 'printing'!description	errorValidationResult ifNil: [ ^'Got no failures but ' , spec description ].		^errorValidationResult description! !!SpecOfBlockValidationFailure methodsFor: 'accessing'!errorValidationResult	^ errorValidationResult! !!SpecOfBlockValidationFailure methodsFor: 'accessing'!errorValidationResult: anObject	errorValidationResult := anObject! !!SpecOfBooleanPropertyValidationFailure methodsFor: 'printing'!description	subjectOwner ifNil: [ ^subject stringForSpecValidation , ' ' , spec description].		^(subjectOwner printSubject: subject)  , ' ' , spec description! !!SpecOfCollectionItemValidationFailure class methodsFor: 'instance creation'!noItemIn: aCollection butShouldBe: aSpecOfCollectionItem	^self spec: aSpecOfCollectionItem for: aCollection! !!SpecOfCollectionItemValidationFailure class methodsFor: 'instance creation'!unexpectedItem: itemObject in: aCollection butShouldBe: aSpecOfCollectionItem	^(self spec: aSpecOfCollectionItem for: aCollection)		wrongItem: itemObject! !!SpecOfCollectionItemValidationFailure methodsFor: 'displaying'!description	wrongItem ifNil: [ ^subject stringForSpecValidation, ' not includes key ', spec containingKey printString, ' which item ' , spec itemDescription ].		^'Got ', wrongItem stringForSpecValidation , ' at key ', spec containingKey printString, ' of ', subject stringForSpecValidation , ' but ', spec itemDescription ! !!SpecOfCollectionItemValidationFailure methodsFor: 'accessing'!wrongItem	^ wrongItem! !!SpecOfCollectionItemValidationFailure methodsFor: 'accessing'!wrongItem: anObject	wrongItem := anObject! !!SpecOfValidationFailure class methodsFor: 'instance creation'!spec: aStateSpec for: anObject 	^self new		subject: anObject;		spec: aStateSpec! !!SpecOfValidationFailure methodsFor: 'debugging'!debugSpecOver: aSpecFailed	spec debugValidationFailingOver: aSpecFailed! !!SpecOfValidationFailure methodsFor: 'printing'!description	subjectOwner ifNil: [ 		^'Got ', subject stringForSpecValidation , ' but it ' , spec description].		^'Got ', (subjectOwner printSubject: subject), ' but it ' , spec description.! !!SpecOfValidationFailure methodsFor: 'testing'!isFailure	^true! !!SpecOfValidationFailure methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream << $( << self description << $)! !!SpecOfValidationFailure methodsFor: 'accessing'!raise	| error |	error := SpecOfFailed withReason: self.	spec failureDescription ifNotNil: [ :desc | error messageText: desc].	^ error signal! !!SpecOfValidationFailure methodsFor: 'accessing'!spec	^spec! !!SpecOfValidationFailure methodsFor: 'accessing'!spec: aStateSpec 	spec := aStateSpec! !!SpecOfValidationFailure methodsFor: 'accessing'!subject	^subject! !!SpecOfValidationFailure methodsFor: 'accessing'!subject: anObject 	subject := anObject! !!SpecOfValidationFailure methodsFor: 'accessing'!subjectOwner	^ subjectOwner! !!SpecOfValidationFailure methodsFor: 'accessing'!subjectOwner: anObject	subjectOwner := anObject! !!SpecOfValidationResult class methodsFor: 'instance creation'!failed: aSpecOfObjectState for: anObject	^SpecOfValidationFailure spec: aSpecOfObjectState for: anObject! !!SpecOfValidationResult class methodsFor: 'defaults'!success	^Success ifNil: [ Success := SpecOfValidationSuccess new ]! !!SpecOfValidationResult methodsFor: 'testing'!isFailure	self subclassResponsibility! !!SpecOfValidationResult methodsFor: 'testing'!isSuccess	^self isFailure not! !!SpecOfValidationResult methodsFor: 'accessing'!raise	self subclassResponsibility! !!SpecOfValidationResult methodsFor: 'accessing'!subjectOwner: anObject	self subclassResponsibility ! !!SpecOfFailureValidationSuccess class methodsFor: 'instance creation'!with: anException	^self new 		signaledFailure: anException! !!SpecOfFailureValidationSuccess methodsFor: 'asserting'!asShouldExpressionReceiver	^signaledFailure asShouldExpressionReceiver! !!SpecOfFailureValidationSuccess methodsFor: 'accessing'!signaledFailure	^ signaledFailure! !!SpecOfFailureValidationSuccess methodsFor: 'accessing'!signaledFailure: anObject	signaledFailure := anObject! !!SpecOfValidationSuccess methodsFor: 'testing'!isFailure	^false! !!SpecOfValidationSuccess methodsFor: 'accessing'!raise! !!SpecOfValidationSuccess methodsFor: 'accessing'!subjectOwner: anObject	"Sucess result does not care about subject which was successfully validated 	and therefore it does not care where this subject was retrieved"! !!Number methodsFor: '*StateSpecs-Specs'!checkStateSpecsEqualityTo: aNumber	(aNumber retriveClassForStateSpecs includesBehavior: Number) ifFalse: [ ^false ].	^aNumber isEqual: self within: 0.00000001! !!Number methodsFor: '*StateSpecs-Specs'!isEqual: aNumber within: accuracy 	^(self - aNumber) abs < accuracy! !!String methodsFor: '*StateSpecs-Specs'!checkStateSpecsEqualityTo: anotherString	^self = anotherString! !!String methodsFor: '*StateSpecs-Specs'!stringForSpecTitle	^self printString! !!Interval methodsFor: '*StateSpecs-Specs'!checkStateSpecsEqualityTo: anotherCollection	(anotherCollection isKindOf: Interval) ifFalse: [^false].		^self = anotherCollection ! !!Interval methodsFor: '*StateSpecs-Specs'!checkStateSpecsOrderedEqualityTo: anotherCollection	^self checkStateSpecsEqualityTo: anotherCollection! !!Interval methodsFor: '*StateSpecs-Specs'!stringForSpecTitle	^self printString ! !!ByteArray methodsFor: '*StateSpecs-Specs'!checkStateSpecsEqualityTo: anotherByteArray	^self = anotherByteArray! !!ByteArray methodsFor: '*StateSpecs-Specs'!stringForSpecTitle 	^self printString! !!Point methodsFor: '*StateSpecs-Specs'!checkStateSpecsEqualityTo: aPoint	(aPoint retriveClassForStateSpecs includesBehavior: Point) ifFalse: [ ^false ].	^aPoint isEqual: self within: 0.00000001! !!Point methodsFor: '*StateSpecs-Specs'!isEqual: aPoint within: accuracy 	^(self dist: aPoint) < accuracy! !!BlockClosure methodsFor: '*StateSpecs-Specs'!asStateSpec	^SpecOfObjectStateByPredicate from: self! !!BlockClosure methodsFor: '*StateSpecs-Specs'!stringForSpecTitle	^self sourceNode formattedCode! !!BlockClosure methodsFor: '*StateSpecs-Specs'!valueForFutureStateValidation	^self value! !!Collection methodsFor: '*StateSpecs-Specs'!checkStateSpecsEqualityTo: anotherCollection	(anotherCollection isKindOf: Collection) ifFalse: [^false].		self size = anotherCollection size ifFalse: [ ^false ].		self do: [ :myEach |		(anotherCollection anySatisfy: [ :anotherEach | 			myEach checkStateSpecsEqualityTo: anotherEach]) ifFalse: [ ^false ]	].	^true! !!Collection methodsFor: '*StateSpecs-Specs'!checkStateSpecsOrderedEqualityTo: anotherCollection	(anotherCollection isKindOf: Collection) ifFalse: [^false].		self size = anotherCollection size ifFalse: [ ^false ].		self with: anotherCollection do: [ :myEach :anotherEach |		(myEach checkStateSpecsEqualityTo: anotherEach) ifFalse: [ ^false ]	].	^true! !!Collection methodsFor: '*StateSpecs-Specs'!stringForSpecTitle	^String streamContents: [:s | 				self printNameOn: s.		s nextPut: ${.		self do: [:element | s << element stringForSpecTitle << '. '].		self ifNotEmpty: [s skip: -2].		s nextPut: $}	]! !!Array methodsFor: '*StateSpecs-Specs'!stringForSpecTitle 	self shouldBePrintedAsLiteral ifTrue: [^self printString].	self isSelfEvaluating ifTrue: [^self printString].	^super stringForSpecTitle ! !!SpecOfFailed class methodsFor: 'instance creation'!raiseWith: aValidationFailing 	(self withReason: aValidationFailing) signal! !!SpecOfFailed class methodsFor: 'instance creation'!withReason: aValidationFailing 	^self new reason: aValidationFailing! !!SpecOfFailed methodsFor: 'accessing'!allowExtraDebugging	messageText := self messageText, '. Proceed to debug it'! !!SpecOfFailed methodsFor: 'private - actions'!defaultAction	^reason debugSpecOver: self! !!SpecOfFailed methodsFor: 'private'!defaultResumeValue	^ reason! !!SpecOfFailed methodsFor: 'testing'!isResumable	^true! !!SpecOfFailed methodsFor: 'displaying'!messageText	^messageText ifNil: [messageText := reason description]! !!SpecOfFailed methodsFor: 'accessing'!reason	^ reason! !!SpecOfFailed methodsFor: 'accessing'!reason: anObject	reason := anObject! !!SpecOfFailed methodsFor: 'sunit support'!sunitAnnounce: aTestCase toResult: aTestResult	aTestResult addFailure: aTestCase! !"StateSpecs-Specs"!!SpecOfBooleanPropertyValidator commentStamp: '' prior: 0!I implement validation of boolean properties of particular object. I am returned from expression 	2 should be And then any message to me will produce SpecOfBooleanProperty which I will use to validate my subject:	2 should be even.	2 should not be even.	1 should be evenInternal Representation and Key Implementation Points.    Instance Variables	subject:		<Object>	withNegation:		<Boolean>!!SpecOfShouldExpression commentStamp: '' prior: 0!I implement all kinds of "should DSL" expressions to perform object validation.You can get instance of me from any object by 	1 should And then you can call my validation methods:	1 should equal: 2	1 should not equal: 2Now I implement validation DSL by explicit messages. But before I was based on pragma approach which now extracted to separate package.To support both approaches I provide class variable CurrentExpressionsClass which is me by default. But if you load package with pragma based expressions then SpecOfPragmaBasedShouldExpression become current (look at it comment for detailes).To activate concrete expressions call 	SpecOfShouldExpression beCurrent All DSL methods are in expressions category. Internal Representation and Key Implementation Points.    Instance Variables	receiver:		<Object>	withNegation:		<Boolean>!!SpecOfFutureShouldExpression commentStamp: '' prior: 0!I am a special "takeAWhile" should expression which gives the system a time to satisfy the given spec: 	[ var ] should takeAWhile to equal: 10.	([ var ] should take: 100 seconds) to equal: 10.	array should takeAWhile to include: 10.I periodically repeat validation of receiver during specified duration (maxWaitingTime) until it's became matched.	By default the duration #maxWaitingTime is just 100 milliseconds.During validation I simply wait in the loop the specified condition. When my time is expired I return actual validation result of given spec.My main purpose is to simplify testing of multi process logic where tested objects fork processes which asyncronously modify some state. In such cases it is easy to just wait the state in the loop instead of organize the synchronization in the test with semaphores which is not always possible. For example test could start the server which initializes some state in separate process. So it becomes started after a while. Following should expression allows to test it in a simple way: 	[ server isStarted ] should takeAWhile to be: true.Or with #be construction it is even more simpler:	server should takeAWhile to be isStarted.Notice #takeAWhile keyword. It converts original should expression to my instance.For concrete waiting timeout use following expression: 	(server should take: 20 seconds) to be isStarted.	 Internal Representation and Key Implementation Points.    Instance Variables	maxWaitingTime:		<Duration>!!SpecOfShouldExpressionReceiverBuilder commentStamp: '' prior: 0!I am used to create internal property instance of given object which then can be validated:	(10@3) which x should equal: 10	which here returns me. Internal Representation and Key Implementation Points.    Instance Variables	property:		<SpecOfObjectProperty>!!SpecOfShouldReceiver commentStamp: '' prior: 0!I am a root of hierarchy of different kind of object properties which are used for validation of object properties in should expressions.My subclasses should implement two methods: - #subPropertyAt: returning another property by constructing the state chain.- #value returning actual value of the property.The main subclass is sSpecOfObjectProperty while others are kind of helpers to represent the root objects: - the object itself- object computed from the given block!!SpecOfShouldReceiverProperty commentStamp: '' prior: 0!I represent deep object property defined by particular message. For example I can be used to describe x coordinate of rectangle origin.	rectangle origin x"x" property in these example will point to "origin" property. And "origin" property will point to rectangle itself (root represented by SpecOfObjectItselfProperty instance).I implement printing method for spec title to look like	(10@20) xin case of property "x" of point (10@20).My instances can be created by 		SpecOfShouldExpressionReceiverProperty of: 	aShouldExpressionReceiver message: aMessage But in practice SpecOfShouldExpressionReceiverBuilder is used to create properties by normal message sends.	(10@20) where x Public API and Key Messages- subPropertyAt:  - value- stringForSpecTitle Internal Representation and Key Implementation Points.    Instance Variables	parent:		<SpecOfShouldExpressionReceiver>	parentMessage:		<Message>	value:		<Object>!!SpecOfShouldReceiverRoot commentStamp: '' prior: 0!I represent the root of should expression receiver.For example in following expression:	#actualValue should equal: 10.	I will represent the #actualValue as receiver in the instance of SpecOfShouldExpression. 	My instances can be created by 		SpecOfShouldReceiverRoot from: anObjectBut there is converting method on Object: 	anObject asShouldExpressionReceiverSome classes redefine this message to return different kind of should receivers.		Public API and Key Messages- propertyFrom:- value- stringForSpecTitle  Internal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!SpecOfFutureShouldReceiverRoot commentStamp: '' prior: 0!I represent the receiver in "future should expression" where validation subject could be specified using block: 	[ value ] should takeAWhile to equal: 10I modify the #validationSubject of superclass to allow using blocks and object in such expressions:	#() should takeAWhile to be isEmpty!!SpecOfObjectHolder class methodsFor: 'accessing'!requiredHolder: anObject	^self new 		requiredHolder: anObject! !!SpecOfObjectHolder methodsFor: 'testing'!basicMatches: anObject 	^requiredHolder includes: anObject! !!SpecOfObjectHolder methodsFor: 'accessing'!requiredHolder	^ requiredHolder! !!SpecOfObjectHolder methodsFor: 'accessing'!requiredHolder: anObject	requiredHolder := anObject! !!Object methodsFor: '*StateSpecs-DSL-ShouldExpressions'!asShouldExpressionReceiver	^SpecOfShouldReceiverRoot from: self! !!Object methodsFor: '*StateSpecs-DSL-ShouldExpressions'!should	^self asShouldExpressionReceiver should! !!Object methodsFor: '*StateSpecs-DSL-ShouldExpressions'!where	^self asShouldExpressionReceiver where! !!SpecOfBooleanPropertyValidator class methodsFor: 'instance creation'!for: aShouldExpression	^self new 		shouldExpression: aShouldExpression! !!SpecOfBooleanPropertyValidator class methodsFor: 'instance creation'!for: anObject withNegation: aBoolean	^self new 		subject: anObject;		withNegation: aBoolean! !!SpecOfBooleanPropertyValidator methodsFor: 'dispatching'!doesNotUnderstand: aMessage	| spec |	spec := SpecOfBooleanProperty fromMessage: aMessage.	^ shouldExpression evaluateWith: spec! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing'!shouldExpression	^ shouldExpression! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing'!shouldExpression: anObject	shouldExpression := anObject! !!SpecOfFutureShouldExpression methodsFor: 'initialization'!initialize	super initialize.		maxWaitingTime := 200 milliSeconds! !!SpecOfFutureShouldExpression methodsFor: 'accessing'!maxWaitingTime	^ maxWaitingTime! !!SpecOfFutureShouldExpression methodsFor: 'accessing'!maxWaitingTime: anObject	maxWaitingTime := anObject! !!SpecOfFutureShouldExpression methodsFor: 'execution'!validate: aSpecOfObjectState	"Idea is to periodicaly validate the receiver for given spec.	As soon as spec will be satisfied the method will return the successfull validation result.	Otherwise the method will wait for a while (maxWaitingTime) to allow it happens.	At the end it will validate the receiver the last time and return the result whatever it will be.		There is extra optimization for fast completion of method: to reduce waiting pauses.	At the beginning the method simply checks that the spec already matches receiver.	Then it will wait couple of small pauses to allow fast completion.	And only then it will enter the loop with long pauses (100 milliseconds)"	| startTime result |	(result := super validate: aSpecOfObjectState) isSuccess ifTrue: [ ^result ].	10 milliSeconds wait.	(result := super validate: aSpecOfObjectState) isSuccess ifTrue: [ ^result ].	20 milliSeconds wait.	(result := super validate: aSpecOfObjectState) isSuccess ifTrue: [ ^result ].		startTime := DateAndTime now - 30 milliSeconds. "which we already waited".	[DateAndTime now < (startTime + maxWaitingTime)] whileTrue: [ 		100 milliSeconds wait.		(result := super validate: aSpecOfObjectState) isSuccess ifTrue: [ ^result ]].		^super validate: aSpecOfObjectState! !!SpecOfShouldExpression class methodsFor: 'accessing'!beCurrent	^CurrentExpressionsClass := self! !!SpecOfShouldExpression class methodsFor: 'accessing'!currentExpressionsClass	^CurrentExpressionsClass ifNil: [ CurrentExpressionsClass := SpecOfShouldExpression ]! !!SpecOfShouldExpression class methodsFor: 'instance creation'!for: anObject	^self withReceiver: (SpecOfShouldReceiverRoot from: anObject)! !!SpecOfShouldExpression class methodsFor: 'instance creation'!startingAt: anObject	^self currentExpressionsClass for: anObject! !!SpecOfShouldExpression class methodsFor: 'instance creation'!withReceiver: aShouldExpressionReceiver	^self new 		receiver: aShouldExpressionReceiver! !!SpecOfShouldExpression class methodsFor: 'instance creation'!withReceiver: aShouldExpressionReceiver negation: aBoolean	^(self withReceiver: aShouldExpressionReceiver)		withNegation: aBoolean! !!SpecOfShouldExpression methodsFor: 'expressions'!be	^SpecOfBooleanPropertyValidator for: self! !!SpecOfShouldExpression methodsFor: 'expressions'!be: anObject 	^self evaluateWith: (SpecOfIdentity requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions'!be: anObject description: failureDescription	| spec |	spec := (SpecOfIdentity requiredValue: anObject).	spec failureDescription: failureDescription.		^self evaluateWith: spec! !!SpecOfShouldExpression methodsFor: 'expressions'!beGreaterOrEqualThan: anObject	^self evaluateWith: (SpecOfGreaterMagnitude than: anObject strong: false)! !!SpecOfShouldExpression methodsFor: 'expressions'!beGreaterThan: anObject	^self evaluateWith: (SpecOfGreaterMagnitude than: anObject strong: true)! !!SpecOfShouldExpression methodsFor: 'expressions'!beInstanceOf: aClass 	^self evaluateWith: (SpecOfObjectClass requiredClass: aClass)! !!SpecOfShouldExpression methodsFor: 'expressions'!beKindOf: aClass 	^self evaluateWith: (SpecOfObjectSuperclass requiredClass: aClass)! !!SpecOfShouldExpression methodsFor: 'expressions'!beLessOrEqualThan: anObject	^self evaluateWith: (SpecOfLesserMagnitude than: anObject strong: false)! !!SpecOfShouldExpression methodsFor: 'expressions'!beLessThan: anObject	^self evaluateWith: (SpecOfLesserMagnitude than: anObject strong: true)! !!SpecOfShouldExpression methodsFor: 'expressions'!beginWith: aString	^ self evaluateWith: (SpecOfStringBeginning requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions'!beginWith: aString caseSensitive: aBool	^ self evaluateWith: (SpecOfStringBeginning requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'execution'!createSpecOfValidationSubject	^receiver createSpecOfValidationSubject! !!SpecOfShouldExpression methodsFor: 'expressions'!endWith: aString	^ self evaluateWith: (SpecOfStringEnding requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions'!endWith: aString caseSensitive: aBool	^ self evaluateWith: (SpecOfStringEnding requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions'!equal: anObject 	^self evaluateWith: (SpecOfEquality requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions'!equal: anObject description: failureDescription	| spec |	spec := (SpecOfEquality requiredValue: anObject) .	spec failureDescription: failureDescription.		^self evaluateWith: spec! !!SpecOfShouldExpression methodsFor: 'expressions'!equal: aNumber within: accuracyNumber 	^self evaluateWith: (SpecOfApproxEquality to: aNumber within: accuracyNumber)! !!SpecOfShouldExpression methodsFor: 'expressions'!equalInOrder: anObject 	^self evaluateWith: (SpecOfCollectionOrderedEquality requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'execution'!evaluateWith: aSpecOfObjectState	| result |	aSpecOfObjectState denial: withNegation.	result := self validate: aSpecOfObjectState.	^ result raise ! !!SpecOfShouldExpression methodsFor: 'expressions'!fail	^self raise: Error! !!SpecOfShouldExpression methodsFor: 'expressions'!haveSize: aNumber 	^self evaluateWith: (SpecOfCollectionSize requiredSize: aNumber)! !!SpecOfShouldExpression methodsFor: 'expressions'!include: anObjectOrSpec	^ self evaluateWith: (SpecOfCollectionContents requiredItem: anObjectOrSpec)! !!SpecOfShouldExpression methodsFor: 'expressions'!include: itemObject at: keyObject	^self evaluateWith: (SpecOfCollectionItem at: keyObject requiredItem: itemObject)! !!SpecOfShouldExpression methodsFor: 'expressions'!includeKey: anObject 	^self evaluateWith: (SpecOfDictionaryKeys requiredKey: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions'!includeSubstring: aString	^ self evaluateWith: (SpecOfSubstring requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions'!includeSubstring: aString caseSensitive: aBool	^ self evaluateWith: (SpecOfSubstring requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'initialization'!initialize	super initialize.	withNegation := false! !!SpecOfShouldExpression methodsFor: 'expressions'!matchRegex: aRegexString	^ self evaluateWith: (SpecOfStringRegex requiredValue: aRegexString)! !!SpecOfShouldExpression methodsFor: 'expressions'!matchRegex: aRegexString caseSensitive: aBool	^ self evaluateWith: (SpecOfStringRegex requiredValue: aRegexString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions'!not	withNegation := withNegation not! !!SpecOfShouldExpression methodsFor: 'expressions'!raise: aClass 	^self evaluateWith: (SpecOfBlockFailure requiredFailure: aClass)! !!SpecOfShouldExpression methodsFor: 'accessing'!receiver	^ receiver! !!SpecOfShouldExpression methodsFor: 'accessing'!receiver: anObject	receiver := anObject! !!SpecOfShouldExpression methodsFor: 'accessing'!receiverOwner	^ receiverOwner! !!SpecOfShouldExpression methodsFor: 'accessing'!receiverOwner: anObject	receiverOwner := anObject! !!SpecOfShouldExpression methodsFor: 'expressions'!respondTo: aSelector 	^self evaluateWith: (SpecOfObjectResponsibility for: aSelector)! !!SpecOfShouldExpression methodsFor: 'expressions'!satisfy: aBlock	^self evaluateWith: (SpecOfObjectStateByPredicate from: aBlock)! !!SpecOfShouldExpression methodsFor: 'expressions'!take: maxDuration	^self takeAWhile 		maxWaitingTime: maxDuration;		yourself! !!SpecOfShouldExpression methodsFor: 'expressions'!takeAWhile	withNegation ifTrue: [		"The expression 'should not takeAWhile' logically means 		that following condition should be already true without any waiting. 		And it makes it equivalent to simple should expression"		 ^self class withReceiver: receiver asNegatedFutureStateShouldRecever].		^SpecOfFutureShouldExpression withReceiver: receiver asFutureStateShouldReceiver! !!SpecOfShouldExpression methodsFor: 'expressions'!to 	"Helper message for readability of should expressions:		some should takeAWhile to be: 10		(some should take: 10 seconds) to be: 10	It is defined here to support negated case: 		some not should takeAWhile to be: 10		(some not should take: 10 seconds) to be: 10	In that case 'should not takeAWhile' returns simple should expression 	and it needs to understand #to"			^self! !!SpecOfShouldExpression methodsFor: 'execution'!validate: aSpecOfObjectState	^receiver validateWith: aSpecOfObjectState! !!SpecOfShouldExpression methodsFor: 'accessing'!withNegation	^ withNegation! !!SpecOfShouldExpression methodsFor: 'accessing'!withNegation: anObject	withNegation := anObject! !!SpecOfShouldExpressionReceiverBuilder class methodsFor: 'instance creation'!startingWith: aShouldExpressionReceiver	^self new 		receiver: aShouldExpressionReceiver ! !!SpecOfShouldExpressionReceiverBuilder methodsFor: 'converting'!asShouldExpressionReceiver 	^receiver! !!SpecOfShouldExpressionReceiverBuilder methodsFor: 'dispatching'!doesNotUnderstand: aMessage	receiver := receiver propertyFrom: aMessage! !!SpecOfShouldExpressionReceiverBuilder methodsFor: 'printing'!printOn: aStream	aStream << 'Got '.	receiver printOn: aStream! !!SpecOfShouldExpressionReceiverBuilder methodsFor: 'accessing'!receiver	^ receiver! !!SpecOfShouldExpressionReceiverBuilder methodsFor: 'accessing'!receiver: anObject	receiver := anObject! !!SpecOfShouldExpressionReceiverBuilder methodsFor: 'accessing'!value	^self doesNotUnderstand: (Message selector: #value)! !!SpecOfShouldReceiver class methodsFor: 'testing'!isAbstract 	^self = SpecOfShouldReceiver! !!SpecOfShouldReceiver methodsFor: 'converting'!asFutureStateShouldReceiver	^self! !!SpecOfShouldReceiver methodsFor: 'converting'!asNegatedFutureStateShouldRecever	^self! !!SpecOfShouldReceiver methodsFor: 'validation'!createSpecOfValidationSubject	^SpecOfIdentity to: self validationSubject! !!SpecOfShouldReceiver methodsFor: 'testing'!includes: anObject	^self validationSubject = anObject! !!SpecOfShouldReceiver methodsFor: 'printing'!printPath	^''! !!SpecOfShouldReceiver methodsFor: 'printing'!printProperty: aShouldExpressionReceiverProperty	^self stringForSpecTitle, ' ', aShouldExpressionReceiverProperty printPath.! !!SpecOfShouldReceiver methodsFor: 'printing'!printSubject: anObject	^anObject stringForSpecTitle! !!SpecOfShouldReceiver methodsFor: 'accessing'!propertyFrom: aMessage	^SpecOfShouldReceiverProperty of: self message: aMessage! !!SpecOfShouldReceiver methodsFor: 'asserting'!should	^SpecOfShouldExpression currentExpressionsClass withReceiver: self! !!SpecOfShouldReceiver methodsFor: 'validation'!validate	"Subclasses can define some logical conditions on where	they can be really used before actual validation of subject.	For example argument capture in Mocketry verifies that expected message was actually sent"		^SpecOfValidationResult success! !!SpecOfShouldReceiver methodsFor: 'validation'!validateWith: aSpecOfObjectState	| result |	result := self validate.	result isSuccess ifFalse: [ ^result ].		result := aSpecOfObjectState validate: self validationSubject.	result subjectOwner: self.	^result! !!SpecOfShouldReceiver methodsFor: 'accessing'!validationSubject	self subclassResponsibility ! !!SpecOfShouldReceiver methodsFor: 'asserting'!where	^SpecOfShouldExpressionReceiverBuilder startingWith: self! !!SpecOfShouldReceiverProperty class methodsFor: 'instance creation'!of: anObjectProperty message: aMessage	^self new 		parent: anObjectProperty;		parentMessage: aMessage! !!SpecOfShouldReceiverProperty methodsFor: 'validation'!createSpecOfValidationSubject	^SpecOfObjectHolder requiredHolder: self! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!parent	^ parent! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!parent: anObject	parent := anObject! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!parentMessage	^ parentMessage! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!parentMessage: anObject	parentMessage := anObject! !!SpecOfShouldReceiverProperty methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: (self printSubject: self validationSubject)! !!SpecOfShouldReceiverProperty methodsFor: 'printing'!printPath	^parent printPath		ifEmpty: [parentMessage printString]		ifNotEmpty: [ :path | path , ' ' , parentMessage printString ]! !!SpecOfShouldReceiverProperty methodsFor: 'printing'!printProperty: aShouldExpressionReceiverProperty	^parent printProperty: aShouldExpressionReceiverProperty! !!SpecOfShouldReceiverProperty methodsFor: 'printing'!printSubject: anObject	^(super printSubject: anObject) , ' from ', self stringForSpecTitle! !!SpecOfShouldReceiverProperty methodsFor: 'printing'!stringForSpecTitle 	^parent printProperty: self! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!updateValue	value := parentMessage sendTo: parent validationSubject! !!SpecOfShouldReceiverProperty methodsFor: 'validation'!validate	^parent validate! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!validationSubject	self updateValue.	^ value! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!value	value! !!SpecOfShouldReceiverProperty methodsFor: 'accessing'!value: anObject	value := anObject! !!SpecOfFutureShouldReceiverRoot methodsFor: 'validation'!validationSubject	^value valueForFutureStateValidation ! !!SpecOfShouldReceiverRoot class methodsFor: 'instance creation'!from: anObject	^self new 		value: anObject! !!SpecOfShouldReceiverRoot methodsFor: 'converting'!asFutureStateShouldReceiver	^SpecOfFutureShouldReceiverRoot from: value! !!SpecOfShouldReceiverRoot methodsFor: 'converting'!asNegatedFutureStateShouldRecever	^self class from: value valueForFutureStateValidation ! !!SpecOfShouldReceiverRoot methodsFor: 'printing'!stringForSpecTitle 	^value stringForSpecTitle ! !!SpecOfShouldReceiverRoot methodsFor: 'accessing'!validationSubject	^ value! !!SpecOfShouldReceiverRoot methodsFor: 'accessing'!value	^value! !!SpecOfShouldReceiverRoot methodsFor: 'accessing'!value: anObject	value := anObject! !"StateSpecs-DSL-ShouldExpressions"!!SpecOfDSLClassWords commentStamp: '' prior: 0!I am created to group all DSL words in one hierarchy.My subclasses only provide better syntax of specs creation sentences.They can define multiple methods to return different kind of specs.Everything are implemented on class side!!Containing commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Equal commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Greater commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Has commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Identical commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Instance commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Kind commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Less commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Raise commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Respond commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Satisfying commentStamp: '' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!String class methodsFor: '*StateSpecs-DSL-ClassWords'!matchingCaseSensitiveRegex: requiredString	^SpecOfStringRegex requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords'!matchingRegex: requiredString	^SpecOfStringRegex requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords'!withBeginning: requiredString	^SpecOfStringBeginning requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords'!withCaseSensitiveBeginning: requiredString	^SpecOfStringBeginning requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords'!withCaseSensitiveEnding: requiredString	^SpecOfStringEnding requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords'!withCaseSensitiveSubstring: requiredString	^SpecOfSubstring requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords'!withEnding: requiredString	^SpecOfStringEnding requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords'!withSubstring: requiredString	^SpecOfSubstring requiredValue: requiredString	! !!Containing class methodsFor: 'specs creation'!item: anObjectOrSpec 	^SpecOfCollectionContents requiredItem: anObjectOrSpec! !!Containing class methodsFor: 'specs creation'!item: itemObject at: keyObject	^SpecOfCollectionItem at: keyObject requiredItem: itemObject! !!Containing class methodsFor: 'specs creation'!key: anObject 	^SpecOfDictionaryKeys requiredKey: anObject! !!Equal class methodsFor: 'specs creation'!inSameOrderTo: anObject 	^SpecOfCollectionOrderedEquality requiredValue: anObject! !!Equal class methodsFor: 'specs creation'!to: anObject 	^SpecOfEquality requiredValue: anObject! !!Equal class methodsFor: 'specs creation'!to: aNumber within: accuracyNumber 	^SpecOfApproxEquality to: aNumber within: accuracyNumber ! !!Greater class methodsFor: 'specs creation'!orEqualThan: anObject	^SpecOfGreaterMagnitude strong: false pattern: anObject ! !!Greater class methodsFor: 'specs creation'!than: anObject	^SpecOfGreaterMagnitude than: anObject strong: true! !!Has class methodsFor: 'specs creation'!emptyItems	^SpecOfCollectionSize requiredSize: 0! !!Has class methodsFor: 'specs creation'!size: aNumber 	^SpecOfCollectionSize requiredSize: aNumber! !!Identical class methodsFor: 'specs creation'!to: anObject 	^SpecOfIdentity requiredValue: anObject! !!Instance class methodsFor: 'specs creation'!of: aClass 	^SpecOfObjectClass requiredClass: aClass! !!Kind class methodsFor: 'specs creation'!of: aClass 	^SpecOfObjectSuperclass requiredClass: aClass! !!Less class methodsFor: 'specs creation'!orEqualThan: anObject	^SpecOfLesserMagnitude strong: false pattern: anObject ! !!Less class methodsFor: 'specs creation'!than: anObject	^SpecOfLesserMagnitude than: anObject strong: true! !!Raise class methodsFor: 'specs creation'!error	^self exception: (Kind of: Error)! !!Raise class methodsFor: 'specs creation'!exception: aClass 	^SpecOfBlockFailure requiredFailure: aClass! !!Respond class methodsFor: 'specs creation'!to: aSelector 	^SpecOfObjectResponsibility for: aSelector! !!Satisfying class methodsFor: 'specs creation'!for: aBlockContext 	^SpecOfObjectStateByPredicate from: aBlockContext! !"StateSpecs-DSL-ClassWords"!!GHTMinimalGhost commentStamp: '' prior: 0!I am trait for most minical ghost implementations.I define == and ~~ for information. These methods are special and actually never send to objects.I define method #yourself because it is not make sense to push it to meta level. And in that case  GHEmptyMetaMessages will not be really empty. Method #isGhost is convinient method to easy check if object is ghost. It is implemented in ProtoObject too!!GHTIdentifiedGhost commentStamp: '' prior: 0!I am trait for ghosts which are not required special identity interception because they supposed to be identified as any other objects.!!GHTNotNilGhost commentStamp: '' prior: 0!I am trait for ghost implementations which can not be nil.Most of my messages (ifNil friends) are never sent to objects because they are special. But I define it here to explicitly mention that NotNilGhost should not intercept them!!GHGhostBehaviour commentStamp: '' prior: 0!I am abstract behaviour of ghosts.Ghosts area special objects which process messages in unnatural Smalltalk way. My subclasses implement actual processing logic which define how gosts are behave.They should implement processing method:	send: aMessage to: aGhostConcrete ghost implementation can define set of meta messages. It is messages which should not be processed by ghost logic and instead should be performed in natural Smalltalk way. For example it can be #printString method which are used by inspectors to show object. Some ghosts are not need to intercept it. Instead inspector should show usual string presentation of such objects. To split metal level and domain level of ghosts my subclasses should implement  #currentMetaLevel method to return GHMetaLevel instance with specific set of meta messages. Meta messages are defined by explicit methods of GHMetaMessages hierarhy. There is GHStandardMetaMessages which for example contains #printString implementation. And there is GHEmptyMetaMessages which will intercept any message to ghosts.  Standard and empty meta levels are defined as singletons:	GHMetaLevel standard.	GHMetaLEvel empty Look at GHMetaLevel comments for details.Public API and Key Messages- intercept: aMessage to: aGhostit intercepts all messages   - send: aMessage to: aGhost it should process intercepted domain messages. It should be implemented by subclasses.- currentMetaLevel it should return GHMetaLevel instance which make sense for concrete ghost implementation!!GHDelegatorBehaviour commentStamp: '' prior: 0!I am delegation behaviour for ghost. I just resend intercepted message to my target objectMy instance can be creation by:	GHDelegatorBehaviour metaLevel: aGHMetaLevel target: anObject	GHDelegatorBehaviour target: anObjectInternal Representation and Key Implementation Points.    Instance Variables	metaLevel:		<GHMetaLevel>	target:		<Object>!!GHMetaLevel commentStamp: '' prior: 0!I represent meta level of particular ghost implementation.I include set of meta messages as explicit GHMetaMessages subclass. All messages which defined on it hierarchy I treat as meta.Public API and Key Messages- isMetaMessage: aMessage    - executeMetaMessage: aMessage on: aGhost it executes given meta message by sending it  to metaMessages instance created on given aGhost.I can be created by 	GHMetaLevel with: GHEmptyMetaMessages Internal Representation and Key Implementation Points.    Instance Variables	metaMessages:		<GHMetaMessages class>!!GHMetaMessages commentStamp: '' prior: 0!All methods of my subclasses define set of meta messages of ghost. They are  implemented with idea that actual receiver is ghost instance variable and not self. In that perpective I am a special helper class which should not be used outside GHMetaLevel. I provide little infrastructure for my subclasses:- ghostClass return real class of ghost - printGhost returns string representation of ghost- extractClassFrom: anObject it is class side method which uses mirror primitive to extract class of given object -includes: aSymbol it is class side method which check if given symbol belongs to meta message- metaMessagesClassit return my real class My instances are created on ghost:	GHMetaMessages for: aGhost	Internal Representation and Key Implementation Points.    Instance Variables	ghost:		<aGhost>!!GHEmptyMetaMessages commentStamp: '' prior: 0!I represent empty meta level for ghosts!!GHMinimalMetaMessages commentStamp: '' prior: 0!I implement minimal set of meta messages which define only class, hash and equality!!GHStandardMetaMessages commentStamp: '' prior: 0!I represent standart set of meta messages which used by tools to explore any objects state!!GHCurrentMetaLevelDepth commentStamp: '' prior: 0!I am process specific variable to count current depth of ghost meta level calls.I am used to prevent calls from meta level to domain level because domain level is intercepted by ghost but it should not happen during meta level call- increaseFor: aBlockit  increases current meta level depth for given block of code!!GHObjectGhost commentStamp: '' prior: 0!I am abstract ghost implementation which uses #doesNotUnderstand: approach to intercept all messages.My subclasses should decide how ghost behaviour should be defined. Should it be singleton for all ghosts? Or should it be specific for each ghost?Subclasses should implement single method #ghostBehaviour to return GHGhostBehaviour instance. Also they should implement instance creation method by #basicNew to create correctly initialized instances. !!GHObjectGhost class methodsFor: 'instance creation'!new 	"It is special naked abstract class. Simple new will hang image because #initialize will be called.	It which will produce infinite recursion due to abstracted DNU handling. 	We prevent it by making new subclass responsibility. 	Subclasses should use basicNew to implement it correctly"		self subclassResponsibility.! !!GHObjectGhost methodsFor: 'dispatching'!doesNotUnderstand: aMessage 		^self ghostBehaviour intercept: aMessage to: self! !!GHObjectGhost methodsFor: 'accessing'!ghostBehaviour	nil subclassResponsibility ! !!GHTIdentifiedGhost methodsFor: 'comparing'!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!GHTIdentifiedGhost methodsFor: 'comparing'!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!GHTIdentifiedGhost methodsFor: 'comparing'!hash	^self identityHash! !!GHTIdentifiedGhost methodsFor: 'comparing'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!GHTMinimalGhost methodsFor: 'comparing'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!GHTMinimalGhost methodsFor: 'converting'!asCollectionElement	! !!GHTMinimalGhost methodsFor: 'set implementation'!asSetElement! !!GHTMinimalGhost methodsFor: 'accessing'!enclosedElement	! !!GHTMinimalGhost methodsFor: 'set implementation'!enclosedSetElement! !!GHTMinimalGhost methodsFor: 'accessing'!ghostClass	^GHMetaMessages extractClassOf: self! !!GHTMinimalGhost methodsFor: 'comparing'!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!GHTMinimalGhost methodsFor: 'printing'!ghostPrintString	^GHMetaMessages printObject: self! !!GHTMinimalGhost methodsFor: 'testing'!isGhost	^true! !!GHTMinimalGhost methodsFor: 'message performing'!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!GHTMinimalGhost methodsFor: 'message performing'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!GHTMinimalGhost methodsFor: 'message performing'!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!GHTMinimalGhost methodsFor: 'message performing'!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!GHTMinimalGhost methodsFor: 'message performing'!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!GHTMinimalGhost methodsFor: 'message performing'!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!GHTMinimalGhost methodsFor: 'message performing'!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!GHTMinimalGhost methodsFor: 'apply primitives'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!GHTMinimalGhost methodsFor: 'accessing'!yourself! !!GHTMinimalGhost methodsFor: 'comparing'!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!GHTNotNilGhost methodsFor: 'testing'!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!GHTNotNilGhost methodsFor: 'testing'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing'!isNil	"Coerces nil to true and everything else to false."	^false! !!GHTNotNilGhost methodsFor: 'testing'!isNotNil	"Coerces nil to false and everything else to true."	^true! !!GHTNotNilGhost methodsFor: 'testing'!notNil	"Coerces nil to false and everything else to true."	^true! !!ProtoObject methodsFor: '*Ghost-ObjectGhost'!ghostClass	^self class! !!ProtoObject methodsFor: '*Ghost-ObjectGhost'!isGhost	^false! !!GHDelegatorBehaviour class methodsFor: 'instance creation'!metaLevel: aGHMetaLevel target: anObject 	^(self target: anObject)		metaLevel: aGHMetaLevel! !!GHDelegatorBehaviour class methodsFor: 'instance creation'!target: anObject 	^self new 		target: anObject! !!GHDelegatorBehaviour methodsFor: 'accessing'!currentMetaLevel	^metaLevel! !!GHDelegatorBehaviour methodsFor: 'initialization'!initialize	super initialize.		metaLevel := GHMetaLevel empty! !!GHDelegatorBehaviour methodsFor: 'accessing'!metaLevel	^ metaLevel! !!GHDelegatorBehaviour methodsFor: 'accessing'!metaLevel: anObject	metaLevel := anObject! !!GHDelegatorBehaviour methodsFor: 'message interception'!send: aMessage to: aGhost	^aMessage sendTo: target! !!GHDelegatorBehaviour methodsFor: 'accessing'!target	^ target! !!GHDelegatorBehaviour methodsFor: 'accessing'!target: anObject	target := anObject! !!GHGhostBehaviour methodsFor: 'accessing'!currentMetaLevel	^GHMetaLevel standard	"Standard meta level disables interception of messages from standard dev tools. 	With such default behaviour it possible to use tools on ghosts with broken interception logic.	When it will be done meta level can be changed to GHMetaLevel empty (or more suitable)"	! !!GHGhostBehaviour methodsFor: 'meta level'!executeMetaMessage: aMessage on: anObject  		^GHCurrentMetaLevelDepth increaseFor: [ 		self currentMetaLevel executeMetaMessage: aMessage on: anObject 	]! !!GHGhostBehaviour methodsFor: 'message interception'!intercept: aMessage to: anObject			^(self isMetaMessage: aMessage)		ifTrue: [ self executeMetaMessage: aMessage on: anObject  ]	 	ifFalse: [ self send: aMessage to: anObject  ]! !!GHGhostBehaviour methodsFor: 'meta level'!isMetaMessage: aMessage	GHCurrentMetaLevelDepth value > 0 ifTrue: [ ^true ]. 		^self currentMetaLevel isMetaMessage: aMessage! !!GHGhostBehaviour methodsFor: 'message interception'!send: aMessage to: aGhost	nil subclassResponsibility ! !!GHMetaLevel class methodsFor: 'accessing'!empty	^Empty ifNil: [ Empty := GHMetaLevel with: GHEmptyMetaMessages ]! !!GHMetaLevel class methodsFor: 'accessing'!standard	^Standard ifNil: [ Standard := GHMetaLevel with: GHStandardMetaMessages ]! !!GHMetaLevel class methodsFor: 'instance creation'!with: aMetaMessagesClass	^self new 		metaMessages: aMetaMessagesClass ! !!GHMetaLevel methodsFor: 'operations'!executeMetaMessage: aMessage on: aGhost		| metaMessageImplementor |	metaMessageImplementor := metaMessages for: aGhost.		^metaMessageImplementor executeMetaMessage: aMessage! !!GHMetaLevel methodsFor: 'initialize'!initialize	super initialize.		metaMessages := GHEmptyMetaMessages ! !!GHMetaLevel methodsFor: 'testing'!isMetaMessage: aMessage	^metaMessages includes: aMessage selector! !!GHMetaLevel methodsFor: 'accessing'!metaMessages	^ metaMessages! !!GHMetaLevel methodsFor: 'accessing'!metaMessages: anObject	metaMessages := anObject! !!GHEmptyMetaMessages class methodsFor: 'testing'!includes: aSymbol	^false! !!GHMetaMessages class methodsFor: 'helpers-primitives'!executeWith: receiver andArguments: argArray method: compiledMethod	"Execute compiledMethod against the receiver and the arguments in argArray"	"Please do not use this method. It is just there to make sure that we can invoke this primitive with right order of arguments"	<primitive: 188>	^self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives'!extractClassOf: anObject	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives'!extractIdentityHashOf: anObject	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives'!extractInstVarOf: anObject at: anIndex	"Primitive. Answer a fixed variable in an object. The numbering of the 	 variables corresponds to the named instance variables. Fail if the index 	 is not an Integer or is not the index of a fixed variable. Essential for the	 debugger. See  Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives'!extractSizeOf: anObject	"Answer the number of indexable variables in the argument anObject without sending	 it a message. This mimics the action of the VM when it fetches an object's variable size.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!GHMetaMessages class methodsFor: 'instance creation'!for: aGhost	^self new 		ghost: aGhost! !!GHMetaMessages class methodsFor: 'testing'!includes: aSymbol	| currentClass |	currentClass := self.		[currentClass == GHMetaMessages] whileFalse: [ 		(currentClass includesSelector: aSymbol) ifTrue: [ ^true ].		currentClass := currentClass superclass.	 ].	^false! !!GHMetaMessages class methodsFor: 'helpers-primitives'!makeShallowCopyOf: anObject	"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method."		<primitive: 148>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives'!printObject: anObject	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 32).	self printObject: anObject on: aStream.	^aStream contents! !!GHMetaMessages class methodsFor: 'helpers-primitives'!printObject: anObject on: aStream 	"Append to the argument aStream a sequence of characters        that describes the receiver."	| title |	title := (self extractClassOf: anObject) name.	aStream 		nextPutAll: ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).	aStream nextPutAll: title! !!GHMetaMessages class methodsFor: 'helpers-primitives'!setClass: classObject to: anObject	<primitive: 160>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives'!withReceiver: anObject perform: selector withArguments: argArray	^self withReceiver: anObject perform: selector withArguments: argArray inClass: (self extractClassOf: anObject)! !!GHMetaMessages class methodsFor: 'helpers-primitives'!withReceiver: anObject perform: selector withArguments: argArray inClass: lookupClass	"Send the selector, aSymbol, to anObject with arguments in argArray.	 Fail if the number of arguments expected by the selector 	 does not match the size of argArray, or if lookupClass	 cannot be found among the anObject's superclasses.	 Primitive. Essential for the debugger."	<primitive: 100 error: error>	self primitiveFailed! !!GHMetaMessages methodsFor: 'primitives'!executeMetaMessage: aMessage	^super perform: aMessage selector withArguments: aMessage arguments! !!GHMetaMessages methodsFor: 'accessing'!ghost	^ ghost! !!GHMetaMessages methodsFor: 'accessing'!ghost: anObject	ghost := anObject! !!GHMetaMessages methodsFor: 'primitives'!ghostClass	^self metaMessagesClass extractClassOf: ghost! !!GHMetaMessages methodsFor: 'primitives'!ghostExecuteWithArguments: argArray method: compiledMethod	^self metaMessagesClass executeWith: ghost andArguments: argArray method: compiledMethod! !!GHMetaMessages methodsFor: 'primitives'!ghostIdentityHash	^self metaMessagesClass extractIdentityHashOf: ghost! !!GHMetaMessages methodsFor: 'primitives'!ghostInstVarAt: index	^self metaMessagesClass extractInstVarOf: ghost at: index! !!GHMetaMessages methodsFor: 'primitives'!ghostSize	^self metaMessagesClass extractSizeOf: ghost! !!GHMetaMessages methodsFor: 'primitives'!metaMessagesClass	^super class! !!GHMetaMessages methodsFor: 'copying'!postCopy	"we define this message as default implementation for ghost copy methods"		^ghost! !!GHMetaMessages methodsFor: 'printing'!printGhost	^ghost ghostPrintString! !!GHMetaMessages methodsFor: 'printing'!printGhostClass	^self ghostClass name! !!GHMetaMessages methodsFor: 'copying'!shallowCopy	"we define this message as default implementation for ghost copy methods"		^self metaMessagesClass makeShallowCopyOf: ghost! !!GHMinimalMetaMessages methodsFor: 'comparing'!= anObject 	^ghost == anObject! !!GHMinimalMetaMessages methodsFor: 'comparing'!basicIdentityHash	^self ghostIdentityHash! !!GHMinimalMetaMessages methodsFor: 'accessing'!basicSize	^self ghostSize! !!GHMinimalMetaMessages methodsFor: 'class membership'!class	^self ghostClass! !!GHMinimalMetaMessages methodsFor: 'comparing'!hash	^self identityHash! !!GHMinimalMetaMessages methodsFor: 'comparing'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!GHStandardMetaMessages methodsFor: 'Tool-Base'!basicInspect	^ Smalltalk tools basicInspector inspect: ghost! !!GHStandardMetaMessages methodsFor: 'Tool-Base'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^ Smalltalk tools inspector inspect: ghost! !!GHStandardMetaMessages methodsFor: 'introspection'!instVarAt: index	^self ghostInstVarAt: index! !!GHStandardMetaMessages methodsFor: 'class membership'!isKindOf: aClass 	^self ghostClass includesBehavior: aClass! !!GHStandardMetaMessages methodsFor: 'literal testing'!isSelfEvaluating	^false! !!GHStandardMetaMessages methodsFor: 'printing'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	super longPrintOn: aStream limitedTo: sizeLimit indent: indent! !!GHStandardMetaMessages methodsFor: 'printing'!printOn: aStream 	^aStream << self printGhost! !!GHStandardMetaMessages methodsFor: 'printing'!printString	^self printGhost! !!GHStandardMetaMessages methodsFor: 'printing'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString := String streamContents: [:s | s << self printGhost ] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!GHStandardMetaMessages methodsFor: 'introspection'!readSlot: aSlot	^super readSlot: aSlot! !!GHStandardMetaMessages methodsFor: 'introspection'!readSlotNamed: aName	^super readSlotNamed: aName! !!GHStandardMetaMessages methodsFor: 'literal testing'!shouldBePrintedAsLiteral	^false! !!GHCurrentMetaLevelDepth class methodsFor: 'private'!decrease	self value: self value - 1! !!GHCurrentMetaLevelDepth class methodsFor: 'evaluating'!decreaseFor: aBlock	self decrease.	^aBlock ensure: [ self increase ]! !!GHCurrentMetaLevelDepth class methodsFor: 'private'!increase	self value: self value + 1! !!GHCurrentMetaLevelDepth class methodsFor: 'evaluating'!increaseFor: aBlock	self increase.	^aBlock ensure: [ self decrease ]! !!GHCurrentMetaLevelDepth methodsFor: 'default'!default	^0! !"Ghost-ObjectGhost"!!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!asStateSpec	^SpecOfIdentity to: self.! !!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!checkStateSpecsEqualityTo: anObject	^self == anObject! !!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!isStateSpec	^false! !!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!should	^SpecOfShouldExpression startingAt: self! !!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!stringForSpecTitle	^self ghostPrintString! !!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!stringForSpecValidation	^self stringForSpecTitle! !!GHTMinimalGhost methodsFor: '*StateSpecs-GhostSupport'!valueForFutureStateValidation	^self! !!GHClassGhost commentStamp: '' prior: 0!I am a ghost implementation which can substitute class of objects. For this I should has special object layout with variables superclass, methodDict and format.I use special trick with canNotInterpret: method to intercept instance messages from object which class I substitute. To make this trick working my subclasses should call method initializeClassProxy during instance creation. This method set up superclass variable with GHInstanceMessagesInterceptor which will perform  #canNotInterpret:. method  Look at it commentAs usual ghost my subclasses should implement #ghostBehaviour method and instance creation method. #ghostBehaviour will process direct messages to ghost.And to substitute real objects class ghosts should implement #instancesBehaviour which will process messages from real object instances.!!GHInstanceMessagesInterceptor commentStamp: '' prior: 0!I am used to intercept messages from instance which class was substituted by GHClassGhostI play role of superclass of proxified class and I intercept messages by #cannotInterpret: trick. Then I found real class proxy and delegate message to it behavior.I can be used as class of superclass variable of GHClassGhost. It will reduce number of objects required to substitute real object class.Or my instance can be used as superclass variable of GHClassGhost. In this case my superclass can be initialized with original object class. And internaly VM will think that object still belongs to original class by inheritance chain. And for example such proxified object can be used normally with VM #perform: primitives with given lookup class.!!GHClassGhost methodsFor: 'accessing'!findGhostInHierarchy	^self! !!GHClassGhost methodsFor: 'initialization'!initializeClassProxy	superclass := GHInstanceMessagesInterceptor.	methodDict := nil.	format := GHClassGhost format.! !!GHClassGhost methodsFor: 'accessing'!instancesBehaviour	nil subclassResponsibility ! !!GHClassGhost methodsFor: 'simulation trick'!lookupSelector: selector	"this method is overriden to allow debugging method calls to objects which classes was proxified by me"		^GHInstanceMessagesInterceptor prepareCannotInterpretMethodFor: selector  ! !!Class methodsFor: '*Ghost-ClassGhost'!findGhostInHierarchy	^superclass findGhostInHierarchy! !!GHInstanceMessagesInterceptor class methodsFor: 'instance creation'!for: originalClass	^self new 		superclass: originalClass! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick'!intercept: message to: receiver	"This method intercepts all messages to objects (receiver) which class was proxified by GHClassGhost.	 IMPORTANT!! In this case, 'receiver' is the instance whose class was proxified. Therefore, we cannot send ANY message to 'receiver' because we will cause an infinitive loop.	We first have to find the ghost in the class hierarchy of receiver. And then we delegate message to it behaviour. Concrete GHClassGhost should define #instancesBehaviour which will perform processing of intercepted messages. (#ghostBehaviour is used to intercept direct messages to ghosts).		Originaly instance side method #cannotInterpret: intercepts message to receiver du to special VM trick. Look at class comment"	| thisClass ghost |	thisClass := GHMetaMessages extractClassOf: receiver.		ghost := thisClass findGhostInHierarchy.		^ ghost instancesBehaviour intercept: message to: receiver! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick'!prepareCannotInterpretMethodFor: selector"I should prepare special method to simulate support behaviour of debugger to step into method which receiver class was proxified. Which means that step into should reflect cannotInterpret: trick"	| numArgs methodName method copy |	numArgs := selector numArgs.	methodName := 'cannotInterpretMethodForSelector'.		numArgs timesRepeat: [methodName := methodName, 'with:'].	methodName := methodName asSymbol.		method := self compiledMethodAt: methodName ifAbsent: [ ^self error: 'Please implement method ', methodName, ' on instance side for new num args'].	copy := method copy.	copy propertyValueAt: #canNotInterpretSelector put: selector.	^copy! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick'!simulateCannotInterpretIn: trickMethodContext"I am called from special methods which created to support debugging of methods which receiver class was proxified by cannotInterpret: trick"		| message selector receiver |	selector := trickMethodContext method propertyValueAt: #canNotInterpretSelector.		message := Message selector: selector arguments: trickMethodContext arguments.	receiver := trickMethodContext receiver.				^self intercept: message to: receiver! !!GHInstanceMessagesInterceptor methodsFor: 'intercepting'!cannotInterpret: aMessage 	"This method intercepts all messages to objects which class was proxified by GHClassGhost.	 IMPORTANT!! In this case, 'self' is the instance whose class was proxified. Therefore, we cannot send ANY message to 'self' because we will cause an infinitive loop.	We first have to find the ghost in the class hierarchy of receiver. And then we delegate message to it behaviour. Concrete GHClassGhost should define #instancesBehaviour which will perform processing of intercepted messages. (#ghostBehaviour is used to intercept direct messages to ghosts).		This logic extracted to class side method to be reused during simulation process when for example debugger step into is executed.	"		^GHInstanceMessagesInterceptor intercept: aMessage to: self! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelector		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelectorwith: arg1		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelectorwith: arg1 with: arg2		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'initialization'!initialize	super initialize.		format := GHInstanceMessagesInterceptor format.	methodDict := MethodDictionary new.	methodDict at: #cannotInterpret: put: GHInstanceMessagesInterceptor >> #cannotInterpret:! !!GHInstanceMessagesInterceptor methodsFor: 'accessing'!superclass	^ superclass! !!GHInstanceMessagesInterceptor methodsFor: 'accessing'!superclass: anObject	superclass := anObject! !"Ghost-ClassGhost"!!GHVictimBehaviour commentStamp: '' prior: 0!I am special ghost behaviour to process messages to objects which class was substituted by mutation.My purpose is to process meta messages by original implementation of mutated objects instead of delegate it to current meta level (look at comments of GHGhostBehaviour).  Nevertheless I use metal level to detect that intercepted message is meta. Also I consider meta all messages defined by GHTNotNilGhost.Some meta messages should be overriden with special mutation related logic. For example if #class message is considered as meta then it should return origial class of objects instead of mutation. Such overriden methods can be added to GHVictimMetaMessages in same way like other meta messages defined in GHMetaMessages subclasses. GHVictimMetaMessages methods are used as preferred implementation of meta messages.  Domain messages are processed by my mutationBehavour with which I should be created: 	GHVictimBehaviour forMutationWith: aGhostBehaviour Internal Representation and Key Implementation Points.    Instance Variables	mutationBehaviour:		<GHGhostBehaviour>!!GHVictimMetaMessages commentStamp: '' prior: 0!I am special meta messages container which is used as preferred implementation for meta messages of mutated objects.For example if #class message is considered as meta then it should return origial class of objects instead of mutation. Such overriden methods can be added to me in same way like other meta messages are defined in GHMetaMessages subclasses.  Only difference that I am not used to detect that intercepted message is meta.!!GHObjectMutation commentStamp: '' prior: 0!I am mutation which infects real objects to intercept all their messages.I replace class of victim object and use cannotInterpret:  trick  from my superclass GHClassGhost.From the meta level point of view mutated objects should be like normal ones. For this I use original implementation of meta messages from mutated objects. So GHMetaMessages approach is only used to detect that particular message belongs to meta level but execution of meta messages is performed by mutated objects themselfs.But some meta messages should be overriden (or new added) to see that object is mutated and to manage it specifically. For this purpose  all methods of GHVictimMetaMessages class are used as preferred implementation of meta messages.All describing logic of meta level is implemented by GHVictimBehaviour which created with actual mutation behaviour to perform actual processing of intercepted domain messages. But meta messages are processed by victim behaviour with help of mutation current meta level.Since I substitute class of mutated object I play role of original object class. I delegate all messages to victim class by classDelegator behaviour.To infect object you can perform: 	mutation mutate: anObject And to heal infected object: 	mutation heal: mutatedObjector just ask object 	mutatedObject recoverFromGHMutationTo check that object infected use 	object hasGHMutation You can ask object for it mutation 	object ghMutation(returns nil for not mutated objects).To create my instances use 	GHObjectMutation behaviour: aGhostBehaviour	Internal Representation and Key Implementation Points.    Instance Variables	classDelegator:		<GHDelegatorBehaviour>	victimBehaviour:		<GHVictimBehaviour>!!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation'!ghMutation	^nil! !!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation'!hasGHMutation	^false! !!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation'!recoverFromGHMutation! !!GHVictimBehaviour class methodsFor: 'instance creation'!forMutationWith: aGhostBehaviour	^self new 		mutationBehaviour: aGhostBehaviour ! !!GHVictimBehaviour class methodsFor: 'initialization'!initialize	OverridenMetaLevel := GHMetaLevel with: GHVictimMetaMessages ! !!GHVictimBehaviour methodsFor: 'meta level'!executeMetaMessage: aMessage on: infectedObject	^GHCurrentMetaLevelDepth increaseFor: [ 		(OverridenMetaLevel isMetaMessage: aMessage)			ifTrue: [ ^OverridenMetaLevel executeMetaMessage: aMessage on: infectedObject ]			ifFalse: [ GHVictimMetaMessages executeOriginalMethodOf: infectedObject for: aMessage ]	]! !!GHVictimBehaviour methodsFor: 'meta level'!isMetaMessage: aMessage		(GHTNotNilGhost includesSelector: aMessage selector) ifTrue: [ ^true ].	aMessage selector == #withArgs:executeMethod: ifTrue: [ ^true ].		^mutationBehaviour isMetaMessage: aMessage! !!GHVictimBehaviour methodsFor: 'accessing'!mutationBehaviour	^ mutationBehaviour! !!GHVictimBehaviour methodsFor: 'accessing'!mutationBehaviour: anObject	mutationBehaviour := anObject! !!GHVictimBehaviour methodsFor: 'messages processing'!send: aMessage to: aGhost	^mutationBehaviour send: aMessage to: aGhost! !!GHVictimMetaMessages class methodsFor: 'helpers'!executeOriginalMethodOf: infectedObject for: aMessage	| infectedClass |	infectedClass := self originalClassOf: infectedObject.			^GHMetaMessages withReceiver: infectedObject perform: aMessage selector withArguments: aMessage arguments inClass: infectedClass! !!GHVictimMetaMessages class methodsFor: 'helpers'!mutationOf: mutatedObject		^self extractClassOf: mutatedObject! !!GHVictimMetaMessages class methodsFor: 'helpers'!originalClassOf: mutatedObject	| mutation |	mutation := self mutationOf: mutatedObject.		^mutation victimClass! !!GHVictimMetaMessages methodsFor: 'meta messages'!class	^self metaMessagesClass originalClassOf: ghost! !!GHVictimMetaMessages methodsFor: 'meta messages'!ghMutation	^self metaMessagesClass mutationOf: ghost! !!GHVictimMetaMessages methodsFor: 'meta messages'!ghostClass	^self class! !!GHVictimMetaMessages methodsFor: 'meta messages'!hasGHMutation	^true! !!GHVictimMetaMessages methodsFor: 'meta messages'!perform: aSymbol	^self perform: aSymbol withArguments: #()! !!GHVictimMetaMessages methodsFor: 'meta messages'!perform: aSymbol with: anObject	^self perform: aSymbol withArguments: {anObject}! !!GHVictimMetaMessages methodsFor: 'meta messages'!perform: aSymbol with: firstObject with: secondObject	^self perform: aSymbol withArguments: {firstObject. secondObject}! !!GHVictimMetaMessages methodsFor: 'meta messages'!perform: aSymbol with: firstObject with: secondObject with: thirdObject	^self perform: aSymbol withArguments: {firstObject. secondObject. thirdObject}! !!GHVictimMetaMessages methodsFor: 'meta messages'!perform: aSymbol withArguments: arguments	^GHCurrentMetaLevelDepth decreaseFor: [ 			GHMetaMessages 			withReceiver: ghost 			perform: aSymbol 			withArguments: arguments] ! !!GHVictimMetaMessages methodsFor: 'meta messages'!perform: selector withEnoughArguments: anArray	^super perform: selector withEnoughArguments: anArray! !!GHVictimMetaMessages methodsFor: 'meta messages'!recoverFromGHMutation	self ghMutation heal: ghost.	^ghost! !!GHVictimMetaMessages methodsFor: 'meta messages'!retriveClassForStateSpecs	^self class! !!GHVictimMetaMessages methodsFor: 'meta messages'!withArgs: argArray executeMethod: compiledMethod		^GHCurrentMetaLevelDepth decreaseFor: [ 			GHMetaMessages executeWith: ghost andArguments: argArray method: compiledMethod]! !!GHObjectMutation class methodsFor: 'instance creation'!behaviour: aGhostBehaviour	^self basicNew 		mutationBehaviour: aGhostBehaviour ! !!GHObjectMutation methodsFor: 'comparison'!= anObject	anObject ghostClass == GHObjectMutation ifTrue: [ ^self victimClass == anObject victimClass ].		^self victimClass = anObject! !!GHObjectMutation methodsFor: 'accessing'!ghostBehaviour	^ classDelegator! !!GHObjectMutation methodsFor: 'infecting'!heal: anObject	anObject ghMutation == self ifFalse: [ 		anObject ghMutation == nil ifTrue: [ ^self ].		self error: 'I cant heal object which was infected by sombody else!!'	].		GHMetaMessages setClass: self victimClass to: anObject! !!GHObjectMutation methodsFor: 'comparison'!inheritsFrom: aClass		^self victimClass inheritsFrom: aClass! !!GHObjectMutation methodsFor: 'accessing'!instancesBehaviour	^ victimBehaviour ! !!GHObjectMutation methodsFor: 'infecting'!mutate: anObject	anObject ghMutation ifNotNil: [ :existedMutation |		existedMutation == self ifTrue: [ ^self ].		self error: 'I cant infect infected object!!'].		self victimClass: anObject class.	anObject injectGHMutation: self! !!GHObjectMutation methodsFor: 'accessing'!mutationBehaviour	^victimBehaviour mutationBehaviour! !!GHObjectMutation methodsFor: 'accessing'!mutationBehaviour: aGhostBehaviour	victimBehaviour := GHVictimBehaviour forMutationWith: aGhostBehaviour.	classDelegator := GHDelegatorBehaviour new.	self initializeClassProxy ! !!GHObjectMutation methodsFor: 'accessing'!victimBehaviour	^ victimBehaviour! !!GHObjectMutation methodsFor: 'accessing'!victimClass	^classDelegator target! !!GHObjectMutation methodsFor: 'accessing'!victimClass: aClass	(self victimClass == nil) | (self victimClass == aClass) ifFalse: [ 		^self error: 'Victim class should not be changed. It instances can be already infected'  ].		classDelegator target: aClass.	superclass := GHInstanceMessagesInterceptor for: aClass! !!ProtoObject methodsFor: '*Ghost-ObjectMutation'!ghMutation	^nil! !!ProtoObject methodsFor: '*Ghost-ObjectMutation'!hasGHMutation	^false! !!ProtoObject methodsFor: '*Ghost-ObjectMutation'!injectGHMutation: anObjectMutation	| helper |	helper := self class newAnonymousSubclass.		GHMetaMessages setClass: helper to: self.	helper becomeForward: anObjectMutation ! !!ProtoObject methodsFor: '*Ghost-ObjectMutation'!recoverFromGHMutation! !"Ghost-ObjectMutation"!!GHMinimalMetaMessages methodsFor: '*Ghost-GTSupport'!gtInspectorHash	^ self identityHash! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!asGlamorousArray 	 	^Array with: ghost! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!asGlamorousMultiValue	^ GLMMultiValue with: ghost! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!gtDebuggerPresentationsIn: composite inContext: aGTInspector	| pragmas |	pragmas := (Pragma 				allNamed: #gtDebuggerPresentationOrder: 				from: self metaMessagesClass 				to: ProtoObject) asOrderedCollection.	pragmas addAll:((Pragma 				allNamed: #gtInspectorPresentationOrder: 				from: self metaMessagesClass 				to: ProtoObject)					reject: [:pragma| pragma methodSelector = #gtInspectorRawIn: ]).	pragmas := pragmas sorted: [: x :y | (x argumentAt: 1) < (y argumentAt: 1)].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!gtDisplayOn: stream	super gtDisplayOn: stream! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!gtDisplayString		^self printString! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!gtInspectorActions	"This is a utility method that allows each object to define a set of actions 	specific for itself. These actions are used when the object appears in the inspector.	The actions are collected based on the #gtInspectorAction pragma that are defined in	unary methods corresponding to the body of the actions"		| all |	all := (Pragma 				allNamed: #gtInspectorAction				from: self metaMessagesClass 				to: ProtoObject) collect: [:eachPragma |					thisContext 						object: self						perform: eachPragma methodSelector 						withArguments: #() 						inClass: self metaMessagesClass ].	^ all asSortedCollection: [:a :b | 		| first second |		first := a isCategorized ifTrue: [a category, a title] ifFalse: [a title].		second := b isCategorized ifTrue: [b category, b title] ifFalse: [b title].		first < second]! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!gtInspectorPresentationsFromPragmas: aCollection In: composite inContext: aGTInspector	aCollection		do: [ :eachPragma | 			eachPragma methodSelector numArgs = 0				ifTrue: [ 					| configurationProvider |					configurationProvider := self perform: eachPragma methodSelector.					configurationProvider glmPresentation cull: composite cull: aGTInspector cull: self ].			eachPragma methodSelector numArgs = 1				ifTrue: [ 					thisContext 						object: self 						perform: eachPragma methodSelector 						withArguments: { composite } 						inClass: self metaMessagesClass ].			eachPragma methodSelector numArgs = 2				ifTrue: [ 					thisContext 						object: self 						perform: eachPragma methodSelector 						withArguments: { composite . aGTInspector } 						inClass: self metaMessagesClass ] ]! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!gtInspectorPresentationsIn: composite inContext: aGTInspector	"This is a utility method that collects all presentations for the current object.	By default, it simply looks for the #gtInspectorPresentationOrder: pragma.	The inspector can decice whether or not a presentation should be dispayed.	Subclasses might want to override it for more special behavior."	| pragmas |	pragmas := Pragma		allNamed: #gtInspectorPresentationOrder:		from: self metaMessagesClass		to: ProtoObject		sortedUsing: [ :x :y | (x argumentAt: 1) < (y argumentAt: 1) ].	pragmas := pragmas select: [ :aPragma | 		(aGTInspector respondsTo: #shouldDisplayPresentationCreatedBy:)			ifTrue: [ "Pharo6" aGTInspector shouldDisplayPresentationCreatedBy: aPragma method]			ifFalse: [ "Pharo5" aGTInspector shouldDisplayPresentationCreateBy: aPragma method ] ].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!gtInspectorVariableValuePairs		^super gtInspectorVariableValuePairs! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport'!iconOrThumbnailOfSize: aNumberOrPoint 	^super iconOrThumbnailOfSize: aNumberOrPoint! !!GHTIdentifiedGhost methodsFor: '*Ghost-GTSupport'!gtInspectorHash	^ self identityHash ! !!SpecOfMessagesValidationSuccess commentStamp: '' prior: 0!I represent successful result of occurred messages validation  by SpecOfOccurredMessages spec.I needed to supply list of occurred messages which satisfying spec. Then this information can be used in other more complex specs.Internal Representation and Key Implementation Points.    Instance Variables	occurredMessages:		<Collection of <MockOccurredMessage>>!!SpecOfAsynchMessage commentStamp: '' prior: 0!I am specification of asynchronous message send which means that I describe that message send should be occurred in not originalProcess.Internal Representation and Key Implementation Points.    Instance Variables	originalProcess:		<Process>!!SpecOfInteractionHistory commentStamp: '' prior: 0!I specify expectation for expected behavior like expected message send or sequence of messages. Concrete type of expectation is represented by difference kind of subclasses of SpecOfOccurredMessages.So my instances are created on top of occurred message specification: 		SpecOfInteractionHistory with: (			SpecOfExpectedMessage receiver: #receiver selector: #testMessage)I validate an instance of MockInteractionHistory which represent the occurred messages and involved objects. Comparing to the spec which I wrap I do extra logic to provide more precise result of validation to detect every involved object which break expectation.For example expected message can be specifyed as: 	spec := SpecOfExpectedMessage from: (MockOccurredMessage 					receiver: (Kind of: Rectangle) selector: #area).	In that case failed validation will produce very abstract result: 	messages := { MockOccurredMessage receiver: (0@0 corner: 1@1) selector: #area2 }.	(spec validate: messages) description "==>(be a kind of Rectangle) never received area"The result just shows that some of involved objects do not match expectation. In contrast I will tell what exact objects were bad:	((SpecOfInteractionHistory with: spec) validate: (MockInteractionHistory withAll: messages)) 			description "==> 0@0 corner: 1@1 never received area"During validation I convert given general spec to the list of corresponding specs for every involved objects in given interaction history: 	expectedBehaviorSpec asObjectInteractionSpecBetweenAll: aHistory involvedObjects. So the actual validation is performed over converted specification.And in case of this example I will validate following spec: 	SpecOfExpectedMessage from: (MockOccurredMessage receiver: (0@0 corner: 1@1) selector: #area).	  Internal Representation and Key Implementation Points.    Instance Variables	expectedBehaviourSpec:		<SpecOfOccurredMessages>!!SpecOfMessagePart commentStamp: '' prior: 0!I am a root of particular message part specs.Internal Representation and Key Implementation Points.    Instance Variables	requiredValue:		<SpecOfObjectState>!!SpecOfMessageArgument commentStamp: '' prior: 0!I specify required value for particular argument of message send.My instance can be created by 	SpecOfMessageArgument number: anInteger requiredValue: anObjectOrSpec Internal Representation and Key Implementation Points.    Instance Variables	argumentNumber:		<Integer>!!SpecOfMessageReceiver commentStamp: '' prior: 0!I specify required value for receiver of message send.My instance can be created by 	SpecOfMessageReceiver requiredValue: anObjectOrSpec!!SpecOfMessageResult commentStamp: '' prior: 0!I specify required result for occurred message send. I am abstract class for differed kind of results: returned value and raised exceptionMy subclasses should just implement usual method basicMatches: and validation result will be correct!!SpecOfMessageRaisedException commentStamp: '' prior: 0!I specify required exception which should be raised from occurred message send. !!SpecOfMessageReturnedValue commentStamp: '' prior: 0!I specify required returned value from occurred message send. !!SpecOfMessageSelector commentStamp: '' prior: 0!I specify required value for selector of message send.My instance can be created by 	SpecOfMessageReceiver requiredValue: anObjectOrSpec!!SpecOfMessageSendCondition commentStamp: '' prior: 0!I specify arbitrary condition during message send. I am used by MockExpectedMessage to validate any state in time when expectation should be executed.My instance can be created by 	SpecOfMessageSendCondition of: aSubjectBlock by: aSpecor it is created by dsl messages: 	mock stub someMessage when: [ anyState ] is: trueor	mock stub someMessage when: [ anyState ] is: (Instance of: Number) Internal Representation and Key Implementation Points.    Instance Variables	conditionSpec:		<SpecOfObjectState>	subjectBlock:		<BlockClosure>    Implementation Points!!SpecOfOccurredMessages commentStamp: '' prior: 0!I am base class for different kind of specifications for occurred message sends!!SpecOfExpectedMessage commentStamp: '' prior: 0!I am specification of expected message send. I consist of messageSend spec and usage spec. First defines message send signature and last defines how many times message can happen.My instance can be creation from MessageSend 	SpecOfExpectedMessage from: aMessageSend	Public API and Key Messages- allowSendsCount: anIntegerIt return true if given messages count can be happen.- detectFailureIn: messageSendsCollection It returns most close message send to me which not satisfy me.- addSpec: extraOccuredMessageSpec It is possible to add extra spec to message send descriptionInternal Representation and Key Implementation Points.    Instance Variables	messageSend:		<SpecOfMessageSend>	usage:		<SpecOfMessageUsage>    Implementation Points!!SpecOfExpectedObjectSender commentStamp: '' prior: 0!I am specification of expected object sender. I specify object which should be returned from one of occurred messages and I specify sender message which actualy should returned it. My instance can be created by	SpecOfExpectedObjectSender for: anObjectOrSpec returnedFrom: aSpecOfExpectedMessage Internal Representation and Key Implementation Points.    Instance Variables	object:		<Object>	requiredSender:	<SpecOfExpectedMessage>!!SpecOfMultipleMessages commentStamp: '' prior: 0!I specify group of expected message specs. (as conjunction)I don't care on messages sends orderMy contents are SpecOfExpectedMessage!!SpecOfExpectedMessageSequence commentStamp: '' prior: 0!I specify ordered group of expected message specs. (as conjunction).I am valid for group of messages only if they occurred in exact order which defined by my contents.My contents are SpecOfExpectedMessage!!SpecOfMessageSend commentStamp: '' prior: 0!I specify message send signature. I consist of receiver, selector and arguments specs (as conjunction).I can be created from MessageSend tempalte:	SpecOfMessageSend from: aMessageSendwhere aMessageSend is supposed to include specs in place of receiver, selector and arguments (objects will be converted to specs anyway).Public API and Key Messages- receiver- selector- arguments!!SpecOfWrongMessageSend commentStamp: '' prior: 0!I am root of different kind of message send validation failures.My subclasses provide suitable description of failure and required information about it.!!SpecOfAbsentMessageArgument commentStamp: '' prior: 0!I represent failure of SpecOfMessageArgument when given message had no particular argument number!!SpecOfExpectedMessageValidationFailure commentStamp: '' prior: 0!I represent failure of SpecOfExpectedMessage.  This spec validates list of occurred messages. And I specify information about what was going wrong.My occurredMessage contains list of valid occurred message sends.My wrongMessage contains validation failure about first wrong message send.Internal Representation and Key Implementation Points.    Instance Variables	occuredMessages:		<Collection of: <MockOccurredMessage>>	wrongMessage:		<SpecOfWrongMessageSend>!!SpecOfWrongMessageArgument commentStamp: '' prior: 0!I represent failure of SpecOfMessageArgument when actual message argument was wrong!!SpecOfWrongMessageProcess commentStamp: '' prior: 0!I represent failure of SpecOfAsynchMessage when actual message was occurred on wrong process!!SpecOfWrongMessageReceiver commentStamp: '' prior: 0!I represent failure of SpecOfMessageReceiver when actual message receiver was wrong!!SpecOfWrongMessageResult commentStamp: '' prior: 0!I represent failure of SpecOfMessageResult when actual message result was wrong!!SpecOfWrongMessageSelector commentStamp: '' prior: 0!I represent failure of SpecOfMessageSelector when actual message selector was wrong!!SpecOfWrongMessagesOrder commentStamp: '' prior: 0!I represent failure of SpecOfOrderedObjetsInteraction when actual messages order was wrongMy wrongMessage variable contains spec of message which was occurred in wrong time.Internal Representation and Key Implementation Points.    Instance Variables	wrongMessage:		<SpecOfExpectedMessage>!!SpecOfWrongObjectSender commentStamp: '' prior: 0!I represent failure of SpecOfExpectedObjectSender when object was not returned from any occurred messages or it was returned from wrong message.Internal Representation and Key Implementation Points.    Instance Variables	wrongSender:		<MockOccurredMessage>!!SpecOfMessageUsage commentStamp: '' prior: 0!I represent restriction on how many times message can be sent.I am part of SpecOfExpectedMessage.Public API and Key Messages- allowMessageSends: anInteger- allowMessageSends: anInteger withNegatedLogic: aBoolean- minCount: anInteger- maxCount: anInteger- exactCount: anIntegerInternal Representation and Key Implementation Points.    Instance Variables	maxCount:		<SmallInteger>	minCount:		<SmallInteger>!!SpecOfMessagesValidationSuccess class methodsFor: 'instance creation'!occurredMessages: messages	^self new 		occurredMessages: messages! !!SpecOfMessagesValidationSuccess class methodsFor: 'instance creation'!occurredMessages: messages minCount: aNumber	^self new 		occurredMessages: messages;		minMessagesCount: aNumber! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing'!minMessagesCount	^ minMessagesCount! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing'!minMessagesCount: anObject	minMessagesCount := anObject! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing'!occurredMessages	^ occurredMessages! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing'!occurredMessages: anObject	occurredMessages := anObject! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing'!requiredOccurredMessages	^occurredMessages first: minMessagesCount ! !!SpecOfAsynchMessage class methodsFor: 'instance creation'!forActiveProcess	^self new 		originalProcess: Processor activeProcess! !!SpecOfAsynchMessage methodsFor: 'testing'!basicMatches: anOccurredMessage		^anOccurredMessage process ~= originalProcess! !!SpecOfAsynchMessage methodsFor: 'accessing'!originalProcess	^ originalProcess! !!SpecOfAsynchMessage methodsFor: 'accessing'!originalProcess: anObject	originalProcess := anObject! !!SpecOfAsynchMessage methodsFor: 'validation'!validationFailureFor: anOccuredMessage	^SpecOfWrongMessageProcess spec: self for: anOccuredMessage ! !!SpecOfInteractionHistory class methodsFor: 'error'!with: anOccurredMessagesSpec	^self new 		expectedBehaviourSpec: anOccurredMessagesSpec ! !!SpecOfInteractionHistory methodsFor: 'validation'!basicMatches: anInteractionHistory	| concreteObjectInteraction |	concreteObjectInteraction := expectedBehaviourSpec 		asInteractionSpecBetweenConcreteObjectsOf: anInteractionHistory.		^concreteObjectInteraction matches: anInteractionHistory occurredMessages! !!SpecOfInteractionHistory methodsFor: 'accessing'!expectedBehaviourSpec	^ expectedBehaviourSpec! !!SpecOfInteractionHistory methodsFor: 'accessing'!expectedBehaviourSpec: anObject	expectedBehaviourSpec := anObject! !!SpecOfInteractionHistory methodsFor: 'accessing'!invertChildren	super invertChildren.	expectedBehaviourSpec invert! !!SpecOfInteractionHistory methodsFor: 'validation'!validate: anInteractionHistory	| concreteObjectInteraction |	concreteObjectInteraction := expectedBehaviourSpec 		asInteractionSpecBetweenConcreteObjectsOf: anInteractionHistory.		^concreteObjectInteraction validate: anInteractionHistory occurredMessages! !!SpecOfMessageArgument class methodsFor: 'instance creation'!number: anInteger requiredValue: anObjectOrSpec	^(self requiredValue: anObjectOrSpec)		argumentNumber: anInteger! !!SpecOfMessageArgument methodsFor: 'printing'!absentArgumentDescription	^'should have arg ', argumentNumber asString, ' which ', requiredValue description! !!SpecOfMessageArgument methodsFor: 'printing'!argumentDescription	^'arg ', argumentNumber asString, ' ', requiredValue description! !!SpecOfMessageArgument methodsFor: 'accessing'!argumentNumber	^ argumentNumber! !!SpecOfMessageArgument methodsFor: 'accessing'!argumentNumber: anObject	argumentNumber := anObject! !!SpecOfMessageArgument methodsFor: 'testing'!basicMatches: aMessageSend	| arg |	argumentNumber > aMessageSend numArgs ifTrue: [^false].		arg := aMessageSend arguments at: argumentNumber.	^requiredValue basicMatches: arg! !!SpecOfMessageArgument methodsFor: 'printing'!defaultTitle	^'have arg ', argumentNumber asString, ' which ' , requiredValue description! !!SpecOfMessageArgument methodsFor: 'validation'!validate: aMessageSend	| result |	argumentNumber > aMessageSend numArgs ifTrue: [ 		^SpecOfAbsentMessageArgument spec: self for: aMessageSend ].		result := requiredValue validate: (aMessageSend arguments at: argumentNumber).		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageArgument of: aMessageSend spec: self! !!SpecOfMessagePart class methodsFor: 'instance creation'!requiredValue: anObjectOrSpec	^self new 		requiredValue: anObjectOrSpec! !!SpecOfMessagePart methodsFor: 'accessing'!invertChildren	super invertChildren.		requiredValue invert! !!SpecOfMessagePart methodsFor: 'accessing'!requiredValue	^ requiredValue! !!SpecOfMessagePart methodsFor: 'accessing'!requiredValue: anObjectOrSpec	requiredValue := anObjectOrSpec asStateSpec! !!SpecOfMessageReceiver methodsFor: 'testing'!basicMatches: aMessageSend	^requiredValue basicMatches: aMessageSend receiver! !!SpecOfMessageReceiver methodsFor: 'printing'!defaultTitle	^'have receiver ' , requiredValue description! !!SpecOfMessageReceiver methodsFor: 'printing'!receiverDescription	^requiredValue description! !!SpecOfMessageReceiver methodsFor: 'accessing'!requiredValue: anObjectOrSpec	requiredValue := anObjectOrSpec isStateSpec 		ifTrue: [anObjectOrSpec ]		ifFalse: [ Identical to: anObjectOrSpec ]! !!SpecOfMessageReceiver methodsFor: 'validation'!validate: aMessageSend	| result |	result := requiredValue validate: aMessageSend receiver.		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageReceiver of: aMessageSend spec: self! !!SpecOfMessageRaisedException methodsFor: 'testing'!basicMatches: anOccurredMessage	^(anOccurredMessage hasRaisedExceptionLike: requiredValue) ~= denial! !!SpecOfMessageResult methodsFor: 'printing'!printResultDescription	^requiredValue description! !!SpecOfMessageResult methodsFor: 'validation'!validationFailureFor: anOccurredMessage	^SpecOfWrongMessageResult of: anOccurredMessage spec: self! !!SpecOfMessageReturnedValue methodsFor: 'testing'!basicMatches: anOccurredMessage	^(anOccurredMessage hasReturnedValueLike: requiredValue) ~= denial		! !!SpecOfMessageSelector methodsFor: 'testing'!basicMatches: aMessageSend	^requiredValue basicMatches: aMessageSend selector! !!SpecOfMessageSelector methodsFor: 'printing'!defaultTitle	^'have selector ' , self selectorDescription! !!SpecOfMessageSelector methodsFor: 'accessing'!requiredValue: anObjectOrSpec		requiredValue := anObjectOrSpec isStateSpec 		ifTrue: [ anObjectOrSpec ] ifFalse: [Identical to: anObjectOrSpec]! !!SpecOfMessageSelector methodsFor: 'printing'!selectorDescription	^requiredValue description! !!SpecOfMessageSelector methodsFor: 'validation'!validate: aMessageSend	| result |	result := requiredValue validate: aMessageSend selector.		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageSelector of: aMessageSend spec: self! !!SpecOfMessageSendCondition class methodsFor: 'instance creation'!of: subjectBlock by: aSpecOfObjectState	^self new 		subjectBlock: subjectBlock;		conditionSpec: aSpecOfObjectState ! !!SpecOfMessageSendCondition methodsFor: 'testing'!basicMatches: aMessageSend	| subject |	subject := subjectBlock valueWithEnoughArguments: aMessageSend arguments.	^(conditionSpec matches: subject)! !!SpecOfMessageSendCondition methodsFor: 'accessing'!conditionSpec	^ conditionSpec! !!SpecOfMessageSendCondition methodsFor: 'accessing'!conditionSpec: anObjectOrSpec	conditionSpec := anObjectOrSpec asStateSpec! !!SpecOfMessageSendCondition methodsFor: 'accessing'!invertChildren	super invertChildren.		conditionSpec invert! !!SpecOfMessageSendCondition methodsFor: 'accessing'!subjectBlock	^ subjectBlock! !!SpecOfMessageSendCondition methodsFor: 'accessing'!subjectBlock: anObject	subjectBlock := anObject! !!SpecOfMessageSendCondition methodsFor: 'validation'!validate: aMessageSend 	| subject |	subject := subjectBlock valueWithEnoughArguments: aMessageSend arguments.		^(conditionSpec validate: subject)! !!SpecOfExpectedMessage class methodsFor: 'instance creation'!from: aMessageSend	^self new 		messageSend: (SpecOfMessageSend from: aMessageSend)! !!SpecOfExpectedMessage methodsFor: 'accessing'!addSpec: extraOccuredMessageSpec 	messageSend addSpec: extraOccuredMessageSpec ! !!SpecOfExpectedMessage methodsFor: 'testing'!allowSendsCount: aNumber	^usage allowMessageSends: aNumber withNegatedLogic: denial! !!SpecOfExpectedMessage methodsFor: 'converting'!asInteractionSpecBetweenConcreteObjectsOf: anInteractionHistory	| result copy |	self isAboutConcreteReceiver ifTrue: [ ^ self ].		result := SpecOfMultipleMessages new.	anInteractionHistory involvedObjects do: [ :eachReceiver | 			(messageSend receiver matches: eachReceiver) ifTrue: [ 				copy := self copy.				copy receiver: eachReceiver.				result addExpectedMessage: copy ] 	].				result isEmpty ifTrue: [ ^ self ].	^ result! !!SpecOfExpectedMessage methodsFor: 'testing'!basicMatches: occurredMessages	| count |	count := occurredMessages count: [ :each | 		messageSend matches: each  ].		^usage allowMessageSends: count! !!SpecOfExpectedMessage methodsFor: 'capturing arguments'!captureArgumentsFrom: aMessageSend	messageSend captureArgumentsFrom: aMessageSend! !!SpecOfExpectedMessage methodsFor: 'copying'!copy	| result |	result := super copy.		result 		messageSend: messageSend copy;		usage: usage copy.		^result! !!SpecOfExpectedMessage methodsFor: 'validation'!createValidationSuccessFor: occurredMessages		^SpecOfMessagesValidationSuccess 		occurredMessages: occurredMessages 		minCount: (denial ifTrue: [ 0 ] ifFalse: [usage minCount ])! !!SpecOfExpectedMessage methodsFor: 'printing'!description		^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' ' << self shouldPrefixPhrase << ' receive '.		messageSend printMessageOn: s.				usage hasMeaningfulRestrictions ifTrue: [ 			s << ' ' << usage printRestrictions].	]	! !!SpecOfExpectedMessage methodsFor: 'validation'!detectFailureIn: messages	| withSimilarReceiver withSimilarSelector |	withSimilarReceiver := messages select: [ :each | messageSend receiver matches: each receiver].	withSimilarReceiver ifEmpty: [ ^nil ].		withSimilarSelector := withSimilarReceiver 		detect: [:each | messageSend selector matches: each selector]		ifNone: [^messageSend validate: withSimilarReceiver first].			^messageSend validate: withSimilarSelector ! !!SpecOfExpectedMessage methodsFor: 'initialization'!initialize	super initialize.		usage := SpecOfMessageUsage new! !!SpecOfExpectedMessage methodsFor: 'testing'!isAboutConcreteReceiver	^ messageSend receiver class = SpecOfIdentity! !!SpecOfExpectedMessage methodsFor: 'accessing'!messageSend	^ messageSend! !!SpecOfExpectedMessage methodsFor: 'accessing'!messageSend: anObject	messageSend := anObject! !!SpecOfExpectedMessage methodsFor: 'accessing'!populateMultipleMessagesSpec: aMultipleMessagesSpec	aMultipleMessagesSpec addExpectedMessage: self! !!SpecOfExpectedMessage methodsFor: 'printing'!printMessageNotHappen	^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' never received '.		messageSend printMessageOn: s]! !!SpecOfExpectedMessage methodsFor: 'printing'!printMessageSend	^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' '.		messageSend printMessageOn: s	]! !!SpecOfExpectedMessage methodsFor: 'accessing'!receiver: aStateSpec	messageSend receiver: aStateSpec! !!SpecOfExpectedMessage methodsFor: 'accessing'!restrictUsage	usage beStrict! !!SpecOfExpectedMessage methodsFor: 'accessing'!usage	^ usage! !!SpecOfExpectedMessage methodsFor: 'accessing'!usage: anObject	usage := anObject! !!SpecOfExpectedMessage methodsFor: 'validation'!validate: occurredMessages	| matched wrongMessage |	matched := occurredMessages select: [ :each | 		messageSend basicMatches: each  ].		(self allowSendsCount: matched size) ifTrue: [ ^ self createValidationSuccessFor: matched].		wrongMessage := self detectFailureIn: (occurredMessages copyWithoutAll: matched).	^SpecOfExpectedMessageValidationFailure 		spec: self 		for: occurredMessages		occuredMessages: matched 		mostSimilarMessage: wrongMessage! !!SpecOfExpectedObjectSender class methodsFor: 'instance creation'!for: aString returnedFrom: aSpecOfExpectedMessage 	^self new 		object: aString;		requiredSender: aSpecOfExpectedMessage ! !!SpecOfExpectedObjectSender methodsFor: 'converting'!asInteractionSpecBetweenConcreteObjectsOf: anInteractionHistory	| result returnedObjects concreteSenderSpec |	object asStateSpec class == SpecOfIdentity ifTrue: [^self]. 	result := SpecOfMultipleMessages new.		returnedObjects := anInteractionHistory occurredMessages 		select: [:each | each hasReturnedValueLike: object]		thenCollect: [:each | each returnedValue ].	returnedObjects do: [ :each | 		concreteSenderSpec := self class for: each returnedFrom: requiredSender.		result addExpectedMessage: concreteSenderSpec 	].	^result! !!SpecOfExpectedObjectSender methodsFor: 'testing'!basicMatches: occurredMessages	| actualSenders |	actualSenders := occurredMessages select: [:each | each hasReturnedValueLike: object].		^requiredSender basicMatches: actualSenders! !!SpecOfExpectedObjectSender methodsFor: 'printing'!description	^self printObject, ' should be returned from ', self printRequiredSender! !!SpecOfExpectedObjectSender methodsFor: 'accessing'!invertChildren	super invertChildren.	 	requiredSender invert! !!SpecOfExpectedObjectSender methodsFor: 'accessing'!object	^ object! !!SpecOfExpectedObjectSender methodsFor: 'accessing'!object: anObjectOrSpec	object := anObjectOrSpec asStateSpec! !!SpecOfExpectedObjectSender methodsFor: 'accessing'!populateMultipleMessagesSpec: aMultipleMessagesSpec	self shouldNotImplement ! !!SpecOfExpectedObjectSender methodsFor: 'printing'!printObject	^object printSimpleValue ! !!SpecOfExpectedObjectSender methodsFor: 'printing'!printRequiredSender	^requiredSender printMessageSend! !!SpecOfExpectedObjectSender methodsFor: 'accessing'!requiredSender	^ requiredSender! !!SpecOfExpectedObjectSender methodsFor: 'accessing'!requiredSender: anObject	requiredSender := anObject! !!SpecOfExpectedObjectSender methodsFor: 'validation'!validate: occurredMessages	| actualSenders result |	actualSenders := occurredMessages	select: [ :each | each hasReturnedValueLike: object ].	actualSenders ifEmpty: [ ^ self validateRequiredSenderFor: occurredMessages ].		result := requiredSender validate: actualSenders.	result isSuccess ifTrue: [ ^ result ].		^ SpecOfWrongObjectSender spec: self for: occurredMessages wrongSender: actualSenders last! !!SpecOfExpectedObjectSender methodsFor: 'validation'!validateRequiredSenderFor: occurredMessages	| result |	result := requiredSender validate: occurredMessages.	result isSuccess ifTrue: [ 		result := (SpecOfMessageReturnedValue requiredValue: object)			validate: result occurredMessages last ].		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongObjectSender spec: self for: occurredMessages! !!SpecOfExpectedMessageSequence methodsFor: 'validation'!basicMatches: occurredMessages	| uncheckedMessages result |		uncheckedMessages := OrderedCollection withAll: occurredMessages.	expectedMessages do: [ :eachSpec |			result := eachSpec validate: uncheckedMessages.				result isFailure ifTrue: [ ^false].		uncheckedMessages := uncheckedMessages copyAfter: result requiredOccurredMessages last.	].		^true! !!SpecOfExpectedMessageSequence methodsFor: 'validation'!validate: occurredMessages	| uncheckedMessages result allOccurred validMessages |	allOccurred := super validate: occurredMessages.	allOccurred isFailure ifTrue: [^allOccurred].		uncheckedMessages := OrderedCollection withAll: occurredMessages.	validMessages := OrderedCollection new.	expectedMessages do: [ :eachSpec |			result := eachSpec validate: uncheckedMessages.				result isFailure ifTrue: [ ^SpecOfWrongMessagesOrder of: occurredMessages spec: self validMessages: validMessages wrongMessage: eachSpec].		result requiredOccurredMessages ifNotEmpty: [:required |			validMessages addAll: required.			uncheckedMessages := uncheckedMessages copyAfter: required last].	].		^SpecOfValidationResult success! !!SpecOfMultipleMessages methodsFor: 'accessing'!addExpectedMessage: aSpecOfExpectedMessage		expectedMessages add: aSpecOfExpectedMessage ! !!SpecOfMultipleMessages methodsFor: 'accessing'!addExpectedMessages: newExpectedMessages		expectedMessages addAll: newExpectedMessages! !!SpecOfMultipleMessages methodsFor: 'converting'!asInteractionSpecBetweenConcreteObjectsOf: anInteractionHistory	| result interactionSpec |	result := self class new.		expectedMessages do: [ :each | 		interactionSpec := each asInteractionSpecBetweenConcreteObjectsOf: anInteractionHistory.		interactionSpec populateMultipleMessagesSpec: result			 ].	^result! !!SpecOfMultipleMessages methodsFor: 'testing'!basicMatches: occurredMessages	^expectedMessages allSatisfy: [ :each | 		each matches: occurredMessages ]! !!SpecOfMultipleMessages methodsFor: 'copying'!copy	| copy |	copy := super copy.	copy expectedMessages: (expectedMessages collect: [ :each | each copy]).	^copy! !!SpecOfMultipleMessages methodsFor: 'accessing'!expectedMessages	^ expectedMessages! !!SpecOfMultipleMessages methodsFor: 'accessing'!expectedMessages: anObject	expectedMessages := anObject! !!SpecOfMultipleMessages methodsFor: 'initialization'!initialize	super initialize.		expectedMessages := OrderedCollection new! !!SpecOfMultipleMessages methodsFor: 'accessing'!invertChildren	expectedMessages do: [ :each | each invert ]! !!SpecOfMultipleMessages methodsFor: 'testing'!isEmpty	^expectedMessages isEmpty! !!SpecOfMultipleMessages methodsFor: 'accessing'!populateMultipleMessagesSpec: aMultipleMessagesSpec	aMultipleMessagesSpec addExpectedMessages: expectedMessages! !!SpecOfMultipleMessages methodsFor: 'validation'!validate: occurredMessages	| uncheckedMessages failedSpecs result |	uncheckedMessages := OrderedCollection withAll: occurredMessages.	failedSpecs := OrderedCollection new.		expectedMessages do: [ :each |				result := each validate: uncheckedMessages.		result isSuccess 			ifTrue: [ uncheckedMessages removeAll: result requiredOccurredMessages ]			ifFalse: [ failedSpecs add: each ]].			failedSpecs ifEmpty: [ ^SpecOfMessagesValidationSuccess occurredMessages: (occurredMessages copyWithoutAll: uncheckedMessages) ].			^failedSpecs first validate: uncheckedMessages! !!SpecOfOccurredMessages class methodsFor: 'testing'!isAbstract 	^self = SpecOfOccurredMessages! !!SpecOfOccurredMessages methodsFor: 'converting'!asInteractionSpecBetweenConcreteObjectsOf: anInteractionHistory	self subclassResponsibility ! !!SpecOfOccurredMessages methodsFor: 'accessing'!populateMultipleMessagesSpec: aMultipleMessagesSpec	self subclassResponsibility ! !!SpecOfMessageSend class methodsFor: 'instance creation'!from: aMessageSendTemplateWithSpecs	^self new 		readSpecsFrom: aMessageSendTemplateWithSpecs ! !!SpecOfMessageSend methodsFor: 'accessing'!arguments	^(specs last: (specs size - 2)) collect: [ :each | each requiredValue ] ! !!SpecOfMessageSend methodsFor: 'capturing arguments'!captureArgumentsFrom: aMessageSend	self arguments withIndexDo: [ :argSpec :argIndex | | argValue |		argValue := aMessageSend arguments at: argIndex.		argSpec captureValue: argValue]! !!SpecOfMessageSend methodsFor: 'printing'!description	^String streamContents: [ :s |		self printReceiverOn: s.		s << ' ' << self shouldPrefixPhrase << ' receive '.		self printMessageOn: s	]! !!SpecOfMessageSend methodsFor: 'printing'!printArgumentsArrayOn: aStream	| args |	aStream << ${.	args := self arguments.		args do: [:each |		each isSimpleValue 			ifTrue: [ aStream << each asSimpleValue stringForSpecTitle]			ifFalse: [ aStream << each title ].		each == args last ifFalse: [ aStream << $.]].		aStream << $}.! !!SpecOfMessageSend methodsFor: 'printing'!printMessageOn: aStream	self selector isSimpleValue 			ifTrue: [ self printSimpleMessageOn: aStream ]			ifFalse: [ 				aStream << self selector title << ' with '.				self printArgumentsArrayOn: aStream ]! !!SpecOfMessageSend methodsFor: 'printing'!printReceiverOn: aStream	aStream << self receiver printSimpleValue ! !!SpecOfMessageSend methodsFor: 'printing'!printSimpleMessageOn: aStream	| selector args |	selector := self selector asSimpleValue.	args := self arguments.	args isEmpty ifTrue: [^ aStream << selector].	args with: selector keywords do: [:arg :word |		aStream << word; space.		arg isSimpleValue 			ifTrue: [aStream << arg asSimpleValue stringForSpecTitle] 			ifFalse: [aStream << $( << arg stringForSpecTitle << $)].		aStream space.	].	aStream skip: -1! !!SpecOfMessageSend methodsFor: 'accessing'!readSpecsFrom: aMessageSend	specs := OrderedCollection new: 2 + aMessageSend numArgs.	specs add: (SpecOfMessageReceiver requiredValue: aMessageSend receiver).	specs add: (	SpecOfMessageSelector requiredValue: aMessageSend selector).		aMessageSend arguments withIndexDo: [:each :i |		specs add: (each asSpecOfArg: i of: self) ]! !!SpecOfMessageSend methodsFor: 'accessing'!receiver	^specs first requiredValue! !!SpecOfMessageSend methodsFor: 'accessing'!receiver: aStateSpec	^specs first requiredValue: aStateSpec! !!SpecOfMessageSend methodsFor: 'accessing'!selector	^specs second requiredValue! !!SpecOfAbsentMessageArgument methodsFor: 'printing'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but it ', spec absentArgumentDescription! !!SpecOfExpectedMessageValidationFailure class methodsFor: 'instance creation'!spec: aSpecOfExpectedMessage for: actualMessages occuredMessages: occurredMessages mostSimilarMessage: wrongMessageFailure	^(self spec: aSpecOfExpectedMessage for: actualMessages )		occuredMessages: occurredMessages;		mostSimilarMessage: wrongMessageFailure! !!SpecOfExpectedMessageValidationFailure methodsFor: 'printing'!description	"mostSimilarMessage ifNotNil: [ ^mostSimilarMessage description]."	occuredMessages ifEmpty: [ ^spec printMessageNotHappen].		^spec description, ' but it was ', occuredMessages size asString , ' times' ! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing'!mostSimilarMessage	^ mostSimilarMessage! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing'!mostSimilarMessage: anObject	mostSimilarMessage := anObject! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing'!occuredMessages	^ occuredMessages! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing'!occuredMessages: anObject	occuredMessages := anObject! !!SpecOfWrongMessageArgument methodsFor: 'printing'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but ', spec argumentDescription! !!SpecOfWrongMessageProcess methodsFor: 'printing'!description	| desc |	desc := subject receiver stringForSpecValidation, ' should receive ', subject printMessage.	spec denial 		ifTrue: [ desc := desc , ' in original process' ]		ifFalse: [ desc := desc , ' in another process' ].	^desc! !!SpecOfWrongMessageReceiver methodsFor: 'printing'!description	^subject printMessage, ' is sent to ', subject receiver stringForSpecValidation			, ' but it ', spec receiverDescription! !!SpecOfWrongMessageResult methodsFor: 'printing'!description	^'Got ', subject stringForResultSpec, ' but it ', spec printResultDescription! !!SpecOfWrongMessageSelector methodsFor: 'printing'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but it ', spec selectorDescription! !!SpecOfWrongMessageSend class methodsFor: 'instance creation'!of: aMessageSend spec: aSpecOfMessageSendReceiver 	^self spec: aSpecOfMessageSendReceiver for: aMessageSend ! !!SpecOfWrongMessagesOrder class methodsFor: 'instance creation'!of: occurredMessages spec: anOrderedInteractionSpec validMessages: validExpectedMessages wrongMessage: anExpectedMessageSpec	^(self spec: anOrderedInteractionSpec for: occurredMessages)		wrongMessage: anExpectedMessageSpec;		validMessages: validExpectedMessages! !!SpecOfWrongMessagesOrder class methodsFor: 'instance creation'!of: occurredMessages spec: anOrderedInteractionSpec wrongMessage: anExpectedMessageSpec	^(self spec: anOrderedInteractionSpec for: occurredMessages)		wrongMessage: anExpectedMessageSpec ! !!SpecOfWrongMessagesOrder methodsFor: 'printing'!description 	| send |	^String streamContents: [ :s | 		send := wrongMessage messageSend.		send printReceiverOn: s.		s << ' received '.		send printMessageOn: s.		s << ' in wrong time'	]! !!SpecOfWrongMessagesOrder methodsFor: 'accessing'!validMessages	^ validMessages! !!SpecOfWrongMessagesOrder methodsFor: 'accessing'!validMessages: anObject	validMessages := anObject! !!SpecOfWrongMessagesOrder methodsFor: 'accessing'!wrongMessage	^ wrongMessage! !!SpecOfWrongMessagesOrder methodsFor: 'accessing'!wrongMessage: anObject	wrongMessage := anObject! !!SpecOfWrongObjectSender class methodsFor: 'instance creation'!spec: aSpecOfExpectedObjectSender for: occurredMessages wrongSender: anOccurredMessage 	^(self spec: aSpecOfExpectedObjectSender for: occurredMessages)		wrongSender: anOccurredMessage ! !!SpecOfWrongObjectSender methodsFor: 'printing'!description	wrongSender ifNil: [ 		^spec printObject, ' was not returned by anybody'			, ' but it should be ', spec printRequiredSender.	 ].				^spec printObject, ' was returned from ', wrongSender printWithoutResult		, ' but it should be ', spec printRequiredSender.	! !!SpecOfWrongObjectSender methodsFor: 'accessing'!wrongSender	^ wrongSender! !!SpecOfWrongObjectSender methodsFor: 'accessing'!wrongSender: anObject	wrongSender := anObject! !!SpecOfMessageUsage methodsFor: 'testing'!allowMessageSends: messagesCount 	^self allowMessageSends: messagesCount withNegatedLogic: false! !!SpecOfMessageUsage methodsFor: 'testing'!allowMessageSends: messagesCount withNegatedLogic: denial	(messagesCount = 0 & (minCount = 0) & denial) ifTrue: [ ^true ].		^(messagesCount between: minCount and: maxCount) ~= denial! !!SpecOfMessageUsage methodsFor: 'accessing'!beStrict	maxCount := minCount! !!SpecOfMessageUsage methodsFor: 'accessing'!beUnlimited	maxCount := Float infinity ! !!SpecOfMessageUsage methodsFor: 'accessing'!exactCount: anInteger 	minCount := anInteger.	maxCount := anInteger! !!SpecOfMessageUsage methodsFor: 'testing'!hasMeaningfulRestrictions	^self isMinCountSpecified or: [ self isMaxCountSpecified ]! !!SpecOfMessageUsage methodsFor: 'initialization'!initialize	super initialize.	minCount := 1.	self beUnlimited ! !!SpecOfMessageUsage methodsFor: 'testing'!isMaxCountSpecified	^maxCount ~= Float infinity! !!SpecOfMessageUsage methodsFor: 'testing'!isMinCountSpecified	^minCount > 1! !!SpecOfMessageUsage methodsFor: 'testing'!isUnlimited	^self isMaxCountSpecified not! !!SpecOfMessageUsage methodsFor: 'accessing'!maxCount	^ maxCount! !!SpecOfMessageUsage methodsFor: 'accessing'!maxCount: anObject	maxCount := anObject! !!SpecOfMessageUsage methodsFor: 'accessing'!minCount	^ minCount! !!SpecOfMessageUsage methodsFor: 'accessing'!minCount: anObject	minCount := anObject! !!SpecOfMessageUsage methodsFor: 'printing'!printOn: aStream	super printOn: aStream.		aStream << $( << self printRestrictions << $)! !!SpecOfMessageUsage methodsFor: 'printing'!printRestrictions	| result |	minCount = maxCount ifTrue: [ ^minCount asString, ' times' ].		(self isMinCountSpecified not and: [ self isMaxCountSpecified not ])		ifTrue: [ ^'at least ', minCount asString , ' times' ].			result := ''.	self isMinCountSpecified ifTrue: [ 		result :=  result , 'at least ', minCount asString , ' times'].	self isMaxCountSpecified ifTrue: [ 		result ifNotEmpty: [ result := result , ' ' ].		result := result , 'at most ', maxCount asString, ' times' ].	^result! !"Mocketry-Specs"!!MockBehaviour commentStamp: '' prior: 0!I am ghost behaviour for mocks.I delegate messages processing to MockRole instance. For example MockTeacher will build expectations for received message. And MockPlayer will use expectations to execute received messages.So I have collection of expectedMessages and collection of occurredMessages.Expected messages contains description of messages with predefined actions for them. Actions are performed when occurred message corresponds to expectation description.Occurred messages contains full histrory of intercepted messages in context of player role. In tests you can write specifications about what was happened.To represent intercepted messages I use MockOccurredMessage class. It provide suitable printing and hold extra information. For example it contains process where message was sent and returned result. In test such information can be used to validate tested behaviour.As ghost behaviour I define my vision on current meta level. I use empty meta level when message intercepted in context of tests. And I use standart meta level when it was happens in contexts of tools (not tests). For this I use process specific variable MockCurrentEnvironment. During test it is MockTestEnvironment and in context of tools it is MockDefaultEnvironment.Usually my instance not created directly. You should use process specific variable to retrive me from current context. 	MockCurrentBahaviour value Idea that mocks inside same test should have single behaviour instance. 	Public API and Key Messages- buildExpectationFor: anOccurredMessageIt will create and return MockExpectedMessage for received message. send. Then users can sent special messages to it to define expected behaviour.- replayMessageSend: anOccurredMessageIt will lookup and execute expectation for received message send. Given occurred message will be saved in occurredMessages history. - validateOccurredMessagesBy: aSpecOfExpectedMessageIt will validate occurredMessages collection by given spec. - createHelperMockAs: aMockRole It will create special mock which will delegate all messages to given role.- useMockRole: aMockRole while: aBlockIt will use given mock role to process intercepted messages during given block execution.- replayMocks It set role MockPlayer- teachMocksIt set role MockTeacher   - setUpContextNameFor: aMockIt will extract name of variable which contains aMock from current test case context. If it will be found detected name will be set to given mock.Internal Representation and Key Implementation Points.    Instance Variables	ownerEnvironment:		<MockEnvironment>	expectedMessages:		<Collection of <MockExpectedMessage>>	mockRole:		<MockRole>	occurredMessages:		<Collection of <MockOccurredMessage>>!!MockCurrentBehaviour commentStamp: '' prior: 0!I am process specific variable to hold MockBehaviour instance during particular test case execution.I detect current test case by another process variable  CurrentExecutionEnvironment. It allows me to detect that test was changed.I ensure that my value will be same only during single test execution!!MockOccurredMessage commentStamp: '' prior: 0!I represent intercepted message send.I extend information defined in ordinar MessageSend. I add process in which context message was occurred. And I add result which represents result of message execution. I implement nice printing.Public API and Key Messages- extractResultForm: aBlock it will execute given block to catch result of self execution - setUpDefaultResult It set default execution result which depends on receiver. For Mocks it will be special new mock. And for real object stubs it will be result of original method execution. Internal Representation and Key Implementation Points.    Instance Variables	process:		<Process>	result:		<MockOccurredMessageResult>!!Mock commentStamp: '' prior: 0!I am mock object. I am implemented by Ghost proxy framework.My behaviour is MockBehaviour which I retrieve during creation from MockCurrentBehaviour process specific variable. All mocks created during tests shares same MockBehaviour instance.I has name which I used for printing. Try:	mock := Mock named: 'test mock'.	mock ghostPrintStringBut it is not required to create me with name. In tests you will usually create me by #new.	testMock := Mock new.I implement special name detection logic to retrive variable name from test context. In that case in debugger you will see "a Mock(testMock)". It is happens only when you debug tests. Look at MockObjectsTests with "fetchingName" prefix and try debug it to watch how it is working in reality. MockBehaviour implements special logic to detect current meta level. Idea that during tests all messages should be intercepted and stubbed. But in context of tools like debugger meta messages should be work normally without stubbing logic. For this MockBehaviour detects MockCurrentTestEnvironment which will be not related to test in case of tools .Look at MockAcceptance tests to learn how to use mocks. In short to create expected behaviour for particular messages use:	mock stub someMessage willReturn: #resultOr to define group of expected message sends:	[ mock someMessage willReturn: 1.	mock2 someMessage2 willReturn: 2 ] should expect To verify that particular message occurred use: 	mock should receive someMessage Or to verify group of message sends use: 	[ mock someMessage.	mock2 someMessage2 ] should occur For ordered message sends use: 	[ mock someMessage.	mock2 someMessage2 ] should occurInSameOrderAlso there is short way to teach and verify expected message sends: 	[ "some tested code here" ]		shoud lenient satisfy: 	[ mock someMessage.	mock2 someMessage2 ]"Lenient" means that expected sends was occurred in any order.	[ "some tested code here" ]		shoud strictly satisfy:	[ mock someMessage.	mock2 someMessage2 ]"Strictly" means that expected sends was occurred in strict order.When no expectation found for received message I return new mock (MockForMessageReturn). By this you dont need to write expectations for any possible messages. You should only specify what you really interesting for particular test. Internal Representation and Key Implementation Points.    Instance Variables	behaviour:		<MockBehaviour>	name:		<String>!!MockHelper commentStamp: '' prior: 0!I am special mock to help work with other objects by explicit messages.I created to not register myself as environment object. Because I am just helper!!MockForMessageReturn commentStamp: '' prior: 0!I am special mock which are returned from messages as default value when no expectation is defined.I contain message which was produced me. And my printed value includes information about it.Also I try to mimic false in ifTrue/ifFalse conditions. When I detect it I replace myself with false.And I try to do same logic for arithmetics operations. I replace myself by zero when I detect that numbers logic is performed with me. Internal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!MockCapturedArgReceiver commentStamp: '' prior: 0!My subclasses represent captured agrument values from the message sends (mock object call) in should expressions.For simplest cases there is MockSingleCapturedValueReceiver which allows to validate the argument of single message send: 	Arg argName should equal: 10Subclasses decide what captured value needs to be validated and according to that they specialize the printing of validation result.	Instances are created with argument capture:	MockSingleCapturedValueReceiver from: Arg argName	 Internal Representation and Key Implementation Points.    Instance Variables	value:		<MockArgCapture>			!!MockAllCapturedValuesReceiver commentStamp: '' prior: 0!I am a special kind of should expression receiver representing captured values from all message sends.I am used to implement following should expression: 	Arg argName fromAllCalls should equal: 10.I validate every value captured from argument of given message send (mock objects call).To implement it I reuse another should receiver MockConcreteCapturedValueReceiver. It produce precise validation result with information about what exact value was bad.I ensure that at least one message was actually sent (at least one value was captured) and in case if it is not true it will be the result of validation.!!MockConcreteCapturedValueReceiver commentStamp: '' prior: 0!I am a special kind of should expression receiver representing captured value from concrete message send.I am used to implement following should expression: 	(Arg argName fromCall: 2) should equal: 10.I ensure that given number of messages was actually sent (given number of values were captured) and in case if it is not true it will be the result of validation.My instances can be created using following method:	MockConcreteCapturedValueReceiver from: Arg argName callNumber: 2. Internal Representation and Key Implementation Points.    Instance Variables	callNumber:		<Integer>!!MockLastCapturedValueReceiver commentStamp: '' prior: 0!I am a special kind of should expression receiver representing captured value from last message send.I am used to implement following should expression: 	Arg argName fromLastCall should equal: 10.I ensure that at least one message was actually sent (at least one value was captured) and in case if it is not true it will be the result of validation.!!MockSingleCapturedValueReceiver commentStamp: '' prior: 0!I am a special kind of should expression receiver representing captured value from single message send.I am used to implement simplest form of should expression with capture: 	Arg argName should equal: 10.I ensure that there was only message send. If there was no messages it will be the validation result. But if there were more than one message it will be general error considering that it is programmer error because it is his responsibility to choose explicitly the captured value for validation.!!MockInvolvedObjectsShouldReceiver commentStamp: '' prior: 0!I am a special kind of should expression receiver representing the group of objects involved in interaction during test. The group is defined by state spec and I perform validation of all involved objects satisfying it.I am used to implement following should expression: 	Any inTest should receive someMessage.	(Instance of: Array) inTest should include: #someItem.I validate every object registered in interaction history of MockCurrentBehavior. It is all mock objects and any real objects registered using #stub message.I ensure that at least one object was involved and if it is not true I return special validation result representing this fact.Internal Representation and Key Implementation Points.    Instance Variables	value:		<SpecOfObjectState>!!MockOccurredMessageProperty commentStamp: '' prior: 0!My subclasses represent concrete property of message send as a root parent of SpecOfObjectProperty.Subclasses should implement single method #extractValueFromMessage to initialize a value of property. Instances can be created by 		SpecOfOccurredMessageProcessProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!MockOccurredMessageProcessProperty commentStamp: '' prior: 0!I represent a process property where message was sent. I am a root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfOccurredMessageProcessProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!MockOccurredResultProperty commentStamp: '' prior: 0!I represent message send result as root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfOccurredResultProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!Arg commentStamp: '' prior: 0!I am special DSL class to get argument captures:	Arg argName	where #argName is name of argument defined by message send.	Arg connection 	Arg x!!MockArgCapture commentStamp: '' prior: 0!I represent of captured argument from series of occurred message sends.I should be retrived by direct message to suitable class Arg:	Arg argName  I supposed to be used as argument spec in expectations. When expectation is executed I capture given message argument for future verification. I allow tests to be looked like: 	mock stub someMessageWith: Arg argName.	 	mock someMessageWith: #argValue.		Arg argName should be: #argValue I capture all argument values from multiple message sends. To retrieve values of concrete call use:	Arg argName fromFirstCall should be: #first.		Arg argName fromLastCall should be: #last.	(Arg argName fromCall: 2) should be: #second.Internal Representation and Key Implementation Points.    Instance Variables	messageSpec:		<SpecOfMessageSend>	name:		<String>	values:		<OrderedCollection>!!MockCleaningProcessHook commentStamp: '' prior: 0!I am a special hook to TestExecutionEnvironment to clean current mock behaviour and recover all global stubs.I play role of forked process during test. So TestExecutionEnvironment terminats me at the end of tests and I perform all required cleaning!!MockDefaultMethods commentStamp: '' prior: 0!I am a special class which provide default methods which should be used for unexpected mock messages.Idea is to simplify mock usage in two scenarios:- when new domain message is sent to mock- when trivial Object behaviour is used in code. For example message #-> to mock should return association by default as for any other object. Or many kind of convertion methods like asLink, asOrderedCollection, asString should be processed by default as any other object. It is expected and intuitive behaviour for mock users.To achieve these goals I lookup method from Object to execute it on mock for given message. If method is not found I just return another new mock as result. But problem is that Object defines huge protocol and there many not trivial methods which could produce undesirable behaviour in context of mocks: 1) methods which could fail for mock and given arguments. For example Object defines #at: which fails by default (no inst vars). But in case of mock it should be handled as domain message by returning another mock.To address this problem I catch any error during default method execution and if it fails I return default mock. So result will be same as for new domain messages.2) some methods can require special logic in context of mock or particular Object methods should not be used at all. For example default #copy method will return just a copy of receiver mock. But we want more clever behaviour where another special mock is returned which indicates that it is a copy. Then during debugging we will explicitly see that some mocks was produced by copy.To address this problem my instance side methods are used as actual default methods implementation instead of Object. In fact I perform lookup of methods starting at myself and not at Object.Users can disable particular default method by implementing it on me with error (using "self disableDefaultMethod"). Then it will lead to case #1) where new default mock will be returned. Default mock always provide information where it was produced!!MockExpectationsValidator commentStamp: '' prior: 0!I am helper object which uses expected messages to create spec and validate tested block. I drive following should expressions: 	[  "tested behaviour"  ] should lenient satisfy: [ "expectations" ]	[  "tested behaviour"  ] should strictly satisfy: [ "expectations" ]My interactionSpec variable should contains specific kind of SpecOfObjectsInteraction spec to provide different kind of validation.#lenient message will create me with simple SpecOfObjectsInteraction spec which will only verify that all expected messages was really occurred.#strictly message will create me with SpecOfOrderedObjectsInteraction spec which wil verify that expected messages was occurred in same order as defined.Public API and Key Messages- satisfy: aBlock It will teach mocks for expected behaviour defined by given aBlock. And then it will verify that during verifiedBlock all expectations was occurred.Internal Representation and Key Implementation Points.    Instance Variables	interactionSpec:		<SpecOfObjectsInteraction>	verifiedBlock:		<BlockClosure>!!MockExpectedAction commentStamp: '' prior: 0!I represent abstract mock expectation action which should be executed when corresponding message send will be intercepted.My subclasses should define method 	 executeFor: aMockOccurredMessage!!MockExpectedActionSequence commentStamp: '' prior: 0!I represent sequence of expected actions which should be executed all together when corresponding message send will be intercepted.I return last action result as execution result.I am used by MockExpectedMessage as actions variable.Public API and Key Messages- add: aMockExpectationAction Internal Representation and Key Implementation Points.    Instance Variables	actions:		<Collection of <MockExpectationAction>>!!MockExpectedException commentStamp: '' prior: 0!I represent expected exception which should be signalled when corresponding message send wil be intercepted.My instances can be created by 	MockExpectedException exception: Erroror with exception isntance:	MockExpectedException exception: anError Internal Representation and Key Implementation Points.    Instance Variables	exception:		<Exception>!!MockExpectedMessageLogging commentStamp: '' prior: 0!I represent expected message action which will log received message send into transcript!!MockExpectedOriginalMethodCall commentStamp: '' prior: 0!I represent expected message result which will execute original method of stubbed real object!!MockExpectedMethodResultStub commentStamp: '' prior: 0!I represent expected message result which will execute original method of stubbed real object but in addition I will stub the result.So the result of my execution will be also stubbed and will record all message sends!!MockExpectedPluggableAction commentStamp: '' prior: 0!I represent expected mock action which defined by block.I will return block result as execution result.I can be created with block by: 	MockExpectedPluggableAction baseOn: aBlock.or by block: 	aBlock asMockExpectationAction	Internal Representation and Key Implementation Points.    Instance Variables	block:		<BlockClosure>!!MockExpectedReceiverReturn commentStamp: '' prior: 0!I represent expected message result which will return receiver of intercepted message!!MockExpectedValueForForEachCall commentStamp: '' prior: 0!I represent expected message result which will be extracted from array for every intercepted message send. So for first send it will be first item of my values array. And for second send it will be second item.I allow easily define expected values for multiple message sends.My instance can be created by 	MockExpectedValueForEachCall value: anArray	Internal Representation and Key Implementation Points.    Instance Variables	values:		<Array of: <Object>>	currentValueIndex:		<SmallInteger>!!MockExpectedValueReturn commentStamp: '' prior: 0!I represent expected message result which will return given value for intercepted messagesMy instances can be created by 	MockExpectedValueReturn value: anObjectInternal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!MockExpectedMessage commentStamp: '' prior: 0!I represent mock expectation.I consist of:  - expected message spec (description of expected message defined by SpecOfExpectedMessage)- current usage count (counter which holds how much times expected message was used)- expected actions (what should be done as result of intercepted message send)- extra conditions spec (extra specs which should be validated before actions will be executed. It allows to check conditions and immediatelly stop execution when it is wrong)  My instance returned as result of intercepted message send during mocks teaching. Then following messages can be used to specify different kind of expected behaviour:- will: aBlock- willReturn: anObject- willRaise: anExceptionOfClass- willReturnValueFrom: anArray- willReturnYourselfTo specify how much times expected message should be used for intercepted sends try this:- use: aNumber - useOne- useTwiceAnd to specify conditions which should be valid when expectation is executed use this:- when: aBlock is: aSpecOfObjectState- when: aBlock satisfying: aBlock - shouldBeSentInThisThread- shouldBeSentInAnotherThread In addition I mark particular methods with pragma <dontSendToMock>. It allows to prevent user mistakes when expectations are defined without #stub message to the mock. It is easy to do such mistake. So such messages (mock teacher API) are completely forbidden for mocks. For example following expressions fail:	mock someMessage willReturn: 1.	mock will: [2].	mock stub willRaise: Error newIt means that users can't stub such messages but it is reasonable restriction.Internal Representation and Key Implementation Points.    Instance Variables	actions:		<MockExpectedActionSequence>	conditionsSpec:		<SpecOfAndConjunction>	spec:		<SpecOfExpectedMessage>	usageCount:		<Integer>!!MockInteractionHistory commentStamp: '' prior: 0!I represent the history of object interaction.I keep all involved objects and messages which were sent to them.I am used by MockBehavior to accumulate message sends between objects.But you can create my instance on given list of messages using: 	MockInteractionHistory withAll: {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.	}.Following API is used to register objects and messages: - recordObject:- recordMessage:	Internal Representation and Key Implementation Points.    Instance Variables	involvedObjects:		<OrderedCollection<Object>>	occurredMessages:		<OrderedCollection<MockOccurredMessage>>!!MockOccurredMessageResult commentStamp: '' prior: 0!I am a root of occurred message results.My subclasses represent different kind of results which was received during occurred message execution!!MockOccurredDefaultReturn commentStamp: '' prior: 0!I represent default message send result when special mock is returned.Internal Representation and Key Implementation Points.    Instance Variables	returnedMock:		<MockForMessageReturn>!!MockOccurredExceptionSignal commentStamp: '' prior: 0!I represent signalled exception during message send. Internal Representation and Key Implementation Points.    Instance Variables	exception:		<Exception>!!MockOccurredValueReturn commentStamp: '' prior: 0!I represent simple value return from message sendInternal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!MockOperationWithMessageSpec commentStamp: '' prior: 0!I represent abstract operation which should be performed on given SpecOfExpectedMessage.I provide DSL-kind message to modify my spec and to execute operation after this.My subclasses should implement method #execute.For public API look at methods. They are all public DSL. Internal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfExpectedMessage>!!MockDetailedExpectationBuilding commentStamp: '' prior: 0!I am special operation on SpecOfExpectedMessage which is used to modify given spec by my DSL api without extra actions.I am used during group of message sends validation: 	[mock someMessage 	mock2 someMessage2 twice] should occur	Look at my superclass comment and methods!!MockDetailedMessagesValidation commentStamp: '' prior: 0!I am special operation on SpecOfExpectedMessage which is used to modify given spec by my DSL api and validate it immediatelly.So for example after sending me message once I will change usage spec of expected message and immediatelly validate occurred message by it. I am used during received message validation: 	mock should receive someMessage once	 Look at my superclass comment and methods!!MockRole commentStamp: '' prior: 0!I am root of different kind of mock roles which they can play during test execution.MockBehaviour always redirect message processing to current mock role (by mockRole variable).Since MockBehaviour is same for all mocks during single test execution modifying mockRole allows to change behaviour of all mocks. It make possible special block based approach for mocks teaching and validation: 	[ mock someMessage willReturn: 2.	mock2 someMessage2 willReturn: 10 ] should expect. 	[ mock someMessage 	mock2 someMessage2 twice ] should occur. My subclasses should implement method	processMessageSend: anOccurredMessage by: aMockBehaviour!!MockHelperRole commentStamp: '' prior: 0!I am a root of helper mock roles which are used to intercept all messages for given object for particular purpose.  I transform intercepted message sends to replace it receiver with my object and to replace #anyMessage with Any spec.My subclasses should implement: 	processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	  Internal Representation and Key Implementation Points.    Instance Variables	object:		<Object>!!MockStubTeacher commentStamp: '' prior: 0!I am special helper mock role which intercepts all messages to produce expectations for my object.I am used during stub teaching: 	mock stub someMessage willReturn: 3!!MockValidator commentStamp: '' prior: 0!I am special helper mock role which intercepts all messages to validate occurred behaviour with my object. During intercepting I build SpecOfExpectedMessage which I use to validate occurred behaviour. I put my object as receiver in these spec.I am used during single message validation: 	mock should receive someMessage once	Internal Representation and Key Implementation Points.    Instance Variables	withNegation:		<Boolean>!!MockInteractionSpecBuilder commentStamp: '' prior: 0!I am special  mock role which intercepts all messages to build and validate group of expected message specs.During intercepting I build SpecOfExpectedMessage for every mock call and add it to my composite spec. Then this spec is validated.I am used during group messages validation: 	[mock someMessage.	mock2 someMessage2 once] should occurand 	[mock someMessage.	mock2 someMessage2 once] should occurInSameOrderInternal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfObjectsInteraction>!!MockPlayer commentStamp: '' prior: 0!I am mock role which force mocks to replay all expected behaviour. With me MockBehaviour will lookup appropriate exectation for intrecepted messages and execute it actions.When MockBehaviour not found expectation for intercepted message it will return new special mock as default resultI am defined as singleton:	MockPlayer default.	I am default role for MockBehaviour!!MockTeacher commentStamp: '' prior: 0!I am mock role which force mocks to learn all intercepted messages as expectation. With me MockBehaviour will create new MockExpectedMessage instance to define expected behaviour. I am defined as singleton:	MockTeacher default!!MockValidatedExpectationsTeacher commentStamp: '' prior: 0!I am special mock teacher to create expectations which then be validated as specs. I keep all defined expectations to validate only them.Every expectation defined by me will be created with useOnce strategy by default.All my expectations will be replayed with same order as they were defined.My users should not use my default instance and instead always create new one:	MockVAlidatedExpectationsTeacher new.	Internal Representation and Key Implementation Points.    Instance Variables	expectations:		<OrderedCollection of: <MockExpectedMessage>>!!Number methodsFor: '*Mocketry-Domain'!isAllowAutoStub	^false! !!SpecOfObjectState methodsFor: '*Mocketry-Domain'!captureValue: anObject! !!SpecOfObjectState methodsFor: '*Mocketry-Domain'!inTest 	^MockInvolvedObjectsShouldReceiver from: self! !!SpecOfObjectState methodsFor: '*Mocketry-Domain'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: self)! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain'!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain'!currentMockBehaviour	^MockCurrentBehaviour value! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain'!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!beDone	| interactionSpec |	interactionSpec := SpecOfMultipleMessages new.		MockCurrentBehaviour 		useMockRole: (MockInteractionSpecBuilder for: interactionSpec) 		while: receiver value.		^self evaluateWith: interactionSpec forMockBehaviour: MockCurrentBehaviour value! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!beDoneInOrder	| interactionSpec |	interactionSpec := SpecOfExpectedMessageSequence new.		MockCurrentBehaviour 		useMockRole: (MockInteractionSpecBuilder for: interactionSpec) 		while: receiver value.		^self evaluateWith: interactionSpec forMockBehaviour: MockCurrentBehaviour value! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!beReturnedFrom: aBlockWithMessageSpec	| interactionSpec expectedSender senderSpec |	interactionSpec := SpecOfMultipleMessages new.		MockCurrentBehaviour 		useMockRole: (MockInteractionSpecBuilder for: interactionSpec) 		while: aBlockWithMessageSpec.			expectedSender := interactionSpec expectedMessages last.	senderSpec := SpecOfExpectedObjectSender 		for: self createSpecOfValidationSubject returnedFrom: expectedSender.		^self evaluateWith: senderSpec forMockBehaviour: MockCurrentBehaviour value! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!evaluateWith: anOccurredMessagesSpec forMockBehaviour: aMockBehaviour	receiver := SpecOfShouldReceiverRoot from: aMockBehaviour interactionHistory.	^self evaluateWith: (SpecOfInteractionHistory with: anOccurredMessagesSpec)! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!expect		| teacher |	teacher := MockTeacher default.	MockCurrentBehaviour useMockRole: teacher while: receiver value.	^teacher! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!lenient		^MockExpectationsValidator for: self by: SpecOfMultipleMessages new! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!receive	^receiver currentMockBehaviour 		createHelperMockAs: (MockValidator forExpression: self)! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain'!strictly		^MockExpectationsValidator for: self by: SpecOfExpectedMessageSequence new! !!MockBehaviour class methodsFor: 'instance creation'!for: aMockEnvironment	^self new		ownerEnvironment: aMockEnvironment ! !!MockBehaviour methodsFor: 'operations'!addExpectation: aMockExpectedMessage	"last added expectation should override previously defined. 	For this new expectation is added to start of expectedMessages list. 	It makes lookup of expectations easy (look at method #replayMessageSend:)"	expectedMessages addFirst: aMockExpectedMessage ! !!MockBehaviour methodsFor: 'operations'!addExpectation: aMockExpectedMessage asPartOfGroup: expectationsGroup	"Expectations can be defined as separated group of messages. 	In that case they should be added in same order as they defined in group.	When group is empty we think it is first expectation for given group and we add it in order to override previously defined expectations. This trick is used to allo lenient/strict validation of spec defined by expectations"	expectationsGroup 		ifEmpty: [ self addExpectation: aMockExpectedMessage]		ifNotEmpty: [ expectedMessages add: aMockExpectedMessage after: expectationsGroup last]! !!MockBehaviour methodsFor: 'accessing'!argCaptureNamed: aSymbol	^messageArgCaptures at: aSymbol ifAbsentPut: [ MockArgCapture named: aSymbol ]! !!MockBehaviour methodsFor: 'operations'!createHelperMockAs: aMockRole	| helperBehaviour mock |	helperBehaviour := self copy.	helperBehaviour mockRole: aMockRole.		mock := MockHelper named: aMockRole printString.	mock ghostBehaviour: helperBehaviour.	^mock! !!MockBehaviour methodsFor: 'accessing'!currentMetaLevel	^CurrentExecutionEnvironment value currentMetaLevelForMocks! !!MockBehaviour methodsFor: 'accessing'!expectedMessages	^ expectedMessages! !!MockBehaviour methodsFor: 'accessing'!expectedMessages: anObject	expectedMessages := anObject! !!MockBehaviour methodsFor: 'initialization'!initialize	super initialize.	interactionHistory := MockInteractionHistory new.	globalStubs := OrderedCollection new.	expectedMessages := OrderedCollection new.	messageArgCaptures := Dictionary new.	self replayMocks.! !!MockBehaviour methodsFor: 'accessing'!interactionHistory	^ interactionHistory! !!MockBehaviour methodsFor: 'accessing'!interactionHistory: anObject	interactionHistory := anObject! !!MockBehaviour methodsFor: 'testing'!isInheritableByFork	^ownerEnvironment allowsForkedProcessInheritMocks! !!MockBehaviour methodsFor: 'accessing'!mockRole	^ mockRole! !!MockBehaviour methodsFor: 'accessing'!mockRole: anObject	mockRole := anObject! !!MockBehaviour methodsFor: 'accessing'!occurredMessages	^ interactionHistory occurredMessages! !!MockBehaviour methodsFor: 'accessing'!ownerEnvironment	^ ownerEnvironment! !!MockBehaviour methodsFor: 'accessing'!ownerEnvironment: anExecutionEnvironment	ownerEnvironment := anExecutionEnvironment.	ownerProcess := Processor activeProcess! !!MockBehaviour methodsFor: 'accessing'!ownerProcess	^ ownerProcess! !!MockBehaviour methodsFor: 'accessing'!ownerTestCase	^ ownerTestCase! !!MockBehaviour methodsFor: 'accessing'!ownerTestCase: aTestCase	ownerTestCase := aTestCase.	testSelector := aTestCase selector! !!MockBehaviour methodsFor: 'controlling'!recoverGlobalStubs	globalStubs do: [ :each |		each recoverFromGHMutation  	]! !!MockBehaviour methodsFor: 'controlling'!registerObject: anObject	interactionHistory recordObject: anObject.	(anObject ghostClass inheritsFrom: Class) ifTrue: [ globalStubs add: anObject ]! !!MockBehaviour methodsFor: 'operations'!replayMessageSend: anOccurredMessage	| expected |		interactionHistory recordMessage: anOccurredMessage.		expected := expectedMessages 		detect: [ :each | each isAbout: anOccurredMessage ]		ifNone: [^anOccurredMessage setUpUnexpectedResult].		^anOccurredMessage extractResultFrom: [expected executeAs: anOccurredMessage].! !!MockBehaviour methodsFor: 'accessing'!replayMocks	mockRole := MockPlayer default! !!MockBehaviour methodsFor: 'message interception'!send: aMessage to: aMockObject	| occurredMessage |	occurredMessage := MockOccurredMessage 				receiver: aMockObject 				selector: aMessage selector				arguments: aMessage arguments.	"Following is a hook to prevent user mistakes do to missing #stub message for expectations. 	Check method comment for details"	occurredMessage shouldBeAllowedForMock.		^mockRole processMessageSend: occurredMessage by: self! !!MockBehaviour methodsFor: 'accessing'!setUpContextNameFor: aMock	ownerEnvironment setUpMockNameFor: aMock inContextOf: ownerProcess! !!MockBehaviour methodsFor: 'accessing'!teachMocks	mockRole := MockTeacher default! !!MockBehaviour methodsFor: 'accessing'!testSelector	^ testSelector! !!MockBehaviour methodsFor: 'operations'!useMockRole: aMockRole while: aBlock	| currentRole |	currentRole := mockRole.	mockRole := aMockRole.	aBlock ensure: [ mockRole := currentRole ]! !!MockCurrentBehaviour class methodsFor: 'testing'!isInheritable 	^true! !!MockCurrentBehaviour class methodsFor: 'operations'!useMockRole: aMockRole while: aBlock	self value useMockRole: aMockRole while: aBlock! !!MockCurrentBehaviour methodsFor: 'accessing'!installValue: aMockBehaviour intoForked: newProcess from: ownerProcess		aMockBehaviour isInheritableByFork ifFalse: [ ^self ].	newProcess psValueAt: index put: aMockBehaviour! !!MockCurrentBehaviour methodsFor: 'evaluating'!value	| currentBehaviour currentEnv |	currentEnv := CurrentExecutionEnvironment value.	currentBehaviour := Processor activeProcess psValueAt: index.			(currentBehaviour notNil and: [currentEnv isMockBehaviourActive: currentBehaviour])		ifTrue: [ ^currentBehaviour].	currentBehaviour := currentEnv createMockBehaviour.	self value: currentBehaviour.	^currentBehaviour! !!MockCurrentBehaviour methodsFor: 'evaluating'!value: anObject	| currentBehaviour |	currentBehaviour := Processor activeProcess psValueAt: index.	currentBehaviour ifNotNil: [ currentBehaviour recoverGlobalStubs].		super value: anObject! !!Behavior methodsFor: '*Mocketry-Domain'!isAllowAutoStub	^false! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain'!allowsForkedProcessInheritMocks	^false! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain'!createMockBehaviour	^MockBehaviour for: self! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain'!currentMetaLevelForMocks	^GHMetaLevel standard! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain'!isMockBehaviourActive: aMockBehaviour	^aMockBehaviour ownerEnvironment == self! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain'!setUpMockNameFor: aMock inContextOf: ownerProcess! !!UndefinedObject methodsFor: '*Mocketry-Domain'!isAllowAutoStub	^false! !!UndefinedObject methodsFor: '*Mocketry-Domain'!stub	"you should not stub nil. it crash anything"	self shouldNotImplement ! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain'!allowsForkedProcessInheritMocks	^true! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain'!createMockBehaviour	| behaviour |	forkedProcesses add: MockCleaningProcessHook instance.		behaviour := super createMockBehaviour.	behaviour ownerTestCase: testCase.	^behaviour! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain'!currentMetaLevelForMocks	^GHMetaLevel empty! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain'!isMockBehaviourActive: aMockBehaviour	^(super isMockBehaviourActive: aMockBehaviour)		and: [ aMockBehaviour ownerTestCase == testCase 			and: [ aMockBehaviour testSelector == testCase selector ] ]! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain'!setUpMockNameFor: aMock inContextOf: ownerProcess	| testContext currentReceiver |	testContext := Processor activeProcess == ownerProcess 		ifTrue: [ thisContext ] ifFalse: [ownerProcess suspendedContext].			[testContext isNil or: [ testContext receiver ghostClass isTestCase]] whileFalse: [ testContext := testContext sender ].		[testContext notNil and: [testContext receiver ghostClass isTestCase]] whileTrue: [ 		currentReceiver := testContext receiver.		currentReceiver class allInstVarNames do: [ :each | 			(currentReceiver instVarNamed: each) == aMock ifTrue: [ ^aMock mockName: each ]].				testContext tempNames do: [ :each  |			(testContext tempNamed: each) == aMock ifTrue: [ ^aMock mockName: each ]].				testContext := testContext sender	]! !!MockOccurredMessage class methodsFor: 'instance creation'!receiver: anObject selector: aSymbol result: anOccurredMessageResult	^(self receiver: anObject selector: aSymbol) result: anOccurredMessageResult ! !!MockOccurredMessage methodsFor: 'comparing'!= aMockOccurredMessage	"Occured message sends should not be equal if they include same parameters.	They are always different entities which reflect sends at different time"	 	^self == aMockOccurredMessage! !!MockOccurredMessage methodsFor: 'accessing'!extractResultFrom: aBlock	| returnedValue |	returnedValue := aBlock on: Exception - Halt do: [ :err | 		result := MockOccurredExceptionSignal exception: err.		err pass ].		result := returnedValue asOccurredMessageResult.	^returnedValue! !!MockOccurredMessage methodsFor: 'testing'!hasRaisedExceptionLike: anExceptionOrSpec	^result isSignalOf: anExceptionOrSpec! !!MockOccurredMessage methodsFor: 'testing'!hasReturnedValueLike: anObjectOrSpec	^result isReturnOf: anObjectOrSpec! !!MockOccurredMessage methodsFor: 'comparing'!hash	"Occured message sends should not be equal if they include same parameters.	They are always different entities which reflect sends at different time"	 	^ self identityHash ! !!MockOccurredMessage methodsFor: 'initialization'!initialize	super initialize.		process := Processor activeProcess! !!MockOccurredMessage methodsFor: 'printing'!printMessage	^String streamContents: [ :s | self printMessageOn: s ]! !!MockOccurredMessage methodsFor: 'printing'!printMessageOn: aStream	arguments isEmpty ifTrue: [^ aStream << selector].	arguments with: selector keywords do: [:arg :word |		aStream << word; space; << arg stringForSpecTitle; space].	aStream skip: -1! !!MockOccurredMessage methodsFor: 'printing'!printOn: aStream	arguments ifNil: [ 		^super printOn: aStream].		self printWithoutResultOn: aStream.	result ifNotNil: [ aStream << ' '; print: result ]! !!MockOccurredMessage methodsFor: 'printing'!printWithoutResult		^String streamContents: [ :s | self printWithoutResultOn: s ]! !!MockOccurredMessage methodsFor: 'printing'!printWithoutResultOn: aStream		aStream << receiver stringForSpecTitle; << ' '.	self printMessageOn: aStream! !!MockOccurredMessage methodsFor: 'accessing'!process	^ process! !!MockOccurredMessage methodsFor: 'accessing'!process: anObject	process := anObject! !!MockOccurredMessage methodsFor: 'accessing'!result	^ result! !!MockOccurredMessage methodsFor: 'accessing'!result: anObject	result := anObject! !!MockOccurredMessage methodsFor: 'accessing'!returnedValue	^result returnedValue! !!MockOccurredMessage methodsFor: 'accessing'!setUpUnexpectedResult	^self extractResultFrom: [ receiver stubDoesNotExpect: self ]! !!MockOccurredMessage methodsFor: 'controlling'!shouldBeAllowedForMock	"Method is introduced to prevent user mistakes due to missing #stub message.	It is easy to forget to send #stub message when defining an expectation for a mock. 	So with this method following examples fail with explicit error:		mock someMessage willReturn: 3.		mock will: [3].		mock stub willRaise: Error new"	| expectationMethod |	expectationMethod := MockExpectedMessage compiledMethodAt: selector ifAbsent: [ ^self ].	(expectationMethod hasPragmaNamed: #dontSendToMock) ifFalse: [ ^self ].		GHCurrentMetaLevelDepth increaseFor: [ | error |		error := receiver ghostBehaviour mockRole isTeaching			ifTrue: [ 'Missing expected message (after #stub)' ] ifFalse: [ 'Missing #stub' ].		self error: error, ' to define expectation using ', selector printString	]! !!MockOccurredMessage methodsFor: 'printing'!stringForResultSpec	^result stringForSpecValidation , ' from ', self printWithoutResult! !!Collection methodsFor: '*Mocketry-Domain'!isAllowAutoStub	^false! !!Boolean methodsFor: '*Mocketry-Domain'!isAllowAutoStub	^false! !!Boolean methodsFor: '*Mocketry-Domain'!stub	"you should not stub true or false. it crash anything"	self shouldNotImplement ! !!Mock class methodsFor: 'accessing'!canonicalArgumentName	^'aMock'! !!Mock class methodsFor: 'instance creation'!named: aString	^self withBehaviour 		mockName: aString! !!Mock class methodsFor: 'instance creation'!new		^self withBehaviour! !!Mock class methodsFor: 'stub'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: (Kind of: self))! !!Mock class methodsFor: 'private'!withBehaviour	"This method creates most primitive mock instance with prepared ghostBehaviour. Users should use high level instance creation methods"		^self basicNew		prepareGhostBehaviour! !!Mock class methodsFor: 'instance creation'!withoutName	"It is explicit message to create mock without name. 	Standart #new message always detects name by name of containing variable in context"	^self withBehaviour		setUpDefaultMockName;		yourself! !!Mock methodsFor: 'accessing'!currentMockBehaviour	^behaviour ! !!Mock methodsFor: 'accessing'!ghostBehaviour	^behaviour! !!Mock methodsFor: 'accessing'!ghostBehaviour: aMockBehaviour	behaviour := aMockBehaviour.	behaviour registerObject: self! !!Mock methodsFor: 'printing' prior: 35249346!ghostPrintString	| objectName |	objectName := GHMetaMessages printObject: self.		^objectName, '(', self mockName, ')'! !!Mock methodsFor: 'testing'!isAllowAutoStub	^true! !!Mock methodsFor: 'accessing'!mockName	^name ifNil: [ self setUpDefaultMockName. "it is to prevent recursion if tools start to debug next sentence and they will needed in mock name"		self setUpNameFromTestContext. 		name ]! !!Mock methodsFor: 'accessing'!mockName: aString	name := aString	! !!Mock methodsFor: 'initialization'!prepareGhostBehaviour	self ghostBehaviour: MockCurrentBehaviour value! !!Mock methodsFor: 'private'!setUpDefaultMockName	^name := self ghostIdentityHash asString! !!Mock methodsFor: 'private'!setUpNameFromTestContext	self ghostBehaviour setUpContextNameFor: self! !!Mock methodsFor: 'accessing'!stub	^behaviour createHelperMockAs: (MockStubTeacher for: self)! !!Mock methodsFor: 'message performing'!stubDoesNotExpect: anOccurredMessage		^MockDefaultMethods execute: anOccurredMessage on: self! !!MockForMessageReturn class methodsFor: 'instance creation'!from: anOccurredMessage	^self withoutName 		mockOwnerMessage: anOccurredMessage ! !!MockForMessageReturn class methodsFor: 'instance creation'!from: anOccurredMessage withBehaviour: aGhostBehavior	^self withoutName 		mockOwnerMessage: anOccurredMessage;		ghostBehaviour: aGhostBehavior! !!MockForMessageReturn methodsFor: 'arithmetics simulation'!adaptToFloat: rcvr andCompare: selector	^self adaptToFloat: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation'!adaptToFloat: rcvr andSend: selector	self mockBecome: 0.0.	^rcvr perform: selector with: 0.0! !!MockForMessageReturn methodsFor: 'arithmetics simulation'!adaptToFraction: rcvr andCompare: selector	^self adaptToFraction: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation'!adaptToFraction: rcvr andSend: selector	^self adaptToInteger: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation'!adaptToInteger: rcvr andCompare: selector	^self adaptToInteger: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation'!adaptToInteger: rcvr andSend: selector	self mockBecome: 0.	^rcvr perform: selector with: 0! !!MockForMessageReturn methodsFor: 'arithmetics simulation'!adaptToPoint: rcvr andSend: selector	| zero |	zero := 0@0.	self mockBecome: zero.	^rcvr perform: selector with: zero! !!MockForMessageReturn methodsFor: 'converting'!asOccurredMessageResult	^MockOccurredDefaultReturn with: self! !!MockForMessageReturn methodsFor: 'printing'!ghostPrintString		^'Result(', self mockName, ') of: ', message printWithoutResult! !!MockForMessageReturn methodsFor: 'private'!mockBecome: anObject	(Array with: self)	elementsForwardIdentityTo: (Array with: anObject) copyHash: false! !!MockForMessageReturn methodsFor: 'accessing'!mockOwnerMessage	^message! !!MockForMessageReturn methodsFor: 'accessing'!mockOwnerMessage: anOccurredMessage	message := anOccurredMessage 	! !!MockForMessageReturn methodsFor: 'boolean simulation'!mustBeBoolean	| sender |		sender := thisContext sender.	sender pc: sender previousPc.	self mockBecome: false! !!MockHelper methodsFor: 'accessing'!ghostBehaviour: aMockBehaviour	behaviour := aMockBehaviour! !!MockAllCapturedValuesReceiver methodsFor: 'accessing'!includes: anObject	^self validationSubject includes: anObject! !!MockAllCapturedValuesReceiver methodsFor: 'validation'!validate		^self argCapture validateNumberOfCalls: 1! !!MockAllCapturedValuesReceiver methodsFor: 'validation'!validateWith: aSpecOfObjectState	| result |	result := self validate.	result isSuccess ifFalse: [ ^result ].		1 to: self argCapture numberOfCalls do: [:each | 		result := (self argCapture fromCall: each) validateWith: aSpecOfObjectState.		result isFailure ifTrue: [ ^result ]].	^result! !!MockAllCapturedValuesReceiver methodsFor: 'accessing'!validationSubject	^self argCapture values! !!MockCapturedArgReceiver class methodsFor: 'testing'!isAbstract 		^self = MockCapturedArgReceiver ! !!MockCapturedArgReceiver methodsFor: 'accessing'!argCapture	^ value! !!MockCapturedArgReceiver methodsFor: 'converting'!asFutureStateShouldReceiver	^self ! !!MockCapturedArgReceiver methodsFor: 'validation'!createSpecOfValidationSubject	^SpecOfObjectHolder requiredHolder: self! !!MockCapturedArgReceiver methodsFor: 'printing'!printSubject: anObject	^(super printSubject: anObject) , ' from ', self stringForSpecTitle! !!MockConcreteCapturedValueReceiver class methodsFor: 'instance creation'!from: aMockArgCapture callNumber: aNumber	^(self from: aMockArgCapture) 		callNumber: aNumber! !!MockConcreteCapturedValueReceiver methodsFor: 'accessing'!callNumber	^ callNumber! !!MockConcreteCapturedValueReceiver methodsFor: 'accessing'!callNumber: anObject	callNumber := anObject! !!MockConcreteCapturedValueReceiver methodsFor: 'printing'!printProperty: aShouldReceiverProperty	^self argCapture stringForSpecTitle, ' ', aShouldReceiverProperty printPath,		' from ' , callNumber asString, ' call'! !!MockConcreteCapturedValueReceiver methodsFor: 'printing'!stringForSpecTitle	^super stringForSpecTitle, ' from ', callNumber asString, ' call'! !!MockConcreteCapturedValueReceiver methodsFor: 'validation'!validate		^self argCapture validateNumberOfCalls: callNumber! !!MockConcreteCapturedValueReceiver methodsFor: 'accessing'!validationSubject		^self argCapture valueFromCall: callNumber! !!MockLastCapturedValueReceiver methodsFor: 'printing'!printProperty: aShouldReceiverProperty	^self argCapture stringForSpecTitle, ' ', aShouldReceiverProperty printPath,		' from last call'! !!MockLastCapturedValueReceiver methodsFor: 'printing'!stringForSpecTitle	^super stringForSpecTitle, ' from last call'! !!MockLastCapturedValueReceiver methodsFor: 'validation'!validate		^self argCapture validateNumberOfCalls: 1! !!MockLastCapturedValueReceiver methodsFor: 'accessing'!validationSubject		^self argCapture valueFromLastCall! !!MockSingleCapturedValueReceiver methodsFor: 'validation'!validate	^self argCapture validateSingleValue! !!MockSingleCapturedValueReceiver methodsFor: 'accessing'!validationSubject		^self argCapture valueFromCall: 1! !!MockInvolvedObjectsShouldReceiver methodsFor: 'converting'!asFutureStateShouldReceiver	^self ! !!MockInvolvedObjectsShouldReceiver methodsFor: 'validation'!createSpecOfValidationSubject	^SpecOfObjectHolder requiredHolder: self! !!MockInvolvedObjectsShouldReceiver methodsFor: 'testing'!includes: anObject	^self validationSubject includes: anObject! !!MockInvolvedObjectsShouldReceiver methodsFor: 'accessing'!objectsSpec	^ value! !!MockInvolvedObjectsShouldReceiver methodsFor: 'validation'!validate	| spec |	spec := Has emptyItems not.	spec failureDescription: 'No object involved in test which ' , self objectsSpec description.	^ spec validate: self validationSubject! !!MockInvolvedObjectsShouldReceiver methodsFor: 'validation'!validateWith: aSpecOfObjectState	| result |	result := self validate.	result isSuccess ifFalse: [ ^result ].		self validationSubject do: [:each | 			result := aSpecOfObjectState validate: each.			result isFailure ifTrue: [ ^result ]].	^result! !!MockInvolvedObjectsShouldReceiver methodsFor: 'accessing'!validationSubject	| all |	all := MockCurrentBehaviour value interactionHistory involvedObjects.	^all select: [ :each | self objectsSpec matches: each ]! !!MockOccurredMessageProcessProperty methodsFor: 'initialization'!extractValueFromMessage	value := message process! !!MockOccurredMessageProcessProperty methodsFor: 'printing'!stringForSpecTitle 	^'process of ', message printWithoutResult! !!MockOccurredMessageProperty class methodsFor: 'instance creation'!of: aMessage	^self new 		message: aMessage! !!MockOccurredMessageProperty methodsFor: 'initialization'!extractValueFromMessage	self subclassResponsibility ! !!MockOccurredMessageProperty methodsFor: 'accessing'!message	^ message! !!MockOccurredMessageProperty methodsFor: 'accessing'!message: anOccurredMessage	message := anOccurredMessage.	self extractValueFromMessage! !!MockOccurredResultProperty methodsFor: 'initialization'!extractValueFromMessage	value := message returnedValue! !!MockOccurredResultProperty methodsFor: 'printing'!stringForSpecTitle 	^message printWithoutResult! !!Any class methodsFor: '*Mocketry-Domain'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Any class methodsFor: '*Mocketry-Domain'!captureValue: anObject! !!Any class methodsFor: '*Mocketry-Domain'!inTest 	^MockInvolvedObjectsShouldReceiver from: self! !!Any class methodsFor: '*Mocketry-Domain'!isAllowAutoStub	^false! !!Any class methodsFor: '*Mocketry-Domain'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: self)! !!GHVictimMetaMessages methodsFor: '*Mocketry-Domain'!currentMockBehaviour	^self ghMutation mutationBehaviour ! !!GHVictimMetaMessages methodsFor: '*Mocketry-Domain'!stubDoesNotExpect: anOccurredMessage	anOccurredMessage selector == #class ifTrue: [ 		"It is special case because we know that #class will return a mutation instance.		And we want to avoid it: by default class of infected object should be original class.		The meta messages logic does not allow to achieve it 		because we want to be able stub #class message too. 		Here is default behaviour with idea that #class is normally not overridden"		^ GHVictimMetaMessages originalClassOf: anOccurredMessage receiver ].		^GHCurrentMetaLevelDepth decreaseFor: [ 	  		GHVictimMetaMessages executeOriginalMethodOf: ghost for: anOccurredMessage	] ! !!SpecOfShouldReceiver methodsFor: '*Mocketry-Domain'!currentMockBehaviour	^self validationSubject currentMockBehaviour! !!Arg class methodsFor: 'captures creation'!doesNotUnderstand: aMessage	^MockCurrentBehaviour value argCaptureNamed: aMessage selector! !!Arg class methodsFor: 'testing'!isMetacelloConfig	"Metacello is full of crap. That's why if class wants implement #doesNotImplement (class side) it also should implement this method"	^false! !!MockArgCapture class methodsFor: 'instance creation'!named: aString 	^self new 		name: aString! !!MockArgCapture methodsFor: 'converting'!asShouldExpressionReceiver 	self ensureMessageSpec.		^MockSingleCapturedValueReceiver from: self! !!MockArgCapture methodsFor: 'specs'!asSimpleValue	^self! !!MockArgCapture methodsFor: 'specs'!asSpecOfArg: argumentNumber of: aMessageSendSpec	messageSpec := aMessageSendSpec.		^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!MockArgCapture methodsFor: 'specs'!asStateSpec	^self! !!MockArgCapture methodsFor: 'validation'!basicMatches: anObject	^true! !!MockArgCapture methodsFor: 'capturing arguments'!captureValue: anObject	anObject isAllowAutoStub ifTrue: [ anObject stub ].		values add: anObject! !!MockArgCapture methodsFor: 'initialization'!ensureMessageSpec	messageSpec ifNil: [ self error: 'Capture is not initialized with messageSpec!!' ].! !!MockArgCapture methodsFor: 'accessing'!fromAllCalls		^MockAllCapturedValuesReceiver from: self! !!MockArgCapture methodsFor: 'accessing'!fromCall: callNumber		^MockConcreteCapturedValueReceiver from: self callNumber: callNumber! !!MockArgCapture methodsFor: 'accessing'!fromFirstCall	^self fromCall: 1! !!MockArgCapture methodsFor: 'accessing'!fromLastCall	^MockLastCapturedValueReceiver from: self! !!MockArgCapture methodsFor: 'initialization'!initialize	super initialize.		values := OrderedCollection new! !!MockArgCapture methodsFor: 'specs'!isSimpleValue	^true! !!MockArgCapture methodsFor: 'accessing'!messageSpec	^ messageSpec! !!MockArgCapture methodsFor: 'accessing'!messageSpec: anObject	messageSpec := anObject! !!MockArgCapture methodsFor: 'accessing'!name	^ name! !!MockArgCapture methodsFor: 'accessing'!name: anObject	name := anObject! !!MockArgCapture methodsFor: 'accessing'!numberOfCalls	^values size! !!MockArgCapture methodsFor: 'printing'!printOn: aStream	super printOn: aStream.		aStream << $( << name << $)! !!MockArgCapture methodsFor: 'printing'!stringForSpecTitle 	^name printString! !!MockArgCapture methodsFor: 'validation'!validate: anObject		^SpecOfValidationResult success! !!MockArgCapture methodsFor: 'validation'!validateNumberOfCalls: callsNumber	| expectedMessageSpec result history |	self ensureMessageSpec.		expectedMessageSpec := SpecOfExpectedMessage new.	expectedMessageSpec messageSend: messageSpec.	expectedMessageSpec usage minCount: callsNumber.		history := MockCurrentBehaviour value interactionHistory.	result := expectedMessageSpec validate: history occurredMessages.	result isSuccess ifTrue: [ 		values ifEmpty: [ self error: 'No argument was captured but message was sent!!' ].		values size < callsNumber ifTrue: [ 			self error: 'Arguments was captured ', values size asString							, ' times but should be ', callsNumber ]].	^result! !!MockArgCapture methodsFor: 'validation'!validateSingleValue 	| result |	result := self validateNumberOfCalls: 1.		result isSuccess ifTrue: [ 		values size > 1			ifTrue: [ self error: 'Multiple args were captured!! Choose concrete by #fromCall: or #fromAllCalls' ]].			^result! !!MockArgCapture methodsFor: 'accessing'!valueFromCall: callNumber		^values at: callNumber! !!MockArgCapture methodsFor: 'accessing'!valueFromLastCall		^values last! !!MockArgCapture methodsFor: 'accessing'!values	^ values! !!MockArgCapture methodsFor: 'accessing'!values: anObject	values := anObject! !!MockCleaningProcessHook class methodsFor: 'accessing'!instance	^instance ifNil: [ instance := MockCleaningProcessHook new]! !!MockCleaningProcessHook methodsFor: 'actions'!terminate	MockCurrentBehaviour value: nil! !!MockDefaultMethods class methodsFor: 'execution'!execute: anOccurredMessage on: aMock	"look at class comment for explanation"	| defaultMethod |	defaultMethod := self lookupSelector: anOccurredMessage selector.	defaultMethod ifNotNil: [		GHCurrentMetaLevelDepth increaseFor: [ 			[^GHMetaMessages 				executeWith: aMock andArguments: anOccurredMessage arguments method: defaultMethod] 					on: Error do: [ :err | ]].	].	^MockForMessageReturn from: anOccurredMessage withBehaviour: aMock ghostBehaviour! !!MockDefaultMethods methodsFor: 'copying'!copy	self disableDefaultMethod! !!MockDefaultMethods methodsFor: 'error signalling'!disableDefaultMethod	self error: 'Sender method should not be used as default for mocks'! !!MockDefaultMethods methodsFor: 'copying'!shallowCopy	self disableDefaultMethod! !!MockExpectationsValidator class methodsFor: 'instance creation'!for: aShouldExpression by: aMultipleMessagesSpec	^self new 		shouldExpression: aShouldExpression;		interactionSpec: aMultipleMessagesSpec! !!MockExpectationsValidator methodsFor: 'accessing'!interactionSpec	^ interactionSpec! !!MockExpectationsValidator methodsFor: 'accessing'!interactionSpec: anObject	interactionSpec := anObject! !!MockExpectationsValidator methodsFor: 'validation'!satisfy: blockWithExpectations	| teacher |	teacher := MockValidatedExpectationsTeacher new.	MockCurrentBehaviour useMockRole: teacher while: blockWithExpectations.		shouldExpression receiver value value.	interactionSpec expectedMessages: teacher convertExpectationsToSpecs.	^shouldExpression evaluateWith: interactionSpec forMockBehaviour: MockCurrentBehaviour value.! !!MockExpectationsValidator methodsFor: 'accessing'!shouldExpression	^ shouldExpression! !!MockExpectationsValidator methodsFor: 'accessing'!shouldExpression: anObject	shouldExpression := anObject! !!MockExpectedAction methodsFor: 'converting'!asMockExpectationAction! !!MockExpectedAction methodsFor: 'evaluating'!executeFor: anOccurredMessage 	self subclassResponsibility! !!MockExpectedActionSequence class methodsFor: 'instance creation'!new	^super new initialize! !!MockExpectedActionSequence methodsFor: 'accessing'!add: aMockAction 	actions add: aMockAction! !!MockExpectedActionSequence methodsFor: 'evaluating'!executeFor: anOccurredMessage 	actions ifEmpty: [ ^anOccurredMessage setUpUnexpectedResult  ].			actions allButLastDo: [:eachPart | eachPart executeFor: anOccurredMessage].		^actions last executeFor: anOccurredMessage! !!MockExpectedActionSequence methodsFor: 'initialize-release'!initialize	actions := OrderedCollection new! !!MockExpectedException class methodsFor: 'instance creation'!exception: anExceptionClass 	^self new exception: anExceptionClass! !!MockExpectedException methodsFor: 'accessing'!exception	^ exception! !!MockExpectedException methodsFor: 'accessing'!exception: anObject	exception := anObject! !!MockExpectedException methodsFor: 'evaluating'!executeFor: anOccurredMessage 	exception signal! !!MockExpectedMessageLogging methodsFor: 'evaluating'!executeFor: anOccurredMessage 	Transcript show: anOccurredMessage printString; cr.	^anOccurredMessage receiver! !!MockExpectedMethodResultStub methodsFor: 'evaluating'!executeFor: anOccurredMessage	| realMethodResult |	realMethodResult := super executeFor: anOccurredMessage.	realMethodResult stub.	^realMethodResult! !!MockExpectedOriginalMethodCall methodsFor: 'evaluating'!executeFor: anOccurredMessage 	^GHVictimMetaMessages executeOriginalMethodOf: anOccurredMessage receiver for: anOccurredMessage! !!MockExpectedPluggableAction class methodsFor: 'instance creation'!basedOn: aBlockContext 	^self new block: aBlockContext! !!MockExpectedPluggableAction methodsFor: 'accessing'!block	^block! !!MockExpectedPluggableAction methodsFor: 'accessing'!block: anObject	block := anObject! !!MockExpectedPluggableAction methodsFor: 'evaluating'!executeFor: anOccurredMessage 	^block valueWithEnoughArguments: anOccurredMessage arguments! !!MockExpectedReceiverReturn methodsFor: 'evaluating'!executeFor: anOccurredMessage 	^anOccurredMessage receiver! !!MockExpectedValueForForEachCall class methodsFor: 'instance creation'!values: anArray	^self new 		values: anArray! !!MockExpectedValueForForEachCall methodsFor: 'evaluating'!executeFor: anOccurredMessage	currentValueIndex ifNil: [ currentValueIndex := 0 ].		^values at: (currentValueIndex := currentValueIndex + 1)! !!MockExpectedValueForForEachCall methodsFor: 'accessing'!values	^ values! !!MockExpectedValueForForEachCall methodsFor: 'accessing'!values: anObject	values := anObject! !!MockExpectedValueReturn class methodsFor: 'instance creation'!value: anObject 	^self new value: anObject! !!MockExpectedValueReturn methodsFor: 'evaluating'!executeFor: anOccurredMessage 	^value! !!MockExpectedValueReturn methodsFor: 'accessing'!value	^value! !!MockExpectedValueReturn methodsFor: 'accessing'!value: anObject	value := anObject! !!MockExpectedMessage class methodsFor: 'instance creation'!from: aMessageSend 	^self new		spec: (SpecOfExpectedMessage from: aMessageSend)! !!MockExpectedMessage methodsFor: 'accessing'!actions	^ actions! !!MockExpectedMessage methodsFor: 'accessing'!actions: anObject	actions := anObject! !!MockExpectedMessage methodsFor: 'converting'!asExpectedMessageSpec	| expectedMessage |	expectedMessage := spec copy.	expectedMessage usage beUnlimited.	^expectedMessage! !!MockExpectedMessage methodsFor: 'evaluating'!executeAs: aMessageSend	spec captureArgumentsFrom: aMessageSend.	(conditionsSpec validate: aMessageSend) raise.	usageCount := usageCount + 1.	^actions executeFor: aMessageSend! !!MockExpectedMessage methodsFor: 'initialization'!initialize	super initialize.		actions := MockExpectedActionSequence new.	usageCount := 0.	conditionsSpec := SpecOfAndConjunction new! !!MockExpectedMessage methodsFor: 'testing'!isAbout: aMessageSend	(spec matches: {aMessageSend}) ifFalse: [ ^false ].		^spec allowSendsCount: usageCount + 1! !!MockExpectedMessage methodsFor: 'testing'!isForLimitedUsage		^spec usage isUnlimited not! !!MockExpectedMessage methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	 	aStream << $( << spec printMessageSend << $)! !!MockExpectedMessage methodsFor: 'accessing'!restrictUsage		spec restrictUsage! !!MockExpectedMessage methodsFor: 'conditions'!shouldBeSentInAnotherProcess	<dontSendToMock>	conditionsSpec addSpec: SpecOfAsynchMessage forActiveProcess! !!MockExpectedMessage methodsFor: 'conditions'!shouldBeSentInThisProcess	<dontSendToMock>	conditionsSpec addSpec: SpecOfAsynchMessage forActiveProcess not! !!MockExpectedMessage methodsFor: 'accessing'!spec	^ spec! !!MockExpectedMessage methodsFor: 'accessing'!spec: anObject	spec := anObject! !!MockExpectedMessage methodsFor: 'accessing'!usageCount	^ usageCount! !!MockExpectedMessage methodsFor: 'accessing'!usageCount: anObject	usageCount := anObject! !!MockExpectedMessage methodsFor: 'usage specs'!use: numberOfTimes	spec usage maxCount:  numberOfTimes! !!MockExpectedMessage methodsFor: 'usage specs'!useArbitrarily	"It is default usage strategy. But for lenient/strict logic default is useOnce"	spec usage beUnlimited! !!MockExpectedMessage methodsFor: 'usage specs'!useOnce	self use: 1! !!MockExpectedMessage methodsFor: 'usage specs'!useTwice	self use: 2! !!MockExpectedMessage methodsFor: 'conditions'!when: subjectBlock is: aSpecOfObjectState	<dontSendToMock>	conditionsSpec addSpec: (SpecOfMessageSendCondition of: subjectBlock by: aSpecOfObjectState)! !!MockExpectedMessage methodsFor: 'conditions'!when: subjectBlock satisfy: conditionBlock	<dontSendToMock>	self when: subjectBlock is: (Satisfying for: conditionBlock)! !!MockExpectedMessage methodsFor: 'actions'!will: anObject	<dontSendToMock>	actions add: anObject asMockExpectationAction! !!MockExpectedMessage methodsFor: 'actions'!willCallOriginalMethod	<dontSendToMock>	self will: MockExpectedOriginalMethodCall new! !!MockExpectedMessage methodsFor: 'actions'!willLogMessage	<dontSendToMock>	self will: MockExpectedMessageLogging new! !!MockExpectedMessage methodsFor: 'actions'!willRaise: anExceptionOrClass 	<dontSendToMock>	self will: (MockExpectedException exception: anExceptionOrClass)! !!MockExpectedMessage methodsFor: 'actions'!willReturn: anObject 	<dontSendToMock>	self will: (MockExpectedValueReturn value: anObject)! !!MockExpectedMessage methodsFor: 'actions'!willReturnValueFrom: anArray 	<dontSendToMock>	self will: (MockExpectedValueForForEachCall values: anArray).	spec usage maxCount: anArray size! !!MockExpectedMessage methodsFor: 'actions'!willReturnYourself	<dontSendToMock>	self will: MockExpectedReceiverReturn new! !!MockExpectedMessage methodsFor: 'actions'!willStubRealResult	<dontSendToMock>	self will: MockExpectedMethodResultStub new! !!MockInteractionHistory class methodsFor: 'instance creation'!withAll: occurredMessages	^self new 		occurredMessages: occurredMessages;		collectInvolvedObjects;		yourself! !!MockInteractionHistory methodsFor: 'initialization'!collectInvolvedObjects	involvedObjects := occurredMessages collect: [ :each | each receiver ] as: IdentitySet! !!MockInteractionHistory methodsFor: 'accessing'!firstMessage	^occurredMessages first! !!MockInteractionHistory methodsFor: 'initialization'!initialize 		involvedObjects := OrderedCollection new.	occurredMessages := OrderedCollection new.! !!MockInteractionHistory methodsFor: 'accessing'!involvedObjects	^ involvedObjects! !!MockInteractionHistory methodsFor: 'accessing'!involvedObjects: anObject	involvedObjects := anObject! !!MockInteractionHistory methodsFor: 'accessing'!lastMessage	^occurredMessages last! !!MockInteractionHistory methodsFor: 'accessing'!occurredMessages	^ occurredMessages! !!MockInteractionHistory methodsFor: 'accessing'!occurredMessages: anObject	occurredMessages := anObject! !!MockInteractionHistory methodsFor: 'controlling'!recordMessage: anOccurredMessage	occurredMessages add: anOccurredMessage ! !!MockInteractionHistory methodsFor: 'controlling'!recordObject: anObject	involvedObjects add: anObject! !!MockOccurredDefaultReturn class methodsFor: 'instance creation'!with: aMockForMessageReturn	^self new 		returnedMock: aMockForMessageReturn ! !!MockOccurredDefaultReturn methodsFor: 'testing'!isReturnOf: anObjectOrSpec	^anObjectOrSpec asStateSpec matches: returnedMock! !!MockOccurredDefaultReturn methodsFor: 'testing'!isSignalOf: anExceptionOrSpec	^false! !!MockOccurredDefaultReturn methodsFor: 'printing'!printOn: aStream		aStream << 'returned ' << self stringForSpecTitle! !!MockOccurredDefaultReturn methodsFor: 'accessing'!returnedMock	^ returnedMock! !!MockOccurredDefaultReturn methodsFor: 'accessing'!returnedMock: anObject	returnedMock := anObject! !!MockOccurredDefaultReturn methodsFor: 'accessing'!returnedValue 	^returnedMock! !!MockOccurredDefaultReturn methodsFor: 'printing'!stringForSpecTitle	returnedMock isGhost ifFalse: [ ^returnedMock stringForSpecValidation]. "it is possible that mock was converted into normal object like boolean or number due to boolean logic or arithmetic operations which happens with returned mock"		^'default mock(' , returnedMock ghostIdentityHash asString , ')'! !!MockOccurredExceptionSignal class methodsFor: 'instance creation'!exception: anException	^self new 		exception: anException! !!MockOccurredExceptionSignal methodsFor: 'accessing'!exception	^ exception! !!MockOccurredExceptionSignal methodsFor: 'accessing'!exception: anObject	exception := anObject! !!MockOccurredExceptionSignal methodsFor: 'testing'!isReturnOf: anObjectOrSpec	^false! !!MockOccurredExceptionSignal methodsFor: 'testing'!isSignalOf: anExceptionOrSpec	^anExceptionOrSpec asStateSpec matches: exception! !!MockOccurredExceptionSignal methodsFor: 'printing'!printOn: aStream		aStream << 'raised '; print: exception! !!MockOccurredExceptionSignal methodsFor: 'printing'!stringForSpecValidation		^'raised ', exception stringForSpecValidation ! !!MockOccurredMessageResult methodsFor: 'testing'!isReturnOf: anObjectOrSpec	self subclassResponsibility ! !!MockOccurredMessageResult methodsFor: 'testing'!isSignalOf: anExceptionOrSpec	self subclassResponsibility ! !!MockOccurredValueReturn class methodsFor: 'instance creation'!value: anObject	^self new 		value: anObject! !!MockOccurredValueReturn methodsFor: 'testing'!isReturnOf: anObjectOrSpec	^anObjectOrSpec asStateSpec matches: value! !!MockOccurredValueReturn methodsFor: 'testing'!isSignalOf: anExceptionOrSpec	^false! !!MockOccurredValueReturn methodsFor: 'printing'!printOn: aStream		aStream << 'returned ' << value stringForSpecTitle! !!MockOccurredValueReturn methodsFor: 'testing'!returnedValue 	^value! !!MockOccurredValueReturn methodsFor: 'printing'!stringForSpecValidation	^value stringForSpecValidation! !!MockOccurredValueReturn methodsFor: 'accessing'!value	^ value! !!MockOccurredValueReturn methodsFor: 'accessing'!value: anObject	value := anObject! !!MockDetailedExpectationBuilding methodsFor: 'execution'!execute	! !!MockDetailedMessagesValidation class methodsFor: 'instance creation'!for: aShouldExpression on: anExpectedMessageSpec	^(self on: anExpectedMessageSpec)		shouldExpression: aShouldExpression ! !!MockDetailedMessagesValidation methodsFor: 'execution'!execute		^shouldExpression evaluateWith: spec forMockBehaviour: MockCurrentBehaviour value! !!MockDetailedMessagesValidation methodsFor: 'extra validation'!inProcessWhich	| result lastMessage |	result := self execute.	lastMessage := result occurredMessages last.		^(MockOccurredMessageProcessProperty of: lastMessage) where! !!MockDetailedMessagesValidation methodsFor: 'accessing'!shouldExpression	^ shouldExpression! !!MockDetailedMessagesValidation methodsFor: 'accessing'!shouldExpression: anObject	shouldExpression := anObject! !!MockDetailedMessagesValidation methodsFor: 'extra validation'!which	| result lastMessage |	result := self execute.	lastMessage := result occurredMessages last.		^(MockOccurredResultProperty of: lastMessage) where! !!MockOperationWithMessageSpec class methodsFor: 'instance creation'!on: anExpectedMessageSpec	^self new 		spec: anExpectedMessageSpec 		! !!MockOperationWithMessageSpec methodsFor: 'usage validation'!atLeast: numberOfTimes	spec usage minCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation'!atLeast: minNumberOfTimes atMost: maxNumberOfTimes	spec usage 		minCount: minNumberOfTimes;		maxCount: maxNumberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation'!atMost: numberOfTimes	spec usage maxCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation'!exactly: numberOfTimes	spec usage exactCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'execution'!execute	self subclassResponsibility ! !!MockOperationWithMessageSpec methodsFor: 'conditions vaildation'!inAnotherProcess	spec addSpec: SpecOfAsynchMessage forActiveProcess.	self execute! !!MockOperationWithMessageSpec methodsFor: 'conditions vaildation'!inThisProcess	spec addSpec: SpecOfAsynchMessage forActiveProcess not.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation'!once	self exactly: 1! !!MockOperationWithMessageSpec methodsFor: 'accessing'!spec	^ spec! !!MockOperationWithMessageSpec methodsFor: 'accessing'!spec: anObject	spec := anObject! !!MockOperationWithMessageSpec methodsFor: 'usage validation'!twice	self exactly: 2! !!MockHelperRole class methodsFor: 'instance creation'!for: anObject	^self new		object: anObject	! !!MockHelperRole methodsFor: 'accessing'!object	^ object! !!MockHelperRole methodsFor: 'accessing'!object: anObject	object := anObject! !!MockHelperRole methodsFor: 'processing'!processMessageSend: anOccurredMessage by: aMockBehaviour	anOccurredMessage receiver: object.	anOccurredMessage selector == #anyMessage ifTrue: [ anOccurredMessage selector: Any ].		^self processTransformedMessageSend: anOccurredMessage by: aMockBehaviour! !!MockHelperRole methodsFor: 'processing'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	self subclassResponsibility ! !!MockStubTeacher methodsFor: 'processing'!anyMessage	"This method for documenting purpose. Look at processing method. You will see that this particular selector is substituted by Any. It allows to build expectation for any message to receiver object (or any object):		mock stub anyMessage willReturn: 2.		Any stub anyMessage willReturn: 10 "! !!MockStubTeacher methodsFor: 'testing'!isTeaching	^true! !!MockStubTeacher methodsFor: 'processing'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour		| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	aMockBehaviour addExpectation: expectation.		^expectation! !!MockValidator class methodsFor: 'instance creation'!forExpression: aShouldExpression	^(self for: aShouldExpression createSpecOfValidationSubject)		shouldExpression: aShouldExpression! !!MockValidator methodsFor: 'processing'!anyMessage	"This method for documenting purpose. Look at processing method. You will see that this particular selector is substituted by Any. It allows to validate that there was any message to particular object (or any object):		mock should receive anyMessage.		Any should receive anyMessage"! !!MockValidator methodsFor: 'processing'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	| spec result |		spec := SpecOfExpectedMessage from: anOccurredMessage.		result := shouldExpression evaluateWith: spec forMockBehaviour: aMockBehaviour.	shouldExpression withNegation ifTrue: [ ^result ].		^MockDetailedMessagesValidation for: shouldExpression on: spec! !!MockValidator methodsFor: 'accessing'!shouldExpression	^ shouldExpression! !!MockValidator methodsFor: 'accessing'!shouldExpression: anObject	shouldExpression := anObject! !!MockInteractionSpecBuilder class methodsFor: 'instance creation'!for: anObjectsInteractionSpec	^self new 		spec: anObjectsInteractionSpec ! !!MockInteractionSpecBuilder methodsFor: 'processing'!processMessageSend: anOccurredMessage by: aMockBehaviour		| messageSpec |	messageSpec := SpecOfExpectedMessage from: anOccurredMessage.		spec addExpectedMessage: messageSpec.		^MockDetailedExpectationBuilding on: messageSpec! !!MockInteractionSpecBuilder methodsFor: 'accessing'!spec	^ spec! !!MockInteractionSpecBuilder methodsFor: 'accessing'!spec: anObject	spec := anObject! !!MockPlayer methodsFor: 'processing'!processMessageSend: anOccurredMessage by: aMockBehaviour	^aMockBehaviour replayMessageSend: anOccurredMessage! !!MockRole class methodsFor: 'defaults'!default	^default ifNil: [ default := self new ]! !!MockRole methodsFor: 'testing'!isTeaching 	^false! !!MockRole methodsFor: 'processing'!processMessageSend: anOccurredMessage by: aMockBehaviour	self subclassResponsibility ! !!MockTeacher methodsFor: 'testing'!isTeaching	^true! !!MockTeacher methodsFor: 'processing'!processMessageSend: anOccurredMessage by: aMockBehaviour	| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	aMockBehaviour addExpectation: expectation.		^expectation! !!MockValidatedExpectationsTeacher methodsFor: 'accessing'!convertExpectationsToSpecs  	^expectations 		select: [ :each | each isForLimitedUsage ] 		thenCollect: [ :each | each asExpectedMessageSpec]! !!MockValidatedExpectationsTeacher methodsFor: 'accessing'!expectations	^ expectations! !!MockValidatedExpectationsTeacher methodsFor: 'accessing'!expectations: anObject	expectations := anObject! !!MockValidatedExpectationsTeacher methodsFor: 'initialization'!initialize	super initialize.		expectations := OrderedCollection new! !!MockValidatedExpectationsTeacher methodsFor: 'processing'!processMessageSend: anOccurredMessage by: aMockBehaviour	| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	expectation restrictUsage.		aMockBehaviour addExpectation: expectation asPartOfGroup: expectations.	expectations add: expectation.		^expectation! !!Object methodsFor: '*Mocketry-Domain'!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Object methodsFor: '*Mocketry-Domain'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Object methodsFor: '*Mocketry-Domain'!currentMockBehaviour	^MockCurrentBehaviour value! !!Object methodsFor: '*Mocketry-Domain'!isAllowAutoStub	^true! !!Object methodsFor: '*Mocketry-Domain'!stub	| behaviour mutation |			self hasGHMutation 		ifTrue: [ behaviour := self ghMutation mutationBehaviour ]		ifFalse: [ 			behaviour := MockCurrentBehaviour value.			behaviour registerObject: self.			mutation := GHObjectMutation behaviour: behaviour.			mutation mutate: self].		^behaviour createHelperMockAs: (MockStubTeacher for: self)! !!Object methodsFor: '*Mocketry-Domain'!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments		 ! !!BlockClosure methodsFor: '*Mocketry-Domain'!asMockExpectationAction	^MockExpectedPluggableAction basedOn: self! !!BlockClosure methodsFor: '*Mocketry-Domain'!runWithMocks	| mocks |	mocks := self argumentNames collect: [:each | Mock named: each ].	self valueWithArguments: mocks! !"Mocketry-Domain"!!TinyCurrentLogger commentStamp: '' prior: 0!Description--------------------I am a dynamic variable defining the current `TinyLogger` to use to record events.Examples--------------------	TinyCurrentLogger value: (TinyLogger new addTranscriptLogger; yourself) during: [ 		'test' record.		TinyCurrentLogger value record: 'Test2'	]!!TinyAbstractLogger commentStamp: '' prior: 0!Description--------------------I am an abstract logger to define the minimal behavior all my subclasses should define.The user should mostly work with the `TinyLogger` class. This class is the main entry point of the project.I follow a composite design pattern. I am subclassed by a `TinyLogger` that is a composite of leaf loggers, and `TinyLeafLogger` defining the behavior of a concrete logger.Users should configure a `TinyLogger` with the concrete loggers they want and use this one that will dispatch the logging behavior to the other loggers.Public API and Key Messages--------------------- #record: 		Takes a string and record it.- #<< 				Alias of #record:.- #clearLog 		Clear the output of the logger. Will have different effect depending on the logger.!!TinyLeafLogger commentStamp: '' prior: 0!Description--------------------I am an abstract class that should be subclasses by the concrete loggers of the project. Each of my subclass represent a different way to log an information (in a file, transcript, stdout...).Users should not use me or my subclasses directly. The user should manage logging via `TinyLogger` which is a composite of my subclasses.Public API and Key Messages--------------------- #record: 	Record a string as parameter	 Internal Representation and Key Implementation Points.--------------------    Instance Variables	parentLogger:		<aTinyLogger>	As said before the user should use my subclasses via a `TinyLogger` composite. My parent logger is this `TinyLogger` instance.!!TinyFileLogger commentStamp: '' prior: 0!Description--------------------I am a logger that will log the informations in a file on the file system.I am configured with a file name. If no file name is given to me, I'll use `TinyLogger.log` by default.I should not be used directly but via a `TinyLogger`.Examples--------------------	(TinyFileLogger for: aTinyLogger) record: 'First log'.		(TinyFileLogger for: aTinyLogger named: 'anotherFile.log') record: 'First log'.	 Internal Representation and Key Implementation Points.--------------------    Instance Variables	fileName:		<aString> 	Name of the file in which informations should be logged.!!TinyStdoutLogger commentStamp: '' prior: 0!Description--------------------I am a logger that will log the informations in the StdOut.I should not be used directly but via a `TinyLogger`.Examples--------------------	(TinyStdoutLogger for: aTinyLogger) record: 'First log'!!TinyTranscriptLogger commentStamp: '' prior: 0!Description--------------------I am a logger that will log the informations in the Transcript.I should not be used directly but via a `TinyLogger`.Examples--------------------	(TinyTranscriptLogger for: aTinyLogger) record: 'First log'!!TinyLogger commentStamp: '' prior: 0!Description--------------------I am the main entry point of the project. This project is build with a composite design pattern and I am the composite. I contains subclasses of TinyLeafLogger.I am a default instance that is used by default in the image when you send #record to a string for example. This instance should be configured by the user before been used (else it will do nothing). It is also possible to create another instance with different loggers and to use it. You can also change the default logger objects will use to record logs with the `TinyCurrentLogger` dynamic variable (See example bellow). The user can configure the timestamp formating via the #timestampFormatBlock paramater.Public API and Key Messages--------------------- #record: 						Log the parameter of the sub loggers- #clearLog 						Clear the output of the sub loggers- #execute:recordedAs: 		Execute a block and log the task when it beging and ends. This will increase the identation of the logging- #addStdoutLogger 			Add a logger on Stdout- #addTrascriptLogger 		Add a logger on the Transcript- #addFileLogger 				Add a logger that will log in a file named `TinyLogger.log`- #addFileLoggerNamed: 		Add a logger on a file whose name is passed as parameter- #ensure: 						Variant of all previous #addX message. This one will add the new logger only if there is not equivalent logger already present- #timestampFormatBlock: 	Give as parameter a block taking a stream as parameter and writing the timestamp you wantExamples--------------------	"Add two file loggers, a stdio logger and a transcript logger to the default logger."	TinyLogger default		addTranscriptLogger;		addStdoutLogger;		addFileLoggerNamed: 'Test.log';		addFileLoggerNamed: 'MyOtherLog.log'.			"Record a string via the default logger"	'My string' record.	TinyLogger default record: 'My string'.		"Record with nesting via the default logger"	self execute: [ 1 to: 10 do: [ :value | value asString record ] ] recordedAs: 'Task with only one nesting.'		self execute: [ 		1 to: 10 do: [ :value1 | 			self execute: [				1 to: value1 do: [ :value2 | value2 asString record ]				] recordedAs: 'My second nest'			 ]		 ] recordedAs: 'My first nest'.		"Record with a non default logger"	TinyLogger new		addTranscriptLogger;		record: 'Test'.		"Change the default logger Objects should use during the execution of a subpart of the system"		TinyCurrentLogger value: (TinyLogger new addTranscriptLogger; yourself) during: [ 		'test' record.		TinyCurrentLogger value record: 'Test2'	]			"Change the default timestamp format"	TinyLogger default		timestampFormatBlock:			[ :aStream :timestamp | timestamp asDate printOn: aStream. aStream << ' '. "Cannot use #space because of Stdio streams" timestamp asTime print24: true on: aStream ]. Internal Representation and Key Implementation Points.--------------------    Instance Variables	depth:							<anInteger>		I record the depth level of the nesting.	loggersMap:					<aDictonary>		I am used to store the loggers. I keep for each kind of loggers a collection of their instances.	timestampFormatBlock:		<aBlock>			I am a block defining the way the timestamp should be written.!!ManifestTinyLogger commentStamp: '' prior: 0!I contains the implementation of a simple and tiny logger.I implement different kind of loggers such as:- Transcript- Stdout - File Check the class comment of `TinyLogger` or the documentation present on https://github.com/jecisc/TinyLogger repository for more informations.!!TinyCurrentLogger methodsFor: 'accessing'!default	^ TinyLogger default! !!Object methodsFor: '*TinyLogger'!execute: aBlock recordedAs: aString	TinyCurrentLogger value execute: aBlock recordedAs: aString! !!Object methodsFor: '*TinyLogger'!record	self record: self asString! !!Object methodsFor: '*TinyLogger'!record: aString	TinyCurrentLogger value record: aString! !!TinyAbstractLogger class methodsFor: 'testing'!isAbstract	<ignoreForCoverage>	^ self = TinyAbstractLogger! !!TinyAbstractLogger methodsFor: 'logging'!<< aString	self record: aString! !!TinyAbstractLogger methodsFor: 'logging'!clearLog	"Whe called, this method should clear the previous logs"	self subclassResponsibility! !!TinyAbstractLogger methodsFor: 'logging'!record: aString	self subclassResponsibility! !!TinyAbstractLogger methodsFor: 'accessing'!timestampFormatBlock	<ignoreForCoverage>	^ self subclassResponsibility! !!TinyFileLogger class methodsFor: 'accessing'!defaultFileName	^ 'TinyLogger.log'! !!TinyFileLogger class methodsFor: 'instance creation'!for: aLogger named: aString	^ (self for: aLogger)		fileName: aString;		yourself! !!TinyFileLogger class methodsFor: 'accessing'!kind	<ignoreForCoverage>	^ 'file'! !!TinyFileLogger class methodsFor: 'instance creation'!named: aString	^ self new		fileName: aString;		yourself! !!TinyFileLogger methodsFor: 'logging'!clearLog	self fileReference ensureDelete! !!TinyFileLogger methodsFor: 'accessing'!defaultFileName	^ self class defaultFileName! !!TinyFileLogger methodsFor: 'accessing'!fileName	^ fileName ifNil: [ fileName := self defaultFileName ]! !!TinyFileLogger methodsFor: 'accessing'!fileName: anObject	fileName := anObject! !!TinyFileLogger methodsFor: 'accessing'!fileReference	^ self fileName asFileReference! !!TinyFileLogger methodsFor: 'accessing'!fileStreamDo: aBlock	"For now we re-open the file all the time to avoid problems when we change its image of computer/OS or if the user delete the file. Maybe later we can find a better solution but in any case we should test such weird behaviors."	self fileReference		ensureCreateFile;		writeStreamDo: [ :s | 			s setToEnd.			aBlock value: s ]! !!TinyFileLogger methodsFor: 'logging'!record: aString	self fileStreamDo: [ :aStream | self record: aString on: aStream ]! !!TinyLeafLogger class methodsFor: 'instance creation'!for: aTinyLogger	^ self new		parentLogger: aTinyLogger;		yourself! !!TinyLeafLogger class methodsFor: 'testing'!isAbstract	<ignoreForCoverage>	^ self = TinyLeafLogger! !!TinyLeafLogger class methodsFor: 'accessing'!kind	<ignoreForCoverage>	^ self subclassResponsibility! !!TinyLeafLogger methodsFor: 'accessing'!depth	^ self parentLogger depth! !!TinyLeafLogger methodsFor: 'accessing'!kind	^ self class kind! !!TinyLeafLogger methodsFor: 'logging'!newLine	^ OSPlatform current lineEnding! !!TinyLeafLogger methodsFor: 'accessing'!parentLogger	^ parentLogger! !!TinyLeafLogger methodsFor: 'accessing'!parentLogger: aLogger	parentLogger := aLogger! !!TinyLeafLogger methodsFor: 'logging'!record: aString on: aStream	self recordPreambleOn: aStream.	aStream << aString << self newLine! !!TinyLeafLogger methodsFor: 'accessing'!recordPreambleOn: aStream	<compilerOptions: #(+ optionInlineTimesRepeat)>		self timestampFormatBlock cull: aStream cull: DateAndTime now.	aStream << ' : '.	"We use explicit tab writing instead of #tab or #tab: because not all streams understand those methods"	self depth timesRepeat: [ aStream nextPut: Character tab ]! !!TinyLeafLogger methodsFor: 'accessing'!timestampFormatBlock	^ self parentLogger timestampFormatBlock! !!TinyStdoutLogger class methodsFor: 'accessing'!kind	<ignoreForCoverage>	^ 'stdout'! !!TinyStdoutLogger methodsFor: 'logging'!clearLog	"We do nothing here since we cannot clear stdout"	! !!TinyStdoutLogger methodsFor: 'initialization'!initialize	super initialize.	self flag: #pharo6. "This is needed because in Pharo 6.1 Stdio does not works well. When Pharo 7 will be the minimum supported, remove this hack."	streamClassProvider := SystemVersion current major < 7 ifTrue: [ FileStream ] ifFalse: [ Stdio ]! !!TinyStdoutLogger methodsFor: 'logging'!record: aString	| stream |	stream := streamClassProvider stdout.	self record: aString on: stream.	"The flush is needed to send the record in the stdout."	stream flush! !!TinyTranscriptLogger class methodsFor: 'accessing'!kind	<ignoreForCoverage>	^ 'transcript'! !!TinyTranscriptLogger methodsFor: 'logging'!clearLog	Transcript clear! !!TinyTranscriptLogger methodsFor: 'logging'!record: aString	Transcript trace: (String streamContents: [ :s | self record: aString on: s ])! !!TinyLogger class methodsFor: 'accessing'!default	^ Default ifNil: [ Default := self new ]! !!TinyLogger class methodsFor: 'accessing'!default: anObject	Default := anObject! !!TinyLogger class methodsFor: 'initialization'!reset	self default: nil! !!TinyLogger methodsFor: 'public API'!addFileLogger	"Since no file name is passed as parameter, I will log in a file named `TinyLogger.log` next to the image."	self addLogger: TinyFileLogger new! !!TinyLogger methodsFor: 'public API'!addFileLoggerNamed: aString	self addLogger: (TinyFileLogger named: aString)! !!TinyLogger methodsFor: 'public API'!addLogger: aLogger	(self loggersMap at: aLogger kind ifAbsentPut: [ OrderedCollection new ]) add: (aLogger parentLogger: self)! !!TinyLogger methodsFor: 'public API'!addStdoutLogger	self addLogger: TinyStdoutLogger new! !!TinyLogger methodsFor: 'public API'!addTranscriptLogger	self addLogger: TinyTranscriptLogger new! !!TinyLogger methodsFor: 'logging'!clearLog	self loggers do: #clearLog! !!TinyLogger methodsFor: 'nesting'!decreaseDepthLevel	self depth: self depth - 1! !!TinyLogger methodsFor: 'accessing'!defaultTimestampFormatBlock	^ [ :aStream :timestamp | aStream << timestamp asString ]! !!TinyLogger methodsFor: 'accessing'!depth	^ depth! !!TinyLogger methodsFor: 'accessing'!depth: anObject	depth := anObject! !!TinyLogger methodsFor: 'public API'!ensureFileLogger	"Ensure a file logger to `TinyLogger.log` is in the logger. In case one already exists, does nothing."	self ensureFileLoggerNamed: TinyFileLogger defaultFileName! !!TinyLogger methodsFor: 'public API'!ensureFileLoggerNamed: aString	"Ensure a file logger to a file whose name is given as parameter is in the logger. In case one already exists, does nothing."	self fileLoggers		detect: [ :e | e fileName = aString ]		ifNone: [ self addFileLoggerNamed: aString ]! !!TinyLogger methodsFor: 'public API'!ensureStdoutLogger	self stdoutLoggers ifEmpty: [ self addStdoutLogger ]! !!TinyLogger methodsFor: 'public API'!ensureTranscriptLogger	self transcriptLoggers ifEmpty: [ self addTranscriptLogger ]! !!TinyLogger methodsFor: 'public API'!execute: aBlock recordedAs: aString	self increaseDepthLevel.	self record: 'Begin: ' , aString.	self increaseDepthLevel.	[ aBlock cull: aString ]		ifCurtailed: [ "If there is an error, we ensure we keep the right indentation and we print an end of action with error."			self decreaseDepthLevel.			self record: 'End with error: ' , aString.			self decreaseDepthLevel ].	self decreaseDepthLevel.	self record: 'End: ' , aString.	self decreaseDepthLevel! !!TinyLogger methodsFor: 'accessing - loggers'!fileLoggers	^ self loggersMap at: TinyFileLogger kind ifAbsentPut: [ OrderedCollection new ]! !!TinyLogger methodsFor: 'nesting'!increaseDepthLevel	self depth: self depth + 1! !!TinyLogger methodsFor: 'initialization'!initialize	super initialize.	self depth: 0.	self timestampFormatBlock: self defaultTimestampFormatBlock.	self loggersMap: Dictionary new! !!TinyLogger methodsFor: 'accessing'!loggers	"Since the loggers variable contains a dictionary of loggers, here we faltten the dictonary."	^ self loggersMap values flatCollect: #yourself! !!TinyLogger methodsFor: 'accessing'!loggersMap	^ loggersMap! !!TinyLogger methodsFor: 'accessing'!loggersMap: anObject	loggersMap := anObject! !!TinyLogger methodsFor: 'public API'!record: aString	self loggers do: [ :each | each record: aString ]! !!TinyLogger methodsFor: 'public API'!removeAllLoggers	self loggers do: [ :each | self removeLogger: each ]! !!TinyLogger methodsFor: 'public API'!removeFileLoggers	self fileLoggers removeAll! !!TinyLogger methodsFor: 'public API'!removeLogger: aLogger	(self loggersMap at: aLogger kind ifAbsentPut: [ OrderedCollection new ]) remove: aLogger! !!TinyLogger methodsFor: 'public API'!removeStdoutLoggers	self stdoutLoggers removeAll! !!TinyLogger methodsFor: 'public API'!removeTranscriptLoggers	self transcriptLoggers removeAll! !!TinyLogger methodsFor: 'accessing - loggers'!stdoutLoggers	^ self loggersMap at: TinyStdoutLogger kind ifAbsentPut: [ OrderedCollection new ]! !!TinyLogger methodsFor: 'accessing'!timestampFormatBlock	^ timestampFormatBlock! !!TinyLogger methodsFor: 'accessing'!timestampFormatBlock: anObject	timestampFormatBlock := anObject! !!TinyLogger methodsFor: 'accessing - loggers'!transcriptLoggers	^ self loggersMap at: TinyTranscriptLogger kind ifAbsentPut: [ OrderedCollection new ]! !!TinyLogger methodsFor: 'public API'!withDefaultLoggers	self		removeAllLoggers;		addTranscriptLogger;		addStdoutLogger;		addFileLogger! !"TinyLogger"!!TinyAbstractLoggerTest commentStamp: '' prior: 0!A TinyAbstractLoggerTest is a test class for testing the behavior of TinyAbstractLogger!!TinyLeafLoggerTest commentStamp: '' prior: 0!A TinyConcreteLoggerTest is a test class for testing the behavior of TinyConcreteLogger!!TinyFileLoggerTest commentStamp: '' prior: 0!A TinyFileLoggerTest is a test class for testing the behavior of TinyFileLogger!!TinyStdoutLoggerTest commentStamp: '' prior: 0!A TinyStdoutLoggerTest is a test class for testing the behavior of TinyStdoutLogger!!TinyLoggerTest commentStamp: '' prior: 0!A TinyLoggerTest is a test class for testing the behavior of TinyLogger!!ManifestTinyLoggerTests commentStamp: '' prior: 0!I contains tests of the implementation of a simple and tiny logger.I implement different kind of loggers such as:- Transcript- Stdout - File Check the class comment of `TinyLogger` or the documentation present on https://github.com/jecisc/TinyLogger repository for more informations.!!TinyAbstractLoggerTest class methodsFor: 'testing'!isAbstract	^ self = TinyAbstractLoggerTest! !!TinyAbstractLoggerTest class methodsFor: 'testing'!shouldInheritSelectors	^ true! !!TinyAbstractLoggerTest methodsFor: 'helpers'!actualClass	^ self subclassResponsibility! !!TinyAbstractLoggerTest methodsFor: 'helpers'!skipInPharo6	self flag: #pharo6. "There is a bug with stdout in Pharo 6 and a hack to manage it. But it breaks the tests so we skip the tests using Stdio streams. Remove that when compatibility with P6 will be dropped."	SystemVersion current major < 7 ifTrue: [ self skip ]! !!TinyAbstractLoggerTest methodsFor: 'test'!testClearLog	self subclassResponsibility! !!TinyAbstractLoggerTest methodsFor: 'test'!testRecord	self subclassResponsibility! !!TinyFileLoggerTest methodsFor: 'helpers'!actualClass	^ TinyFileLogger! !!TinyFileLoggerTest methodsFor: 'test'!fileNameNumber: number	^ 'testFile' , number asString , 'ForTinyLogger.log'! !!TinyFileLoggerTest methodsFor: 'running'!tearDown	log ifNotNil: #ensureDelete.	super tearDown! !!TinyFileLoggerTest methodsFor: 'test'!testCanHaveDefaultFile	self shouldnt: [ self actualClass new fileReference ] raise: Error! !!TinyFileLoggerTest methodsFor: 'test'!testClearLog	log := (self fileNameNumber: 1) asFileReference.	logger := self actualClass for: parentLogger named: log basename.	logger record: 'this is a test'.	self assert: log exists.	logger clearLog.	self deny: log exists! !!TinyFileLoggerTest methodsFor: 'test'!testFileName	log := (self fileNameNumber: 4) asFileReference.	logger := self actualClass for: parentLogger named: log basename.	logger record: 'this is a test'.	self assert: (self fileNameNumber: 4) asFileReference exists! !!TinyFileLoggerTest methodsFor: 'test'!testLoggerCreatesFile	log := (self fileNameNumber: 10) asFileReference.	logger := self actualClass for: parentLogger named: log basename.	self deny: log exists.	logger record: 'this is a test'.	self assert: log exists! !!TinyFileLoggerTest methodsFor: 'test'!testRecord	log := (self fileNameNumber: 1) asFileReference.	logger := self actualClass for: parentLogger named: log basename.	logger record: 'this is a test'.	self assert: log exists.	self assert: log contents lines isNotEmpty.	self assert: (log contents lines last includesSubstring: 'this is a test')! !!TinyFileLoggerTest methodsFor: 'test'!testRecordSetFileToTheEnd	log := (self fileNameNumber: 1) asFileReference.	logger := self actualClass for: parentLogger named: log basename.	logger record: 'this is a test'.	self assert: log contents lines size equals: 1.	logger record: 'this is a test2'.	self assert: log contents lines size equals: 2! !!TinyLeafLoggerTest class methodsFor: 'testing'!isAbstract	^ self = TinyLeafLoggerTest! !!TinyLeafLoggerTest methodsFor: 'running'!setUp	super setUp.	parentLogger := TinyLogger new.	logger := self actualClass for: parentLogger! !!TinyLeafLoggerTest methodsFor: 'test'!testRecordPreambleOn	parentLogger timestampFormatBlock: [ :s | s << 'this is a test' ].	self assert: (String streamContents: [ :s | logger recordPreambleOn: s]) equals: 'this is a test : '.	parentLogger timestampFormatBlock: [ :s | s << 'this is a test2' ].	self assert: (String streamContents: [ :s | logger recordPreambleOn: s]) equals: 'this is a test2 : '! !!TinyStdoutLoggerTest methodsFor: 'helpers'!actualClass	^ TinyStdoutLogger! !!TinyStdoutLoggerTest methodsFor: 'test'!testClearLog	self shouldnt: [ logger clearLog ] raise: Error! !!TinyStdoutLoggerTest methodsFor: 'test'!testRecord	| stream |	self skipInPharo6.	stream := '' writeStream.	[ Stdio stub stdout willReturn: stream.	logger record: 'This is a test'.	self assert: (stream contents asString lines last includesSubstring: 'This is a test') ]		ensure: [ Stdio recoverFromGHMutation.			stream close ]! !!TinyLoggerTest methodsFor: 'helpers'!actualClass	^ TinyLogger! !!TinyLoggerTest methodsFor: 'running'!setUp	super setUp.	logger := TinyLogger new! !!TinyLoggerTest methodsFor: 'test'!testAddFileLogger	logger removeAllLoggers.	self assert: logger loggers isEmpty.		logger		addFileLogger;		addFileLogger.	self assert: logger loggers size equals: 2.	self assert: logger fileLoggers size equals: 2! !!TinyLoggerTest methodsFor: 'test'!testAddFileLoggerNamed	logger removeAllLoggers.	self assert: logger loggers isEmpty.		logger addFileLoggerNamed: 'test.log'.	self assert: logger fileLoggers size equals: 1.	self assert: logger loggers anyOne fileName equals: 'test.log'! !!TinyLoggerTest methodsFor: 'test'!testAddLogger	logger removeAllLoggers.	self assert: logger loggers isEmpty.		logger		addLogger: (TinyFileLogger for: logger);		addLogger: (TinyFileLogger for: logger named: 'test.log').	self assert: logger loggers size equals: 2.	self assert: logger fileLoggers size equals: 2! !!TinyLoggerTest methodsFor: 'test'!testAddStdoutLogger	logger removeAllLoggers.	self assert: logger loggers isEmpty.	logger		addStdoutLogger;		addStdoutLogger.	self assert: logger loggers size equals: 2.	self assert: logger stdoutLoggers size equals: 2! !!TinyLoggerTest methodsFor: 'test'!testAddTranscriptLogger	logger removeAllLoggers.	self assert: logger loggers isEmpty.		logger		addTranscriptLogger;		addTranscriptLogger.	self assert: logger loggers size equals: 2.	self assert: logger transcriptLoggers size equals: 2! !!TinyLoggerTest methodsFor: 'test'!testClearLog	logger		addTranscriptLogger;		addFileLoggerNamed: 'testFileForTinyLogger.log';		addFileLoggerNamed: 'testFileForTinyLogger2.log'.	logger record: 'Test'.	self assert: (logger fileLoggers allSatisfy: [ :fileLogger | fileLogger fileReference exists ]).	logger clearLog.	self assert: (logger fileLoggers noneSatisfy: [ :fileLogger | fileLogger fileReference exists ])! !!TinyLoggerTest methodsFor: 'test'!testCurrentLogger	self assert: TinyCurrentLogger value isNotNil.	self assert: TinyCurrentLogger value class equals: TinyLogger! !!TinyLoggerTest methodsFor: 'test'!testEnsureFileLogger	logger removeAllLoggers.	self assert: logger loggers isEmpty.	logger ensureFileLogger.	self assert: logger loggers size equals: 1.	self assert: logger fileLoggers size equals: 1.	logger ensureFileLogger.	self assert: logger loggers size equals: 1.	self assert: logger fileLoggers size equals: 1! !!TinyLoggerTest methodsFor: 'test'!testEnsureFileLoggerNamed	logger removeAllLoggers.	self assert: logger loggers isEmpty.	logger ensureFileLoggerNamed: 'test.log'.	self assert: logger fileLoggers size equals: 1.	logger ensureFileLoggerNamed: 'test.log'.	logger ensureFileLoggerNamed: 'test2.log'.	self assert: logger fileLoggers size equals: 2! !!TinyLoggerTest methodsFor: 'test'!testEnsureStdoutLogger	logger removeAllLoggers.	self assert: logger loggers isEmpty.	logger		ensureStdoutLogger;		ensureStdoutLogger.	self assert: logger loggers size equals: 1.	self assert: logger stdoutLoggers size equals: 1! !!TinyLoggerTest methodsFor: 'test'!testEnsureTranscriptLogger	logger removeAllLoggers.	self assert: logger loggers isEmpty.		logger		ensureTranscriptLogger;		ensureTranscriptLogger.	self assert: logger loggers size equals: 1.	self assert: logger transcriptLoggers size equals: 1! !!TinyLoggerTest methodsFor: 'test'!testExecuteRecordedAs	| contents stream bool |	self skipInPharo6.	bool := false.	logger		removeAllLoggers;		addStdoutLogger.	stream := '' writeStream.	[ Stdio stub stdout willReturn: stream.	logger execute: [ bool := true ] recordedAs: 'This is a new test'.	contents := Stdio stdout contents asString.	self assert: bool.	self assert: (contents includesSubstring: 'Begin: This is a new test').	self assert: (contents includesSubstring: 'End: This is a new test') ]		ensure: [ Stdio recoverFromGHMutation.			stream close ]! !!TinyLoggerTest methodsFor: 'test'!testExecuteRecordedAs2	| contents stream |	self skipInPharo6.	logger		timestampFormatBlock: [ :s | s nextPutAll: 'No time' ];		removeAllLoggers;		addStdoutLogger.	stream := '' writeStream.	[ Stdio stub stdout willReturn: stream.	TinyCurrentLogger value: logger during: [ Object new execute: [ 'test' record ] recordedAs: 'This is a new test' ].	contents := Stdio stdout contents asString.	"Ensure we have the right indentation."	self		assert: contents withUnixLineEndings		equals:			'No time : 	Begin: This is a new testNo time : 		testNo time : 	End: This is a new test' withUnixLineEndings ]		ensure: [ Stdio recoverFromGHMutation.			stream close ]! !!TinyLoggerTest methodsFor: 'test'!testExecuteRecordedAsKeepRightIndentation	| contents stream |	self skipInPharo6.	logger		timestampFormatBlock: [ :s | s nextPutAll: 'No time' ];		removeAllLoggers;		addStdoutLogger.	stream := '' writeStream.	[ Stdio stub stdout willReturn: stream.	TinyCurrentLogger		value: logger		during: [ [ Object new execute: [ Error signal ] recordedAs: 'This is a new test' ]				on: Error				do: [ "nothing" ].			Object new execute: [ 'test' record ] recordedAs: 'This is a new test' ].	contents := Stdio stdout contents asString.	"Ensure we have the right indentation."	self		assert: contents withUnixLineEndings		equals:			'No time : 	Begin: This is a new testNo time : 	End with error: This is a new testNo time : 	Begin: This is a new testNo time : 		testNo time : 	End: This is a new test' withUnixLineEndings ]		ensure: [ Stdio recoverFromGHMutation.			stream close ]! !!TinyLoggerTest methodsFor: 'test'!testFileLoggers	logger		addTranscriptLogger;		addFileLoggerNamed: 'test.log';		addFileLoggerNamed: 'test2.log'.	self assert: logger loggers size equals: 3.	self assert: logger fileLoggers size equals: 2.	self assert: (logger fileLoggers allSatisfy: [ :each | each kind = TinyFileLogger kind ]).	self assert: (logger fileLoggers anySatisfy: [ :each | each kind = TinyFileLogger kind and: [ each fileName = 'test.log' ] ]).	self assert: (logger fileLoggers anySatisfy: [ :each | each kind = TinyFileLogger kind and: [ each fileName = 'test2.log' ] ])! !!TinyLoggerTest methodsFor: 'test'!testLoggers	logger		addTranscriptLogger;		addFileLoggerNamed: 'test.log';		addFileLoggerNamed: 'test2.log'.	self assert: logger loggers size equals: 3.	self assert: (logger loggers anySatisfy: [ :each | each kind = TinyFileLogger kind and: [ each fileName = 'test.log' ] ]).	self assert: (logger loggers anySatisfy: [ :each | each kind = TinyFileLogger kind and: [ each fileName = 'test2.log' ] ]).	self assert: (logger loggers anySatisfy: [ :each | each kind = TinyTranscriptLogger kind ])! !!TinyLoggerTest methodsFor: 'test'!testNestedExecuteRecordedAs	| contents stream bool1 bool2 |	self skipInPharo6.	bool1 := false.	bool2 := false.	logger		removeAllLoggers;		addStdoutLogger.	stream := '' writeStream.	[ Stdio stub stdout willReturn: stream.	logger		execute: [ bool1 := true.			logger execute: [ bool2 := true ] recordedAs: 'Test2' ]		recordedAs: 'Test1'.	contents := Stdio stdout contents asString.	self assert: bool1.	self assert: bool2.	self assert: (contents includesSubstring: '	Begin: Test1').	self assert: (contents includesSubstring: '	End: Test1').	self assert: (contents includesSubstring: '			Begin: Test2').	self assert: (contents includesSubstring: '			End: Test2') ]		ensure: [ Stdio recoverFromGHMutation.			stream close ]! !!TinyLoggerTest methodsFor: 'test'!testRecord	| contents stream |	self skipInPharo6.	logger		removeAllLoggers;		addStdoutLogger;		addStdoutLogger;		addTranscriptLogger.	stream := '' writeStream.	[ Stdio stub stdout willReturn: stream.	logger record: 'This is a new test'.	contents := Stdio stdout contents asString lines.	self assert: (contents last includesSubstring: 'This is a new test').	self assert: ((contents at: contents size - 1) includesSubstring: 'This is a new test') ]		ensure: [ Stdio recoverFromGHMutation.			stream close ]! !!TinyLoggerTest methodsFor: 'test'!testRecord2	| contents stream |	self skipInPharo6.	logger		removeAllLoggers;		addStdoutLogger;		addStdoutLogger;		addTranscriptLogger.	stream := '' writeStream.	[ Stdio stub stdout willReturn: stream.	logger << 'This is a new test'.	contents := Stdio stdout contents asString lines.	self assert: (contents last includesSubstring: 'This is a new test').	self assert: ((contents at: contents size - 1) includesSubstring: 'This is a new test') ]		ensure: [ Stdio recoverFromGHMutation.			stream close ]! !!TinyLoggerTest methodsFor: 'test'!testRecord3	| log |	log :=  'testFileForTinyLogger.log' asFileReference.	[	logger addFileLoggerNamed: log basename.		TinyCurrentLogger value: logger during: [ 'this is a test' record ].		self assert: log exists.	self assert: log contents lines isNotEmpty.	self assert: (log contents lines last includesSubstring: 'this is a test') ]		ensure: [ (log isNotNil and: [ log exists ])				ifTrue: [ log ensureDelete ] ]! !!TinyLoggerTest methodsFor: 'test'!testRemoveAllLoggers	logger		addTranscriptLogger;		addFileLoggerNamed: 'test.log';		addFileLoggerNamed: 'test2.log'.	self assert: logger loggers size equals: 3.	logger removeAllLoggers.	self assert: logger loggers isEmpty! !!TinyLoggerTest methodsFor: 'test'!testRemoveFileLoggers	logger		addTranscriptLogger;		addFileLoggerNamed: 'test.log';		addFileLoggerNamed: 'test2.log'.	self assert: logger loggers size equals: 3.	logger removeFileLoggers.	self assert: logger loggers size equals: 1! !!TinyLoggerTest methodsFor: 'test'!testRemoveLogger	| logger1 logger2 |	logger removeAllLoggers.	self assert: logger loggers isEmpty.		logger		addLogger: (logger1 := TinyFileLogger for: logger);		addLogger: (logger2 := TinyFileLogger for: logger named: 'test.log').	self assert: logger loggers size equals: 2.		logger removeLogger: logger1.	self assert: logger loggers size equals: 1.	self assert: logger loggers anyOne equals: logger2.		logger removeLogger: logger2.	self assert: logger loggers isEmpty! !!TinyLoggerTest methodsFor: 'test'!testRemoveStdoutLoggers	logger		addStdoutLogger;		addStdoutLogger;		addFileLoggerNamed: 'test.log'.	self assert: logger loggers size equals: 3.	logger removeStdoutLoggers.	self assert: logger loggers size equals: 1! !!TinyLoggerTest methodsFor: 'test'!testRemoveTranscriptLoggers	logger		addTranscriptLogger;		addTranscriptLogger;		addFileLoggerNamed: 'test.log'.	self assert: logger loggers size equals: 3.	logger removeTranscriptLoggers.	self assert: logger loggers size equals: 1! !!TinyLoggerTest methodsFor: 'test'!testStdoutLoggers	logger		addStdoutLogger;		addStdoutLogger;		addFileLoggerNamed: 'test.log'.	self assert: logger loggers size equals: 3.	self assert: logger stdoutLoggers size equals: 2.	self assert: (logger stdoutLoggers allSatisfy: [ :each | each kind = TinyStdoutLogger kind ])! !!TinyLoggerTest methodsFor: 'test'!testTranscriptLoggers	logger		addTranscriptLogger;		addTranscriptLogger;		addFileLoggerNamed: 'test.log'.	self assert: logger loggers size equals: 3.	self assert: logger transcriptLoggers size equals: 2.	self assert: (logger transcriptLoggers allSatisfy: [ :each | each kind = TinyTranscriptLogger kind ])! !!TinyLoggerTest methodsFor: 'test'!testWithDefaultLoggers	| numberOfDefaultLoggers |	logger withDefaultLoggers.	self assert: logger loggers isNotEmpty.	numberOfDefaultLoggers := logger loggers size.	logger addStdoutLogger.	logger withDefaultLoggers.	"Ensure the loggers are reset when this method is called"	self assert: logger loggers size equals: numberOfDefaultLoggers! !"TinyLogger-Tests"!!SObject commentStamp: '' prior: 0!Superclass of almost all project classes, between them:	- AST classes used to create statements and assertions	- Core classes which configure the environment, manage assertions creation and so.	- GA classes that are responsible for testCase's fitness increasing. It means coverage augmentation.	- Info classes which transform the profiler result in nodes that are easier to use in the assertions and statements creation.	- Profiler classes which get classes' info types.!!SExpression commentStamp: '' prior: 0!Superclass of all nodes for 	- expressions (they represent nodes which are used to create messages),	- messages (concerned with: assertion messages, factory messages, access messages and mesasges that modify the behavior of a class)	Instance Variables	id:		               <Integer> 	randomGenerator:		<SRandom>	returnType:		      <Symbol>!!SAbstractMessage commentStamp: '' prior: 0!Abstract class of nodes for	- messages (access messages and messages that update the state of a class)	- factory methods (to represent the class creation messages),	- assertion messages (to represent assertion messages that match with an according requirement)Instance Variables	args:		    <Collection>	receiver:		 <Symbol>	selector:		 <Symbol>!!SAssertionMessage commentStamp: '' prior: 0!Superclass of assertion messages nodes for 	- comparison assertion (it compares an object with other)	- inspector assertion (it compares the result of a method executed with a value)	- primitive assertion (it compares the primitive values)	- string assertion (it compares the way to represent an object as string with a string)!!SComparisonAssertion commentStamp: '' prior: 0!A SComparisonAssertion selects the execution context values that are comparable.Collection's items of the same class are compared and for each one is created a new instance of this class with the selector depending the result of the comparison.For example: 	List with items that are comparable: 		Array with: '_var1'-> 9		with: '_var2' -> 5		with: '_var3' -> 9		with: '_var4' -> 'hello'.	It returns items like: 		self deny: _var1 equals: _var2.		self assert: _var1 equals: _var3.		!!SInspectorAssertion commentStamp: '' prior: 0!A SInspectorAssertion selects methods categorized as returnField and creates an instance for each one if the execution result is primitive.For example: 		List with classes' items categorized as returnField: 		Array with: '_var2' -> (2@10).	It returns items like: 		self assert: _var2 x equals: 2.		self assert: _var2 y equals: 10.!!SPrimitiveAssertion commentStamp: '' prior: 0!A SPrimitiveAssertion collects instances of the class if the execution context's values are primitives.For example: 		List with items classified as primitive: 		Array with: '_var1' -> 'hello'		with: '_var2' -> 2		with: '_var3' -> (3@5).	It returns items like: 		self assert: _var1 equals: 'hello'.		self assert: _var2 equals: 2.!!SStringAssertion commentStamp: '' prior: 0!A SStringAssertion select execution context's values that their class implement some method of printing like: 'printOn:', 'asString'. From the resulting collection each item is used to create an instance of the class using #printString as selector.For example: 		List with classes' items which have implemented printing methods: 		Array with: '_var1' -> 'hello'		with: '_var2' -> 2.3		with: '_var3' -> (3@5).	It returns items like: 		self assert: _var1 printString equals: ''hello''.		self assert: _var2 printString equals: '2.3'.		self assert: _var3 printString equals: (2@3).!!SFactoryMessage commentStamp: '' prior: 0!SFactoryMessage is a node that represents the class' creation with methods of meta class.For example: 	1.			SStack newStack.			#SStack -> It's the receiver 		#newStack -> It's a method of meta class.			2. 		SFoo score: _var1.				#SFoo -> Receiver		#score: -> Message of receiver		_var1 -> Argument 			3. 		SFoo new.				#SFoo new -> Receiver		#new -> Default selector!!SFieldAccessMessage commentStamp: '' prior: 0!SFieldAccessMessage is a node which represents method calls that return an instance variable of a class.For example: 	1.			_var1 x.			_var1 -> Receiver which points to Point's factoryMessage.		#x -> selector of the method!!SMessage commentStamp: '' prior: 0!SMessage is a node which represents method calls that not return an instance variable of a class. They are a little more complex. It can receive arguments also.For example: 	1.			_var1 returnCollection.			_var1 -> Receiver which points to SFoo's factoryMessage.		#returnCollection -> selector of the method.			2. 		_var1 return: _var2.				_var1 -> Receiver		#return: -> selector		_var2 -> Argument of type ByteString!!SAssignment commentStamp: '' prior: 0!SAssignment is a node which is compossed by a variable and an expression.For example: 	1.			_var0 := 1.			_var0 -> Variable.		1 -> value (in this case a literal).			2. 		_var1 := SFoo new.				_var1 -> Varaible		SFoo new -> an instance of factoryMessage!!SLiteral commentStamp: '' prior: 0!SLiteral is a node which is compossed by a value that is included in typeInfo scalars.For example: 	1.			10				10 -> SmallInteger.			2. 		'hello'				'hello' -> ByteString.!!SVariable commentStamp: '' prior: 0!SVariable is a node which is represented by a name and id.For example: 	1.			_var2				_var -> Name of variable.		2 -> Id of variable			2. 		_int3				'_int' -> Name		3 -> Id!!SSelf commentStamp: '' prior: 0!SSelf is a node which is part of the assertion message.!!SFitnessFunction commentStamp: '' prior: 0!SFitnessFunction is an abstract class that represents a fitness abstract function used in genetic algorithm evolution to determine how fit a testCase is.!!SMultiFitnessFunction commentStamp: '' prior: 0!SMultiFitnessFunciton is the fitness function that contains simple fitness function's collection.!!SSimpleFitnessFunction commentStamp: '' prior: 0!SSimpleFitnessFunction is an abstract class of simple fitness function like: 		- SMethodCoverage -> It calculates the number of class methods executed	- SStatementCoverage -> It calculates the number of statements executed 	Instance Variables	profiler:		<SSTypeCollector>	!!SMethodCoverage commentStamp: '' prior: 0!SMethodCoverage is responsible for calculating the method coverage in each testCase of a testSuite. It means that for each class defined in the testCase it calculates how many methods were executed.!!SStatementCoverage commentStamp: '' prior: 0!SStatementCoverage is responsible for calculating statement coverage of each testCase in the testSuite. It calculates how many statements were executed in each class defined of the testSuite. The number of statements refers to number of lines of code executed !!SGAEngineExample commentStamp: '' prior: 0!SGAEngineExample contains some examples to validate correct project functionality !!SGALog commentStamp: '' prior: 0!SGALog saves some important data about genetic algorithm evolution like: genetic algotithm's generation number, testCase with the highest fitness and time in which is produced the generation.In each iteration of the genetic algorithm a new instance of the class is created.Instance Variables	fittestTestCase:				<STestCase>	generationNumber:				<Smallnteger>	timeToProduceGeneration:		<SmallInteger>!!SGAObject commentStamp: '' prior: 0!Abstract class of those nodes responsible for the genetic algorithm evolution:	- engine (like its name says, it is responsible to execute the algorithm in order to get the testCases with the highest fitness value)	- operations classes -> Responsible for executing crossover and mutation operation	- selection algorithm class -> It selects the fittest individuals testCases!!SGAEngine commentStamp: '' prior: 0!SGAEngine is responsible for executing the genetic algorithm, it means that it follows the phases to get a testCase population with the highest fitness score.The phases followed are:	1. Create an initial population 	2. Use the fitness function established to calculate the fitness score of each testCase in the population	3. Determine the selection strategy to select the fittest testCases and let them pass their statements to the next generation	4. Apply the crossover operation to get offsprings (new testCases) by exchanging the statements of parents (testCases). 	5. Apply mutation operation with a low random probability to modify some statements. Internal Representation and Key Implementation Points.Instance Variables	crossoverOperator:			<SGACrossoverOperator>	fitness:						<SFitnessFunction>	logs:							<OrderedCollection>	mutationOperator:			<SGAMutationOperator>	numberOfIterations:		<SmallInteger>	numberOfStatements:		<SmallInteger>	population:					<OrderedCollection>	populationSize:				<SmallInteger>	selectionStrategy:			<SGATournamentSelection>	targetClassName:			<ByteString>	typeInfo:						<STypeInfo>!!SGAOperation commentStamp: '' prior: 0!SGAOperation is an abstract class for operation nodes which are necessary to create a new population  	- crossover operation 	- mutation operation !!SGACrossoverOperation commentStamp: '' prior: 0!SGACrossoverOperation is the operation node that is responsible to create offsprings combining the statements of their parents.To create a new offspring it gets a random percent of statements of a testCase and the rest of another testCase. Furthermore, it checks the statements references (dependencies) and repairs them if it is necessary.For example if the parents are:	Parent1	_var0 := 1.	_var1 := 'hello'.		Parent2	_var0 := SFoo new.	_var1 := _var0 returnString.	The new offspring with a 50% of statements of each parent:	_var0 := 1.	_var1 := _var0 returnString.	Like it has an inconsistency because '_var0' in the first parent is of type SFoo, it is repaired. Then the new offspring resultant is:	_var0 := 1.	_var2 := SFoo new.	_var1 := _var2 returnString. !!SGAMutationOperation commentStamp: '' prior: 0!SGAMutationOperation is an operator which modifies some statements of the testCase. However this operation depends of a random probability to be applied.This operation can apply three different types of mutation: 		- remove -> It means that a statement choosen randomly can be removed of the testCase.	- change -> According to the statement choosen, it is modified in value or selector.	- insert -> A statement is added following one of these options: asRandomMessage, asMethodMessage or asParameter. The reason for these options is because statements are usually of different expressions.!!SGASelection commentStamp: '' prior: 0!Abstract class for strategy selection!!SGARandomSelection commentStamp: '' prior: 0!SGARankSelection is responsible for select testCases randomly regardless of fitness!!SGARankSelection commentStamp: '' prior: 0!SGARankSelectionModified is responsible for select testCases based of their rank!!SGARouletteSelection commentStamp: '' prior: 0!SGARoulleteSelection is responsible for select testCases, gives more probaility of be selected when a testCase has more fitness!!SGATournamentSelection commentStamp: '' prior: 0!SGATournamentSelection is responsible for select the fittest testCase based in their fitness.!!SGATruncatedSelection commentStamp: '' prior: 0!SGATrouncateSelection is responsible for select testCases, this type of selection descart the worst N testCases (less fitness) and then select randomly testCases!!SInitialization commentStamp: '' prior: 0!SInitialization is abstract class to create an instance taking some considerations!!SNumericParameterization commentStamp: '' prior: 0!SNumericParametrization creates instances changing values like: 		- numberOfStatements 	- numberOfPopulation	- numberOfGenerations!!SSeedingParameterization commentStamp: '' prior: 0!SSeedingParametrization creates instances changing the seed whether adding or reducing a value to the original seed!!SSelectionParameterization commentStamp: '' prior: 0!SSelectionParametrization creates instances changing selectionStrategy of GA and use: 		- SGATournamentSelection 	- SGARankSelectionModified 	- SGARouletteSelection !!SPlatform commentStamp: '' prior: 0!SConfiguration is responsible for defining or instantiating some classes or values used in the project.Furthermore, some configuration parameters are defined depending the environment, it means Pharo or VisualWorks!!SPlatformPharo commentStamp: '' prior: 0!SConfigurationPharo is a subclass called when the project environment is running in Pharo. Furthermore, it defines parameters used in Pharo.!!SPlatformVisualWorks commentStamp: '' prior: 0!SConfigurationVisualWorks is a subclass called when the project environment is running in VisualWorks.!!SReportTypeInfo commentStamp: '' prior: 0!SReportTypeInfo exports data about coverage and patterns frequency of projects in Smalltalk. It exports two kinds of reports:	1. Project's coverage covered in the genetic algorithm. It presents 	- Project -> Project name in Smalltalk.	- Classes -> Number of classes executed in the project.	- Methods -> Number of methods executed in the project.	- Test -> Number of tests that are evaluated in the project.	- Coverage -> Project coverage percent covered.	2. Patterns frequency of type method info. Each type method info is categorized according its receiver, arguments and return type. The report contains:	- Project name	- Number of all methods	- Number of type method infos categorized in each pattern.!!SSExecutionContext commentStamp: '' prior: 0!SSExecutionContext takes a snapshot of the SSTestRunner's instance context. It saves the tempNames of variables and values as dictionaryInstance Variables	values:		<Dictionary>!!SSTestShifter commentStamp: '' prior: 0!SSTestShifter is responsible for creating, mutating and validating statements. It is responsible to for creating different kind of statements: primitive, factory messages, messages, accessor messages.Genetic algorithm's evolution depends this class' increasing fitness. For this reason it is one of the main classes and essential for the project.Instance Variables	assertions:						<OrderedCollection>	fitness:							<Dictionary>	fitnessByClass:					<Dictionary>	maxNumberOfStatements:		<SmallInteger>	nextId:							<SmallInteger>	randomGenerator:				<SRandomGenerator>	statements:						<OrderedCollection>	targetClassesNames:			<Set>	typeInfo:							<STypeInfo>	validatedTargetClassName:	<Boolean>!!SSTestCase commentStamp: '' prior: 0!SSTestCase is a subclass that defines or initializes some instance variables which are util in the genetic algorithm evolution!!STestCaseFactory commentStamp: '' prior: 0!STestCaseFactory is an abstract class that represents the project facade. It contains the main methods to run the project!!STestCaseFactoryPharo commentStamp: '' prior: 0!STestCaseFactoryPharo is a subclass that it is called when the project runs in Pharo!!STestCaseFactoryVisualWorks commentStamp: '' prior: 0!STestCaseFactoryVisualWorks is a subclass that it is called when the project runs in VisualWorks!!STestCaseFactoryExample commentStamp: '' prior: 0!STestCaseFactoryExample contains some examples to run and validate the project functionality!!STypeInfo commentStamp: '' prior: 0!STypeInfo is responsible for collecting the STypeCollector's main data and building a new instance from the collected data.It is composed of STypeClassInfo collection and each item likewise is formed by STypeMethodInfo collection.Instance Variables	types:						<Dictionary>	All the classes (represented as an instance of STypeClassInfo) for which information is collected	classes:					<Dictionary>	noneAbstractClasses:	<Collection>	scalars: 					<Dictionary>	collection of classes that cannot be instrumented!!STypeObjectInfo commentStamp: '' prior: 0!STypeObjectInfo is an abstract class of info nodes: 			- type class -> Which collect type info data of a class in the profiler	- type method -> Collect types of the receiver, arguments and returnType of a method in the profiler!!SMultiTypeInfo commentStamp: '' prior: 0!SMultiTypeInfo is a set of types.Instance Variables	types:		<Set>!!STypeClassInfo commentStamp: '' prior: 0!STypeClassInfo is an info type node for a class.Instance Variables	classMethodTypes:	<Dictionary>	methodTypes:			<Dictionary>	typeName:				<Symbol>!!STypeMethodInfo commentStamp: '' prior: 0!STypeMethodInfo is an info type node for a method.Instance Variables	argTypes:			<Array>	isDeprecated:	<Boolean>	isQuick:			<Boolean>	receiver:			<SMultiTypeInfo>	returnType:		<SMultiTypeInfo>	selector:			<Symbol>!!SUndefinedObject commentStamp: '' prior: 0!I'm a generic class for returnType of methods unexecuted!!ManifestSmallSuiteGenerator commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!SError commentStamp: '' prior: 0!SError is a subclass of Error. It is used to represent error's conditions in test generation process.Additionally, it saves in a log all the errors gotten.!!SRandom commentStamp: '' prior: 0!SRandom is a subclass of Random that is responsible for select an item of the collection or collect items randomly in a collection!!Object methodsFor: '*SmallSuiteGenerator'!aVariableNodeClass	^ RBVariableNode! !!Object methodsFor: '*SmallSuiteGenerator'!mutateToChange	^ self! !!Object methodsFor: '*SmallSuiteGenerator'!smallStoreString	| string |	SPlatform initLevelToPrint.	string := String		streamContents: [ :s | 			self storeOn: s.			SPlatform levelToPrint < 0				ifTrue:					[ "^ s nextPutAll: '(' , self class name , ' new ) '" SError signal: 'error in storeString' ].			SPlatform initLevelToPrint ].	^ string! !!Object methodsFor: '*SmallSuiteGenerator' prior: 55093011!storeOn: aStream	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	SPlatform reduceLevel.	aStream nextPut: $(.	self class isVariable		ifTrue: [ aStream				nextPutAll: '(' , self class name , ' basicNew: ';				store: self basicSize;				nextPutAll: ') ' ]		ifFalse: [ aStream nextPutAll: self class name , ' basicNew' ].	SPlatform levelToPrint < 0		ifFalse: [ 1 to: self class instSize do: [ :i | 				aStream					nextPutAll: ' instVarAt: ';					store: i;					nextPutAll: ' put: ';					store: (self instVarAt: i);					nextPut: $; ].			1 to: self basicSize do: [ :i | 				aStream					nextPutAll: ' basicAt: ';					store: i;					nextPutAll: ' put: ';					store: (self basicAt: i);					nextPut: $; ] ].	aStream nextPutAll: ' yourself)'! !!SAbstractMessage class methodsFor: 'creation'!args: aMethodTypeInfo with: statements	| dict |	(statements isEmpty or: [ aMethodTypeInfo argTypes isNil ])		ifTrue: [ ^ #() ].	dict := Dictionary new.	(SPlatform randomGenerator collectAtRandom: statements)		do: [ :stm | dict at: stm returnType put: stm variable copy ].	^ aMethodTypeInfo argTypes		collect: [ :aTypeReturn | 			| ft |			ft := (SPlatform randomGenerator collectAtRandom: aTypeReturn types) "lack to update types of MultiTypeInfo"				detect: [ :type | dict at: type ifPresent: [ true ] ifAbsent: [ false ] ]				ifNone: [ nil ].			ft				ifNil: [ self						error:							'Cannot build the method call: ' , aMethodTypeInfo selector								, ', even it was tried to build the argument first' ].			dict at: ft ]! !!SAbstractMessage methodsFor: 'comparing'!= other	^ super = other 		and: [ args = other args 			and: [ receiver = other receiver 				and: [ (selector = other selector) ] ] ]! !!SAbstractMessage methodsFor: 'accessing'!args	^ args! !!SAbstractMessage methodsFor: 'accessing'!args: anObject	args := anObject! !!SAbstractMessage methodsFor: 'mutation'!changeArgsFrom: expression in: aTestCase	args isEmpty		ifTrue: [ ^ self error: 'Cannot change args from: ', self selector  ].	args do: [ :arg | arg repairOn: aTestCase changing: expression ]! !!SAbstractMessage methodsFor: 'mutation'!changeReceiverFrom: expression in: aTestCase	receiver repairOn: aTestCase changing: expression! !!SAbstractMessage methodsFor: 'override'!changeSelectorFrom: aExpression in: aTestCase	^ self subclassResponsibility! !!SAbstractMessage methodsFor: 'copying'!copy	| copy |	copy := super copy.	copy		args: args deepCopy;		receiver: receiver copy;		selector: selector copy.	^ copy! !!SAbstractMessage methodsFor: 'comparing'!hash  ^super hash bitXor: (receiver hash bitXor: (selector hash bitXor: args hash))! !!SAbstractMessage methodsFor: 'accessing'!id 	^ receiver id! !!SAbstractMessage methodsFor: 'initialization'!initialize	super initialize.	args := OrderedCollection new: 2! !!SAbstractMessage methodsFor: 'mutation'!insertRandomMessage: expression using: aTestCase	| anotherExpression |	anotherExpression := self copy.	anotherExpression mutated: true.	anotherExpression needsBeFixed: true.	^ aTestCase insertExpression: anotherExpression after: expression! !!SAbstractMessage methodsFor: 'accessing'!mutated 	^ mutated or: [receiver mutated or: [ args detect: #mutated ifFound: [ true ] ifNone: [ false ] ]]! !!SAbstractMessage methodsFor: 'mutation'!pickUpReferences: aExpression	^ (receiver pickUpReferences: aExpression)		, (args flatCollect: [ :arg | arg pickUpReferences: aExpression ])! !!SAbstractMessage methodsFor: 'printing'!printOn: aStream	receiver printOn: aStream.	aStream	nextPut: Character space.	self printSelectors: aStream! !!SAbstractMessage methodsFor: 'printing'!printSelectors: aStream	args		ifEmpty: [ aStream nextPutAll: self selector ]		ifNotEmpty: [ | withColon index stop |			withColon := self selector includes: $:.			index := 0.			stop := self args size.			(self selector substrings: ':')				with: self args				do: [ :selectorPart :arg | 					index := index + 1.					aStream nextPutAll: selectorPart.					withColon						ifTrue: [ aStream nextPutAll: ': ' ].					aStream nextPutAll: arg printString.					(index < stop and: [ withColon ])						ifTrue: [ aStream nextPut: Character space ] ] ]! !!SAbstractMessage methodsFor: 'accessing'!receiver	^ receiver! !!SAbstractMessage methodsFor: 'accessing'!receiver: anObject	receiver := anObject! !!SAbstractMessage methodsFor: 'mutation'!repairOn: aTestCase changing: expression	(self random collectAtRandom: #(#changeReceiverFrom:in: #changeSelectorFrom:in: #changeArgsFrom:in:))		do: [ :aSelector | 			[ ^ self				perform: aSelector				withArguments: (Array with: expression with: aTestCase) ]				on: SError				do: [  ] ].	self error: 'Cannot change the statement: ' , expression printString! !!SAbstractMessage methodsFor: 'mutation'!replaceArgBy: expression	args ifEmpty: [ self error: self printString, ' does not have args to replace.' ].		args do: [ :arg | [ ^ arg replaceArgBy: expression ] on: SError do: [  ] ].	self error: 'Cannot replace any argument by: ', expression printString! !!SAbstractMessage methodsFor: 'accessing'!replaceBy: anAbstractMessage	" I replace my attributes values with the ones in the otherExpression."		mutated := (receiver ~= anAbstractMessage receiver) or: [( selector ~= anAbstractMessage selector) or: [ args ~= anAbstractMessage args ]].	receiver replaceBy: anAbstractMessage receiver.	self selector: anAbstractMessage selector.	self args size = anAbstractMessage args size		ifTrue: [ self args				with: anAbstractMessage args				do: [ :arg :newArg | arg replaceBy: newArg ] ]		ifFalse: [ self args: anAbstractMessage args deepCopy ].! !!SAbstractMessage methodsFor: 'actions'!replaceExpression: anExpression by: newExpression	"It replace the references to this expresion to the newExpresion"	receiver replaceExpression: anExpression by: newExpression.	args do: [ :arg | arg replaceExpression: anExpression by: newExpression ]! !!SAbstractMessage methodsFor: 'accessing'!selector	^ selector! !!SAbstractMessage methodsFor: 'accessing'!selector: anObject	selector := anObject! !!SAbstractMessage methodsFor: 'mutation'!variablesWithId	^ receiver variablesWithId , (args flatCollect: [:arg | arg variablesWithId])! !!SAssertionMessage class methodsFor: 'instance creation'!for: aExecutionContext	^ self subclassResponsibility.! !!SAssertionMessage methodsFor: 'override'!changeSelectorFrom: aExpression in: aTestCase	"not sure what it should return"! !!SAssertionMessage methodsFor: 'initialization'!initialize	super initialize.	receiver := SSelf new.	 ! !!SAssertionMessage methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $.! !!SComparisonAssertion class methodsFor: 'instance creation'!comparisonAssertion: anExecutionContext with: array			| varName1 varName2 val1 val2 |			varName1 := array first.			varName2 := array second.			val1 := anExecutionContext at: varName1.			val2 := anExecutionContext at: varName2.			val1 class = val2 class				ifTrue: [ (val1 class allSelectorsBelow: Object)						detect: [ :selector | selector = #= ]						ifFound: [ | selector |							selector := val1 = val2								ifTrue: [ #assert:equals: ]								ifFalse: [ #deny:equals: ].							^ self new										selector: selector;										args:											(Array												with: (SVariable nameOrId: varName1)												with: (SVariable nameOrId: varName2));										yourself ]							 ].						^ nil! !!SComparisonAssertion class methodsFor: 'instance creation'!for: anExecutionContext	| assertions |	assertions := OrderedCollection new.	anExecutionContext keys asOrderedCollection		combinations: 2		atATimeDo: [ :comb | 			| compareAssert |			compareAssert := self				comparisonAssertion: anExecutionContext				with: comb.			compareAssert				ifNotNil: [ assertions add: compareAssert			 ] ].	^ assertions! !!SInspectorAssertion class methodsFor: 'instance creation'!for: anExecutionContext	^ anExecutionContext associations		flatCollect: [ :assoc | self inspectorAssertionOf: assoc ]! !!SInspectorAssertion class methodsFor: 'instance creation'!inspectorAssertionOf: assoc	^ (assoc value class methods select: #isReturnField)		collect:			[ :compiledMethod | 			self inspectorAssertionOf: assoc and: compiledMethod ]		thenSelect: [ :assertion | 			assertion isNotNil			 ]! !!SInspectorAssertion class methodsFor: 'instance creation'!inspectorAssertionOf: assoc and: compiledMethod	|result|	result := assoc value perform: compiledMethod selector.	^ (self isPrimitive: result)		ifFalse: [ nil ]		ifTrue: [ self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable nameOrId: assoc key);								selector: compiledMethod selector;								yourself)						with: (SLiteral new value: result));				yourself ]! !!SPrimitiveAssertion class methodsFor: 'instance creation'!for: anExecutionContext	^ anExecutionContext associations		select: [ :assoc | self isPrimitive: assoc value ]		thenCollect: [ :assoc | 			self new				selector: #assert:equals:;				args:					(Array						with: (SVariable nameOrId: assoc key)						with: (SLiteral new value: assoc value));				yourself ]! !!SStringAssertion class methodsFor: 'instance creation'!for: anExecutionContext	^ (anExecutionContext associations		reject: [ :assoc | self isPrimitive: assoc value ])		collect: [ :assoc | self stringAssertionsOf: assoc ]		thenSelect: [ :stringAssertion | stringAssertion isNil not ]! !!SStringAssertion class methodsFor: 'instance creation'!stringAssertionsOf: assoc	| aValue |	aValue := assoc value.	^ (aValue class allSelectorsBelow: Object)		detect: [ :aSelector | aSelector = #printOn: or: [ aSelector = #asString ] ]		ifFound: [ | fieldValue |			[ fieldValue := aValue perform: #printString.			self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable nameOrId: assoc key);								selector: #printString;								yourself)						with: (SLiteral new value: fieldValue));				yourself ]				on: Error				do: [ Transcript						show: aValue class name , ' cant answer printString without error' ] ]		ifNone: [ nil ]! !!SFactoryMessage class methodsFor: 'accessing'!default: aClassName	^ self new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName;				yourself);		selector: #new;		returnType: aClassName;		yourself! !!SFactoryMessage class methodsFor: 'creation'!method: aMethodTypeInfo class: aClassName previousStatements: statements	^ self new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName ;				yourself);		returnType: aClassName;		selector: aMethodTypeInfo selector;		args: (self args: aMethodTypeInfo with: statements);		yourself! !!SFactoryMessage class methodsFor: 'creation'!method: aMethodTypeInfo previousStatements: statements	|returnType|	returnType := aMethodTypeInfo returnType type.	^ self new		receiver:			(SVariable new				varName: returnType ;				returnType: returnType ;				yourself);		returnType: returnType;		selector: aMethodTypeInfo selector;		args: (self args: aMethodTypeInfo with: statements);		yourself! !!SFactoryMessage methodsFor: 'override'!changeSelectorFrom: aExpression in: aTestCase	| otherFactoryMessage |	otherFactoryMessage := aTestCase		alternativeFactoryMessage: self		before: aExpression.	mutated := otherFactoryMessage selector ~= self selector.	self selector: otherFactoryMessage selector.	self args: otherFactoryMessage args! !!SFactoryMessage methodsFor: 'mutation'!insertOn: aTestCase	[^ aTestCase		addFactoryMessage: self returnType		ofSelector: self selector] on: SError do: [  ]! !!SFactoryMessage methodsFor: 'testing'!isFactoryMessage	^ true! !!SFactoryMessage methodsFor: 'accessing'!referenceTo: aClassName	^ receiver referenceTo: aClassName! !!SFieldAccessMessage class methodsFor: 'instance creation'!newFromReceiver: aReceiver andMethod: aMethod	^ SFieldAccessMessage new		returnType: aMethod returnType type;		selector: aMethod selector;		receiver: aReceiver;		needsBeFixed: ((aMethod returnType types size > 1) or: [ aMethod hasProfiler not ]);		yourself ! !!SFieldAccessMessage methodsFor: 'override'!changeSelectorFrom: expression in: aTestCase	| otherFieldAccessMessage |	otherFieldAccessMessage := aTestCase		alternativeFieldAccessMessage: self.	mutated := otherFieldAccessMessage selector ~= self selector.	self selector: otherFieldAccessMessage selector! !!SFieldAccessMessage methodsFor: 'fixing'!fixWith: anObject in: aTestCase	(anObject receiver types includes: receiver returnType) ifFalse: [ self halt ].	returnType := self random selectAtRandom: anObject returnType types.	needsBeFixed := false.! !!SFieldAccessMessage methodsFor: 'mutation'!insertOn: aTestCase	[^ aTestCase addFieldAccessMessage: self selector from: self receiver returnType] on: SError do: [  ]! !!SFieldAccessMessage methodsFor: 'actions'!replaceArg: expressions by: newExpressions! !!SMessage class methodsFor: 'instance creation'!newFromReceiver: aReceiver method: aMethod andPreviousStatements: statements	^ SMessage new		returnType: (aMethod returnTypeFor: aReceiver);		selector: aMethod selector;		receiver: aReceiver;		args: (self args: aMethod with: statements);		needsBeFixed: ((aMethod returnType types size > 1) or: [ aMethod hasProfiler not ]);		yourself! !!SMessage methodsFor: 'override'!changeSelectorFrom: aExpression in: aTestCase	| otherMessage |	otherMessage := aTestCase		alternativeMessage: self		before: aExpression.	mutated := otherMessage selector ~= self selector.	self selector: otherMessage selector.	self args: otherMessage args! !!SMessage methodsFor: 'fixing'!fixWith: anObject in: aTestCase	(anObject receiver types includes: receiver returnType) ifFalse: [ self halt ].	returnType := self random selectAtRandom: anObject returnType types.	anObject argTypes with: args do: [ :arg1 :arg2 | 		(arg1 types includes: arg2 returnType) ifFalse: [ self halt. ]		 ].	needsBeFixed := false.! !!SMessage methodsFor: 'mutation'!insertMethodMessage: aExpression using: aTestCase	^ self insertRandomMessage: aExpression using: aTestCase! !!SMessage methodsFor: 'mutation'!insertOn: aTestCase	[^ aTestCase addMessage: self selector from: self receiver returnType] on: SError do: [  ]! !!SAssignment class methodsFor: 'instance creation'!name: aVariable value: anExpression	^ self new		variable:  aVariable;		value: anExpression;		returnType: anExpression returnType;		needsBeFixed: anExpression needsBeFixed;		yourself! !!SAssignment methodsFor: 'comparing'!= other	^ (super = other) 		and: [ (variable = other variable) 			and: [ (value = other value) ] ]! !!SAssignment methodsFor: 'copying'!copy 	|copy|	copy := super copy.	copy variable: variable copy;	value: value copy.	^ copy! !!SAssignment methodsFor: 'fixing'!fixWith: anObject in: aTestCase	value fixWith: anObject in: aTestCase.	returnType := value returnType.	variable returnType: value returnType.	needsBeFixed := value needsBeFixed ! !!SAssignment methodsFor: 'comparing'!hash	^ super hash bitXor: (variable hash bitXor: value hash)! !!SAssignment methodsFor: 'accessing'!id 			^ variable id! !!SAssignment methodsFor: 'initialization'!initialize 		super initialize.! !!SAssignment methodsFor: 'mutation'!insertAsParameter: aExpression using: aTestCase	^ variable insertAsParameter: aExpression using: aTestCase! !!SAssignment methodsFor: 'mutation'!insertMethodMessage: aExpression using: aTestCase	^ value insertMethodMessage: aExpression using: aTestCase! !!SAssignment methodsFor: 'mutation'!insertOn: aTestCase	^ value insertOn: aTestCase! !!SAssignment methodsFor: 'mutation'!insertRandomMessage: aExpression using: aTestCase	^ value insertRandomMessage:aExpression using: aTestCase! !!SAssignment methodsFor: 'accessing'!mutated 	^ value mutated! !!SAssignment methodsFor: 'accessing'!needsBeFixed: aBoolean	super needsBeFixed: aBoolean.	value ifNotNil: [ value needsBeFixed: aBoolean ]! !!SAssignment methodsFor: 'mutation'!pickUpReferences: aExpression	^ value pickUpReferences: aExpression! !!SAssignment methodsFor: 'printing'!printOn: aStream	SPlatform asDict 		ifFalse: [			variable printOn: aStream.			aStream nextPutAll: ' := '.			value printOn: aStream.			aStream nextPut:$.]		ifTrue: [			aStream nextPutAll: 'var at: '.			aStream nextPutAll: (variable id + 1) printString.			aStream nextPutAll: ' put: ('.			value printOn: aStream.			aStream nextPutAll:' ).']! !!SAssignment methodsFor: 'accessing'!reference 	^ variable! !!SAssignment methodsFor: 'accessing'!referenceTo: aClassName	^ value referenceTo: aClassName! !!SAssignment methodsFor: 'mutation'!repairOn: aTestCase changing: expression	self reference = expression reference		ifTrue: [ value repairOn: aTestCase changing: expression ]! !!SAssignment methodsFor: 'mutation'!replaceArgBy: expression	value replaceArgBy: expression! !!SAssignment methodsFor: 'accessing'!replaceBy: aExpression	" If I am the expresion to be replace it.	I replace my attributes values with the ones in the otherExpression."	self reference = aExpression reference ifTrue: [ value replaceBy: aExpression value ]! !!SAssignment methodsFor: 'actions'!replaceExpression: expression by: newExpression	"It replace the references to this expresion to the newExpresion"	value replaceExpression: expression by: newExpression! !!SAssignment methodsFor: 'evaluating'!value 	^ value! !!SAssignment methodsFor: 'accessing'!value: anObject	value := anObject! !!SAssignment methodsFor: 'accessing'!variable	^ variable! !!SAssignment methodsFor: 'accessing'!variable: anObject	variable := anObject! !!SAssignment methodsFor: 'mutation'!variablesWithId	^ variable variablesWithId, value variablesWithId! !!SExpression class methodsFor: 'error handling'!error: string		^ SError signal: string ! !!SExpression class methodsFor: 'instance creation'!isPrimitive: anObject	^ self new isPrimitive: anObject.! !!SExpression class methodsFor: 'as yet unclassified'!nextIdentifier	nextId ifNil: [ nextId := 0 ].		^ nextId := nextId + 1! !!SExpression class methodsFor: 'initialization'!resetId	nextId := nil! !!SExpression methodsFor: 'comparing'!= another	"I return true if all my attributes are equals than the another"	^ (self class = another class) 		and: [ (self id = another id) 			and: [ returnType = another returnType ] ]	! !!SExpression methodsFor: 'accesing'!allParents	"I return my self with all my parents"	^ parent ifNil: #() ifNotNil: [ 		Set new add: parent;	 	addAll: parent allParents; 		yourself ]! !!SExpression methodsFor: 'copying'!copy	^ self class new		id: self id;		returnType: self returnType;		mutated: self mutated;		needsBeFixed: self needsBeFixed;		parent: self         ! !!SExpression methodsFor: 'error handling'!error: aString	"It throws an error signal with the string passed as argument, it is important to distinguish parsing error with others"	^ SError signal: aString! !!SExpression methodsFor: 'fixing'!fixWith: anObject in: aTestCase! !!SExpression methodsFor: 'comparing'!hash	^ self id hash bitXor: self returnType hash! !!SExpression methodsFor: 'accessing'!id	^ id! !!SExpression methodsFor: 'accessing'!id: anObject	id := anObject! !!SExpression methodsFor: 'initialization'!initialize	super initialize .	mutated := false.	identifier := self class nextIdentifier.	needsBeFixed := false! !!SExpression methodsFor: 'mutation'!insertAsParameter: aExpression using: aTestCase		^ aTestCase insertAsParameter: self copy after: aExpression! !!SExpression methodsFor: 'mutation'!insertMethodMessage: expression using: aTestCase	self error: 'cannot be inserted the methodMessage: ', expression printString! !!SExpression methodsFor: 'mutation'!insertOn: aTestCase	! !!SExpression methodsFor: 'mutation'!insertRandomMessage: expression using: aTestCase	self error: 'cannot be inserted the randomMessage: ', expression printString! !!SExpression methodsFor: 'testing'!isFactoryMessage	^ false! !!SExpression methodsFor: 'comparing'!isPrimitive: anObject	^ (anObject isKindOf: Number) or: [ (anObject isKindOf: Boolean)		or: [ anObject isKindOf: String ]]! !!SExpression methodsFor: 'accessing'!mutated 	^ mutated! !!SExpression methodsFor: 'accessing'!mutated: aBoolean	mutated := aBoolean! !!SExpression methodsFor: 'accessing'!needsBeFixed	^ needsBeFixed! !!SExpression methodsFor: 'accessing'!needsBeFixed: aBoolean	needsBeFixed := aBoolean ! !!SExpression methodsFor: 'accessing'!parent	^ parent! !!SExpression methodsFor: 'accessing'!parent: anObject	parent := anObject! !!SExpression methodsFor: 'mutation'!pickUpReferences: aExpression	^ #()! !!SExpression methodsFor: 'accessing'!reference	^ self! !!SExpression methodsFor: 'accessing'!referenceTo: aClassName	^ false! !!SExpression methodsFor: 'mutation'!repairOn: aTestCase changing: aExpression	! !!SExpression methodsFor: 'mutation'!replaceArgBy: expression	self error: 'cannot be inserted: ', expression printString, ' as parameter'! !!SExpression methodsFor: 'actions'!replaceBy: otherExpression	self subclassResponsibility ! !!SExpression methodsFor: 'actions'!replaceExpression: expression by: newExpression	"It replace the references to this expresion to the newExpresion"! !!SExpression methodsFor: 'accessing'!returnType	^ returnType! !!SExpression methodsFor: 'accessing'!returnType: anObject	returnType := anObject! !!SExpression methodsFor: 'mutation'!variablesWithId	^ #()! !!SLiteral class methodsFor: 'parsing'!value: aValue	^ self new value: aValue; yourself.! !!SLiteral methodsFor: 'comparing'!= other	^ super = other		and: [ (value isLiteral ifTrue: [ value = other value ] 			ifFalse: [ 			value isClass				ifTrue: [ value name = other value name ]				ifFalse: [ value className = other value className ]]) ]! !!SLiteral methodsFor: 'copying'!copy 	| copy|	copy := super copy.	copy value: value copy.	^ copy! !!SLiteral methodsFor: 'comparing'!hash	^ super hash bitXor: value hash! !!SLiteral methodsFor: 'mutation'!insertOn: aTestCase	[^ aTestCase addLiteral: self returnType] on: SError do: [  ]! !!SLiteral methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll:			((value isNumber or: [ value isBlock ])				ifTrue: [ value printString ]				ifFalse: [ value storeString ])! !!SLiteral methodsFor: 'actions'!referenceTo: aClassName	^( value isClass		ifTrue: [ value name ]		ifFalse: [ value className ]) = aClassName asString! !!SLiteral methodsFor: 'mutation'!repairOn: aTestCase changing: aExpression	self value: value mutateToChange! !!SLiteral methodsFor: 'actions'!replaceBy: otherExpression	" I replace my attributes values with the ones in the otherExpression.	  the argument is an object from my same class"	self value: otherExpression value! !!SLiteral methodsFor: 'evaluating'!value 		^ value! !!SLiteral methodsFor: 'accessing'!value: anObject	value := anObject.! !!SSelf methodsFor: 'initialization'!initialize	super initialize.	varName := 'self'.! !!SVariable class methodsFor: 'accessing'!name: aString	| variable |	variable := self new.	variable varName: aString.	^ variable! !!SVariable class methodsFor: 'accessing'!nameOrId: anObject	| variable |	variable := self new.	anObject isString 		ifTrue: [ variable varName: anObject ]		ifFalse: [ variable id: (anObject - 1) ].	^ variable! !!SVariable methodsFor: 'comparing'!= other	^ super = other and: [ varName = other varName ]! !!SVariable methodsFor: 'copying'!copy	| copy |	copy := super copy.	copy		varName: varName copy.	^ copy! !!SVariable methodsFor: 'comparing'!hash	^ super hash bitXor: varName  hash! !!SVariable methodsFor: 'initialization'!initialize	super initialize.	varName := '_var'! !!SVariable methodsFor: 'accessing'!key	SPlatform asDict ifTrue: [ ^ id + 1 ] ifFalse: [ ^ self printString asSymbol ]! !!SVariable methodsFor: 'mutation'!pickUpReferences: anExpression	^ self = anExpression reference		ifFalse: [ #() ]		ifTrue: [ (Array with: self) ]! !!SVariable methodsFor: 'printing'!printOn: aStream	SPlatform asDict 		ifFalse: [			aStream nextPutAll: varName.			id ifNotNil: [ aStream nextPutAll: id printString ]]		ifTrue: [			id ifNil: [ aStream nextPutAll: varName. ]			ifNotNil: [ 				aStream nextPutAll: '( var at: '.				aStream nextPutAll: (id+1) printString.				aStream nextPutAll: ' )' ].			]! !!SVariable methodsFor: 'accessing'!referenceTo: aClassName	^ self returnType = aClassName! !!SVariable methodsFor: 'mutation'!repairOn: aTestCase changing: anExpression	| otherVariable |	otherVariable := aTestCase		alternativeOfVariable: self		before: anExpression.	mutated := otherVariable ~= self.	self varName: otherVariable varName.	self id: otherVariable id.! !!SVariable methodsFor: 'mutation'!replaceArgBy: expression	returnType = expression returnType		ifFalse: [ ^ self				error:					'Cannot replace argument of type: ' , returnType , ' by: '						, expression returnType ].	self replaceBy: expression! !!SVariable methodsFor: 'accessing'!replaceBy: otherVariable	" I replace my attributes values with the ones in the otherExpression.	  the argument is an object from my same class"	self varName: otherVariable varName.	self id: otherVariable id.	self returnType: otherVariable returnType! !!SVariable methodsFor: 'actions'!replaceExpression: anExpression by: newExpression	"If I am referencing to anExprension. I will now reference to the newExpresion"		| reference |	self = anExpression		ifFalse: [ ^ self ].	reference := newExpression reference.	self		id: reference id;		varName: reference varName;		returnType: reference returnType;		mutated: true! !!SVariable methodsFor: 'accessing'!varName	^ varName! !!SVariable methodsFor: 'accessing'!varName: anObject	varName := anObject! !!SVariable methodsFor: 'mutation'!variablesWithId	^ id ifNotNil: [ (Array with: self) ] ifNil: [ super variablesWithId ]! !!SFitnessFunction methodsFor: 'actions'!compute: testCaseCollection	^ self subclassResponsibility.! !!SFitnessFunction methodsFor: 'accessing'!tagetPackagesRegex	^ tagetPackagesRegex! !!SFitnessFunction methodsFor: 'accessing'!tagetPackagesRegex: anObject	tagetPackagesRegex := anObject! !!SFitnessFunction methodsFor: 'accessing'!targetClass: anObject	targetClass := anObject! !!SMultiFitnessFunction methodsFor: 'accessing'!add: aFitness weight: aFloat	fitness at: aFitness put: aFloat.! !!SMultiFitnessFunction methodsFor: 'actions'!compute: aTestCase	"^ fitness associations inject: 0 into:[:assoc :acum |  				acum +  ((assoc first compute: aTestCase)* (assoc second))s]."! !!SMultiFitnessFunction methodsFor: 'initialization'!initialize 	super initialize.	fitness := Dictionary new.! !!SMethodCoverage methodsFor: 'actions'!fitnessOf: testCase withKey: string	testCase fitness at:string put: profiler methodCoverage.	testCase fitnessByClass at: string put: profiler methodCoverage1! !!SMethodCoverage methodsFor: 'accesing'!functionName	^ 'method-coverage'! !!SMethodCoverage methodsFor: 'actions'!setUp! !!SMethodCoverage methodsFor: 'actions'!tearDown	! !!SSimpleFitnessFunction methodsFor: 'actions'!compute: testCaseCollection	self setUp.	self run: testCaseCollection.	self tearDown.! !!SSimpleFitnessFunction methodsFor: 'actions'!fitnessOf: testCase withKey: string	self subclassResponsibility ! !!SSimpleFitnessFunction methodsFor: 'accesing'!functionName	^ self subclassResponsibility! !!SSimpleFitnessFunction methodsFor: 'accesing'!profiler	^ profiler ! !!SSimpleFitnessFunction methodsFor: 'accesing'!profiler: aProfiler	profiler := aProfiler.! !!SSimpleFitnessFunction methodsFor: 'actions'!run: testCaseCollection	| string |	string := self functionName.	testCaseCollection		do: [ :testCase | 			testCase length > 0 ifTrue: [				profiler cleanBlocksOfMethods.				testCase runWithoutAssertions.				testCase summaryExecutionMethods: profiler summaryExecutionMethods.				"self abstractDataOn: testCase."				self fitnessOf: testCase withKey: string. ]			ifFalse: [ testCase fitness at: string put: 0 ] ]	! !!SSimpleFitnessFunction methodsFor: 'actions'!runPopulation: testCaseCollection	profiler cleanBlocksOfMethods.	testCaseCollection		do: [ :testCase | 			testCase length > 0 ifTrue: [ testCase runWithoutAssertions ] ].	^ profiler summaryMethodsOf: targetClass  ! !!SSimpleFitnessFunction methodsFor: 'actions'!setUp! !!SSimpleFitnessFunction methodsFor: 'actions'!tearDown! !!SSimpleFitnessFunction methodsFor: 'accessing'!typeInfo: anObject 	profiler typeInfo: anObject! !!SStatementCoverage methodsFor: 'actions'!computeFitness	^ profiler statementCoverage! !!SStatementCoverage methodsFor: 'actions'!fitnessOf: testCase withKey: string	testCase fitness at: string put: (profiler statementCoverageFor: targetClass ).	testCase fitnessByClass at: string put: profiler statementCoverage1! !!SStatementCoverage methodsFor: 'accesing'!functionName	^ 'block-coverage'! !!SStatementCoverage methodsFor: 'actions'!setUp	! !!SStatementCoverage methodsFor: 'actions'!tearDown	! !!SGAEngineExample methodsFor: 'examples - onClass'!exampleSSTeacherOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) >= 20.	"20 = (1/5) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 80.	"80 = (4/5) * 100"	engine clean! !!SGAEngineExample methodsFor: 'examples - onClass'!exampleSSTeacherOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) >= 37.5.	"37.5 = (3/8) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) >= 87.5.	"87.5 = (7/8) * 100"	engine clean! !!SGAEngineExample methodsFor: 'examples - onPackages'!exampleSSTeacherOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				<=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean! !!SGAEngineExample methodsFor: 'examples - onPackages'!exampleSSTeacherOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				<=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean! !!SGAEngineExample methodsFor: 'examples - onClass'!exampleSStackOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack				newStackWith:				#(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) >= 14.28.	"14.28 = (1/7) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) >= 57.14.	"57.14 = (4/7) * 100 round: 2"	engine clean! !!SGAEngineExample methodsFor: 'examples - onClass'!exampleSStackOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack newStackWith: #(2  4  6  1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) >= 21.05.	"21.05 = (4/19) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) >= 73.68.	"73.68 = (14/19) * 100 round: 2"	engine clean! !!SGAEngineExample methodsFor: 'examples - onPackages'!exampleSStackOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				<=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean! !!SGAEngineExample methodsFor: 'examples - onPackages'!exampleSStackOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				<=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean! !!SGAEngineExample methodsFor: 'examples - onClass'!exampleSStudentOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) >= 20.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean! !!SGAEngineExample methodsFor: 'examples - onClass'!exampleSStudentOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) >= 37.5.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean! !!SGAEngineExample methodsFor: 'examples - onPackages'!exampleSStudentOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				<=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean! !!SGAEngineExample methodsFor: 'examples - onPackages'!exampleSStudentOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				<=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean! !!SGAEngineExample methodsFor: 'actions'!runOnClass: aClass withBlock: aBlock andFitness: aClassFitness	| engine |	engine := SGAEngine new.	engine		populationSize: 30;		numberOfStatements: 15;		blockToExecute: aBlock;		targetClassName: aClass name.	engine		typeInfo:			(STypeInfo				asTypeInfo: (SSTypeCollector profile: engine blockToExecute forClassNamed: aClass name));		fitness: aClassFitness;		targetClassName: aClass name;		numberOfGenerations: 15;		run.	^ engine! !!SGAEngineExample methodsFor: 'actions'!runOnPackagesMatching: regex withBlock: aBlock andFitness: aClassFitness	| engine |	engine := SGAEngine new.	engine		populationSize: 30;		numberOfStatements: 15;		blockToExecute: aBlock.	engine		typeInfo:			(STypeInfo asTypeInfo: (SSTypeCollector				profile: engine blockToExecute				onPackagesMatching: regex));		fitness: aClassFitness;		numberOfGenerations: 15;		run.	^ engine! !!SGALog class methodsFor: 'as yet unclassified'!collectFitnessByNameOf: population	| dictFit |	dictFit := Dictionary new.	((population collect: #fitness) flatCollect: #associations) do: [ 		:assoc | 		| aValue |		aValue := dictFit at: assoc key ifAbsentPut: [ OrderedCollection new].		aValue add: assoc value].	^ dictFit! !!SGALog class methodsFor: 'as yet unclassified'!logOf: aSGAEngine inGeneration: anInteger inTime: t	| log dictFitness |	log := self new 		generationNumber: anInteger;		fittestTestCase: aSGAEngine population first;		timeToProduceGeneration: Time new asSeconds - t;		population: aSGAEngine population.	dictFitness := self collectFitnessByNameOf: aSGAEngine population.	log lowestFit: aSGAEngine population last fitness;	averageFit: (self pickAverageFitTest: dictFitness). 	log summaryTargetClass: (aSGAEngine fitness runPopulation: aSGAEngine population).	log typeInfoGeneration: (aSGAEngine typeInfo classAt: aSGAEngine targetClassName) deepCopy.	^ log! !!SGALog class methodsFor: 'as yet unclassified'!pickAverageFitTest: aDictionary	^ (aDictionary keys collect: [ :key | 		   key -> (aDictionary at: key) average ]) asDictionary! !!SGALog methodsFor: 'accessing'!averageFit	^ averageFit ! !!SGALog methodsFor: 'accessing'!averageFit: aNumber	averageFit := aNumber! !!SGALog methodsFor: 'accessing'!averageTestSize	^ (self population collect: [ :x |  x statements size ]) average asFloat! !!SGALog methodsFor: 'initialization'!exportDataCSV: neoCSVWriter withFilter: aSymbol	(self filteredMethodsBy: aSymbol) doWithIndex: [ :each :i |		each writeDataCSV: neoCSVWriter withIndex: i ]  ! !!SGALog methodsFor: 'initialization'!filteredMethodsBy: aSymbol	^ ((self selectorsFilter includes: aSymbol)		ifTrue: [ self summaryTargetClass select: aSymbol ]		ifFalse: [ self summaryTargetClass ]) select: #isNotNil! !!SGALog methodsFor: 'accessing'!fitness 		^ fittestTestCase fitness	! !!SGALog methodsFor: 'accessing'!fittestTestCase	^ fittestTestCase! !!SGALog methodsFor: 'accessing'!fittestTestCase: anTestCase	fittestTestCase := anTestCase! !!SGALog methodsFor: 'accessing'!generationNumber	^ generationNumber! !!SGALog methodsFor: 'accessing'!generationNumber: anObject	generationNumber := anObject! !!SGALog methodsFor: 'initialization'!initialize 		mutationResult := Dictionary new! !!SGALog methodsFor: 'accessing'!lowestFit	^ lowestFit! !!SGALog methodsFor: 'accessing'!lowestFit: aNumber	lowestFit := aNumber! !!SGALog methodsFor: 'accessing'!mutationResult: mutationTestingResult	self		assert: mutationResult isEmpty		description: 'The analysis of mutants has already been calculated'.	[ mutationResult		at: 'noEvaluatedMutants'			put: mutationTestingResult numberOfEvaluatedMutants;		at: 'noKilledOrTerminatedMutants'			put: mutationTestingResult numberOfKilledOrTerminatedMutants;		at: 'noAliveMutants'			put: mutationTestingResult numberOfAliveMutants;		at: 'mutationScore' put: mutationTestingResult mutationScore ]		on: Exception		do: [ nil ]! !!SGALog methodsFor: 'accessing'!percentageOftestCasesWithErrors	^((population select: [ :e | e hasErrors ]) size / population size) asFloat! !!SGALog methodsFor: 'accessing'!population	^ population! !!SGALog methodsFor: 'accessing'!population: anObject	population := anObject! !!SGALog methodsFor: 'printing'!printOn: str	super printOn: str.	str		nextPut: $<;		nextPutAll: fittestTestCase statements printString;		nextPut: $>! !!SGALog methodsFor: 'initialization'!selectorsFilter	^ #( #executed #unexecuted #notAllBlocksExecuted #allBlocksExecuted)! !!SGALog methodsFor: 'accessing'!summaryTargetClass	^ summaryTargetClass! !!SGALog methodsFor: 'accessing'!summaryTargetClass: anObject	summaryTargetClass := anObject! !!SGALog methodsFor: 'accessing'!timeToProduceGeneration: anInteger	timeToProduceGeneration := anInteger! !!SGALog methodsFor: 'accessing'!typeInfoGeneration	^ typeInfoGeneration! !!SGALog methodsFor: 'accessing'!typeInfoGeneration: anObject	typeInfoGeneration := anObject! !!SGAEngine methodsFor: 'testing'!checkFitness	self		assert: [ fitness notNil ]		description: 'Need to set a fitnessBlock'! !!SGAEngine methodsFor: 'testing'!checkIfReadyToRun	self checkTypeInfo.	self checkFitness.	self checkLogs! !!SGAEngine methodsFor: 'testing'!checkLogs	self assert: [ logs isEmpty ] description: 'Already been run'! !!SGAEngine methodsFor: 'testing'!checkTypeInfo	self		assert: [ typeInfo notNil ]		description: 'Set a typeInfo'! !!SGAEngine methodsFor: 'cleaning'!clean	fitness ifNotNil: [ fitness tearDown ]! !!SGAEngine methodsFor: 'actions'!computeFitness	fitness compute: population.! !!SGAEngine methodsFor: 'creating'!createNewPopulation	| newPopulation currentPopulationSize lastLowestFitness options newNumber |	lastLowestFitness := logs last lowestFit at: fitness functionName.	currentPopulationSize := initialPopulation size.   newPopulation := self eliteOfCurrentPopulation.	newNumber := newPopulation size.  	[ newPopulation size < currentPopulationSize ] whileTrue: [ | selectedList P1copy P2copy P1 P2 O1 O2 OM1 OM2 selectedOptions children |		  selectedList := selectionStrategy selectOf: initialPopulation.   		  P1 := selectedList first.        P2 := selectedList second.		  P1copy := self similarChild: P1 with: newNumber + 1.		  P2copy := self similarChild: P2 with: newNumber + 2.        self shouldCrossOver 				ifTrue: [ children := crossoverOperator crossover: P1 with: P2.              O1 := self updateHierarchyData: (Array with: P1 with: P2) of: (children first idPopulation: newNumber + 3).              O2 := self updateHierarchyData: (Array with: P1 with: P2) of: (children second idPopulation: newNumber + 4) ] 				ifFalse: [ 					O1 := (P1copy deepCopy) idPopulation: newNumber + 3; addParent: P1.              	O2 := (P2copy deepCopy) idPopulation: newNumber + 4; addParent: P2 ].        OM1 := self mutateAndUpdate: O1.        OM2 := self mutateAndUpdate: O2.        fitness compute: (Array with: OM1 with: OM2).		  options := Array with: OM1 with: OM2 with: P1copy with: P2copy.        selectedOptions := (self selectTwoBestOf: options excludingAll: newPopulation) select: [ :option | (option fitness at: fitness functionName) >= lastLowestFitness ].		  selectedOptions := selectedOptions first: (selectedOptions size min: currentPopulationSize - newPopulation size).		  options reject: [ :opt | selectedOptions includes: opt ] 				thenDo: [ :opt | P1 removeChild: opt.					P2 removeChild: opt ].			newPopulation addAll: (selectedOptions collect: [:option | 				newNumber := newNumber +1.				option idPopulation: newNumber ]) ].   self updateTypeInfoWith: newPopulation.   self fixPopulation: newPopulation.   population := newPopulation.   population := self order: population! !!SGAEngine methodsFor: 'creating'!createRandomPopulation  ^ (1 to: populationSize) collect: [:idPop |  | value test |        value := self next * numberOfStatements + 1.        test := SSTestCase with: typeInfo.        test           addTargetClassName: targetClassName;           addFactoryMessage: targetClassName;           generateStatements: value;           lastMessage: lastMessage;           idPopulation: idPop;			  clean.		  selectionStrategyTestCase ifNotNil: [ test selectionStrategy: selectionStrategyTestCase ].        test ]! !!SGAEngine methodsFor: 'accessing'!crossoverOperator: aCrossoverOperator	crossoverOperator := aCrossoverOperator! !!SGAEngine methodsFor: 'rating'!crossoverRate	^ crossoverRate! !!SGAEngine methodsFor: 'rating'!crossoverRate: aNumber	selectionStrategy crossoverRate: aNumber! !!SGAEngine methodsFor: 'actions'!doSelection	self createNewPopulation.	initialPopulation := population.! !!SGAEngine methodsFor: 'actions'!eliteOfCurrentPopulation	| endIndex index popSize |	popSize := population size.	endIndex := ((popSize * elitismRate * 0.01) round: 0) asInteger.	(popSize > 0 and: [ endIndex == 0 ]) ifTrue: [ endIndex := 1 ].	index := 0.	endIndex >= 1 ifTrue: [ ^ (((population copyFrom: 1 to: endIndex) collect: [:testCase |			index := index + 1.			self similarChild: testCase with: index.			])) asOrderedCollection ].	^ OrderedCollection new! !!SGAEngine methodsFor: 'rating'!elitismRate: aNumber	elitismRate := aNumber! !!SGAEngine methodsFor: 'accessing'!fitness	^ fitness! !!SGAEngine methodsFor: 'accessing'!fitness: aFitness	fitness := aFitness.	selectionStrategy fitness: aFitness! !!SGAEngine methodsFor: 'updating'!fixPopulation: aCollection 	| targetClassMessages |	targetClassMessages := (typeInfo types at: targetClassName) methodTypes values asOrderedCollection 		removeAllSuchThat: [:method | method returnType mustBeFixed not ].	 	aCollection do: [ :testCase | 		testCase statements select: [ :stm | [(targetClassMessages collect: #selector) includes: stm value selector]			on: Error do: [ false ] ] thenDo: [ :stm | testCase fixTypeReturnOf: (stm needsBeFixed: true) ] ]! !!SGAEngine methodsFor: 'initialization'!initialize  super initialize.  logs := OrderedCollection new.  populationSize := 30.  numberOfGenerations := 100.  selectionStrategy := SGARandomSelection new.  crossoverRate := 0.8.  elitismRate := 0.1.  numberOfStatements := 10.  stopIterations := 30.	totalExecutionGA := 0.  self initializeMutationOperator.  self initializeCrossoverOperator! !!SGAEngine methodsFor: 'initialization'!initializeCrossoverOperator	crossoverOperator := SGACrossoverOperation new.! !!SGAEngine methodsFor: 'initialization'!initializeMutationOperator	mutationOperator := SGAMutationOperation new.	mutationOperator mutationRate: (1 / 3) asFloat.! !!SGAEngine methodsFor: 'initialization'!initializePopulation	| t |	t := Time now asSeconds.   population := self createRandomPopulation.   SExpression resetId.   self computeFitness.   population := self order: population.   initialPopulation := population.	self updateTypeInfoWith: population.	logs add: (SGALog logOf: self inGeneration: 0 inTime: t)! !!SGAEngine methodsFor: 'initialization'!initializeProfiler	| aProfiler |	aProfiler := self aSLProfilerCoverage profilerForClass: targetClassName.	(aProfiler allMethods select: #isNotMethodExtension)		do: #installGhosts		displayingProgress: 'Instrumenting ' , targetClassName.	^ aProfiler! !!SGAEngine methodsFor: 'actions'!lastBestFitness	^ logs last fittestTestCase fitnessFor: fitness functionName! !!SGAEngine methodsFor: 'actions'!lastGenerationNumber	^ logs last generationNumber! !!SGAEngine methodsFor: 'accessing'!lastMessage: anObject	lastMessage := anObject 	! !!SGAEngine methodsFor: 'accessing'!logs	^ logs! !!SGAEngine methodsFor: 'updating'!mergeTypeInfo: otherTypeInfo	typeInfo joinWith: otherTypeInfo.! !!SGAEngine methodsFor: 'actions'!mutateAndUpdate: aTestCase	| newTestCase |	newTestCase := mutationOperator mutate: aTestCase.   newTestCase updateWith: aTestCase.	^ newTestCase ! !!SGAEngine methodsFor: 'actions'!mutationRate: aFloat	mutationOperator mutationRate: aFloat! !!SGAEngine methodsFor: 'accessing'!numberOfGenerations: anInteger	"Set the number of generation the genetic algorithm has to run"	numberOfGenerations := anInteger! !!SGAEngine methodsFor: 'accessing'!numberOfStatements: anInteger	"Set the number of statements the initial population should have.	Ideally, a small number, such as 3, is convenient. The evolution makes the individuals grow over time"	numberOfStatements := anInteger! !!SGAEngine methodsFor: 'sorting'!order: aCollection	^ aCollection sort: [ :stm1 :stm2 | stm1 isBetterThan: stm2 using: fitness functionName ]! !!SGAEngine methodsFor: 'accessing'!packageRegex: aString	packageRegex := aString! !!SGAEngine methodsFor: 'accessing'!population	^ population! !!SGAEngine methodsFor: 'accessing'!populationSize: aInteger	populationSize := aInteger! !!SGAEngine methodsFor: 'updating'!profilerForPackagesMatching	Transcript show: 'profiling...'; cr.	typeInfoProfiler := self aSTypeCollectorClass 		profilerForPackagesMatching: targetPackageRegex.	typeInfoProfiler beforeProfiling.! !!SGAEngine methodsFor: 'updating'!profilerForTargetClass	| packageSpy cls classSpy |	cls := Smalltalk at: targetClassName.	Transcript show: 'profiling...'; cr.	typeInfoProfiler := self aSTypeCollectorClass new.	self aSTypeCollectorClass installOnClass: cls.	typeInfoProfiler beforeProfiling .	classSpy := typeInfoProfiler spyForClass: cls.	packageSpy := typeInfoProfiler class spyClassForPackage new.	packageSpy classAt: targetClassName put: classSpy.	typeInfoProfiler addPackage: packageSpy.	classSpy packageSpy: packageSpy.! !!SGAEngine methodsFor: 'actions'!run  | counter bestFitness stopFlag |  totalExecutionGA := Time millisecondClockValue.  counter := 0.  stopFlag := false.  self initializePopulation.	totalExecutionGA := Time millisecondClockValue - totalExecutionGA.  bestFitness := self lastBestFitness.  (1 to: numberOfGenerations) do: [:iteration |  | t lastBestFitness |        stopFlag ifFalse: [ t := Time millisecondClockValue.              self doSelection.              logs add: (SGALog logOf: self inGeneration: iteration inTime: t).              lastBestFitness := self lastBestFitness.              lastBestFitness <= bestFitness ifTrue: [ counter := counter + 1.                    counter > stopIterations ifTrue: [ stopFlag := true ] ] ifFalse: [ counter := 0.                    bestFitness := lastBestFitness ].				totalExecutionGA := totalExecutionGA + Time millisecondClockValue - t ]	 ] displayingProgress: [:iteration |  'Evolving - Iteration' , iteration printString ]! !!SGAEngine methodsFor: 'actions'!selectTwoBestOf: aCollection excludingAll: excludingColl	| options |	options := (aCollection asOrderedCollection select: #notEmpty) removeAllSuchThat: [ :e | excludingColl includes: e ]; yourself.   options := self order: options.   ^ options first: (2 min: options size).! !!SGAEngine methodsFor: 'accessing'!selectionStrategy: aSelectionStrategy	selectionStrategy := aSelectionStrategy ! !!SGAEngine methodsFor: 'accessing'!selectionStrategyTestCase: aSelectionStrategy 	selectionStrategyTestCase := aSelectionStrategy ! !!SGAEngine methodsFor: 'testing'!shouldCrossOver	^ self next < self crossoverRate! !!SGAEngine methodsFor: 'actions'!similarChild: testCase with: idPopulation	^ testCase deepCopy 		generationNumber: testCase generationNumber + 1;		idPopulation: idPopulation;		addParent: testCase; 		yourself! !!SGAEngine methodsFor: 'actions'!targetClassName	^ targetClassName! !!SGAEngine methodsFor: 'accessing'!targetClassName: anObject	targetClassName := anObject! !!SGAEngine methodsFor: 'accessing'!targetPackageRegex	^ targetPackageRegex! !!SGAEngine methodsFor: 'accessing'!targetPackageRegex: aString	targetPackageRegex := aString! !!SGAEngine methodsFor: 'accessing'!totalExecutionGA	^ totalExecutionGA ! !!SGAEngine methodsFor: 'accessing'!tournamentSize: aNumber	selectionStrategy tournamentSize: aNumber! !!SGAEngine methodsFor: 'accessing'!typeInfo	^ typeInfo! !!SGAEngine methodsFor: 'accessing'!typeInfo: aTypeInfo	typeInfo := aTypeInfo.	typeInfo completeTypeInfo! !!SGAEngine methodsFor: 'updating'!uninstall	typeInfoProfiler afterProfiling;		uninstall.	Transcript show: 'ended...'; cr.! !!SGAEngine methodsFor: 'updating'!updateArgsOf: aMethod 	aMethod argTypes do: [ :argType |	|res|	res := argType types anySatisfy: [ :type | typeInfo scalars keys includes: type ].	res ifFalse: [ argType types do: [ :type | typeInfo scalars keys select: [ :scalar | 			 (type asClass allSubclasses collect: #name) includes: scalar ] thenDo: [ :scalar |			argType type: scalar ] ] ] ]! !!SGAEngine methodsFor: 'actions'!updateHierarchyData: parents of: testCase	parents do: [ :parent | testCase addParent: parent ].	^ testCase! !!SGAEngine methodsFor: 'updating'!updateTypeInfoWith: aPopulation	fitness profiler uninstallClass: targetClassName.   self profilerForTargetClass.   aPopulation do:		[ :aTestCase | aTestCase runWithoutAssertions ].   self mergeTypeInfo: (STypeInfo asTypeInfo: typeInfoProfiler).   self uninstall .   fitness profiler updateClass: ((self initializeProfiler packages at:1) classes at: targetClassName).	fitness profiler deleteCache.	! !!SGACrossoverOperation methodsFor: 'accessing'!alpha	^ (self random selectAtRandom: (0.1 to: 0.9 by: 0.1)) round: 1! !!SGACrossoverOperation methodsFor: 'validation'!checkReferencesOf: testCase withDescription: aString	self		assert: testCase validReferences		description: aString , ' must have valid references'! !!SGACrossoverOperation methodsFor: 'actions'!crossover: testCaseA with: testCaseB	| alpha offSpring1 offSpring2 |	self checkReferencesOf: testCaseA withDescription: 'testCase'.	self checkReferencesOf: testCaseB withDescription: 'testCase'.	"join typeInfo of testCaseA with testCaseB"	testCaseA typeInfo joinWith: testCaseB typeInfo.	alpha := self alpha.	"first alpha(P1) and last (1-alpha)(P2)"	offSpring1 := self offSpringOf: testCaseA and: testCaseB using: alpha.	self checkReferencesOf: offSpring1 withDescription: 'offspring'.	"first alpha(P2) and last (1-alpha)(P1)"	offSpring2 := self offSpringOf: testCaseB and: testCaseA using: (alpha).	self checkReferencesOf: offSpring2 withDescription: 'offspring'.	^ (Array with: offSpring1 with: offSpring2) do: 			[ :e | e lastMessage: testCaseA lastMessage]! !!SGACrossoverOperation methodsFor: 'actions'!offSpringOf: parentA and: parentB using: alpha  | sizeA sizeB offSpring |  sizeA := parentA length.  sizeB := parentB length.  offSpring := SSTestCase with: parentA typeInfo copy.  offSpring     addTargetClassNames: parentA targetClassesNames;     addTargetClassNames: parentB targetClassesNames.  offSpring addStatements: (parentA statements copyFrom: 1 to: ((sizeA * alpha) asInteger max: 1)) copy.  (parentB statements copyFrom: ((alpha * sizeB) asInteger max: 1) + 1 to: sizeB) do: [:aStm |  [ | lastStm |        aStm insertOn: offSpring.        lastStm := offSpring statements last.        lastStm needsBeFixed ifTrue: [ offSpring fixTypeReturnOf: lastStm ] ] on: SError do: [  ] ].  offSpring	  generationNumber: parentA generationNumber + 1;	  clean.  ^ offSpring! !!SGAMutationOperation methodsFor: 'actions'!doMutate: aTestCase	self next <= mutationRate		ifTrue: [ aTestCase removeStatement ].	self next <= mutationRate		ifTrue: [ aTestCase changeStatement ].	self next <= mutationRate		ifTrue: [ aTestCase insertStatement ]! !!SGAMutationOperation methodsFor: 'initialization'!initialize	super initialize.	self mutationRate: (1 / 3) asFloat! !!SGAMutationOperation methodsFor: 'actions'!mutate: aTestCase  | newTestCase |  newTestCase := aTestCase copy. "copyForMutation"  self doMutate: newTestCase.  ^newTestCase! !!SGAMutationOperation methodsFor: 'accessing'!mutationRate: aFloat	mutationRate := aFloat! !!SGARandomSelection methodsFor: 'selection'!selectJustOneOf: aCollection with: probabilities	^ self random selectAtRandom: aCollection! !!SGARandomSelection methodsFor: 'selection'!selectOf: aCollection 	^ self random collectAtRandom: aCollection! !!SGARankSelection methodsFor: 'as yet unclassified'!ranksOf: values	| indexValue |	indexValue := 0.	^ (self ranksWithIndexOf: (values collect: [:val | 		indexValue := indexValue + 1.		val -> indexValue ])) collect: #value.! !!SGARankSelection methodsFor: 'actions'!ranksWithIndexOf: associations 	| rank sortBlock |	sortBlock := [ :a :b | a key < b key ].	associations sort: sortBlock.	rank := 0.	^ (associations collect: [ :each | 		rank := rank + 1.		each value -> rank ]) sort: sortBlock! !!SGARankSelection methodsFor: 'selection'!selectJustOneOf: aCollection with: probabilities	^ SGARouletteSelection new selectJustOneOf: aCollection with: (self ranksOf: probabilities)! !!SGARankSelection methodsFor: 'selection'!selectOf: aCollection 	^ self selectOf: aCollection with: (aCollection collect: [:testCase | self fitnessFor: testCase ])! !!SGARankSelection methodsFor: 'selection'!selectOf: aCollection with: values	^ SGARouletteSelection new selectOf: aCollection with: (self ranksOf: values)! !!SGARouletteSelection methodsFor: 'creating'!createRouletteWith: probability 	| sum roulette |	sum := probability sum.	roulette := probability collect: [ :e | e/sum ].	2 to: probability size do: [ :i | 		roulette at: i put: (roulette at: (i-1)) + (roulette at: i) 	].	^ roulette ! !!SGARouletteSelection methodsFor: 'selection'!selectJustOneOf: aCollection with: probabilities	| roulette random |	roulette := self createRouletteWith: probabilities.	random := self next.	roulette doWithIndex: [ :probability :index |		(random < probability) ifTrue: [ 			^ aCollection at: index ] ].	^ nil! !!SGARouletteSelection methodsFor: 'selection'!selectOf: aCollection 	^ self selectOf: aCollection with: (aCollection collect: [:testCase | self fitnessFor: testCase ])! !!SGARouletteSelection methodsFor: 'selection'!selectOf: collection with: probability	| roulette random newCollection collectionSize indexes index |	roulette := self createRouletteWith: probability.	newCollection := OrderedCollection new.	collectionSize := collection size.	indexes := OrderedCollection new.	[ newCollection size < collectionSize ] whileTrue: [ 		random := self next.		index := 0.		roulette detect: [ :rv | 			index := index + 1. 			random < rv and: [ (indexes includes: index) not ] ] 			ifFound: [ newCollection add: (collection at: index).				indexes add: index ]		].	^ newCollection! !!SGASelection methodsFor: 'accessing'!fitness: anObject 	fitness := anObject ! !!SGASelection methodsFor: 'actions'!fitnessFor: aTestCase	^ aTestCase fitness at: fitness functionName! !!SGASelection methodsFor: 'initialization'!initialize! !!SGASelection methodsFor: 'selection'!selectJustOneOf: aCollection with: probabilities	^ self subclassResponsibility ! !!SGASelection methodsFor: 'selection'!selectOf: collection 	^ self subclassResponsibility ! !!SGATournamentSelection methodsFor: 'initialization'!initialize	super initialize .	tournamentSize := 5.! !!SGATournamentSelection methodsFor: 'selection'!selectJustOneOf: aCollection with: probabilities	| sample index |	index := 0.	sample := (self random collectAtRandom: 		(probabilities collect: [:prob | 			index := index + 1.			index -> prob ] ) )		first: (2 min: probabilities size).	sample := (sample sort: [ :a :b | a value > b value ]) first.	^ aCollection at: sample key ! !!SGATournamentSelection methodsFor: 'selection'!selectOf: aCollection	"Return the best testCases from tournamentSize testCase randomly chosen from the population"	| sample |	sample := (self random collectAtRandom: aCollection )		first: (tournamentSize min: aCollection size).	sample := sample		asSortedCollection: [ :a :b | (a fitnessFor: fitness functionName) > (b fitnessFor: fitness functionName) ].	^ sample! !!SGATournamentSelection methodsFor: 'accessing'!tournamentSize: anInteger	tournamentSize := anInteger ! !!SGATruncatedSelection methodsFor: 'actions'!discarding: aNumber	discarding := aNumber! !!SGATruncatedSelection methodsFor: 'initialization'!initialize 	super initialize.	discarding := 5! !!SGATruncatedSelection methodsFor: 'selection'!selectJustOneOf: aCollection with: probabilities	^ (self selectOf: aCollection) first! !!SGATruncatedSelection methodsFor: 'selection'!selectOf: aCollection	| newColl |	newColl := (aCollection sort: [ :a :b | (self fitnessFor: a) > (self fitnessFor: b) ]).	(discarding < aCollection size)		ifTrue: [ newColl := newColl copyFrom: 1 to: (aCollection size - discarding) ].	^ newColl! !!SInitialization methodsFor: 'copying'!copy: testCaseFactory	^ testCaseFactory class new 		typeInfo: testCaseFactory typeInfoOrigin copy;		fitness: testCaseFactory fitness class new;		targetClassName: testCaseFactory targetClassName;		targetPackageRegex: testCaseFactory targetPackageRegex;		outputPackageName: testCaseFactory outputPackageName;		asDict: testCaseFactory initialAsDict;		seed: testCaseFactory initialSeed;		fitnessSeedCalculated: testCaseFactory fitnessSeed;		numberOfGenerations: testCaseFactory numberOfGenerations;		numberOfStatements: testCaseFactory engine numberOfStatements;		populationSize: testCaseFactory engine populationSize;		yourself! !!SInitialization methodsFor: 'initialization'!initialize 		configurationDict := self initializeDictionary! !!SInitialization methodsFor: 'initialization'!initializeDictionary	^ self subclassResponsibility ! !!SInitialization methodsFor: 'public tree building'!newInstance: testCaseFactory with: key	| instance |	instance := self copy: testCaseFactory.	(configurationDict at: key) value: instance.	instance createTestCases.	^ instance	! !!SNumericParameterization methodsFor: 'initialization'!initializeDictionary	^ Dictionary new 			at: #largePopulationNumber put: [ :testCaseFactory | 				testCaseFactory engine populationSize < 30 					ifTrue: [ testCaseFactory populationSize: 30 ] ];			at: #largeGenerationNumber put: [ :testCaseFactory | 				testCaseFactory numberOfGenerations < 50 					ifTrue: [ testCaseFactory numberOfGenerations: 50 ] ];			at: #largeStatementNumber put: [ :testCaseFactory |				testCaseFactory engine numberOfStatements < 50 ifTrue: [ 					testCaseFactory numberOfStatements: 50 ] ];			at: #smallPopulationNumber put: [ :testCaseFactory | 				testCaseFactory engine populationSize > 5 					ifTrue: [ testCaseFactory populationSize: 5 ] ];			at: #smallGenerationNumber put: [ :testCaseFactory | 				testCaseFactory numberOfGenerations > 3 					ifTrue: [ testCaseFactory numberOfGenerations: 3 ] ];			at: #smallStatementNumber put: [ :testCaseFactory |				testCaseFactory engine numberOfStatements > 3 ifTrue: [ 					testCaseFactory numberOfStatements: 3 ] ];			yourself! !!SNumericParameterization methodsFor: 'public tree building'!newInstancesM: testCaseFactory	| "generationSizes statementSizes"producer1 producer2 populationSizes monitor instances goalReached activeProducers counter  |	"generationSizes := statementSizes :=" populationSizes := #(10).	counter := 0.	goalReached := false.	activeProducers := 0.	monitor := Monitor new.	instances := OrderedCollection new.	producer1 := [ | instance | 		monitor critical: [ activeProducers := activeProducers + 1 ].		[ monitor 			critical: [ monitor waitUntil: [ counter \\ 5 = 0 ].				goalReached or: [ 					instance := self copy: testCaseFactory.					instance numberOfGenerations: 15;						numberOfStatements: 15;						populationSize: 10;						createTestCases.					instances add: instance.					counter := counter +1 ].				goalReached := instances size = 1.				monitor signal  ].			goalReached ] whileFalse.		monitor critical: [ activeProducers := activeProducers - 1.			monitor signal: #finish ] ].	producer2 := [ | instance | 		monitor critical: [ activeProducers := activeProducers + 1 ].		[ monitor 			critical: [ monitor waitWhile: [ counter \\ 5 = 0 ].				goalReached or: [ 					instance := self copy: testCaseFactory.					instance numberOfGenerations: 15;						numberOfStatements: 15;						populationSize: 10;						createTestCases.					instances add: instance.					counter := counter +1 ].				goalReached := instances isNotEmpty.				monitor signal  ].			goalReached ] whileFalse.		monitor critical: [ activeProducers := activeProducers - 1.			monitor signal: #finish ] ].		producer1 forkAt: Processor userBackgroundPriority.	producer2 forkAt: Processor userBackgroundPriority.		monitor critical: [ monitor waitUntil: [ activeProducers = 0 & goalReached ] for: #finish ].		^ instances	! !!SSeedingParameterization methodsFor: 'initialization'!initialize 	super initialize.	numberToChangeSeed := 0! !!SSeedingParameterization methodsFor: 'initialization'!initializeDictionary	^ Dictionary new 		at: #lowerSeed put: [ :testCaseFactory | 			testCaseFactory seed: testCaseFactory initialSeed - self numberToChangeSeed ];		at: #greaterSeed put: [ :testCaseFactory |			testCaseFactory seed: testCaseFactory initialSeed + self numberToChangeSeed ];		yourself! !!SSeedingParameterization methodsFor: 'accessing'!numberToChangeSeed	numberToChangeSeed == 0 ifTrue: [ numberToChangeSeed := 10 ].	^ numberToChangeSeed! !!SSeedingParameterization methodsFor: 'accessing'!numberToChangeSeed: number	numberToChangeSeed := number! !!SSelectionParameterization class methodsFor: 'public tree building'!setting: testCaseFactory	testCaseFactory engine 			selectionOfGA: self gaSelection;		selectionOfTestCase: self testCaseSelection;		yourself! !!SSelectionParameterization methodsFor: 'initialization'!initializeDictionary	^ Dictionary new 		at: #rankSelection put: [ :testCaseFactory |			testCaseFactory selectionStrategy: SGARankSelection new ];		at: #tournamentSelection put: [ :testCaseFactory |			testCaseFactory selectionStrategy: SGATournamentSelection new ];		at: #rouleteWheelSelection put: [ :testCaseFactory |			testCaseFactory selectionStrategy: SGARouletteSelection new ];		at: #rankSelectionForTestCase put: [ :testCaseFactory |			testCaseFactory selectionStrategyTestCase: SGARankSelection new ];		at: #tournamentSelectionForTestCase put: [ :testCaseFactory |			testCaseFactory selectionStrategyTestCase: SGATournamentSelection new ];		at: #rouleteWheelSelectionForTestCase put: [ :testCaseFactory |			testCaseFactory selectionStrategyTestCase: SGARouletteSelection new ];		yourself! !!SObject class methodsFor: 'instance creation'!new	"Answer a newly created and initialized instance."	^super new initialize! !!SObject methodsFor: 'as yet unclassified'!fullNameOfClass: aString	^ aString! !!SObject methodsFor: 'as yet unclassified'!fullSymbolOf: aSymbol	^ aSymbol! !!SObject methodsFor: 'initialization'!initialize! !!SObject methodsFor: 'as yet unclassified'!next  ^ self random next! !!SObject methodsFor: 'as yet unclassified'!random  ^ SPlatform randomGenerator! !!SPlatform class methodsFor: 'accessing'!asDict	asDict ifNil: [ asDict := false ].	^ asDict ! !!SPlatform class methodsFor: 'accessing'!asDict: aBoolean	asDict := aBoolean! !!SPlatform class methodsFor: 'accessing'!classConfigurationName	^ self subclassResponsibility ! !!SPlatform class methodsFor: 'accessing'!classTestCaseFactory	^ self configurationClass classTestCaseFactory ! !!SPlatform class methodsFor: 'logging'!cleanAllLogs	self configurationClass cleanAllLogs ! !!SPlatform class methodsFor: 'logging'!clearLog	self configurationClass clearLog! !!SPlatform class methodsFor: 'accessing'!configurationClass	configurationClass ifNil: [  	configurationClass := self subclasses		detect: [ :aClass | 			[ Smalltalk at: aClass classConfigurationName.			true ]				on: Error				do: [ false ] ]		ifNone: [ nil ].	configurationClass ifNil: [ self error: 'Error to look a configurationClass' ]].	^ configurationClass! !!SPlatform class methodsFor: 'tests'!createTestCaseClass: aClassName inPackage: aPackageName	^ self configurationClass createTestCaseClass: aClassName inPackage: aPackageName ! !!SPlatform class methodsFor: 'accessing'!defaultLogName	^ 'SmallSuiteLogger.log'! !!SPlatform class methodsFor: 'accessing'!defaultSeed	^ 100! !!SPlatform class methodsFor: 'instance creation'!fileLogger: fileName	self configurationClass fileLogger: fileName! !!SPlatform class methodsFor: 'accessing'!implementationType	^ self subclassResponsibility ! !!SPlatform class methodsFor: 'accessing'!initLevelToPrint 		level := 10! !!SPlatform class methodsFor: 'accessing'!levelToPrint	^ level! !!SPlatform class methodsFor: 'accessing'!logName 	^ logName ifNil: [ self defaultLogName  ]! !!SPlatform class methodsFor: 'accessing'!logName: string	logName := string! !!SPlatform class methodsFor: 'accessing'!lookUpClass: aClassName	^ Smalltalk at: aClassName ifAbsent: [ nil ]! !!SPlatform class methodsFor: 'instance creation'!newRandomGenerator	^ SRandom seed: self seed! !!SPlatform class methodsFor: 'accessing'!randomGenerator	randomGenerator ifNil: [ randomGenerator := self newRandomGenerator ].	^ randomGenerator ! !!SPlatform class methodsFor: 'accessing'!randomGenerator: sRandom	randomGenerator := sRandom! !!SPlatform class methodsFor: 'settings'!rbParserClass	^ self configurationClass rbParserClass! !!SPlatform class methodsFor: 'actions'!reduceLevel	level ifNil: [ self initLevelToPrint  ].	level := level - 1! !!SPlatform class methodsFor: 'initialization'!resetConfigurationClass	configurationClass := nil! !!SPlatform class methodsFor: 'accessing'!resetRandomGenerator	self randomGenerator: self newRandomGenerator ! !!SPlatform class methodsFor: 'logging'!saveOnLog: message	self configurationClass saveOnLog: message! !!SPlatform class methodsFor: 'accessing'!seed 		seed ifNil: [ seed := self defaultSeed.		 ].	^ seed! !!SPlatform class methodsFor: 'instance creation'!seed: aNumber	seed := aNumber! !!SPlatform class methodsFor: 'tests'!testCaseClass	^ self configurationClass testCaseClass! !!SPlatformPharo class methodsFor: 'accessing'!classConfigurationName	^ superclass name , self implementationType! !!SPlatformPharo class methodsFor: 'accessing'!classLogger	^ TinyLogger! !!SPlatformPharo class methodsFor: 'accessing'!classTestCaseFactory	^ STestCaseFactoryPharo ! !!SPlatformPharo class methodsFor: 'logging'!cleanAllLogs	self instanceLogger removeAllLoggers! !!SPlatformPharo class methodsFor: 'actions'!clearFileLog: string	self instanceLogger fileLoggers		detect: [ :fileLogger | fileLogger fileName = string ]		ifFound: [ :fileLogger | fileLogger clearLog ]! !!SPlatformPharo class methodsFor: 'logging'!clearLog	self instanceLogger clearLog! !!SPlatformPharo class methodsFor: 'actions'!createFileLogger	self instanceLogger ensureFileLoggerNamed: self logName! !!SPlatformPharo class methodsFor: 'tests'!createTestCaseClass: aClassName inPackage: aPackageName	^ self testCaseClass		subclass: aClassName		instanceVariableNames: ''		classVariableNames: ''		package: aPackageName! !!SPlatformPharo class methodsFor: 'actions'!defaultFileLogger	self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			^ self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = self logName ] ]! !!SPlatformPharo class methodsFor: 'instance creation'!fileLogger: fileName	self logName: fileName.	^ self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = fileName ]				ifNone: [ self createFileLogger.					self fileLogger: fileName ] ]		ifNil: [ nil ]! !!SPlatformPharo class methodsFor: 'accessing'!implementationType 	^ SystemVersion current type! !!SPlatformPharo class methodsFor: 'accessing'!instanceLogger	^ self classLogger default! !!SPlatformPharo class methodsFor: 'settings'!rbParserClass	^ RBParser! !!SPlatformPharo class methodsFor: 'logging'!saveOnLog: string 	self defaultFileLogger record: string! !!SPlatformPharo class methodsFor: 'tests'!testCaseClass	^ TestCase! !!SPlatformVisualWorks class methodsFor: 'accessing'!classTestCaseFactory	^ STestCaseFactoryVisualWorks ! !!SPlatformVisualWorks class methodsFor: 'logging'!cleanAllLogs 	! !!SPlatformVisualWorks class methodsFor: 'logging'!clearLog 	! !!SPlatformVisualWorks class methodsFor: 'instance creation'!fileLogger: fileName! !!SPlatformVisualWorks class methodsFor: 'logging'!saveOnLog: string! !!SReport class methodsFor: 'accessing'!exportData: anObject onCSV: aString usingFilter: aSymbol	(self fileReference: aString)		writeStreamDo: [ :stream | 			| neoCSVWriter |			neoCSVWriter := (NeoCSVWriter on: stream)				nextPut: self titles.			anObject exportDataCSV: neoCSVWriter withFilter: aSymbol.			neoCSVWriter flush ]! !!SReport class methodsFor: 'accessing'!fileReference: aString	^ self new fileReference: aString! !!SReport class methodsFor: 'accessing'!titles	self subclassResponsibility ! !!SReport methodsFor: 'accessing'!fileReference: aString	| filename |	filename := aString , '.csv'.	filename asFileReference ensureDelete.	^ filename asFileReference! !!SReportSGALog class methodsFor: 'class-factory'!engine: aSGAEngine	^ self new engine: aSGAEngine ! !!SReportSGALog class methodsFor: 'export'!exportResumeOf: logColl onCSV: aString	(self fileReference: aString)		writeStreamDo: [ :stream | 			| neoCSVWriter |			neoCSVWriter := (NeoCSVWriter on: stream)				nextPut: #('ID' 'Avg Tests Size' '% Has Errors' 'BestTest Size' 'BestTest hasErrors' 'Best' 'Average' 'Worst').			logColl do: [ :aLog | neoCSVWriter nextPut: (Array withAll:				(OrderedCollection new add: aLog generationNumber;					add: aLog averageTestSize;					add: aLog percentageOftestCasesWithErrors;					add: aLog fittestTestCase statements size;					add: aLog fittestTestCase hasErrors;					add: aLog fittestTestCase fitness values first;					add: aLog averageFit values first;					add: aLog lowestFit values first;					yourself )) ].			neoCSVWriter flush ]! !!SReportSGALog class methodsFor: 'export'!generateReportForDifferencesBtwGenerationsOf: aSGAEngine	^ (self engine: aSGAEngine) generateReportForDifferencesBtwGenerations ! !!SReportSGALog class methodsFor: 'accessing'!titles	^ #('ID' 'Class Name' 'Method Name' 'Is Class Side' 'Was Executed' 'Has TypeInfo' 'Code' 'Args Types' 'Return Type' 'Executed Block' 'Unexecuted Block')! !!SReportSGALog methodsFor: 'accessing'!dictOfDifferences: differences 	| result keys |	result := OrderedCollection new.	keys := #('Generations' 'Method' 'UpdateReturnType' 'UpdateArgsType' 'ConvertToExecutedMethod' 'ConvertToUnexecutedMethod' 'AddTypeInfo' 'AddExecutedBlocks' 'DecreaseExecutedBlocks').   differences do: [:e |  | generationText |		generationText := '{1} -> {2}' format: (Array with: (e key - 1) with: e key).      e value do: [:diff |  | aux |         aux := Dictionary newFromKeys: keys andValues: (OrderedCollection ofSize: 9).         aux at: 'Generations' put: generationText.         aux at: 'Method' put: diff first.         diff allButFirst do: [:d |              d key = 'WasExecuted' ifTrue: [ d value = #(false true) ifTrue: [ aux at: 'ConvertToExecutedMethod' put: true ] ifFalse: [ aux at: 'ConvertToUnexecutedMethod' put: true ]].             d key = 'ReturnType' ifTrue: [ aux at: 'UpdateReturnType' put: true ].             d key = 'HasTypeInfo' ifTrue: [ aux at: 'AddTypeInfo' put: true ].             d key = 'ArgTypes' ifTrue: [ aux at: 'UpdateArgsType' put: true ].             d key = 'ExecutedBlock' ifTrue: [ aux at: 'AddExecutedBlocks' put: (d value second difference: d value first) asString].             d key = 'UnexecutedBlock' ifTrue: [ aux at: 'DecreaseExecutedBlocks' put: (d value second difference: d value first) asString ] ].         result add: aux ] ].  ^ result ! !!SReportSGALog methodsFor: 'reporting'!differencesBtw: summary1 and: summary2	| result |   result := OrderedCollection new.   summary1 with: summary2 do: [:x :y |  x = y 		ifFalse: [ | aux |			aux := OrderedCollection new.         x keysAndValuesDo: [:key :value |  (x at: key) = (y at: key) 				ifFalse: [ aux add: key -> (Array with: value with: (y at: key)) ] ]. 		aux ifNotEmpty: [ aux addFirst: (x at: 'MethodName').	result add: aux] ] ]. 	^ result! !!SReportSGALog methodsFor: 'reporting'!differencesBtwGenerations	| generations result |	generations := self summaryGenerations.	result := OrderedCollection new.	2 to: generations size do: [ :index | |diff|		diff := self differencesBtw: (generations at: index-1) and: (generations at: index).		diff ifNotEmpty: [ result add: (index -> diff)] ].	^ result! !!SReportSGALog methodsFor: 'accessing'!engine: anObject 	engine := anObject ! !!SReportSGALog methodsFor: 'reporting'!generateReportForDifferencesBtwGenerations	| differences dictColl keys |	keys := #('Generations' 'Method' 'UpdateReturnType' 'UpdateArgsType' 'ConvertToExecutedMethod' 'ConvertToUnexecutedMethod' 'AddTypeInfo' 'AddExecutedBlocks' 'DecreaseExecutedBlocks').	differences := self differencesBtwGenerations.	dictColl := self dictOfDifferences: differences.	(self fileReference: 'ReportChangesOfGenerations_', engine targetClassName asString)		writeStreamDo: [ :stream | 			| neoCSVWriter |			neoCSVWriter := (NeoCSVWriter on: stream)				nextPut: keys;				addRawFieldsAt: keys.			dictColl do: [ :aDict | neoCSVWriter nextPut: aDict ].			neoCSVWriter flush ]! !!SReportSGALog methodsFor: 'groups collecting'!methodTrackingFor: aSymbol	| methodCalls dict idMethods |	idMethods := #().	methodCalls := engine logs collect: [ :log | log population 		select: [ :testCase | testCase statements anySatisfy: 			[ :e | [e value selector = aSymbol] on: Error  do: [ false ] ] ] ].	dict := Dictionary new.	methodCalls doWithIndex: [ :methods :i | methods 		ifNotEmpty: [ dict at: i put: (self reportOf: methods withParents: idMethods).			idMethods := methods collect: #idPopulation ]		ifEmpty: [ idMethods := #() ] ].	^ dict! !!SReportSGALog methodsFor: 'groups collecting'!reportOf: methods withParents: idMethods	| keys |	keys := #('TestCase' 'hasError' 'parentHasMethod').	^ methods collect: [ :method | Dictionary 		newFromKeys: keys 		andValues: (Array with: method			with: method hasErrors			with: ((method parents collect: #idPopulation) includesAny: idMethods) )]! !!SReportSGALog methodsFor: 'reporting'!summaryGenerations	^ engine logs collect: [ :aLog | 		aLog summaryTargetClass collect: [ :e | e ifNotNil: [ 				Dictionary newFromKeys: #('ClassName' 'MethodName' 'IsClassSide' 'WasExecuted' 'HasTypeInfo' 'Code' 'ArgTypes' 'ReturnType' 'ExecutedBlock' 'UnexecutedBlock')					 andValues: e summaryAsColl ] ] ]	! !!SReportSTestCaseFactory class methodsFor: 'class-factory'!on: anObject	^ self new factoryTestCase: anObject ! !!SReportSTestCaseFactory methodsFor: 'actions'!engine	^ factoryTestCase engine! !!SReportSTestCaseFactory methodsFor: 'actions'!evolutionTypeInfo	| typeInfos evolution |	typeInfos := Array with: factoryTestCase typeInfoSeed withAll: (self engine logs collect: #typeInfoGeneration).	evolution := Dictionary new.	2 to: typeInfos size do: [ :index | | partialResult |		partialResult := (typeInfos at: index - 1) difference: (typeInfos at: index).		(partialResult notNil and: [partialResult notEmpty]) ifTrue: [ 			evolution 				at: ('{1} -> {2}' format:(Array with: (index - 2) with: (index-1))) 				put: partialResult ]		 ].	^ evolution! !!SReportSTestCaseFactory methodsFor: 'accessing'!factoryTestCase: anObject	factoryTestCase := anObject ! !!SReportSTestCaseFactory methodsFor: 'actions'!generateReportForAllMethodsOf: aLog 	self generateReportOf: aLog usingFilter: #all! !!SReportSTestCaseFactory methodsFor: 'actions'!generateReportForAllMethodsOfAllLogs	self engine logs do: [ :aLog | self generateReportForAllMethodsOf: aLog ]! !!SReportSTestCaseFactory methodsFor: 'actions'!generateReportForUnexecutedMethodsOf: anIndex	self generateReportOf: anIndex usingFilter: #notAllBlocksExecuted! !!SReportSTestCaseFactory methodsFor: 'actions'!generateReportForUnexecutedMethodsOfAllLogs	self engine logs do: [ :aLog | self generateReportForUnexecutedMethodsOf: aLog ]! !!SReportSTestCaseFactory methodsFor: 'actions'!generateReportOf: aLog usingFilter: aSymbol 	SReportSGALog exportData: aLog 	onCSV: ('Report_', aLog generationNumber asString,'_', aSymbol asString capitalized, factoryTestCase targetClassName asString) 	usingFilter: aSymbol! !!SReportSTestCaseFactory methodsFor: 'actions'!generateReportOfAllMethods	self generateReportForAllMethodsOf: self engine logs last! !!SReportSTestCaseFactory methodsFor: 'actions'!generateResumeDifferenceOfGeneration	SReportSGALog generateReportForDifferencesBtwGenerationsOf: self engine! !!SReportSTestCaseFactory methodsFor: 'actions'!generateResumeReportOfLogs	SReportSGALog exportResumeOf: self engine logs 	onCSV: ('Report_Resume_' , factoryTestCase targetClassName asString)! !!SReportTypeInfo class methodsFor: 'export'!dataCaseStudy: profiler from: projectName		^	(Array				with: projectName				with: profiler numberOfClasses				with: profiler numberOfMethods				with:					(profiler allMethods						collect: #selector						thenSelect: [ :selector | selector beginsWith: 'test' ]) size				with:					(((profiler allMethods count: #wasExecuted) / profiler numberOfMethods)						asFloat round: 4) * 100)! !!SReportTypeInfo class methodsFor: 'export'!dataFrequency: typeInfo from: projectName	^ (Array with: projectName)		, (typeInfo reportFrequencyByFilter associations sort collect: #value)! !!SReportTypeInfo class methodsFor: 'export as CSV'!exportData: aTypeInfo onCSV: aString	self exportData: aTypeInfo onCSV: aString usingFilter: #all! !!SReportTypeInfo class methodsFor: 'export as CSV'!exportReportData: projectName 	self exportReportData: projectName withName: projectName! !!SReportTypeInfo class methodsFor: 'export as CSV'!exportReportData: projectName usingFilter: aSymbol	self exportReportData: projectName withName: projectName usingFilter: aSymbol! !!SReportTypeInfo class methodsFor: 'export as CSV'!exportReportData: projectName withName: aString	self		exportData: (STypeInfo asTypeInfo: (self profilerProject: projectName))		onCSV: aString! !!SReportTypeInfo class methodsFor: 'export as CSV'!exportReportData: projectName withName: aString usingFilter: aSymbol	self		exportData: (STypeInfo asTypeInfo: (self profilerProject: projectName))		onCSV: aString		usingFilter: aSymbol! !!SReportTypeInfo class methodsFor: 'export'!exportReportsCaseStudyAndFrequency: fileNames of: projectsName	| data |	self		assert: fileNames size = 2		description: 'Set the fileNames correctly'.	data := projectsName		collect: [ :projectName | 			| profiler |			profiler := self profilerProject: projectName.			Array				with: (self dataCaseStudy: profiler from: projectName)				with: (self dataFrequency: (STypeInfo asTypeInfo: profiler) from: projectName) ].	self writeReport: fileNames first ofCaseStudy: (data collect: #first).	self		writeReport: fileNames second		ofFrequency: (data collect: #second)! !!SReportTypeInfo class methodsFor: 'export'!exportReportsCaseStudyAndFrequencyOf: projectsName	self exportReportsCaseStudyAndFrequency: #('CaseStudy' 'Frequency') of: projectsName! !!SReportTypeInfo class methodsFor: 'accessing'!fileReference: aString	| filename |	filename := aString , '.csv'.	filename asFileReference ensureDelete.	^ filename asFileReference! !!SReportTypeInfo class methodsFor: 'export'!profilerProject: projectName	^ self aSTypeCollectorClass		profile: [ (SPlatform testCaseClass withAllSubclasses				select: [ :t | t category beginsWith: projectName ])				do: [ :tc | 					[ tc buildSuite run ]						on: Exception						do: [ :e | 							Transcript								show: e printString;								cr ] ]				displayingProgress: 'working' ]		onPackagesMatching: projectName , '*'! !!SReportTypeInfo class methodsFor: 'export as CSV'!titles	^ #('ClassName' 'MethodName' 'Receivers' 'CommSupcls' 'ArgTypes' 'CommSupcls' 'ReturnTypes' 'CommSupcls')! !!SReportTypeInfo class methodsFor: 'writing'!writeReport: filename ofCaseStudy: data	(self fileReference: filename)		writeStreamDo: [ :stream | 			(NeoCSVWriter on: stream)				nextPut: #('Project' 'Classes (#)' 'Methods (#)' 'Test (#)' 'Coverage(%)');				nextPutAll: data;				flush ]! !!SReportTypeInfo class methodsFor: 'writing'!writeReport: filename ofFrequency: data	(self fileReference: filename)		writeStreamDo: [ :stream | 			(NeoCSVWriter on: stream)				nextPut:					#('Project')						, (STypeMethodInfo selectorsFilter , #(#others #all)) sort;				nextPutAll: data;				flush ]! !!SSExecutionContext methodsFor: 'accessing'!associations	^ values associations! !!SSExecutionContext methodsFor: 'initialization'!at: aSymbol	^ values at: aSymbol.! !!SSExecutionContext methodsFor: 'initialization'!at: aSymbol put: aValue	values at: aSymbol put: aValue.! !!SSExecutionContext methodsFor: 'initialization'!initialize	super initialize.	values := OrderedDictionary new! !!SSExecutionContext methodsFor: 'initialization'!keys	^ values keys asOrderedCollection ! !!SSTestCase class methodsFor: 'instance creation'!with: aTypeInfo  | testCase |  testCase := self new.  testCase typeInfo: aTypeInfo.  ^testCase! !!SSTestCase methodsFor: 'comparing'!= another  ^ self class = another class 	and: [ statements = another statements 		and: [ fitness = another fitness 			and: [ parents = another parents 				and: [ generationNumber = another generationNumber and: [ idPopulation = another idPopulation  ] ] ] ] ]! !!SSTestCase methodsFor: 'actions'!analyze	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	|result|	self setUp.	result := SSTestRunner new evaluate: self.	self tearDown.	SPlatform asDict ifTrue: [ result := result at: 'var' ].	^ result.! !!SSTestCase methodsFor: 'actions'!computeFitness: fitnessClass	| valueFitness |	valueFitness := fitnessClass computeFitness: self.	[ fitness addAll: valueFitness ]		on: MessageNotUnderstood		do: [ fitness add: valueFitness ]! !!SSTestCase methodsFor: 'copying'!copy	| copy |	copy := self class with: typeInfo copy.	copy addTargetClassNames: targetClassesNames.	statements do: [ :stm | copy addStatement: stm copy ].	copy updateNextId.	^ copy! !!SSTestCase methodsFor: 'copying'!deepCopy  | copy |  copy := self copy.  copy setFitness: self fitness.  copy setFitnessByClass: self fitnessByClass.  copy generationNumber: self generationNumber.  copy summaryExecutionMethods: self summaryExecutionMethods.  copy hasErrors: self hasErrors.  ^ copy! !!SSTestCase methodsFor: 'actions'!fitnessFor: functionName 	^ self fitness at: functionName! !!SSTestCase methodsFor: 'accessing'!generationNumber	^ generationNumber! !!SSTestCase methodsFor: 'accessing'!generationNumber: anObject	generationNumber := anObject! !!SSTestCase methodsFor: 'actions'!hasErrors	^ hasErrors! !!SSTestCase methodsFor: 'actions'!hasErrors: aBoolean	hasErrors := aBoolean ! !!SSTestCase methodsFor: 'comparing'!hash  ^ super hash bitXor: "(self number hash bitXor:" self statements hash")"! !!SSTestCase methodsFor: 'accessing'!idPopulation	^ idPopulation! !!SSTestCase methodsFor: 'accessing'!idPopulation: anObject	idPopulation := anObject! !!SSTestCase methodsFor: 'initialization'!initialize   super initialize.   generationNumber := 1.   idPopulation := 1.   summaryExecutionMethods := OrderedCollection new.	hasErrors := false! !!SSTestCase methodsFor: 'accessing'!isBetterThan: testCase2 using: fitnessStrategy    |fitness1 fitness2|    fitness1 := self fitness at: fitnessStrategy.    fitness2 := testCase2 fitness at: fitnessStrategy.    (fitness1 > fitness2) ifTrue:[ ^ true ].	 (self hasErrors and: [ testCase2 hasErrors not and: [ self next < 0.5 ]]) ifTrue: [^ false].    ((fitness1 = fitness2) and:        [self length < testCase2 length])                 ifTrue:[^ true].     (fitness1 = fitness2 and:        [self length = testCase2 length and:[ self idPopulation > testCase2 idPopulation]])                ifTrue:[^ true].     ^ false! !!SSTestCase methodsFor: 'printing'!printOn: aStream	self statements do: [ :stm | 			stm printOn: aStream.			aStream nextPut: Character cr ]! !!SSTestCase methodsFor: 'actions'!run	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	|result|	self setUp.	result := SSTestRunner new run: self.	self tearDown.	^ result.! !!SSTestCase methodsFor: 'actions'!runWithoutAssertions	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	|result|	self setUp.	result := SSTestRunner new runWithoutAssertions: self.	self tearDown.	^ result.! !!SSTestCase methodsFor: 'initialization'!setFitness: aDictionary 	fitness := aDictionary copy! !!SSTestCase methodsFor: 'initialization'!setFitnessByClass: aDictionary 	fitnessByClass := aDictionary copy! !!SSTestCase methodsFor: 'actions'!setUp	previousOpenWindows := SystemWindow allInstances.! !!SSTestCase methodsFor: 'accessing'!summaryExecutionMethods	^ summaryExecutionMethods! !!SSTestCase methodsFor: 'accessing'!summaryExecutionMethods: summaryExecutionMethod 	summaryExecutionMethods := summaryExecutionMethod ! !!SSTestCase methodsFor: 'actions'!tearDown 	|windowsToDelete|	windowsToDelete := SystemWindow allInstances asOrderedCollection removeAll: previousOpenWindows.	windowsToDelete do:[:w| w close].! !!SSTestCase methodsFor: 'repairing'!updateWith: anotherTestCase	self generationNumber: anotherTestCase generationNumber.	self idPopulation: anotherTestCase idPopulation.	anotherTestCase parents do: [ :parent | 		parent removeChild: anotherTestCase.		self addParent:  parent ]! !!SSTestShifter methodsFor: 'adding'!addArgument: arg before: aStatement considering: prevTypes and: scalarNames	| res addArgBlock |	res := arg types anySatisfy: [ :type | prevTypes includes: type ].	addArgBlock := [ (self random collectAtRandom: arg types)				detect: [ :missType | 					[ (scalarNames includes: missType)						ifTrue: [							self								addStatement: (self newAssignment: (self newLiteral: missType))								before: aStatement ]						ifFalse: [ self								addAssignment: "(self newStatementOfType: missType before: aStatement)"								(self newFactoryMessage: missType before: aStatement) ].					true ]						on: SError						do: [ false ] ]				ifNone: [ self						error: 'It is not possible to meet the arguments of this method call' ] ].	(res not or: [ self next > 0.5 ]) ifTrue: addArgBlock ! !!SSTestShifter methodsFor: 'inserting'!addAssignment: anExpression	|assignment|	assignment := self newAssignment: anExpression.	(assignment returnType isNil or: [assignment returnType = #SUndefinedObject]) 		ifFalse: [ self validTargetClassName: assignment returnType ].	self addStatement: assignment.	^ assignment! !!SSTestShifter methodsFor: 'adding'!addChild: aTestCase	children add: aTestCase! !!SSTestShifter methodsFor: 'inserting'!addFactoryMessage	| variables |	variables := self objectVariables.	variables		ifEmpty: [ (self random collectAtRandom: typeInfo noneAbstractClasses)				do: [ :aClass | 					[ ^ self addFactoryMessage: (self fullSymbolOf: aClass name) ]						on: SError						do: [  ] ].			self error: 'Cannot create a factoryMessage.' ]		ifNotEmpty: [ ^ self addFactoryMessage: (self random selectAtRandom: variables) returnType ]! !!SSTestShifter methodsFor: 'inserting'!addFactoryMessage: symbol	^ self addAssignment: (self newFactoryMessage: symbol before: nil)! !!SSTestShifter methodsFor: 'inserting'!addFactoryMessage: aClassName ofSelector: aSelector	^ [ self		addAssignment:			(self				factoryMessageUsing: (typeInfo classMethodType: aSelector from: aClassName)				before: nil) ]		on: SError		do: [ self addFactoryMessage: aClassName ]! !!SSTestShifter methodsFor: 'inserting'!addFieldAccessMessage	| receiver methods |	receiver := self pickAnObjectVariable.	methods := self pickAccessorsOf: receiver returnType.	methods		ifNotEmpty: [ ^ self				addFieldAccessMessage: (self selectMethod: methods)				withReceiver: receiver ].	self error: 'Cannot create a field access message.'! !!SSTestShifter methodsFor: 'inserting'!addFieldAccessMessage: aSelector from: aClassName	| receiver anAccessor |	anAccessor := (self pickAccessorsOf: aClassName)		detect: [ :accessor | accessor selector = aSelector ]		ifNone: [ nil ].	anAccessor		ifNil: [ self				error:					'None field access message of selector: ' , aSelector						, ' matches with: ' , aClassName ].	receiver := self pickOrCreateObjectVariableOf: aClassName.	^ self addFieldAccessMessage: anAccessor withReceiver: receiver! !!SSTestShifter methodsFor: 'inserting'!addFieldAccessMessage: method withReceiver: receiver	^ self		addAssignment: (SFieldAccessMessage newFromReceiver: receiver copy andMethod: method)! !!SSTestShifter methodsFor: 'inserting'!addLiteral	^ self addLiteral: self randomLiteralClassName! !!SSTestShifter methodsFor: 'inserting'!addLiteral: aClassName		^ self addAssignment: (self newLiteral: aClassName)! !!SSTestShifter methodsFor: 'inserting'!addMessage	| receiver methods |	receiver := self pickAnObjectVariable.	methods := self pickMessagesOf: receiver returnType.	methods		ifEmpty: [self				error: 'There are no method typeInfos for: ' , receiver returnType , '.' ]		ifNotEmpty: [ ^ self addMessage: (self selectMethod: methods) withReceiver: receiver ]! !!SSTestShifter methodsFor: 'inserting'!addMessage: aSelector from: aClassName	| receiver aMethod |	aMethod := (self pickMessagesOf: aClassName)		, (typeInfo factoryMessagesFrom: aClassName)		detect: [ :aMessage | aMessage selector = aSelector ]		ifNone: [ nil ].	aMethod		ifNil: [ self				error:					'None message of selector: ' , aSelector						, ' matches with: ' , aClassName ].	receiver := self pickOrCreateObjectVariableOf: aClassName.	^ self addMessage: aMethod withReceiver: receiver! !!SSTestShifter methodsFor: 'inserting'!addMessage: method withReceiver: receiver	^ self addAssignment: (self messageUsing: method and: receiver before: nil)! !!SSTestShifter methodsFor: 'accessing'!addParent: aTestCase   parents add: aTestCase.	aTestCase addChild: self.! !!SSTestShifter methodsFor: 'accessing'!addParents: aCollection   aCollection do: [ :e | self addParent: e ]! !!SSTestShifter methodsFor: 'inserting'!addStatement: anExpression	self canAddStatement ifTrue: [ statements add: anExpression ]! !!SSTestShifter methodsFor: 'inserting'!addStatement: newExpression after: aStatement	| anIndex |	self canAddStatement ifFalse: [ ^ self ].	anIndex := statements indexOf: aStatement.	anIndex = 0		ifTrue: [ self addStatement: newExpression ]		ifFalse: [ anIndex := self random selectAtRandom: (anIndex to: self length).			statements add: newExpression afterIndex: anIndex ].	^ newExpression! !!SSTestShifter methodsFor: 'inserting'!addStatement: newExpression before: aStatement	"I add a newExpression before aStatement"	self canAddStatement ifFalse: [ ^ self ].	statements		add: newExpression		afterIndex: (self randomIndexToAdd: newExpression before: aStatement)! !!SSTestShifter methodsFor: 'inserting'!addStatementOfType: aType before: expression	| newExpression |	newExpression := self newStatementOfType: aType before: expression.	newExpression mutated: true.	newExpression := self		newAssignment: newExpression.	self addStatement: newExpression before: expression.	^ newExpression! !!SSTestShifter methodsFor: 'inserting'!addStatements: collStatements	self		assert: statements isEmpty		description: 'statements must be empty'.	collStatements do: [ :stm | self addStatement: stm ]"	statements addAll: collStatements"! !!SSTestShifter methodsFor: 'adding'!addTargetClassName: aSymbol	typeInfo types at: aSymbol ifAbsent: [ self error: 'Class name: ', aSymbol, ' is not found in typeInfo' ].	targetClassesNames add: aSymbol! !!SSTestShifter methodsFor: 'adding'!addTargetClassNames: symbols	symbols do: [ :symbol | self addTargetClassName: symbol ]! !!SSTestShifter methodsFor: 'hierarchy'!allChildren	^ (Set newFrom: children)	addAll: (children flatCollect: [ :tC | tC allChildren ]); yourself! !!SSTestShifter methodsFor: 'hierarchy'!allParents	|  list |	list := OrderedCollection new.	self allParents: self on: list using: Set new.	^ list! !!SSTestShifter methodsFor: 'accessing'!allParents: testCase on: collection using: associationSet	testCase parents 		reject: [ :tC | (associationSet includes: tC generationNumber -> tC idPopulation) ] 		thenDo:  [ :tC | 			associationSet add: tC generationNumber -> tC idPopulation.			collection add: tC.			self allParents: tC on: collection using: associationSet			]! !!SSTestShifter methodsFor: 'accessing'!allVarNames	^ statements collect: [ :stm | stm reference printString ]! !!SSTestShifter methodsFor: 'repairing'!alternativeFactoryMessage: aFactoryMessage before: aExpression	| returnType |	returnType := aFactoryMessage returnType.	^ (typeInfo factoryMessagesFrom: returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFactoryMessage selector ] ]		ifFound: [ :meth | self factoryMessageUsing: meth before: aExpression ]		ifNone: [ SFactoryMessage default: returnType ]! !!SSTestShifter methodsFor: 'repairing'!alternativeFieldAccessMessage: aFieldAccessMessage	| returnType receiver |	receiver := aFieldAccessMessage receiver.	returnType := aFieldAccessMessage returnType.	(self pickAccessorsOf: receiver returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFieldAccessMessage selector ] ]		ifFound:			[ :meth | ^ SFieldAccessMessage newFromReceiver: receiver andMethod: meth ].	self		error:			'There is no alternative for fieldAccessMessage of selector: '				, aFieldAccessMessage selector! !!SSTestShifter methodsFor: 'repairing'!alternativeMessage: aMessage before: expression	| returnType receiver |	receiver := aMessage receiver.	returnType := aMessage returnType.	(self pickMessagesOf: receiver returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aMessage selector ] ]		ifFound:			[ :meth | ^ self messageUsing: meth and: receiver before: expression ].	self		error:			'There is no alternative for message of selector: '				, aMessage selector! !!SSTestShifter methodsFor: 'repairing'!alternativeOfVariable: aVariable before: aExpression	| returnType |		self statementOfVarName: aVariable printString.	returnType := aVariable returnType.	(self statementsOfType: returnType before: aExpression)		detect: [ :stm | stm reference ~= aVariable ]		ifFound: [ :stm | ^ stm reference ].	^ (self addStatementOfType: returnType before: aExpression) reference! !!SSTestShifter methodsFor: 'accessing'!assertions	^ assertions! !!SSTestShifter methodsFor: 'accessing'!assignId	| idToAssign assignedIds |	assignedIds := self assignedIds.	[ assignedIds includes: nextId ] whileTrue: [ nextId := nextId + 1 ].	idToAssign := nextId.	nextId := nextId + 1.	^ idToAssign! !!SSTestShifter methodsFor: 'accessing'!assignedIds	^ statements collect: #id! !!SSTestShifter methodsFor: 'repairing'!buildArgs: argTypes before: aStatement	argTypes		ifNotNil: [ | prevTypes scalarsKeys |			prevTypes := (self subStatementsFrom: 1 toPrevIndexOf: aStatement)				select: [ :stm | stm needsBeFixed not and: [ stm returnType isNil not ]]				thenCollect: #returnType.			scalarsKeys := typeInfo scalars keys asOrderedCollection .			argTypes				do: [ :arg | 					self						addArgument: arg						before: aStatement						considering: prevTypes						and: scalarsKeys ] ]! !!SSTestShifter methodsFor: 'inserting'!canAddStatement	SPlatform asDict 		ifFalse: [			^ ((self length + 3) < CompiledMethod fullFrameSize)		] ifTrue: [ ^ true ]! !!SSTestShifter methodsFor: 'modifying'!changeMessageNotUnderstood: aSelector from: aClassName	^ false! !!SSTestShifter methodsFor: 'modifying'!changeStatement	(self random collectAtRandom: statements)		do: [ :stm | 			[ ^ self changeStatement: stm ]				on: SError				do: [  ] ]! !!SSTestShifter methodsFor: 'modifying'!changeStatement: aStatement	| statementChanged newStm |	statementChanged := aStatement copy		repairOn: self		changing: aStatement.	(self statementAt: aStatement ) replaceBy: statementChanged.	newStm := self statementAt: statementChanged .	self fixTypeReturnOf: (newStm needsBeFixed: true).	^ statementChanged! !!SSTestShifter methodsFor: 'modifying'!changeStatementOfClassName: aClassName	| varExpressions changed |		varExpressions := self messagesVariablesFrom: aClassName.	changed := false.	"if the expression can't be replaced by another, then it will be removed"	varExpressions		do: [ :var | 			| changedStm origStm |			origStm := self statementOfVarName: var printString.			changedStm := self changeStatement: origStm.			changedStm = origStm				ifTrue: [ self removeStatementNoRepairing: origStm ]				ifFalse: [ changed := true ] ].	^ changed! !!SSTestShifter methodsFor: 'removing'!changeStatementOfVarName: varName	^ self changeStatement: (self statementOfVarName: varName)! !!SSTestShifter methodsFor: 'accessing'!children 	^ children! !!SSTestShifter methodsFor: 'repairing'!clean	|literals unused|	literals := self statements select: [ :e | (e value isKindOf: SLiteral) or: [ e value isKindOf: SFactoryMessage ] ].	unused := literals difference: (literals select: 		[ :e | (self statements collect: 			[:stm | stm pickUpReferences: e]) anySatisfy: [ :x | x isNotEmpty  ]]).	unused do: [ :stm | self removeStatement: stm ]! !!SSTestShifter methodsFor: 'repairing'!error: string		^ SError signal: string ! !!SSTestShifter methodsFor: 'repairing'!factoryMessageUsing: method before: aStatement	self buildArgs: method argTypes before: aStatement.	^ SFactoryMessage		method: method		previousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement)! !!SSTestShifter methodsFor: 'querying'!factoryMessageVariablesBefore: aStatement	^ (self subStatementsFrom: 1 toPrevIndexOf: aStatement)		select: [ :stm | stm value isFactoryMessage ]		thenCollect: [ :stm | stm variable ]! !!SSTestShifter methodsFor: 'accessing'!fitness 		^ fitness! !!SSTestShifter methodsFor: 'accessing'!fitnessByClass	^ fitnessByClass ! !!SSTestShifter methodsFor: 'actions'!fixTypeReturnOf: aStatement	[| executionContext aReturnType |	executionContext := self analyze.	aReturnType := (executionContext at: aStatement variable key) class name.	aStatement returnType = aReturnType ifTrue: [ 		aStatement needsBeFixed: false.		^ self ].	(self subStatementsAfterIndexOf: aStatement) do: [ :stm | 		self repairReferenceTo: aStatement of: stm	].	aStatement variable returnType: aReturnType.	aStatement value returnType: aReturnType.	aStatement needsBeFixed: false.	aStatement returnType: aReturnType ]	on: Exception 	do: [  ]! !!SSTestShifter methodsFor: 'actions'!generateAssertions	^ self		generateAssertions:			(Array with: SComparisonAssertion			with: SInspectorAssertion			with: SPrimitiveAssertion			with: SStringAssertion)! !!SSTestShifter methodsFor: 'actions'!generateAssertions: classAssertions	"	it analyze each kind of assertion an generate a set of assertion based on the test case -- double dispatch	"	| executionContext |	executionContext := self analyze.	assertions := classAssertions		flatCollect: [ :assertion | assertion for: executionContext ]! !!SSTestShifter methodsFor: 'actions'!generateStatements  | flag counter |  flag := true.  counter := 0.  self assert: typeInfo types isNotEmpty description: 'TypeInfo does not contain info at all.'.  [ flag and: [ self length < self maxNumberOfStatements ] ] whileTrue: [ | array |        array := self random collectAtRandom: (Array with: #addMessage with: #addFieldAccessMessage).        array detect: [:aMethod |  [ (self perform: aMethod) isNotNil ] on: SError do: [ false ] ] ifFound: [:aMethod |  | lastStm |              lastStm := statements last.              lastStm needsBeFixed ifTrue: [ self fixTypeReturnOf: lastStm ] ] ifNone: [ counter := counter + 1.              counter > self maxNumberOfStatements ifTrue: [ flag := false.                    self error: 'Not able to generate statements' ] ]        "	[ self addMessage ]				on: SError				do: [  ]" ]! !!SSTestShifter methodsFor: 'actions'!generateStatements: anInteger	self maxNumberOfStatements: anInteger.	self generateStatements.	! !!SSTestShifter methodsFor: 'parsing'!getStringOf: stm	stm isString ifTrue: [ ^ stm ].	^ stm printString ! !!SSTestShifter methodsFor: 'initalize'!initialize  super initialize.  statements := OrderedCollection new.  assertions := OrderedCollection new.  fitness := Dictionary new.  fitnessByClass := Dictionary new.  nextId := 0.  maxNumberOfStatements := 10.  targetClassesNames := Set new.  validatedTargetClassName := false.  parents := OrderedCollection new.  children := OrderedCollection new.  selectionStrategy := SGARouletteSelection new.! !!SSTestShifter methodsFor: 'inserting'!insertAsParameter: expression after: aStatement	(self random collectAtRandom: (statements		copyFrom: (statements indexOf: aStatement) + 1		to: self length))		do: [ :stm | [ | mutatedStm |			mutatedStm := stm replaceArgBy: expression.			(mutatedStm pickUpReferences: expression) ifNotEmpty: 				[ mutatedStm value mutated: true.				mutatedStm needsBeFixed: true ].			 ^ mutatedStm ]				on: SError				do: [  ] ].	self		error: 'Cannot insert any parameter by: ' , expression printString! !!SSTestShifter methodsFor: 'inserting'!insertExpression: expression after: aStatement	^ self		addStatement: (self newAssignment: expression)		after: aStatement! !!SSTestShifter methodsFor: 'inserting'!insertExpressionRandomly	(self random collectAtRandom: #(#insertRandomMessage:using: #insertMethodMessage:using: #insertAsParameter:using:))		do: [ :selector | 			[ | insertedStm |			insertedStm := self insertStatementOfSelector: selector.			insertedStm value mutated ifTrue: [ self fixTypeReturnOf: insertedStm ].			^ insertedStm ]				on: Error				do: [  ] ]! !!SSTestShifter methodsFor: 'inserting'!insertStatement	| l stop alpha count |	l := 1.	count := 1.	stop := self length.	alpha := 0.5.	[ l < stop and: [ self next <= (alpha raisedTo: count) ] ]		whileTrue: [ self insertExpressionRandomly.			l := l + 1.			count := count + 1 ]! !!SSTestShifter methodsFor: 'inserting'!insertStatementOfSelector: selector	(self random collectAtRandom: statements copy)		do: [ :stm | 			[ ^ self perform: selector inStatement: stm ]				on: SError				do: [  ] ].	self		error: 'Cannot insert statement of selector: ' , selector printString! !!SSTestShifter methodsFor: 'repairing'!invariant	self typeInfo		ifNil: [ self				error: 'TypeInfo is nil. Set the testCase with a typeInfo' ]! !!SSTestShifter methodsFor: 'querying'!involvedClasses		^ (self objectVariables collect:[:var| var returnType]) asSet.! !!SSTestShifter methodsFor: 'accessing'!lastMessage	^ lastMessage ! !!SSTestShifter methodsFor: 'accessing'!lastMessage: anObject 		lastMessage := anObject ! !!SSTestShifter methodsFor: 'accessing'!length  ^ statements size! !!SSTestShifter methodsFor: 'repairing'!literal: aClassName	^  self newLiteral: aClassName.	! !!SSTestShifter methodsFor: 'accessing'!maxNumberOfStatements	^ maxNumberOfStatements! !!SSTestShifter methodsFor: 'accessing'!maxNumberOfStatements: anObject	maxNumberOfStatements := anObject! !!SSTestShifter methodsFor: 'repairing'!messageUsing: method and: receiver before: aStatement	self buildArgs: method argTypes before: aStatement.	^ SMessage		newFromReceiver: receiver copy		method: method		andPreviousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement)! !!SSTestShifter methodsFor: 'repairing'!messagesVariablesFrom: aClassName	|varExpressions|	varExpressions := self		messagesVariablesWhichContain: aClassName		before: nil.	varExpressions ifEmpty: [ 		typeInfo classes at: aClassName ifPresent: [ (typeInfo classes at: aClassName) subclasses detect: [ :aClass | 			varExpressions := self messagesVariablesWhichContain: aClass name before: nil.			varExpressions isNotEmpty ] ] ifAbsent: [ 		typeInfo scalars at: aClassName ifPresent: [ 				varExpressions := self messagesVariablesWhichContain: aClassName before: nil.			varExpressions isNotEmpty ] ].		 ].	^ varExpressions! !!SSTestShifter methodsFor: 'querying'!messagesVariablesWhichContain: aClassName before: aStatement	^ (self subStatementsFrom: 1 toPrevIndexOf: aStatement)		select: [ :stm | stm referenceTo: aClassName ]		thenCollect: [ :stm | stm variable ]! !!SSTestShifter methodsFor: 'instance creation'!newAssignment: anExpression	[ ^ SAssignment		name:			(SVariable new				varName: '_var';				id: self assignId;				returnType: anExpression returnType;				yourself)		value: anExpression copy ]		on: MessageNotUnderstood		do: [ :error | 			self				error: anExpression printString , ' is not an expression.' ]! !!SSTestShifter methodsFor: 'instance creation'!newFactoryMessage: aClassName before: aStatement	| methods |	typeInfo		classAt: aClassName		ifNone: [ self				error:					'Error to create factoryMessage of: ' , aClassName						, ' because it is not found in typeInfo.' ].	self validTargetClassName: aClassName.	methods := typeInfo factoryMessagesFrom: aClassName.	^ methods		ifEmpty: [ SFactoryMessage default: aClassName ]		ifNotEmpty: [  self newFactoryMessageUsing: aClassName and: aStatement ]! !!SSTestShifter methodsFor: 'instance creation'!newFactoryMessageUsing: aClassName and: aStatement	| methods |	methods := typeInfo factoryMessagesFrom: aClassName.	(self random collectAtRandom: methods)		do: [ :method | 			[ self buildArgs: method argTypes before: aStatement.			^ SFactoryMessage				method: method				class: aClassName				previousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement) ]				on: SError				do: [  ] ].	self error: 'Error to create a factoryMessage of: ' , aClassName! !!SSTestShifter methodsFor: 'instance creation'!newFieldAccessMessageOfType: aType andReceiver: receiver	(self pickAccessorsOf: receiver returnType)		detect: [ :aMethod | aMethod returnType hasOnlyOneType and: [ aMethod returnType includes: aType ]]		ifFound: [ :aMethod | 			^ SFieldAccessMessage				newFromReceiver: receiver copy				andMethod: aMethod ]		ifNone:			[ self error: 'Cannot create a field access message of type: ' , aType, ' and receiver of type: ', receiver returnType ]! !!SSTestShifter methodsFor: 'instance creation'!newFieldAccessMessageOfType: aType before: aStatement	(self factoryMessageVariablesBefore: aStatement)		do: [ :receiver | 			[ ^ self newFieldAccessMessageOfType: aType andReceiver: receiver ]				on: SError				do: [  ] ].	self error: 'Cannot create a field access message of type: ' , aType! !!SSTestShifter methodsFor: 'instance creation'!newLiteral: aClassName	typeInfo scalars		at: aClassName		ifPresent: [ :values | 			values				ifEmpty: [ self error: 'Scalar of type: ' , aClassName , ' is empty.' ].			^ SLiteral new				returnType: aClassName;				value: (self random selectAtRandom: values asOrderedCollection) ].	self error: 'Scalars dont include: ' , aClassName! !!SSTestShifter methodsFor: 'instance creation'!newMessageOfType: aType before: aStatement	(self factoryMessageVariablesBefore: aStatement)		do: [ :receiver | 			[ ^ self newMessageOfType: aType using: receiver before: aStatement ]				on: SError				do: [  ] ].	self		error:			'Cannot create a message of type: ' , aType printString				,					'. A possible reason is because there is none factoryMessage which has a message of this return type.'! !!SSTestShifter methodsFor: 'instance creation'!newMessageOfType: aType using: receiver before: aStatement	(self pickMessagesOf: receiver returnType)		detect: [ :aMethod | aMethod returnType hasOnlyOneType and: [ aMethod returnType includes: aType ] ]		ifFound: [ :aMethod | 			[ ^ self messageUsing: aMethod and: receiver before: aStatement ]				on: SError				do: [  ] ].	^ self		error:			'Error to create a message of type: ' , aType				, ' with receiver of type: ' , receiver returnType! !!SSTestShifter methodsFor: 'repairing'!newStatementOfType: aType before: aStatement	(self random collectAtRandom: #(#newFactoryMessage:before: #newLiteral: #newFieldAccessMessageOfType:before: #newMessageOfType:before:))		do: [ :message | 			[ ^ self				perform: message				withEnoughArguments: (Array with: aType with: aStatement) ]				on: SError				do: [ "try with the next one" ] ].	self error: 'Cannot create expression of returnType: ' , aType! !!SSTestShifter methodsFor: 'accessing'!notEmpty  ^ self length > 0! !!SSTestShifter methodsFor: 'accessing'!numMaxStatements	^ maxNumberOfStatements! !!SSTestShifter methodsFor: 'accessing'!numMaxStatements: anObject	maxNumberOfStatements := anObject! !!SSTestShifter methodsFor: 'querying'!objectVariables		^ statements select:[:stm| 			stm needsBeFixed not and: 				[ (self typeInfo classAt: stm returnType ifNone:[nil]) isNil not]] 		thenCollect:[:stm| stm variable].! !!SSTestShifter methodsFor: 'accessing'!parents	^ parents! !!SSTestShifter methodsFor: 'parsing'!parseTree	| stmList |	stmList := self statements, (lastMessage ifNil: [#()] ifNotNil: [Array with: lastMessage]).	SPlatform asDict 		ifTrue: [ ^ self parseTreeAsDictWith: stmList ]		ifFalse: [ ^ self parseTreeWith: stmList]! !!SSTestShifter methodsFor: 'parsing'!parseTreeAsDictWith: statementCollection	| node temporaries rbParserClass |	statementCollection ifEmpty: [ self error: 'testCase does not have statements' ].	rbParserClass := SPlatform rbParserClass.	node := rbParserClass parseExpression: '[]'.	temporaries := Array with: (self aVariableNodeClass named: 'var').	node body temporaries: temporaries.	node body addNode: (rbParserClass parseExpression: 'var := Dictionary new.').	statementCollection		do: [ :stm | 			| aNode |			[ aNode := rbParserClass parseExpression: (self getStringOf: stm).			node body addNode: aNode ]				on: Error				do: [  ] ].	^ node! !!SSTestShifter methodsFor: 'parsing'!parseTreeWith: statementCollection	| node temporaries rbParserClass |	statementCollection ifEmpty: [ self error: 'testCase does not have statements' ].	rbParserClass := SPlatform rbParserClass.	node := rbParserClass parseExpression: '[]'.	temporaries := (self allVarNames		collect: [ :varName | rbParserClass parseExpression: varName ]) 		select: [:e | e isKindOf: self aVariableNodeClass ].	node body temporaries: temporaries.	statementCollection		do: [ :stm | 			| aNode |			[ aNode := rbParserClass parseExpression: (self getStringOf: stm).			node body addNode: aNode ]				on: Error				do: [  ] ].	^ node! !!SSTestShifter methodsFor: 'parsing'!parseTreeWithAssertions	| stmList |	stmList := self statements, (lastMessage ifNil: [#()] ifNotNil: [Array with: lastMessage]), self assertions.	SPlatform asDict 		ifTrue: [ ^ self parseTreeAsDictWith: stmList ]		ifFalse: [ ^ self parseTreeWith: stmList]! !!SSTestShifter methodsFor: 'repairing'!perform: selector inStatement: stm	^ stm		perform: selector		withArguments:			(Array with: stm copy with:			self)! !!SSTestShifter methodsFor: 'querying'!pickAccessorsOf: aType	^ typeInfo accessMessagesFrom: aType! !!SSTestShifter methodsFor: 'querying'!pickAnObjectVariable	| variables |	variables := self objectVariables.	variables		ifEmpty: [ self addFactoryMessage.			variables := self objectVariables ].	^ self random selectAtRandom: variables! !!SSTestShifter methodsFor: 'querying'!pickMessagesOf: aType	^ typeInfo messagesFrom: aType! !!SSTestShifter methodsFor: 'querying'!pickObjectVariableOf: aClassName	(self random collectAtRandom: (self subStatementsFrom: 1 toPrevIndexOf: nil))		detect: [ :stm | stm returnType = aClassName ]		ifFound: [ :stm | ^ stm reference ]		ifNone: [  ].	self error: 'Does not exist a statement of type: ' , aClassName! !!SSTestShifter methodsFor: 'querying'!pickOrCreateObjectVariableOf: aClassName	^ [ self pickObjectVariableOf: aClassName ]		on: SError		do: [ (self addFactoryMessage: aClassName) variable ]! !!SSTestShifter methodsFor: 'printing'!printDescriptiveComment	^ self printSummaryFitness , (String with: Character cr)		, self printSummaryFitnessByClass! !!SSTestShifter methodsFor: 'printing'!printFunctionByClassName: dict on: stream	(dict associations select: [ :assoc | assoc value > 0 ])		do: [ :assoc | 			stream				nextPutAll: assoc key;				nextPut: $:;				nextPutAll: assoc value printString;				nextPut: $%;				nextPutAll: (String with: Character cr) ]! !!SSTestShifter methodsFor: 'printing'!printStatements	^ statements collect: #printString! !!SSTestShifter methodsFor: 'printing'!printSummaryFitness	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"Fitness: ';				nextPut: Character cr.			fitness				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: ': ';						nextPutAll: assoc value printString;						nextPut: Character cr ].			stream				nextPutAll: '"' ]! !!SSTestShifter methodsFor: 'printing'!printSummaryFitnessByClass	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"This test covers: ';				nextPut: Character cr.			fitnessByClass				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: (String with: Character cr).					self printFunctionByClassName: assoc value on: stream ].			stream				nextPutAll: '"';				nextPutAll: (String with: Character cr) ]! !!SSTestShifter methodsFor: 'repairing'!randomIndexToAdd: aExpression before: aStatement	| refIndexes anIndex |	anIndex := statements indexOf: aStatement.	anIndex = 0		ifTrue: [ ^ self length ].	refIndexes := self referencesIndexes: aExpression.	anIndex := anIndex - 1.	refIndexes		ifNotEmpty: [ | ini end maxIndex |			maxIndex := refIndexes max.			ini := anIndex min: maxIndex.			end := anIndex max: maxIndex.			^ self random selectAtRandom: (ini to: end) ].	anIndex = 0		ifTrue: [ ^ anIndex ].	^ self random selectAtRandom: (1 to: anIndex)! !!SSTestShifter methodsFor: 'inserting'!randomLiteralClassName	^ [ self random selectAtRandom: typeInfo scalars keys asOrderedCollection  ]		on: Error		do: [ self				error: 'TypeInfo does not have scalars. Set scalars on typeInfo.' ]! !!SSTestShifter methodsFor: 'repairing'!referencesIndexes: expression	^ ((expression variablesWithId ) allButFirst collect: [ :var | statements indexOf: (self statementOfVarName: var printString) ])! !!SSTestShifter methodsFor: 'removing'!removeChild: testCase	| index |	index := 0.	children detect: [:tC | index := index + 1.		(tC generationNumber == testCase generationNumber) and: [ tC idPopulation == testCase idPopulation ] ]		ifFound: [ :tC | children removeAt: index ]! !!SSTestShifter methodsFor: 'removing'!removeExpression: expression	self removeFromStatements: expression.	statements copy do: [ :stm | (stm pickUpReferences: expression) ifNotEmpty: [ self repairReferenceTo: expression of: stm ] ].! !!SSTestShifter methodsFor: 'removing'!removeExpressionWithoutRepairing: expression	self removeFromStatements: expression.	[ self statementAt: expression ]		on: SError		do: [ (self statements copy				flatCollect: [ :stm | 					(stm pickUpReferences: expression)						ifNotEmpty: [ Array with: stm ] ])				do: [ :stm | self removeExpressionWithoutRepairing: stm ] ]! !!SSTestShifter methodsFor: 'removing'!removeFromStatements: expression	[ statements remove: expression ]		on: Error		do: [ self error: expression printString , ' is not found.' ]! !!SSTestShifter methodsFor: 'removing'!removeStatement	"If other statements refer the statement to remove, then this reference is replaced with another value out of the set which has the same type"	statements ifEmpty: [ ^ #() ].	self		removeStatement:			(statements				at: (self random selectAtRandom: (1 to: self length) asArray)).! !!SSTestShifter methodsFor: 'removing'!removeStatement: anExpression	self removeExpression: (self statementAt: anExpression)! !!SSTestShifter methodsFor: 'removing'!removeStatementNoRepairing: aStatement	"remove all statements that reference to statement because this cant be fixed"	self removeExpressionWithoutRepairing: (self statementAt: aStatement)! !!SSTestShifter methodsFor: 'removing'!removeStatementOfVarName: varName	^ self removeStatement: (self statementOfVarName: varName) copy! !!SSTestShifter methodsFor: 'repairing'!repair: expression	[ self statementAt: expression ]		on: SError		do: [ ^ self statements copy				flatCollect: [ :stm | self repairReferenceTo: expression of: stm ] ].	self		error: expression printString , ' does not exist.'! !!SSTestShifter methodsFor: 'inserting'!repair: exprToReplace of: expression	| aType replacement |	aType := exprToReplace returnType.	replacement := (self random collectAtRandom:(self subStatementsFrom: 1 toPrevIndexOf: expression))		detect:			[ :stm | stm reference ~= exprToReplace and: [ stm returnType = aType ] ]		ifNone: [ self addStatementOfType: aType before: expression ].	self replace: exprToReplace by: replacement on: expression! !!SSTestShifter methodsFor: 'repairing'!repairReferenceTo: removedExpression of: expression	| references exprsToDelete |	references := expression pickUpReferences: removedExpression.	exprsToDelete := OrderedCollection new.	references		do: [ :reference | 			[ self repair: reference of: expression ]				on: SError				do: [ exprsToDelete add: reference ] ].	^ exprsToDelete! !!SSTestShifter methodsFor: 'repairing'!replace: exprToReplace by: otherExpression on: expression	(self statementAt: expression)		replaceExpression: exprToReplace 		by: otherExpression ! !!SSTestShifter methodsFor: 'inserting'!selectMethod: aCollection 	selectionStrategy ifNil: [ ^ self random selectAtRandom: aCollection ]	ifNotNil: [ ^ selectionStrategy selectJustOneOf: aCollection with: (aCollection collect: #executions) ]	! !!SSTestShifter methodsFor: 'accessing'!selectionStrategy: selectStrategy	selectionStrategy := selectStrategy ! !!SSTestShifter methodsFor: 'accessing'!statementAt: statement	statements		detect: [ :stm | stm = statement ]		ifFound: [ :stm | ^ stm ].	self		error: 'Statement: ' , statement printString , ' is not found in testCase.'! !!SSTestShifter methodsFor: 'accessing'!statementOfVarName: aString	statements		detect: [ :stm | stm reference printString = aString ]		ifFound: [ :stm | ^ stm ].	self error: 'Statement of varName: ' , aString, 'is not found.'! !!SSTestShifter methodsFor: 'accessing'!statements	^ statements! !!SSTestShifter methodsFor: 'repairing'!statementsOfType: aType before: expression	(statements includes: expression)		ifFalse: [ self error: 'Statement: ', expression printString , 'is not found in testCase.' ].	^ (self subStatementsFrom: 1 toPrevIndexOf: expression)		select: [ :stm | stm returnType = aType ]! !!SSTestShifter methodsFor: 'repairing'!subStatementsAfterIndexOf: aStatement	| start |	start := statements indexOf: aStatement.	start < self length		ifFalse: [ ^ Array new ].	^ statements copyFrom: start + 1 to: self length! !!SSTestShifter methodsFor: 'repairing'!subStatementsFrom: start toPrevIndexOf: aStatement	| stop |	stop := statements indexOf: aStatement.	stop = 0		ifTrue: [ ^ statements ].	start <= stop		ifFalse: [ ^ self error: start printString, ' (indexIni) is greater than ', stop printString, ' (indexPos).' ].	^ statements copyFrom: start to: stop - 1! !!SSTestShifter methodsFor: 'accessing'!targetClassesNames	^ targetClassesNames ! !!SSTestShifter methodsFor: 'accessing'!typeInfo	^ typeInfo! !!SSTestShifter methodsFor: 'accessing'!typeInfo: anObject	typeInfo := anObject! !!SSTestShifter methodsFor: 'repairing'!updateNextId 	nextId = 0 ifTrue: [ nextId := statements size ]! !!SSTestShifter methodsFor: 'accessing'!validReferences	| references |	references := Set new.	^ statements		detect: [ :stm | 			| variables |			variables := stm variablesWithId asSet.			references add: stm reference.			(references includesAll: variables)				ifFalse: [self halt. true ]				ifTrue: [ references addAll: variables.					false ] ]		ifFound: [ false ]		ifNone: [ true ]! !!SSTestShifter methodsFor: 'accessing'!validTargetClassName: aClassName	(validatedTargetClassName		and: [ (targetClassesNames includes: aClassName) not				and: [ |classInfo|					classInfo := typeInfo classAt: aClassName ifNone: [].					classInfo isNil not and: [ classInfo allMethods isNotEmpty ] ] ])		ifTrue: [ self addTargetClassName: aClassName ].	((targetClassesNames includes: aClassName) not		or: [ typeInfo isAbstractClass: aClassName ])		ifTrue: [ [typeInfo scalars at: aClassName ] on: Error do:[ self error: 'Class: ' , aClassName , ' is not able to be used.' ]]		ifFalse: [ validatedTargetClassName := true ]! !!STestCaseFactory class methodsFor: 'settings-colors'!darkColors	^ Dictionary new 		at: 'background' put: (Color r: 0.12549019607843137 g: 0.1803921568627451 b: 0.23529411764705882);		at: 'backgroundTestCase' put: (Color r: 0.1607843137254902 g: 0.3686274509803922 b: 0.4470588235294118);		at: 'backgroundHigherFitnessTestCase' put:  (Color fromHexString: '1B8D8D' "'0B6969'""'1E7676'");		at: 'scaleLighter' put: (Color r: 0.5098039215686274 g: 0.9607843137254902 b: 0.7725490196078432);		at: 'scaleDarker' put: (Color r: 0.30980392156862746 g: 0.6235294117647059 b: 0.49019607843137253);		at: 'baseBar' put: (Color r: 0.7647058823529411 g: 0.803921568627451 b: 0.788235294117647);		at: 'forwardBar' put: (Color r: 0.5098039215686274 g: 0.9607843137254902 b: 0.7725490196078432);		at: 'backwardBar' put: (Color r: 1 g: 0 b: 0.25098039215686274);		at: 'edge' put: (Color r: 0.7647058823529411 g: 0.803921568627451 b: 0.788235294117647);		at: 'classCoverage' put: (Color r: 0.5098039215686274 g: 0.7803921568627451 b: 0.9607843137254902);		at: 'methodCoverage' put: (Color r: 0.9607843137254902 g: 0.5098039215686274 b: 0.7215686274509804);		at: 'statementCoverage' put: (Color r: 0.5098039215686274 g: 0.9607843137254902 b: 0.7725490196078432);		at: 'highlightTestCase' put: (Color r: 0.13725490196078433 g: 0.7215686274509804 b: 0.7725490196078432 alpha: 0.8);		at: 'highlightMethod' put: Color cyan;		at: 'fontMethodBox' put: Color white;		at: 'border' put: Color white;		at: 'axis' put: Color white;		at: 'fittestCoverage' put: (Color r: 0 g: 1 b: 0.67);		at: 'averageCoverage' put: (Color r: 0.5063538611925709 g: 0.5259042033235581 b: 0.8357771260997068);		at: 'lowestCoverage' put: (Color pink);		at: 'seedCoverage' put: (Color r: 0.9530791788856305 g: 0.5102639296187683 b: 0.43499511241446726);		at: 'font' put: Color white;		at: 'rangeMethodColor' put:			(#('83142C' 'AF0404' 'BB1542' 'ED3833' 'EB5F5D' 'F3826F' 'FFBA92' 'F0DAB1' 'FFF8CD' 'F7FF56' 'DCFFCC' 'DDF796' 'C3F584' 'A3F7BF' '6bffb8' '42E6A4' '4DD599' '71A95A' '007944' '00818A' '216583' '366ED8' '64C4ED' '5EDFFF' 'B2FCFF' 'FFEDFF' 'C6CBEF' '8186D5' '494CA2' '560764' '930077' 'D527B7' 'FF78AE' 'FFA0D2' ) collect: [:c | Color fromHexString: c ]);		yourself.! !!STestCaseFactory class methodsFor: 'settings-colors'!lightColors	^ Dictionary new 		at: 'background' put: Color white;		"at: 'backgroundTestCase' put: (Color r: 0.1607843137254902 g: 0.3686274509803922 b: 0.4470588235294118);"		at: 'backgroundTestCase' put: (Color fromHexString: 'ebecf0');		"at: 'backgroundHigherFitnessTestCase' put: (Color fromHexString: '1B8D8D' '0B6969' '1E7676');"		at: 'borderTestCase' put: (Color r: 0.1607843137254902 g: 0.3686274509803922 b: 0.4470588235294118);		at: 'scaleLighter' put: (Color r: 0 g: 1 b: 0.67);		at: 'scaleDarker' put: (Color r: 0 g: 0 b: 0 alpha: 0.1)"(Color r: 0.30980392156862746 g: 0.6235294117647059 b: 0.49019607843137253)";		at: 'baseBar' put: Color white;		at: 'forwardBar' put: (Color r: 0.611764705882353 g: 0.6431372549019608 b: 0.6274509803921569);		at: 'backwardBar' put: (Color r: 1 g: 0 b: 0.25098039215686274);		at: 'edge' put: (Color r: 0.611764705882353 g: 0.6431372549019608 b: 0.6274509803921569);		at: 'classCoverage' put: (Color r: 0.05 g: 0.75 b: 0.91);		at: 'methodCoverage' put: (Color r:0.88 g:0.26 b:0.5);		at: 'statementCoverage' put: (Color r: 0 g: 1 b: 0.67);		at: 'highlightTestCase' put: (Color r: 0.13725490196078433 g: 0.7215686274509804 b: 0.7725490196078432 alpha: 0.8);		at: 'highlightMethod' put: Color cyan"(Color r: 111/255 g: 1 b: 233/255)";		"at: 'fontMethodBox' put: Color white;"		at: 'fontMethodBox' put: Color black;		at: 'border' put: (Color r: 0.12549019607843137 g: 0.1803921568627451 b: 0.23529411764705882);		at: 'axis' put: (Color r: 0.12549019607843137 g: 0.1803921568627451 b: 0.23529411764705882);		at: 'fittestCoverage' put: (Color r: 0 g: 1 b: 0.67);		at: 'averageCoverage' put: (Color r: 0.5063538611925709 g: 0.5259042033235581 b: 0.8357771260997068);		at: 'lowestCoverage' put: (Color pink);		at: 'seedCoverage' put: (Color r: 0.9530791788856305 g: 0.5102639296187683 b: 0.43499511241446726);		at: 'font' put: (Color r: 0.12549019607843137 g: 0.1803921568627451 b: 0.23529411764705882);		at: 'rangeMethodColor' put:			(#('83142C' 'AF0404' 'BB1542' 'ED3833' 'EB5F5D' 'F3826F' 'FFBA92' 'F0DAB1' 'FFF8CD' 'F7FF56' 'DCFFCC' 'DDF796' 'C3F584' 'A3F7BF' '6bffb8' '42E6A4' '4DD599' '71A95A' '007944' '00818A' '216583' '366ED8' '64C4ED' '5EDFFF' 'B2FCFF' 'FFEDFF' 'C6CBEF' '8186D5' '494CA2' '560764' '930077' 'D527B7' 'FF78AE' 'FFA0D2' ) collect: [:c | Color fromHexString: c ]);		yourself.! !!STestCaseFactory methodsFor: 'actions'!asDict: aBoolean	initialAsDict := aBoolean.	SPlatform asDict: aBoolean! !!STestCaseFactory methodsFor: 'actions'!checkInvariants	self assert: typeInfo isNil not description: 'Please provide type information of the target project'.	self assert: targetPackageRegex isNil not description: 'Please provide a regex that match the packages under analysis'! !!STestCaseFactory methodsFor: 'accessing'!classesForRegex: regexExpressions	^ (regexExpressions		flatCollect: [ :regex | 			RPackage organizer packages				select: [ :p | regex match: p name printString ] ]) asSet		flatCollect: #definedClasses! !!STestCaseFactory methodsFor: 'actions'!createConfigurationMethods	| class |	class := self getClassOf: ('GA' , self targetClassName , 'Test').	setUpMethod ifNotNil: [ class compile: setUpMethod  ].	tearDownMethod ifNotNil: [ class compile: tearDownMethod ]! !!STestCaseFactory methodsFor: 'actions'!createTestCases	self checkInvariants.	self setUp.	self run.	self tearDown.! !!STestCaseFactory methodsFor: 'accessing'!crossoverRate: aNumber	engine crossoverRate: aNumber! !!STestCaseFactory methodsFor: 'accessing'!elitismRate: aNumber	engine elitismRate: aNumber! !!STestCaseFactory methodsFor: 'accessing'!engine	^ engine! !!STestCaseFactory methodsFor: 'accessing'!engineDefault	^ SGAEngine new		fitness: fitness;		numberOfStatements: 30;		numberOfGenerations: numberOfIterations;		yourself.! !!STestCaseFactory methodsFor: 'actions'!export: aTestCase with: aSelector	| class |	class := self getClassOf: ('GA' , self targetClassName , 'Test').	[ aTestCase generateAssertions.	class		compile:			(SPlatform rbParserClass				parseMethod:					aSelector , aTestCase printDescriptiveComment						, aTestCase parseTreeWithAssertions body formattedCode)				formattedCode ]		on: Error		do: [ | carReturn |			carReturn := String with: Character cr.			class				compile:					aSelector , carReturn , 'self should:'						, aTestCase parseTree formattedCode , carReturn						, ' raise:Error.' , carReturn ]! !!STestCaseFactory methodsFor: 'actions'!exportTests	| index |	index := 1.	engine population		do: [ :test | 			test lastMessage: lastMessage.			self export: test with: ('test{1}' format: {index}).			index := index + 1 ].	self createConfigurationMethods! !!STestCaseFactory methodsFor: 'accessing'!firstExecution	^ firstExecution ifNil: [ firstExecution := true ] ifNotNil: [ false ]! !!STestCaseFactory methodsFor: 'configuration'!fitness	^ fitness! !!STestCaseFactory methodsFor: 'configuration'!fitness: aFitness	fitness := aFitness! !!STestCaseFactory methodsFor: 'accessing'!fitnessSeed	^ fitnessSeed ! !!STestCaseFactory methodsFor: 'accessing'!fitnessSeedCalculated: number 	fitnessSeed := number! !!STestCaseFactory methodsFor: 'actions'!getClassOf: aString	| aClassName class |	aClassName := aString asSymbol.	class := SPlatform lookUpClass: aClassName.	class		ifNil: [ class := SPlatform				createTestCaseClass: aClassName				inPackage: self outputPackageName].	^ class! !!STestCaseFactory methodsFor: 'accessing'!initialAsDict	^ initialAsDict ! !!STestCaseFactory methodsFor: 'accessing'!initialSeed	^ initialSeed ! !!STestCaseFactory methodsFor: 'initialization'!initialize	SPlatform resetRandomGenerator.	super initialize.	fitness := SMethodCoverage new.	numberOfIterations := 20.	engine := self engineDefault.	fitnessSeed := 0.	outputPackageName := 'SmallSuiteGenerator-Tests-Generated'.	initialSeed := 100.	initialAsDict := false.! !!STestCaseFactory methodsFor: 'actions'!initializeProfiler	self subclassResponsibility 	! !!STestCaseFactory methodsFor: 'configuration'!lastMessage: aMessage	lastMessage := aMessage.	engine lastMessage: aMessage ! !!STestCaseFactory methodsFor: 'accessing'!numberOfGenerations	^ numberOfIterations! !!STestCaseFactory methodsFor: 'initialization'!numberOfGenerations: aNumber	engine numberOfGenerations: aNumber.	numberOfIterations := aNumber.! !!STestCaseFactory methodsFor: 'configuration'!numberOfStatements: aInt	engine numberOfStatements: aInt! !!STestCaseFactory methodsFor: 'accessing'!outputPackageName	^ outputPackageName! !!STestCaseFactory methodsFor: 'accessing'!outputPackageName: anObject	outputPackageName := anObject! !!STestCaseFactory methodsFor: 'configuration'!populationSize: int	engine populationSize: int! !!STestCaseFactory methodsFor: 'accessing'!reportClass	reportClass ifNil: [ reportClass := SReportSTestCaseFactory on: self ].	^ reportClass ! !!STestCaseFactory methodsFor: 'actions'!run	engine run.	! !!STestCaseFactory methodsFor: 'running'!run: aNumber	numberOfIterations := aNumber.	self createTestCases! !!STestCaseFactory methodsFor: 'instance creation'!seed: aNumber 	initialSeed := aNumber.	SPlatform seed: aNumber! !!STestCaseFactory methodsFor: 'configuration'!seedBlock: aBlock 		fitnessSeed := (self aSLProfilerCoverage profile: aBlock inPackagesMatching:targetPackageRegex) statementCoverageFor: targetClassName.! !!STestCaseFactory methodsFor: 'actions'!selectionStrategy: aSelectionStrategy	engine selectionStrategy: aSelectionStrategy ! !!STestCaseFactory methodsFor: 'actions'!selectionStrategyTestCase: aSelectionStrategy	engine selectionStrategyTestCase: aSelectionStrategy ! !!STestCaseFactory methodsFor: 'actions'!setUp		self initializeProfiler.	self firstExecution ifTrue: [	SPlatform resetRandomGenerator.	fitness profiler: profiler;		typeInfo: typeInfo;		targetClass: self targetClassName.	engine fitness: fitness;		numberOfGenerations: numberOfIterations;		typeInfo: self typeInfo;		targetClassName: self targetClassName;		targetPackageRegex: targetPackageRegex.	typeInfoSeed := (typeInfo classAt: targetClassName) deepCopy]ifFalse: [ engine fitness profiler: profiler.	engine numberOfGenerations: numberOfIterations ]! !!STestCaseFactory methodsFor: 'actions'!setUpMethod: anObject	setUpMethod := anObject 	! !!STestCaseFactory methodsFor: 'accessing'!targetClassName	^ targetClassName ! !!STestCaseFactory methodsFor: 'accessing'!targetClassName: aSymbol	targetClassName := aSymbol.! !!STestCaseFactory methodsFor: 'accessing'!targetPackageRegex	^ targetPackageRegex! !!STestCaseFactory methodsFor: 'accessing'!targetPackageRegex: anObject	targetPackageRegex := anObject.	engine packageRegex: anObject ! !!STestCaseFactory methodsFor: 'actions'!tearDown	self uninstall.	self exportTests.	SPlatform asDict: false.	SPlatform resetRandomGenerator ! !!STestCaseFactory methodsFor: 'actions'!tearDownMethod: anObject	tearDownMethod := anObject 	! !!STestCaseFactory methodsFor: 'accessing'!typeInfo 	^ typeInfo! !!STestCaseFactory methodsFor: 'accessing'!typeInfo: aTypeInfo	typeInfoOrigin := aTypeInfo copy.	typeInfo := aTypeInfo! !!STestCaseFactory methodsFor: 'accessing'!typeInfoOrigin	^ typeInfoOrigin ! !!STestCaseFactory methodsFor: 'accessing'!typeInfoSeed	^ typeInfoSeed! !!STestCaseFactory methodsFor: 'actions'!uninstall! !!STestCaseFactoryPharo methodsFor: 'actions'!initializeProfiler	profiler := self aSLProfilerCoverage profilerForPackagesMatching: self targetPackageRegex.	(profiler allMethods select: #isNotMethodExtension)		do: #installGhosts		displayingProgress: 'Instrumenting ' , self targetPackageRegex.! !!STestCaseFactoryPharo methodsFor: 'actions'!uninstall	profiler uninstall! !!STestCaseFactoryExample methodsFor: 'accessing'!clean	Spy2 clean.S2Profiler remove.! !!STestCaseFactoryExample methodsFor: 'examples - onPackages'!exampleEmptyBlockOnPackages	|facade|	self clean.	facade := SPlatform classTestCaseFactory.	^ facade new		typeInfo:			(SSTypeCollector				profile: [  ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario');		fitness: SMethodCoverage new;		targetClassName: #SFoo;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onClass'!exampleSSTeacherOnClass	| typeInfo facade|	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onClass: SSTeacher.	^ facade new		typeInfo: typeInfo;		fitness: SMethodCoverage new;		targetClassName: #SSTeacher;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onPackages'!exampleSSTeacherOnPackages	| typeInfo facade |	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SSTeacher;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onClass'!exampleSStackOnClass	| typeInfo facade |	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStack newStackWith: #(1 5 3 2))				pop;				top;				push: 4 ]		onClass: SStack.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SStack;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onPackages'!exampleSStackOnPackages	| typeInfo facade |	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStack newStackWith: #(1 5 3 2))				pop;				top;				push: 4 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	^ facade new		typeInfo: typeInfo;		fitness: SStatementCoverage new;		targetClassName: #SStack;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onClass'!exampleSStudentOnClass	| typeInfo facade |	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		onClass: SStudent.	^ facade new		typeInfo: typeInfo;		fitness: SStatementCoverage new;		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onClass'!exampleWithSubclassToRun	| typeInfo facade |	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario2'.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario2';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onClass'!exampleWithWrongClassToRun	| typeInfo facade |	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		onClass: SFoo.	^ facade new		typeInfo: typeInfo;		fitness: SStatementCoverage new;		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario2';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STestCaseFactoryExample methodsFor: 'examples - onPackages'!exampleWithWrongRegexToRun	| typeInfo facade |	self clean.	facade := SPlatform classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself! !!STypeInfo class methodsFor: 'converting'!asTypeInfo: aTypeCollector	^ self new asTypeInfo: aTypeCollector ! !!STypeInfo class methodsFor: 'converting'!asTypeInfo: aTypeCollector methodsBlacklist: aList	^ self new blackList: aList; asTypeInfo: aTypeCollector" methodsBlacklist: aList"! !!STypeInfo methodsFor: 'comparing'!= other	^ self class = other class		and: [ types = other types				and: [ | otherScalars |					otherScalars := other scalars.					scalars keys = otherScalars keys						and: [ (scalars values collect: #size)								= (otherScalars values collect: #size) ] ] ]! !!STypeInfo methodsFor: 'accessing'!accessMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType accessMessages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]! !!STypeInfo methodsFor: 'adding'!addClassInfo: aTypeClassInfo	types		at: aTypeClassInfo typeName		ifPresent: [ :aTypeClass | aTypeClass joinWith: aTypeClassInfo ]		ifAbsentPut: [ aTypeClassInfo ].	self joinScalars: aTypeClassInfo scalars! !!STypeInfo methodsFor: 'converting'!asTypeInfo: aTypeCollector	self cleanBlockClosuresOf: aTypeCollector.	aTypeCollector allClasses		do: [ :aSpyClass | 			blackList select: [ :aMethod | aMethod origin name == aSpyClass className ] 				thenDo: [:aMethod | aSpyClass removeMethod: aMethod ].			(aSpyClass className endsWith: 'BlockClosure')				ifFalse: [ self addClassInfo: (STypeClassInfo asClassInfo: aSpyClass) ] ].	self joinScalars: aTypeCollector scalars copy.	^ self! !!STypeInfo methodsFor: 'accessing'!blackList: aList	blackList := aList! !!STypeInfo methodsFor: 'accessing'!classAt: aClassName	^ types at: aClassName! !!STypeInfo methodsFor: 'accessing'!classAt: aClassName ifNone: aBlock	^ types at: aClassName ifAbsent: aBlock! !!STypeInfo methodsFor: 'lookup'!classMethodType: aSelector from: aClassName	aSelector = #new		ifTrue: [ ^ self defaultFactoryMessageFrom: aClassName ].	(self factoryMessagesFrom: aClassName)		detect: [ :aMessage | aMessage selector = aSelector ]		ifFound: [ :aMessage | ^ aMessage ].	self		error:			'ClassMethodType of selector: ' , aSelector				, ' is not found in class: ' , aClassName! !!STypeInfo methodsFor: 'accessing'!classes	classes ifNil: [ classes := Dictionary new ].	types		keysDo: [ :aClassName | 			classes				at: aClassName				ifAbsentPut: (SPlatform lookUpClass: aClassName) ].	^ classes! !!STypeInfo methodsFor: 'converting'!cleanBlockClosuresOf: aTypeCollector 	[ |cleanBlocks|		cleanBlocks := (aTypeCollector scalars at: #BlockClosure) select: [ :aBlock | aBlock isClean ].		aTypeCollector scalars at: #BlockClosure put: cleanBlocks ]	on: Error	do: [].! !!STypeInfo methodsFor: 'adding'!completeTypeInfo	self types keysDo: [:aClass | |classInfo realClassInfo|	classInfo := SmallTypeCollector new collectTypeFrom: aClass asClass.	realClassInfo := self types at: aClass.	classInfo methodTypes keysAndValuesDo: [ :key :value |		((self isInBlackListClass: aClass with: key) not and: [ key isUnary not and: [ value argTypes allSatisfy: [ :arg | arg types notEmpty ] ] ]) 		ifTrue: [			realClassInfo methodTypes 			at: key			ifAbsentPut: [ 				self updateArgsOf: value.				value returnType types ifEmpty: [value returnType type: #SUndefinedObject].				value receiver type: aClass.				value hasProfiler: false.				value executions: 0.5 ] ] ] ]! !!STypeInfo methodsFor: 'copying'!copy	| copy |	copy := self class new.	types		do: [ :aClassTypeInfo | copy addClassInfo: aClassTypeInfo copy ].	copy scalars: scalars copy.	^ copy! !!STypeInfo methodsFor: 'accessing structure variables'!defaultFactoryMessageFrom: aClassName	(self messagesFrom: aClassName)		detect: [ :message | message selector = #initialize ]		ifFound: [ ^ STypeMethodInfo				type:					#new						->							(Array								with: aClassName								with: aClassName								with: #()								with: false) ].	self error: 'ClassMethodType of selector new cannot be applied at class: ', aClassName! !!STypeInfo methodsFor: 'error handling'!error: aString	^ SError signal: aString! !!STypeInfo methodsFor: 'actions'!exportDataCSV: neoCSVWriter withFilter: aSymbol	types		do: [ :type | type exportDataCSV: neoCSVWriter withFilter: aSymbol ]! !!STypeInfo methodsFor: 'lookup'!factoryMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType factoryMessages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]! !!STypeInfo methodsFor: 'initialization'!initialize	super initialize.	types := Dictionary new.	scalars := Dictionary new.	self initializeBlackList! !!STypeInfo methodsFor: 'initialization'!initializeBlackList	blackList ifNil: [ blackList := OrderedCollection new ]! !!STypeInfo methodsFor: 'accessing'!isAbstractClass: symbol	| aClass |	aClass := self classes at: symbol.	^  (aClass methods select: #isAbstract) isNotEmpty! !!STypeInfo methodsFor: 'accessing'!isInBlackListClass: aClass with: selector 	^ (blackList anySatisfy: [:each | (each origin name = aClass) & (each selector = selector) ]) ! !!STypeInfo methodsFor: 'actions'!joinScalars: aDict	aDict associations do: [ :assoc | 		scalars			at: assoc key			ifPresent: [ :values | 			scalars at: assoc key put: (values union: assoc value) asArray ]			ifAbsentPut: [ assoc value asArray ] ]! !!STypeInfo methodsFor: 'actions'!joinWith: otherTypeInfo	otherTypeInfo types		do: [ :aTypeClass | self addClassInfo: aTypeClass ].		self joinScalars: otherTypeInfo scalars! !!STypeInfo methodsFor: 'accessing'!messagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType messages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]! !!STypeInfo methodsFor: 'lookup'!methodType: aSelector from: aClassName	types		do: [ :aTypeClassInfo | 			aTypeClassInfo messagesAndAccessMessages				detect: [ :aMessage | 					(aMessage isFromReceiver: aClassName)						and: [ aMessage selector = aSelector ] ]				ifFound: [ :aMessage | ^ aMessage ]				ifNone: [ false ] ].	^ self error: 'MethodType of selector: ', aSelector , ' is not found in class: ' , aClassName! !!STypeInfo methodsFor: 'accessing'!noneAbstractClasses	noneAbstractClasses ifNil: [ 		noneAbstractClasses := self classes associations			select: [ :assoc | (self isAbstractClass: assoc key) not ]			thenCollect: [ :assoc | assoc value ] ].	^ noneAbstractClasses! !!STypeInfo methodsFor: 'accessing'!reportFrequencyByFilter	| report |	report := Dictionary new.	(STypeMethodInfo selectorsFilter, #(#others #all))		do: [ :aSelector | 			report				at: aSelector				put:					(types						inject: 0						into: [ :sum :type | sum + (type reportFrequencyByFilter: aSelector) ]) ].	^ report! !!STypeInfo methodsFor: 'actions'!scalar: aClassName with: aValue	scalars at: aClassName put: aValue asSet asArray! !!STypeInfo methodsFor: 'accessing'!scalars	^ scalars! !!STypeInfo methodsFor: 'accessing'!scalars: aDictionary	aDictionary associationsDo: [ :assoc | 		self scalar: assoc key with: assoc value ]! !!STypeInfo methodsFor: 'accessing structure variables'!type: aAssoc	self addClassInfo: (STypeClassInfo type: aAssoc)! !!STypeInfo methodsFor: 'accessing'!types 	^ types! !!STypeInfo methodsFor: 'lookup'!updateArgsOf: aMethod 	aMethod argTypes do: [ :argType |	| includeTypes |	includeTypes := argType types anySatisfy: [ :type | self scalars keys includes: type ].	includeTypes ifFalse: [ 		argType types do: [ :type | 			self scalars keys 				select: [ :scalar | (type asClass allSubclasses collect: #name) includes: scalar ] 				thenDo: [ :scalar | argType type: scalar ] ] ] ].	"updateArgsOf: aMethod 	aMethod argTypes do: [ :argType |	| includeTypes |	includeTypes := argType types anySatisfy: [ :type | self scalars keys includes: type ].	includeTypes ifFalse: [ 		argType types do: [ :type |			(type substrings: '.') last = 'Object' ifFalse: [			self scalars keys 				select: [ :scalar | ((self classOf: type asString) first allSubclasses 					collect: [:e | e fullName asSymbol]) includes: scalar ] 				thenDo: [ :scalar | argType type: scalar ] ] ] ]]"! !!SMultiTypeInfo class methodsFor: 'instance creation'!new: aType	^ self new type: aType! !!SMultiTypeInfo methodsFor: 'comparing'!= other	^ self class = other class and: [ self types = other types ]! !!SMultiTypeInfo methodsFor: 'accessing'!commonSuperclass	| commonSuperclass |	types ifEmpty: [ ^ '' ].	commonSuperclass := SPlatform lookUpClass: types anyOne.	commonSuperclass ifNil: [ ^ '' ].	types		do: [ :aType | 			| otherClass |			otherClass := SPlatform lookUpClass: aType.			otherClass ifNil: [ ^ '' ].			(commonSuperclass isClass and: [ commonSuperclass name = #Object ])				ifTrue: [ ^ #Object ].			commonSuperclass := commonSuperclass				commonSuperclassWith: otherClass ].	^ commonSuperclass name! !!SMultiTypeInfo methodsFor: 'copying'!copy	| copy |	copy := self class instance.	types do: [ :aType | copy type: aType ].	^ copy! !!SMultiTypeInfo methodsFor: 'comparing'!equals: other	(self types size = other types size) ifFalse:[ ^ false ].		self types asOrderedCollection with: (other types asOrderedCollection) do:[ :a :b|		(a = b) ifFalse:[ ^ false ].	].	^ true.! !!SMultiTypeInfo methodsFor: 'instance creation'!fromSton: stonReader	stonReader		parseListDo: [ :each :index | 			self type: each ]	! !!SMultiTypeInfo methodsFor: 'metrics'!hasOnlyOneType	^ types size <= 1.! !!SMultiTypeInfo methodsFor: 'comparing'!hash	^ self types hash! !!SMultiTypeInfo methodsFor: 'testing'!includes: aType	^ self types includes: aType! !!SMultiTypeInfo methodsFor: 'initialization'!initialize	types := Set new.	mustBeFixed := false! !!SMultiTypeInfo methodsFor: 'metrics'!isBlockSymbol		^ types size = 2 		and: [ (types anySatisfy: [ :aType | aType = #BlockClosure ]) 			and: [ types anySatisfy:[ :aType | aType = #ByteSymbol ] ] ]! !!SMultiTypeInfo methodsFor: 'actions'!joinWith: otherTypeReturn	| hasOneType |	hasOneType := self hasOnlyOneType.		otherTypeReturn types do: [ :aType | self type: aType ].	types size > 1 ifTrue: [ types remove: #SUndefinedObject ifAbsent: [ ] ].	mustBeFixed := hasOneType and: [ types size > 1 ]! !!SMultiTypeInfo methodsFor: 'accessing'!mustBeFixed 	^ mustBeFixed! !!SMultiTypeInfo methodsFor: 'ston persistence'!stonOn: stonWriter	stonWriter		writeObject: self		streamShortList: [ :array | self types do: [:type | array add: type] ]! !!SMultiTypeInfo methodsFor: 'accessing'!type	^ types ifEmpty: [ nil ] ifNotEmpty: [ self random selectAtRandom: self types  ]! !!SMultiTypeInfo methodsFor: 'accessing structure variables'!type: aClassName	aClassName ~= #nil ifTrue: [ 		types add: aClassName ]! !!SMultiTypeInfo methodsFor: 'accessing'!types	^ types asArray! !!STypeClassInfo class methodsFor: 'converting'!asClassInfo: aSpyClass	^ self new asClassInfo: aSpyClass ! !!STypeClassInfo class methodsFor: 'instance creation'!newFrom: aClassName	^ self new		typeName: aClassName! !!STypeClassInfo class methodsFor: 'accessing structure variables'!type: aAssoc	| dataOfAllMethods inst dataMethods dataClassMethods |	inst := self new typeName: aAssoc key.	dataOfAllMethods := aAssoc value.	dataMethods := dataOfAllMethods first.	dataClassMethods := dataOfAllMethods second.	dataMethods		do: [ :data | inst typeMethod: data ].	dataClassMethods		do: [ :data | inst typeClassMethod: data ].	inst methodTypes do: [ :meth | meth executions: 1 ].	^ inst! !!STypeClassInfo methodsFor: 'comparing'!= other	^ self class = other class		and: [ typeName = other typeName				and: [ methodTypes = other methodTypes						and: [ classMethodTypes = other classMethodTypes ] ] ]! !!STypeClassInfo methodsFor: 'private'!accessMessages	^ self messagesAndAccessMessages select: #isQuick! !!STypeClassInfo methodsFor: 'adding'!addClassMethod: methodTypeInfo	"methodTypeInfo typeInfo: typeInfo."	classMethodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: methodTypeInfo.	self addScalars: methodTypeInfo scalars ! !!STypeClassInfo methodsFor: 'adding'!addClassMethods: methodTypeInfos	methodTypeInfos do: [ :aMethodType | 		self addClassMethod: aMethodType ]! !!STypeClassInfo methodsFor: 'adding'!addMethod: methodTypeInfo	"methodTypeInfo typeInfo: typeInfo."	methodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: [ methodTypeInfo ].	self addScalars: methodTypeInfo scalars! !!STypeClassInfo methodsFor: 'adding'!addMethods: methodTypeInfos	methodTypeInfos do: [ :aMethodType | self addMethod: aMethodType ]! !!STypeClassInfo methodsFor: 'adding'!addScalars: aDictionary	aDictionary associations		do: [ :assoc | 			scalars				at: assoc key				ifPresent: [ :values | scalars at: assoc key put: (values union: assoc value) asArray ]				ifAbsentPut: [ assoc value asArray ] ]! !!STypeClassInfo methodsFor: 'accessing - read only'!allMethods	^ methodTypes values , classMethodTypes values! !!STypeClassInfo methodsFor: 'converting'!asClassInfo: aSpyClass	| aTypeClass instanceMethods classMethods |	aTypeClass := self class newFrom: aSpyClass typeName.	instanceMethods := self instanceMethodsFor: aSpyClass.	classMethods := self classMethodsFor: aSpyClass .	aTypeClass		addMethods:			(instanceMethods				collect: [ :instMeth | STypeMethodInfo asMethodInfo: instMeth ]);		addClassMethods:			(classMethods				collect: [ :instMeth | STypeMethodInfo asMethodInfo: instMeth ]).	^ aTypeClass! !!STypeClassInfo methodsFor: 'accessing - read only'!classMethodOf: aSelector	^ classMethodTypes at: aSelector! !!STypeClassInfo methodsFor: 'accessing'!classMethodTypes	^ classMethodTypes! !!STypeClassInfo methodsFor: 'acccessing'!classMethodsFor: aSpyClass	| classMethods |	classMethods := OrderedCollection new.	(aSpyClass metaclassSpy typeName endsWith: ' class') ifTrue: [ 		classMethods := (aSpyClass metaclassSpy methods reject: #isTest) select:					[ :clsMethod | clsMethod wasExecuted and: [ clsMethod isValidReturnTypeWithReceiver ] ] 	].	^ classMethods ! !!STypeClassInfo methodsFor: 'copying'!copy	| copy |	copy := self class instance.	methodTypes do: [ :methodType | copy addMethod: methodType copy ].	classMethodTypes		do: [ :classMethodType | copy addClassMethod: classMethodType copy ].	copy typeName: typeName.	^ copy! !!STypeClassInfo methodsFor: 'adding'!difference: anotherClassInfo	^ (OrderedCollection withAll: 		(self differenceWith: anotherClassInfo usingSelector: #methodTypes ))		addAll: (self differenceWith: anotherClassInfo usingSelector: #classMethodTypes); yourself! !!STypeClassInfo methodsFor: 'adding'!differenceWith: another usingSelector: aSymbol	| dict1 dict2 result |	result := OrderedCollection new.	dict1 := self perform: aSymbol.	dict2 := another perform: aSymbol.	dict2 keysAndValuesDo: [ :key :val1 | | val2 |		[val2 := dict1 at: key.		(val1 = val2) ifFalse: [ result add: (Array with: val2 with: val1) ]]		on: KeyNotFound 		do: [result add: (Array with: nil with: val1)]	 ].	^ result! !!STypeClassInfo methodsFor: 'actions'!exportDataCSV: neoCSVWriter withFilter: aSymbol		self writeDataCSV: neoCSVWriter using: (self filteredMethodsBy: aSymbol)! !!STypeClassInfo methodsFor: 'private'!factoryMessages	^ classMethodTypes values reject: [ :method | method selector = #basicNew ].! !!STypeClassInfo methodsFor: 'private'!factoryMessagesFrom: aClassName	^ self factoryMessages		select: [ :factMessage | 			(factMessage isFromReceiver: aClassName)				and: [ factMessage isWithReturnType: aClassName ] ]! !!STypeClassInfo methodsFor: 'accessing'!filteredMethodsBy: aSymbol	^ (STypeMethodInfo selectorsFilter includes: aSymbol)		ifTrue: [ self allMethods select: aSymbol ]		ifFalse: [ self remainingOrAllMethods: aSymbol ]! !!STypeClassInfo methodsFor: 'comparing'!hash	^ typeName hash bitXor: (methodTypes hash bitXor: classMethodTypes hash)! !!STypeClassInfo methodsFor: 'initialization'!initialize	methodTypes := Dictionary new.	classMethodTypes := Dictionary new.	scalars := Dictionary new! !!STypeClassInfo methodsFor: 'accesing'!instanceMethodsFor: aSpyClass	| instanceMethods |	instanceMethods := OrderedCollection new.	(aSpyClass typeName endsWith: ' class') ifFalse: [ 		instanceMethods := (aSpyClass methods reject: #isTest)				select: [ :instMeth | instMeth wasExecuted or: [ instMeth isUnary ] ].		instanceMethods do: [ :instMeth | instMeth wasExecuted ifFalse: [			instMeth numberOfExecutions: 0.5.			instMeth returnValue: SUndefinedObject basicNew.			instMeth saveReceiver: (instMeth originalMethod origin)		] ] ].	^ instanceMethods! !!STypeClassInfo methodsFor: 'actions'!joinWith: otherTypeClass	otherTypeClass methodTypes do: [ :aMethod | 		self addMethod: aMethod ].	otherTypeClass classMethodTypes do: [ :aMethod | self addClassMethod: aMethod ]! !!STypeClassInfo methodsFor: 'private'!messages	^ self messagesAndAccessMessages reject: #isQuick! !!STypeClassInfo methodsFor: 'private'!messagesAndAccessMessages	^ methodTypes values		select: [ :methType | 			methType isDeprecated not				 and: [ methType returnType isNil not ] ]! !!STypeClassInfo methodsFor: 'accessing - read only'!methodOf: aSelector	^ methodTypes at: aSelector! !!STypeClassInfo methodsFor: 'accessing'!methodTypes	^ methodTypes! !!STypeClassInfo methodsFor: 'accessing'!remainingOrAllMethods: aSymbol	^ aSymbol = #others		ifTrue: [ | methods |			methods := self allMethods.			STypeMethodInfo selectorsFilter do: [ :key | methods := methods reject: key ].			methods ]		ifFalse: [ self allMethods ]! !!STypeClassInfo methodsFor: 'accessing - read only'!reportFrequencyByFilter: aSelector	^ (self filteredMethodsBy: aSelector) size! !!STypeClassInfo methodsFor: 'accessing'!scalars 	^ scalars ! !!STypeClassInfo methodsFor: 'actions'!typeClassMethod: aAssoc	self addClassMethod: (STypeMethodInfo type: aAssoc)! !!STypeClassInfo methodsFor: 'actions'!typeMethod: aAssoc	self addMethod: (STypeMethodInfo type: aAssoc)! !!STypeClassInfo methodsFor: 'accessing'!typeName	^ typeName! !!STypeClassInfo methodsFor: 'accessing'!typeName: anObject	typeName := anObject! !!STypeClassInfo methodsFor: 'writing'!writeDataCSV: neoCSVWriter using: methods	methods		do: [ :aMethod | 			neoCSVWriter				nextPut: (Array with: typeName printString) , aMethod dataCSV ]! !!STypeMethodInfo class methodsFor: 'converting'!asMethodInfo: aSpyMethod	^ self new asMethodInfo: aSpyMethod ! !!STypeMethodInfo class methodsFor: 'accessing'!selectorsFilter	^ (self selectors		select: [ :aSelector | aSelector beginsWith: 'isSimpleTyped' ])		! !!STypeMethodInfo class methodsFor: 'accessing structure variables'!type: aAssoc	| aValue |	aValue := aAssoc value.	^ self new		selector: aAssoc key;		receiver: (SMultiTypeInfo new: aValue first);		returnType: (SMultiTypeInfo new: aValue second);		argTypes: (aValue third collect: [ :aType | SMultiTypeInfo new: aType ]);		isQuick: aValue fourth";		isDeprecated: aValue fifth"! !!STypeMethodInfo methodsFor: 'comparing'!= other	^ self class = other class 		and: [ selector = other selector 			and: [ receiver = other receiver 				and: [ returnType = other returnType 					and: [ argTypes = other argTypes 						and: [ isQuick = other isQuick							and: [ hasProfiler = other hasProfiler ] ] ] ] ] ]! !!STypeMethodInfo methodsFor: 'adding'!addType: aType	argTypes do: [ :arg | arg type: aType ].	returnType type: aType! !!STypeMethodInfo methodsFor: 'accessing'!allArgTypes	argTypes ifNil: [ ^ #() ].	^ argTypes flatCollect: [ :arg | arg types ]! !!STypeMethodInfo methodsFor: 'accessing'!allReceivers	^ receiver types! !!STypeMethodInfo methodsFor: 'accessing'!argTypes	^ argTypes! !!STypeMethodInfo methodsFor: 'accessing'!argTypes: anObject	argTypes := anObject! !!STypeMethodInfo methodsFor: 'converting'!asMethodInfo: typeCollMethod	^ self class new		selector: typeCollMethod selector;		receiver: (self transform: typeCollMethod receiverType);		returnType: (self transform: typeCollMethod returnType);		argTypes: (self transformArgs: typeCollMethod argTypes);		isQuick: typeCollMethod isQuick;		scalars: typeCollMethod dictLiterals;		isDeprecated: typeCollMethod isDeprecated;		executions: typeCollMethod numberOfExecutions;		hasProfiler: typeCollMethod wasExecuted ! !!STypeMethodInfo methodsFor: 'copying'!copy	| copy |	copy := self class instance.	copy		selector: selector;		isQuick: isQuick;		isDeprecated: isDeprecated;		returnType: returnType copy;		argTypes: argTypes copy;		scalars: scalars copy;		executions: executions;		receiver: receiver copy.	^ copy! !!STypeMethodInfo methodsFor: 'actions'!copyValuesOf: otherTypeMethod	(otherTypeMethod hasProfiler and: [ otherTypeMethod returnType types isNotEmpty ]) 		ifFalse: [^ self].	returnType := otherTypeMethod returnType.	argTypes := otherTypeMethod argTypes.	receiver := otherTypeMethod receiver.	hasProfiler := otherTypeMethod hasProfiler.! !!STypeMethodInfo methodsFor: 'accessing'!dataCSV	^ Array with: selector		withAll: (OrderedCollection new add: receiver types asArray;		add: receiver commonSuperclass;		add:			(argTypes				ifNil: [ #() ]				ifNotNil: [ (argTypes collect: [ :argType | argType types asArray ]) asArray ]);		add: (argTypes ifNil: [''] ifNotNil: [ argTypes collect: [:argType | argType commonSuperclass]]);		add: returnType types asArray;		add: returnType commonSuperclass; yourself)! !!STypeMethodInfo methodsFor: 'acccessing'!executions	^ executions  ! !!STypeMethodInfo methodsFor: 'acccessing'!executions: anObject	executions := anObject ! !!STypeMethodInfo methodsFor: 'accessing'!hasProfiler	^ hasProfiler! !!STypeMethodInfo methodsFor: 'accessing'!hasProfiler: aBoolean	hasProfiler := aBoolean ! !!STypeMethodInfo methodsFor: 'comparing'!hash	^ selector hash		bitXor: (receiver hash bitXor: (returnType hash bitXor: (argTypes hash bitXor: isQuick hash)))! !!STypeMethodInfo methodsFor: 'initialization'!initialize	argTypes := #().	isQuick := false.	returnType := SMultiTypeInfo new.	receiver := SMultiTypeInfo new.	isDeprecated := false.	scalars := Dictionary new.	hasProfiler := true! !!STypeMethodInfo methodsFor: 'accessing'!isDeprecated	^ isDeprecated! !!STypeMethodInfo methodsFor: 'accessing'!isDeprecated: anObject	isDeprecated := anObject! !!STypeMethodInfo methodsFor: 'testing'!isFromReceiver: aClassName	^ receiver types includes: aClassName! !!STypeMethodInfo methodsFor: 'accessing'!isQuick	^ isQuick! !!STypeMethodInfo methodsFor: 'accessing'!isQuick: aBoolean	isQuick := aBoolean! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped	"	- one type of receiver only one type for each argument	"	^ (Array with: receiver hasOnlyOneType			with: returnType hasOnlyOneType			with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped10	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped11	"		"	^ (Array		with: receiver hasOnlyOneType not		with:			returnType hasOnlyOneType not		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ])		with: (receiver equals: returnType ) not)		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped12	"		"	^ (Array		with: (receiver hasOnlyOneType not and: [ receiver commonSuperclass ~= 'Object' ])		with: returnType hasOnlyOneType not		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped2	"	- this guy return the type that he receive 	"	^ (Array with: receiver hasOnlyOneType not	with: returnType hasOnlyOneType not	with: (receiver equals: returnType)	with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped3	"	- this guy return the type that he receive 	"	^ (Array with: receiver hasOnlyOneType not	with: (receiver commonSuperclass ~= 'Object')	with: returnType hasOnlyOneType	with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped4	"		"	^ (Array with: receiver hasOnlyOneType	with: returnType hasOnlyOneType	with: (argTypes notNil		and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])	with: (argTypes notNil		and: [ argTypes				allSatisfy: [ :t | t hasOnlyOneType or: [ t isBlockSymbol ] ] ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped5	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped6	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped7	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped8	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'metrics'!isSimpleTyped9	"		"	^ (Array		with:			(receiver hasOnlyOneType not				and: [ receiver commonSuperclass ~= 'Object' ])		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself! !!STypeMethodInfo methodsFor: 'accessing'!isUnary	^ selector isUnary ! !!STypeMethodInfo methodsFor: 'testing'!isWithReturnType: aClassName	^ returnType types includes: aClassName! !!STypeMethodInfo methodsFor: 'actions'!joinWith: otherTypeMethod	hasProfiler ifFalse: [ self copyValuesOf: otherTypeMethod ]	ifTrue: [ 		argTypes ifNotNil: [argTypes			with: otherTypeMethod argTypes			do: [ :argType :otherArgType | argType joinWith: otherArgType ] ].		returnType joinWith: otherTypeMethod returnType	]! !!STypeMethodInfo methodsFor: 'accessing'!receiver	^ receiver! !!STypeMethodInfo methodsFor: 'accessing'!receiver: anObject	receiver := anObject! !!STypeMethodInfo methodsFor: 'accessing'!returnType	^ returnType! !!STypeMethodInfo methodsFor: 'accessing'!returnType: anObject	returnType := anObject! !!STypeMethodInfo methodsFor: 'metrics'!returnTypeFor: aReceiver	^ self isSimpleTyped2		ifTrue: [ aReceiver returnType ] "it is the same than his father"		ifFalse: [ self returnType type ] "it return one random"! !!STypeMethodInfo methodsFor: 'accessing'!scalars 		^ scalars! !!STypeMethodInfo methodsFor: 'adding'!scalars: aDictionary	scalars := aDictionary! !!STypeMethodInfo methodsFor: 'accessing'!selector	^ selector! !!STypeMethodInfo methodsFor: 'accessing'!selector: anObject	selector := anObject! !!STypeMethodInfo methodsFor: 'accessing'!transform: aSet	| multiType |	multiType := SMultiTypeInfo new.	aSet do: [ :anObject | multiType type: anObject ].	^ multiType! !!STypeMethodInfo methodsFor: 'converting'!transformArgs: allArgs	^ allArgs		collect: [ :args | self transform: args ]! !!STypeObjectInfo class methodsFor: 'instance creation'!instance 		^ self new! !!STypeObjectInfo methodsFor: 'actions'!joinWith: otherObject	self subclassResponsibility ! !!SmallTypeCollector methodsFor: 'action'!collectTypeFrom: aClass	|collector extractor typeInfo methodInfo|	aClass isMeta ifTrue:[ ^ nil.].	collector := TypeCollector new.	collector onClass: aClass.	extractor := collector newExtractor.	aClass selectorsAndMethodsDo: [ :selector :method |		collector currentExtractedMethod: method. 			extractor				extractInterfacesFrom: method				addTo: collector].	typeInfo := STypeClassInfo newFrom: aClass name.	aClass methods do:[ :method | 			collector localTypingResults at: method ifPresent:[ :tmpTypes |				methodInfo := self methodInfoIn: method from: tmpTypes.				typeInfo addMethod: methodInfo.			]			].	aClass class methods do:[ :method | 			collector localTypingResults at: method ifPresent:[ :tmpTypes |						methodInfo := self methodInfoIn: method from: tmpTypes.				typeInfo addClassMethod: methodInfo.					]		].	^ typeInfo.! !!SmallTypeCollector methodsFor: 'initalize'!initialize	super initialize.	classDict := Dictionary new.	Object withAllSubclasses do:[ :class|			classDict at: class name asLowercase put: class.		]! !!SmallTypeCollector methodsFor: 'action'!methodInfoIn: aCompiledMethod from: tempTypes	|methodTypeInfo argTypes returnType types|	methodTypeInfo := STypeMethodInfo new.	methodTypeInfo 		selector: aCompiledMethod selector;		isQuick: aCompiledMethod isQuick;		scalars: Dictionary new;		isDeprecated: aCompiledMethod isDeprecated;		executions: 0.	argTypes := OrderedCollection new.	aCompiledMethod ast argumentNames doWithIndex:[ :argName : index|			|argType|			argType := SMultiTypeInfo new.			types := (tempTypes at: index) types.			((types size = 1) and:[types first = Object]) ifTrue:[ "name type"					argType type: (self typeFor:argName).				] ifFalse:[					types do:[ :argClass | argClass isMeta ifFalse: [ argType type: argClass name asSymbol ] ].								].			argTypes add: argType.		].	returnType := SMultiTypeInfo new.	types := tempTypes last types.	((types size =1) and:[ types first = Object]) ifFalse:[		types do:[ :argClass | returnType type: argClass name asSymbol. ].	]. "if not it is empty"	methodTypeInfo returnType: returnType.	methodTypeInfo argTypes: argTypes.	^ methodTypeInfo.! !!SmallTypeCollector methodsFor: 'action'!typeFor: argName	|index lastPart|	(argName = 'arg') ifTrue:[^#nil.].	"Case 1:"	(classDict at: argName asLowercase ifPresent:[ :value | ^ value name ]).	"Case 2:"	index := 1.		[(index <= argName size) and:[ (argName at: index) isLowercase]] whileTrue:[ index := index + 1.].	lastPart := argName copyFrom: index to: argName size.	(classDict at: lastPart asLowercase ifPresent:[ :value | ^ value name ]).	"Case 3:"	(argName asLowercase = 'spec') ifTrue:[^ #MetacelloAbstractVersionConstructor].	"Case 4:"	('.*(b|B)lock.*' asRegex matches: argName) ifTrue:[^#BlockClosure].	"Case 5:"	('.*(o|O)rderedCollection.*' asRegex matches: argName) ifTrue:[^#OrderedCollection].	('.*(a|A)rray.*' asRegex matches: argName) ifTrue:[^#Array].	('.*(d|D)ictionary.*' asRegex matches: argName) ifTrue:[^#Dictionary].	('.*(s|S)et.*' asRegex matches: argName) ifTrue:[^#Set ].	('.*(b|B)ag.*' asRegex matches: argName) ifTrue:[^#Bag].	('.*(c|C)ollection.*' asRegex matches: argName) ifTrue:[^#Collection].	('.*(s|S)tring.*' asRegex matches: argName) ifTrue:[^#String].	('.*(s|S)ymbol.*' asRegex matches: argName) ifTrue:[^#Symbol].		^ #nil.	! !!Number methodsFor: '*SmallSuiteGenerator'!mutateToChange	^ (self perform: (SPlatform randomGenerator selectAtRandom: #(#+ #- #*))  with: (SPlatform randomGenerator selectAtRandom: (1 to: 100) asArray) )		perform: (SPlatform randomGenerator selectAtRandom: #(#+ #-))		with: 1! !!RBProgramNode class methodsFor: '*SmallSuiteGenerator' prior: 57659339!formatterClass	^ RBSimpleFormatter ! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33668419!collectorAfterTypeInstvarsOfClass: aClass	"self typeInstvarsOfClass: Point"	^self new typeInstvarsOfClass: aClass; yourself! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33668603!new	"Override new to return either a VWTypeCollector or a SqueakTypeCollector"	^self newForPlatform! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33668763!newForPlatform	"Return either a VWTypeCollector or a SqueakTypeCollector, depending on the platform used."	^PharoTypeCollector basicNew! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33668959!onClass: aClass	^self new onClass: aClass! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33669059!typeInstvar: var ofClass: aClass	"self typeInstvar: #x ofClass: Point "	^(self new typeInstvarsOfClass: aClass) at: var! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33669239!typeInstvar: var ofClassWithLookup: aClass 	"self typeInstvar: #origin ofClassWithLookup: Quadrangle"	| theClass |	theClass := aClass.	[theClass isNil not		and: [theClass instVarNames includes: var]]		whileFalse: [theClass := theClass superclass].	theClass isNil		ifTrue: [^ ExtractedType new].	^ self typeInstvar: var ofClass: theClass! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33669642!typeInstvarsOfClass: aClass	"self typeInstvarsOfClass: Point"	^self new typeInstvarsOfClass: aClass! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33669802!typeTmpsIn: aCompiledMethod ofClass: aClass	"self typeInstvarsOfClass: Point"	^self new typeTmpsIn: aCompiledMethod ofClass: aClass! !!TypeCollector class methodsFor: '*SmallSuiteGenerator' prior: 33669994!versionString	"Take the removal of the standard version method on Smalltalk into account for Squeak :-( "	^(Smalltalk		at: #SystemVersion		ifAbsent: [^Smalltalk version]) current version! !!TypeCollector methodsFor: '*SmallSuiteGenerator'!localTypingResults	^ localTypingResults! !!SUndefinedObject methodsFor: 'comparing'!printOn: aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'nil'! !!RSGroup methodsFor: '*SmallSuiteGenerator'!addShape: shape	^ self add: shape! !!String methodsFor: '*SmallSuiteGenerator'!mutateToChange	| interval stringCopy |	"correct bug to some characters form the string correctly, e.g: $-> problem in a string"	interval := (41 to: 127) asArray.	stringCopy := self		ifEmpty: [ '' ]		ifNotEmpty: [ self copyFrom: 1 to: self size - 1 ].	^ ((Character value: (SPlatform randomGenerator selectAtRandom: interval))		asString , stringCopy		,			(Character value: (SPlatform randomGenerator selectAtRandom: interval)) asString)		asString! !!ManifestSmallSuiteGenerator class methodsFor: 'code-critics'!ruleRBModifiesCollectionRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'SComparisonAssertion class' #for: #true)) #'2019-10-08T16:32:31.453793-04:00') )! !!ManifestSmallSuiteGenerator class methodsFor: 'code-critics'!ruleRBStringConcatenationRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#STestCaseFactory #tearDown #false)) #'2019-10-22T22:14:33.332959-04:00') )! !!ManifestSmallSuiteGenerator class methodsFor: 'code-critics'!ruleRBkeysDoRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'SComparisonAssertion class' #for: #true)) #'2019-10-08T16:32:13.154793-04:00') )! !!Boolean methodsFor: '*SmallSuiteGenerator'!mutateToChange 	^ self not! !!Character methodsFor: '*SmallSuiteGenerator'!mutateToChange	| newValue interval |	interval := (33 to: 127) asArray.	newValue := SPlatform randomGenerator selectAtRandom: interval.	[ newValue == self asInteger ]		whileTrue: [ newValue := SPlatform randomGenerator selectAtRandom: interval ].	^ Character value: newValue! !!SError class methodsFor: 'exceptioninstantiator'!signal: anObject	^ self new signal: anObject ! !!SError methodsFor: 'signaling'!signal: message	SPlatform saveOnLog: message.	super signal: message! !!SRandom class methodsFor: 'instance creation'!seed: anObject	^ self new seed: anObject! !!SRandom methodsFor: 'enumerating'!collectAtRandom: collection	| indexes |	indexes := self shuffleCollection: collection size.	^ indexes		inject: OrderedCollection new		into: [ :result :index | 			result add: (collection at: index).			result ]! !!SRandom methodsFor: 'enumerating'!selectAtRandom: collection	^ collection at: (self nextInt: collection size)! !!SRandom methodsFor: 'enumerating'!selectIndexAtRandom: collection	^ self nextInt: collection size! !!SRandom methodsFor: 'enumerating'!shuffleCollection: stop	|numbers|	numbers := (1 to: stop) asArray.	stop to: 2 by: -1 do: [ :i | numbers swap: i with: (self nextInt: i) ].	^ numbers! !!ByteSymbol methodsFor: '*SmallSuiteGenerator'!mutateToChange	| interval stringCopy |	"correct bug to some characters form the string correctly, e.g: $-> problem in a string"	interval := Character alphabet , $_ asString.	stringCopy := self		ifEmpty: [ '' ]		ifNotEmpty: [ self copyFrom: 1 to: self size - 1 ].	^ ((SPlatform randomGenerator selectAtRandom: interval)		asString , stringCopy		,			(SPlatform randomGenerator selectAtRandom: interval) asString)		asSymbol! !!SSTestRunner methodsFor: 'test - instrumentation'!analyze: aSmalltalkContext	"it takes an snapshot of the thisContext object"	| sContext |	sContext := SSExecutionContext new.	aSmalltalkContext tempNames		doWithIndex:			[ :varName :index | sContext at: varName put: (aSmalltalkContext namedTempAt: index) ].	^ sContext! !!SSTestRunner methodsFor: 'compiling'!compile: aBlock	self class compile: ('performTest	',aBlock body formattedCode)! !!SSTestRunner methodsFor: 'compiling'!compile: aBlock withName: symbol on: aClass	aClass		compile: symbol asString , (String with: Character cr) , aBlock body formattedCode! !!SSTestRunner methodsFor: 'running'!evaluate: aSTestCase	| node |	node := aSTestCase parseTree.	node body		addNode: (SPlatform rbParserClass parseExpression: '^ self analyze: thisContext').	self compile: node.	^ self performTest! !!SSTestRunner methodsFor: 'initialization'!initialize	invariants := OrderedCollection new! !!SSTestRunner methodsFor: 'as yet unclassified'!performTest	| var |var := Dictionary new.var at: 1 put: ((Array new: 3)         at: 1 put: (DataSeries new               add: #Female -> 41.58;               add: #Male -> 55.03;               yourself);         at: 2 put: (DataSeries new               add: #Female -> 20.79;               add: #Male -> 18.343333333333334;               yourself);         at: 3 put: (DataSeries new               add: #Female -> 2.31;               add: #Male -> 2.8233333333333337;               yourself);         yourself).var at: 2 put: (DataFrame withColumns: (var at: 1)).var at: 3 put: #average.var at: 4 put: (var at: 2) rowNames.var at: 5 put: (var at: 2) rowNames.var at: 45 put: (DataFrame withRows: (var at: 1)).var at: 10 put: (var at: 2) columnNames.var at: 11 put: (var at: 45) rowNames.var at: 12 put: (var at: 2) rowNames.var at: 13 put: (var at: 45) numberOfColumns.var at: 8 put: ((var at: 2) applyToAllColumns: (var at: 3)).var at: 9 put: ((var at: 2) applyToAllColumns: (var at: 3)).var at: 14 put: ((var at: 2) tail: (var at: 13)).var at: 17 put: ((var at: 14) rowsFrom: (var at: 13) to: (var at: 13) put: (var at: 1)).var at: 19 put: (var at: 2) contents.var at: 20 put: (var at: 14) columnNames.var at: 21 put: (var at: 14) columnNames.var at: 6 put: (var at: 2) rowNames.var at: 7 put: (var at: 17) numberOfRows.var at: 16 put: ((var at: 2) column: (var at: 7)).var at: 18 put: (var at: 16) name.var at: 22 put: (var at: 45) columnNames.var at: 23 put: (var at: 2) columnNames.var at: 24 put: (var at: 17) tail.var at: 25 put: (var at: 14) rowNames.var at: 26 put: (var at: 17) numberOfRows.var at: 27 put: (var at: 45) rowNames.var at: 28 put: ((var at: 8) atIndex: (var at: 7)).var at: 29 put: (var at: 45) rowNames.var at: 30 put: ((var at: 9) atIndex: (var at: 13)).var at: 31 put: (var at: 14) rowNames.var at: 32 put: (var at: 8) name.var at: 34 put: ((var at: 17) columnNames: (var at: 1)).var at: 35 put: (var at: 17) rowNames.var at: 36 put: (var at: 16) name.var at: 39 put: ((var at: 9) atIndex: (var at: 26)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'running'!run: aSTestCase	testCase := aSTestCase.	self compile: aSTestCase parseTreeWithAssertions.	self setTestSelector: #performTest.	^ self run.! !!SSTestRunner methodsFor: 'running'!runCase	self resources do: [:each | each availableFor: self].	[[self setUp.	self performTest.	testCase hasErrors: false]    on: Error	 do: [ testCase hasErrors: true]] ensure: [		self tearDown.		self cleanUpInstanceVariables]! !!SSTestRunner methodsFor: 'running'!runWithoutAssertions: aSTestCase	testCase := aSTestCase.	self compile: aSTestCase parseTree.	self setTestSelector: #performTest.	^ self run.! !"SmallSuiteGenerator"!!SStack commentStamp: '' prior: 0!SStack is a proof class created to test project functionality!!SEvent commentStamp: '' prior: 0!SEVent is a proof class created to test project functionalityInstance Variables	discount:		<Object>	price:			<Object>!!SConference commentStamp: '' prior: 0!SConference is a proof class created to test project functionalityInstance Variables	date:				<Object>	offerPrice:		<Object>	speaker:			<Object>!!SParty commentStamp: '' prior: 0!SParty is a proof class created to test project functionalityInstance Variables	date:		<Object>!!SFoo commentStamp: '' prior: 0!SFoo is a proof class created to test project functionality!!SSPerson commentStamp: '' prior: 0!SSPerson is a proof class created to test project functionality!!SSTeacher commentStamp: '' prior: 0!SSTeacher is a proof class created to test project functionality!!SEventTest methodsFor: 'tests'!testDiscount	| event |	event := SEvent new.	event price: 80.	event discount: 20.	self assert: event discount equals: 20.	self assert: event price equals: 64! !!SEventTest methodsFor: 'tests'!testDiscountWithZeroPrice	| event |	event := SEvent new.	event discount: 20.	self assert: event discount equals: 0.	self assert: event price equals: 0.	! !!SEventTest methodsFor: 'tests'!testPrice	| event |	event := SEvent new.	event price: 80.	self assert: event price equals: 80! !!SStack class methodsFor: 'instance creation'!newStack	^ self new! !!SStack class methodsFor: 'instance creation'!newStackWith: aList	| inst |	inst := self newStack.	aList		do: [ :element | 			inst push: element ].	^ inst! !!SStack methodsFor: 'accessing'!firstLinkStack	^ firstLink! !!SStack methodsFor: 'accessing'!lastLinkStack	^ lastLink! !!SStack methodsFor: 'removing'!pop	self isEmpty		ifTrue: [ ^ nil ]		ifFalse: [ ^ self removeFirst ]! !!SStack methodsFor: 'adding'!push: anObject	self addFirst: anObject.	^ anObject! !!SStack methodsFor: 'accessing'!top	self isEmpty		ifTrue: [ 			^ nil ]		ifFalse: [ 			^ self firstLink value ]! !!SConference methodsFor: 'accessing'!date	^ date! !!SConference methodsFor: 'accessing'!date: anObject	date := anObject! !!SConference methodsFor: 'initialization'!initialize	price := 100.	discount := 0.	offerPrice := price.	date := Date today! !!SConference methodsFor: 'accessing'!offerPrice	^ offerPrice! !!SConference methodsFor: 'accessing'!offerPrice: aNumber	offerPrice := aNumber! !!SConference methodsFor: 'accessing'!speaker	^ speaker! !!SConference methodsFor: 'accessing'!speaker: anObject	speaker := anObject! !!SEvent class methodsFor: 'as yet unclassified'!price: aNumber	^ self new price: aNumber! !!SEvent methodsFor: 'testing'!canRegister: aPerson	^ aPerson canRegister: self! !!SEvent methodsFor: 'accessing'!discount	^ discount! !!SEvent methodsFor: 'accessing'!discount: aNumber	price > 0 ifTrue: [ discount := aNumber ].! !!SEvent methodsFor: 'initialization'!initialize	price := 0.	discount := 0! !!SEvent methodsFor: 'accessing'!price 	^ price - ((discount * price)/100)! !!SEvent methodsFor: 'as yet unclassified'!price: aNumber	price := aNumber! !!SParty methodsFor: 'accessing'!date	^ date! !!SParty methodsFor: 'accessing'!date: anObject	date := anObject! !!SFoo class methodsFor: 'accessing'!score: aNumber	| ins |	ins := self new score: aNumber.	^ ins! !!SFoo methodsFor: 'initailize-release'!initialize	score := 0! !!SFoo methodsFor: 'accessing'!return: aType	^ aType.! !!SFoo methodsFor: 'handling'!returnCollection	| a |	a := OrderedCollection new.	^ a! !!SFoo methodsFor: 'handling'!returnFloat	| a |	a := 2.3.	^ a! !!SFoo methodsFor: 'handling'!returnNum 	| a |	a := 4.	^ a! !!SFoo methodsFor: 'handling'!returnString	| a |	a := 'Hello'.	^ a! !!SFoo methodsFor: 'accessing'!score	^ score! !!SFoo methodsFor: 'accessing'!score: aNumber	score := aNumber! !!SSPerson class methodsFor: 'as yet unclassified'!name: aString 	| inst |	inst := self new		name: aString;		id: 1;		nickname: aString.	^ inst! !!SSPerson class methodsFor: 'as yet unclassified'!name: aString with: aNumber	| inst |	inst := self new name: aString; id: aNumber; nickname: aString.	^ inst! !!SSPerson methodsFor: 'accessing'!age: aNumber	^ aNumber! !!SSPerson methodsFor: 'testing'!canRegister: aConference	^ aConference price - aConference offerPrice		> (aConference price * 0.05)! !!SSPerson methodsFor: 'as yet unclassified'!fullIdentifier	^ name , '_' , nickname , '_' , id printString! !!SSPerson methodsFor: 'accessing'!id	^ id! !!SSPerson methodsFor: 'accessing'!id: anObject	id := anObject! !!SSPerson methodsFor: 'accessing'!identifier	^ name , id printString! !!SSPerson methodsFor: 'accessing'!name	^ name! !!SSPerson methodsFor: 'accessing'!name: anObject	name := anObject! !!SSPerson methodsFor: 'accessing'!nickname	self subclassResponsibility ! !!SSPerson methodsFor: 'accessing'!nickname: anObject	nickname := anObject! !!SSTeacher methodsFor: 'accessing'!idTeacher	^ idTeacher! !!SSTeacher methodsFor: 'initialization'!initialize	idTeacher := 100 + (id ifNil: [0]).	yearsWorkExperience := 0! !!SSTeacher methodsFor: 'accessing'!nickname	^ 'teacher_'		,			(nickname				ifNil: [ 					'1' ])! !!SSTeacher methodsFor: 'accessing'!yearsWorkExperience	^ yearsWorkExperience! !!SSTeacher methodsFor: 'accessing'!yearsWorkExperience: anObject	yearsWorkExperience := anObject! !"SmallSuiteGenerator-Scenario"!!SStudent commentStamp: '' prior: 0!SStudent is a proof class created to test project functionality!!SAbstractClass commentStamp: '' prior: 0!SAbstractClass is a proof abstract class created to test project functionality!!SSubclassChild commentStamp: '' prior: 0!SSubclassChild is a proof class created to test project functionality!!ManifestSmallSuiteGeneratorScenario commentStamp: '' prior: 0!Second group of classes used in tests!!SStudent methodsFor: 'accessing'!idStudent	^ idStudent! !!SStudent methodsFor: 'initialization'!initialize	id := 1.	scoreStudent := 1.	idStudent := id! !!SStudent methodsFor: 'accessing'!nickname	^ 'student_'	, (nickname ifNil: [ '1' ])! !!SStudent methodsFor: 'accessing'!scoreStudent	^ scoreStudent! !!SStudent methodsFor: 'accessing'!scoreStudent: aNumber		scoreStudent := aNumber! !!SAbstractClass methodsFor: 'accessing'!id	^ id! !!SAbstractClass methodsFor: 'accessing'!id: anObject	id := anObject! !!SAbstractClass methodsFor: 'accessing'!identifier	^ self subclassResponsibility! !!SAbstractClass methodsFor: 'initialization'!initialize 	id := 1! !!SSubclassChild methodsFor: 'accessing'!identifier 	^ self className, '_', self id asString! !"SmallSuiteGenerator-Scenario2"!!SMessage methodsFor: '*SmallSuiteGenerator-Visualization'!stmColor  ^ Color r: 0.7996089931573802 g: 1.0 b: 0.0"Color r: 0.8885630498533724 g: 0.8611925708699902 b: 0.41642228739002934""Color r: 0.9139784946236559 g: 0.8172043010752689 b: 0.4858260019550342"! !!SFieldAccessMessage methodsFor: '*SmallSuiteGenerator-Visualization'!stmColor  ^ Color r: 1.0 g: 0.20039100684261973 b: 0.6001955034213099"Color r: 1.0 g: 0.12512218963831867 b: 0.4780058651026393""Color r: 0.7595307917888563 g: 0.17497556207233628 b: 0.7380254154447703""Color r: 0.40762463343108507 g: 0.0039100684261974585 b: 0.20234604105571846"! !!SFactoryMessage methodsFor: '*SmallSuiteGenerator-Visualization'!stmColor  ^ Color cyan"Color r: 0.01857282502443793 g: 0.2512218963831867 b: 0.9110459433040078""Color r: 0.1573802541544477 g: 0.3196480938416422 b: 0.5141739980449658""Color r: 0.21407624633431085 g: 0.3831867057673509 b: 0.6803519061583577"! !!SMemo methodsFor: 'accessing'!at: summaryExecMethod of: generationNumber and: idPopulation	^ self at: summaryExecMethod of: generationNumber and: idPopulation ifAbsent: [ nil ]! !!SMemo methodsFor: 'accessing'!at: summaryExecMethod of: generationNumber and:idPopulation ifAbsent: absentBlock	^ memo at: summaryExecMethod executorClass -> summaryExecMethod selector		ifPresent: [ :dictSummary | dictSummary at: summaryExecMethod 			ifPresent: [ :dictGeneration | dictGeneration at: generationNumber 				ifPresent: [ :dictIdP | dictIdP at: idPopulation ifAbsent: absentBlock  ] 				ifAbsent: absentBlock ]			ifAbsent: absentBlock ]		ifAbsent: absentBlock! !!SMemo methodsFor: 'accessing'!at: summaryExecMethod of: generationNumber and: idPopulation ifPresent: presentBlock ifAbsent: absentBlock	^  (self at: summaryExecMethod of: generationNumber and: idPopulation)		ifNotNil: [ :value | presentBlock cull: value ] 		ifNil: absentBlock! !!SMemo methodsFor: 'accessing'!at: summaryExecMethod of: generationNumber and: idPopulation put: newCoverage	self at: summaryExecMethod of: generationNumber and: idPopulation 		ifPresent: [ :value | 			value < newCoverage ifTrue: [(((memo at: summaryExecMethod executorClass -> summaryExecMethod selector) at: summaryExecMethod) at: generationNumber) at: idPopulation put: newCoverage ]  ]		ifAbsent: [ memo at: summaryExecMethod executorClass -> summaryExecMethod selector 			ifPresent: [ :dictSummary | dictSummary at: summaryExecMethod 				ifPresent: [ :dictGeneration | dictGeneration at: generationNumber					ifPresent: [ :dictPop | dictPop at: idPopulation put: newCoverage ]					ifAbsentPut: [ Dictionary new at: idPopulation put: newCoverage; yourself ] ] 				ifAbsentPut: [ Dictionary new at: generationNumber put: (Dictionary new at: idPopulation put: newCoverage; yourself); yourself ] ]			ifAbsentPut: [ (Dictionary new at: summaryExecMethod 				put: (Dictionary new at: generationNumber put: (Dictionary new at: idPopulation put: newCoverage; yourself); yourself); yourself) ]		]! !!SMemo methodsFor: 'initialization'!initialize 	memo := Dictionary new! !!SLiteral methodsFor: '*SmallSuiteGenerator-Visualization'!stmColor  ^ Color r: 0.2072336265884653 g: 0.8504398826979472 b: 0.1573802541544477"Color r: 0.2072336265884653 g: 0.5503421309872922 b: 0.19745845552297164""Color r: 0.5953079178885631 g: 0.7644183773216031 b: 0.1466275659824047"! !!SExpression methodsFor: '*SmallSuiteGenerator-Visualization'!mutantColor  ^ self mutated ifTrue: [ Color r: 0.9726295210166178 g: 0.0 b: 0.0	"Color r: 0.7038123167155426 g: 0.3841642228739003 b: 0.4310850439882698" "Color r: 0.40762463343108507 g: 0.0039100684261974585 b: 0.20234604105571846" ] ifFalse: [ Color gray ]! !!SExpression methodsFor: '*SmallSuiteGenerator-Visualization'!stmColor  ! !!SAssignment methodsFor: '*SmallSuiteGenerator-Visualization'!mutantColor	^ self value mutantColor! !!SAssignment methodsFor: '*SmallSuiteGenerator-Visualization'!stmColor  ^ self value stmColor! !!RSSparkCircle methodsFor: 'accessing - computed'!alphaAngleFor: aShape	values ifNil: [ self slices: #yourself ].	^ ((sumValues at: aShape index) + (self defaultSliceShape border width/360)) * 360 / totalSum! !!RSSparkCircle methodsFor: 'accessing - computed'!betaAngleFor: aShape	^ ( aShape index - (self defaultSliceShape border width / 360)) * 360 / totalSum.! !!RSSparkCircle methodsFor: 'accessing'!defaultSliceShape	^ sliceShape! !!RSSparkCircle methodsFor: 'initialization'!initialize	super initialize.	scale := 100.	self sliceColor: [ :slice | 		slice index even 			ifTrue: [ Color lightGray ]			ifFalse: [ Color gray ] ].	sliceShape := RSPieSlice new		segmentSpacing: 0.13;		border: (RSBorder new width: 5; color: Color gray; yourself);		innerRadius: 10;		externalRadius: 120! !!RSSparkCircle methodsFor: 'accessing'!objects	^ objects! !!RSSparkCircle methodsFor: 'accessing'!objects: anObject	objects := anObject! !!RSSparkCircle methodsFor: 'actions'!scaleTo: aNumber	scale := aNumber.	sliceShape 		innerRadius: scale/ 10;		externalRadius: scale * 1.2! !!RSSparkCircle methodsFor: 'hooks'!shapeFor: anObject index: index	| slice value externalRadius width |	slice := self defaultSliceShape copy.	value := values at: index.	externalRadius := (Array with: 1 with: (value <= 1 ifTrue: [ value * 100 ] ifFalse: [ value ])) max.	width := (values min * slice innerRadius) max: 0.2.	slice		model: value * 100;		index: index;		color: (self sliceColor rsValue: slice);		alphaAngle: (self alphaAngleFor: slice);		betaAngle: (self betaAngleFor: slice);		externalRadius: slice innerRadius + (slice externalRadius/10 * (externalRadius log)) + 1.	slice border: (RSBorder new width: width;		color: (width == 0.2 ifTrue: [ Color black] ifFalse: [ slice color muchDarker]));		popup.	^ slice! !!RSSparkCircle methodsFor: 'hooks'!shapesFor: anObject	| k |	k := 0.	^ values collect: [ :m |		k := k + 1. 		self shapeFor: m yourself index: k.		 ] as: RSGroup.! !!RSSparkCircle methodsFor: 'accessing'!sliceColor	^ sliceColor! !!RSSparkCircle methodsFor: 'accessing'!sliceColor: anObject	sliceColor := anObject! !!RSSparkCircle methodsFor: 'accessing'!slices: blocksOrSymbols	values := blocksOrSymbols collect: [:blOrSymbol | 		blOrSymbol value: objects ] as: Array.	sumValues := Array new: blocksOrSymbols size.	1 to: values size do: [ :index | sumValues at: index put: index - 1 ]. 	totalSum := blocksOrSymbols size! !!RSSparkCircle methodsFor: 'accessing'!totalSum	^ totalSum! !!RSSparkCircle methodsFor: 'accessing'!values	^ values! !!STestCaseFactory methodsFor: '*SmallSuiteGenerator-Visualization'!fitnessResultAsDictionary	| functionNames dictResult |	self		assert: (engine isNil not and: [ engine logs isNotEmpty ])		description: 'Run the generation before'.	functionNames := (Array with: engine fitness functionName) asSet.	dictResult := Dictionary new.	engine logs doWithIndex: [ :log :index | 			functionNames do: [ :functionName | 			| val |			val := dictResult				       at: functionName , '_fittest'				       ifAbsentPut: [ OrderedCollection new ].			val add: (index @ (log fittestTestCase fitness at: functionName)).			val := dictResult				       at: functionName , '_average'				       ifAbsentPut: [ OrderedCollection new ].			val add: (index @ (log averageFit at: functionName)).			val := dictResult				       at: functionName , '_lowest'				       ifAbsentPut: [ OrderedCollection new ].			val add: (index @ (log lowestFit at: functionName)) ] ].	^ dictResult! !!STestCaseFactory methodsFor: '*SmallSuiteGenerator-Visualization'!generationEvolutionCanvas	^ engine generationVisualization: fitnessSeed ofColor: self class lightColors ! !!STestCaseFactory methodsFor: '*SmallSuiteGenerator-Visualization'!gtInspectorCanvasIn: composite	<gtInspectorPresentationOrder: -5>	composite roassal3		title: 'GenerationEvoution';		initializeCanvas: [ self generationEvolutionCanvas ]! !!STestCaseFactory methodsFor: '*SmallSuiteGenerator-Visualization'!gtInspectorViewIn: composite	<gtInspectorPresentationOrder: -10>	composite roassal3		title: 'Evolution';		initializeCanvas: [ self visualizeEvolutionFitness ]! !!STestCaseFactory methodsFor: '*SmallSuiteGenerator-Visualization'!visualizeEvolutionFitness	| canvas group legend g d y |	canvas := RSCanvas new.	group := RSGroup new.	legend := RSLegend new 		title: 'Fitness evolution';		container: canvas;		yourself.	y := (1 to: engine logs size) asArray.	g := RSChart new.	g container: group.	self fitnessResultAsDictionary associations doWithIndex: [ :association :index | 		d := RSLinePlot new x: (association value collect: #x) y: (association value collect: #y).		g addPlot: d.		legend text: association key withBoxColor: (g colors range at: index) ].	d := RSLinePlot new x: y y: ((OrderedCollection ofSize: engine logs size) atAllPut: fitnessSeed).	g addPlot: d.	legend text: 'Fitness seed' withBoxColor: (g colors range at: 4).	g addDecoration: (RSVerticalTick new).	g addDecoration: (RSHorizontalTick new). 		g title: 'Fitness Evolution'.	g xlabel: 'Iterations'.	g addDecoration: (RSYLabelDecoration new title: 'Fitness'; offset: -15; vertical).	g build.	canvas add: group asShape.	legend leyendDo: [ :l |		l			draggable;			withBorder;			padding: 20;			scaleBy: 0.5 ].	legend location offset: 10.	legend build.	canvas @ RSCanvasController.	^ canvas! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addDescriptiveTextOn: canvas ofColor: color and: offsets	| blockText text dictionary |	blockText := [:string | RSLabel new 		text: string;		color: color;		fontSize: 40;		yourself ].	dictionary := Dictionary new 		at: 'Generation contribution' put: (RSLocation new top left offset: (100 negated@110 negated); yourself);		at: 'Evolution of Genetic Algorithm' put: (RSLocation new top center offset: (offsets first@0); yourself);		at: 'Evolution Coverage %' put: (RSLocation new top right offset: (offsets second@0); yourself);		yourself.	dictionary associationsDo: [ :assoc |		| label |		label := blockText value: assoc key. 		assoc value move: label on: canvas shapes.		canvas addShape: label	].	text := blockText value: 'TargetClass: ', self targetClassName, ' in package: ', self targetPackageRegex.	RSLocation new top center offset: 0@130 negated; move: text on: canvas shapes.	canvas addShape: text.! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addHighlightMethodEvent: highlight on: canvas ofColor: color	| interaction |	interaction := RSHighlightable new highlightColor: color; yourself.	highlight 		when: RSHighlightEvent do: [ :evt | 			| shapes shape index |			index := 0.			shape := canvas shapes detect: [ :sh | 				index := index + 1.				sh model isNotNil and: [ sh children isNotNil and: [ sh children includes: evt shape ] ]  ] ifNone: [ nil ].			shape ifNotNil: [ 				shapes := shape model allParents.				shapes := (canvas shapes first: index - 1) select: [ :s | shapes includes: s model ].				shapes := (shapes flatCollect: #children) select: [ :sh |					[ sh model selector = evt shape model selector ] on: MessageNotUnderstood do: [ false ]					 ].				interaction doHighlightShapes: shapes.				canvas propertyAt: #summaryExecutedMethods put: shapes			] ];		when: RSUnHighlightEvent do: [ :evt | 			(canvas propertyAt: #summaryExecutedMethods ifAbsent: [ #() ]) do: [:shape | 				interaction restore: shape selector: #color				]]! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addHighlightTestCaseEvent: highlight on: canvas ofColor: color	| interaction  |	interaction := RSHighlightable new highlightColor: color; yourself.	highlight 		when: RSHighlightEvent do: [ :evt | 			| shapes edges index |			index := canvas shapes indexOf: evt shape.			shapes := evt shape model allParents.			shapes := (canvas shapes first: index) select: [ :shape | shapes includes: shape model ].			edges := ((Array with: evt shape),  shapes) flatCollect: [ :testCase | testCase incomingEdges collect: #yourself as: RSGroup ].			interaction doHighlightShapes: shapes, edges.			canvas propertyAt: #testCases put: shapes.			canvas propertyAt: #edges put: edges ];		when: RSUnHighlightEvent do: [ :evt | 			(canvas propertyAt: #testCases ifAbsent: [ #() ]) do: [:shape | 				interaction restore: shape selector: #color				].			(canvas propertyAt: #edges ifAbsent: [ #() ]) do: [ :edge | 				interaction restore: edge selector: #color				 ] ]! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addLegend: associations on: container withFontColor: color and: blockLocation	| legend |	legend := RSLegend new 		container: container;		defaultLabel: (RSLabel new color: color; yourself);		yourself.		associations do: [ :assoc | | colorBox |			colorBox := assoc value.			colorBox isArray ifFalse: [ legend text: assoc key withBoxColor: colorBox ] 				ifTrue:  [ colorBox first isColor 					ifTrue: [ legend text: assoc key withShape: (legend defaultBox border: (RSBorder new color: colorBox second); paint: colorBox first) ] 					ifFalse: [ legend text: assoc key withFadingRamp: colorBox ] ] ].		legend leyendDo: [ :l |				l					padding: 5;					scaleBy: 2.5 ].		blockLocation value: legend.		legend build! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addLegendOn: canvas with: dictColor	| colors |	self addLegend: (Array with: 'Class coverage' -> (dictColor at: 'classCoverage')		with: 'Method coverage' -> (dictColor at: 'methodCoverage')		with: 'Branch coverage' -> (dictColor at: 'statementCoverage')) on: canvas withFontColor: (dictColor at: 'font') and: [:legend | legend location below left offset: (500@0) ].			colors := dictColor at: 'rangeMethodColor'.	self addLegend: (Array  			with: 'Testcase (TC)' -> (dictColor at: 'backgroundTestCase') 			with: 'TC with higher coverage than parents' -> (Array with: (dictColor at: 'backgroundTestCase') with: (dictColor at: 'borderTestCase'))			with: 'Executed methods' -> (Array with: 0 -> colors first with: 1 -> (colors at: 19))) on: canvas  withFontColor: (dictColor at: 'font') and: [ :legend | legend location below center offset: -100@150 negated ].				self addLegend: (Array with: 'Lowest-Fitness' -> (dictColor at: 'lowestCoverage')		with: ('Average-Fitness' -> (dictColor at: 'averageCoverage'))		with: ('Fittest-Fitness' -> (dictColor at: 'fittestCoverage'))) on: canvas withFontColor: (dictColor at: 'font') and: [:legend | legend location below right offset: -700@150 negated ].! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addSurvivorTestCase: testCase on: collection using: set and: maxNumber	| selected association |	association := testCase generationNumber -> testCase idPopulation.	selected := testCase generationNumber == maxNumber.	selected ifFalse: [		testCase children do: [ :each | | aux | 			aux := (set includes: each generationNumber -> each idPopulation) or: [self addSurvivorTestCase: each on: collection using: set and: maxNumber ].			selected := selected or: [ aux ] ] ].	selected ifTrue: [ 		(set includes: association) ifFalse: [ set add: association.		collection add: testCase ].		^ true ]. 	^ false! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addTickX: composite withScale: scale color: color y: y and: posMax	| stepX |	stepX := posMax x / 5.	stepX to: posMax x by: stepX do: [ :i |		| aTick lbl |		aTick := RSLine new 			startPoint: (scale scale: i)@(y - (0.01 * posMax y));			color: color;			width: 10;			endPoint: (scale scale: i)@(y - ((0.01 * posMax y) - 35));			yourself.		composite addShape: aTick.		lbl := RSLabel new 		fontSize: scale range second * 0.04;		color: color;		text: (i round: 1) asString, '%'.		RSLocation new below move: lbl on: aTick.		composite addShape: lbl.	].! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!addTickY: composite withScale: xScale xMax: xMax ofColor: color andPositions: ys	ys doWithIndex: [ :y :index | 		| tick lbl |		tick := RSLine new 			startPoint: (xScale scale: 0)@y;			color: color;			width: 10;			endPoint: (xScale scale: (xMax * -0.03))@y;			yourself.		composite addShape: tick.		lbl := RSLabel new 				fontSize: 30;			color: color;			text: index.		RSLocation new outer left move: lbl on: tick.		composite addShape: lbl.	].! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!borderOfSize: size andColor: color	^ RSBox new 		color: Color transparent;		border: (RSBorder new width: 2; color: color; yourself);		width: size x + 40;		height: size y;		yourself.! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!contributionShapeOfHeight: height color: dictColor and: ys  	| infoColor groupSpark element scale x |	infoColor := Dictionary new 		at: 1 put: ('Class coverage' -> (dictColor at: 'classCoverage'));		at: 2 put: ('Method coverage' -> (dictColor at: 'methodCoverage'));		at: 3 put: ('Branch coverage' -> (dictColor at: 'statementCoverage'));		yourself.	scale := NSScale linear		domain: (Array with: 0 with: ys size);		range: (Array with: 0 with: height).	groupSpark := self sparkCircleGroupOfColor: infoColor andSize: (scale scale: 1).	x := (groupSpark maxValue: #width) / 2.0.	groupSpark with: (ys collect: [:y | x @ y ]) do: [ :shape :position | 		shape translateTo: position + (shape nodes first extent / 2 *  (0 @ 1)).		 ].	element := RSComposite new 		shapes: groupSpark;		yourself.	^ element! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!evolutionPoints: ypositions withScale: scale	| endPoint points listFittest listLowest listAverage |	points := Dictionary new.	endPoint := 0 @ 0.	listLowest := OrderedCollection new add: endPoint; yourself.	listAverage := OrderedCollection new add: endPoint; yourself.	listFittest := OrderedCollection new add: endPoint; yourself.	points at: 'fittest' put: listFittest;		at: 'average' put: listAverage;		at: 'lowest' put: listLowest.	(self logs collect: [:log | 		Array with: log lowestFit values first			with: log averageFit values first			with: (log fittestTestCase fitnessByClass values first at: targetClassName)])		doWithIndex: [ :array  :index | | y |			y := ypositions at: index.			listLowest add: (scale scale: array first) @ y.			listAverage add: (scale scale: array second) @ y.			listFittest add: (scale scale: array third) @ y		].	^ points! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!evolutionShapeWith: yPositions ofColor: dictColor size: size	| composite scale points axis spaceStick xMax yMax |	composite := RSComposite new 		color: Color transparent.	xMax := self logs last fittestTestCase fitnessByClass values first at: targetClassName.	scale := NSScale linear 		domain: (Array with: 0 with: xMax);		range: (Array with: 0 with: size x).	yMax := yPositions last.	points := self evolutionPoints: yPositions, #(0) withScale: scale.	spaceStick := yMax - (0.01 * size y).	axis := RSPolyline new 		color: (dictColor at: 'axis');		width: 10;			controlPoints: ((Array with: 0@0 with: 0@spaceStick with: (scale scale:xMax)@spaceStick));		yourself.	composite addShape: axis; 		addShape: (RSPolyline new 			controlPoints: (points at: 'lowest'); 			color: (dictColor at: 'lowestCoverage');			width: 10; yourself);		addShape: (RSPolyline new 			controlPoints: (points at: 'average'); 			color: (dictColor at: 'averageCoverage');			width: 10; yourself);		addShape: (RSPolyline new 			controlPoints: (points at: 'fittest'); 			color: (dictColor at: 'fittestCoverage');			width: 10; yourself).	self addTickX: composite withScale: scale color: (dictColor at: 'font') y: yMax and: xMax @ size y.	self addTickY: composite withScale: scale xMax: xMax ofColor: (dictColor at: 'font') andPositions: yPositions.	^ composite adjustToChildren! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!fitnessOf: summaryExecMethod	^ summaryExecMethod summaryStatements 		ifEmpty: [ 100 ] 		ifNotEmpty: [ ((summaryExecMethod summaryStatements select: #executed) size / summaryExecMethod summaryStatements size) asFloat * 100 ]! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!generationVisualization: fitnessSeed ofColor: dictColor	| canvas contributionShape infoMethodShape evolutionShape highlightTestCase highlightMethod ys border widthShape barGroup height |	canvas := RSCanvas new 		color: (dictColor at: 'background').	highlightTestCase := RSHighlightable new 		highlightColor: (dictColor at: 'highlightTestCase');		yourself.	highlightMethod := RSHighlightable new 		highlightColor: (dictColor at: 'highlightMethod');		yourself.	infoMethodShape := self infoMethodShapesOn: canvas ofColor: dictColor highlight: (Array with: highlightTestCase with: highlightMethod).		ys := infoMethodShape at: 3.	barGroup := infoMethodShape at: 2.	infoMethodShape := infoMethodShape at: 1.	height := infoMethodShape height.	contributionShape := self contributionShapeOfHeight: height color: dictColor and: ys.	barGroup := RSComposite new shapes: (self setPositions: barGroup using: ys).	"align the contribution element"	contributionShape translateTo: infoMethodShape encompassingRectangle topLeft x - (contributionShape encompassingRectangle width) @ contributionShape position y.	"add contributionShape on canvas"	canvas addShape: contributionShape.	"add infoMethodShapeGroup on canvas"	canvas addAll: infoMethodShape.	"add barGroup on canvas"	RSLocation new right offset: ((barGroup width * 1.2)@0); move: barGroup on: canvas shapes.	canvas addShape: barGroup.	"addition of highlight"	self addHighlightTestCaseEvent: highlightTestCase on: canvas ofColor: (dictColor at: 'highlightTestCase').	self addHighlightMethodEvent: highlightMethod on: canvas ofColor: (dictColor at: 'highlightMethod').	widthShape := 800.	evolutionShape := self evolutionShapeWith: ys ofColor: dictColor size: widthShape @height negated.	height := (Array with: contributionShape height with: height with: evolutionShape height) max + ((infoMethodShape select: [:e | (e model isKindOf: SSTestCase) and: [ e model generationNumber == (numberOfGenerations + 1)  ] ] thenCollect: #height) max).	"addition of contributionShape border"	border := self borderOfSize: contributionShape width @ height andColor: (dictColor at: 'border').	border translateTo: infoMethodShape encompassingRectangle topLeft x - (contributionShape encompassingRectangle width) @ contributionShape position y.	canvas addShape: border.	"addition of infoMethodShape border"	border := self borderOfSize: (infoMethodShape width + (barGroup width * 1.3)) @ height andColor: (dictColor at: 'border').	RSLocation new middle offset: 120@0; move: border on: canvas shapes. 	canvas addShape: border.	"add evolutionShape on canvas"	RSLocation new top right offset: ((evolutionShape width * 1.1)@0); move: evolutionShape on: canvas shapes.	canvas addShape: evolutionShape.	"border of evolutionShape"	border := self borderOfSize: ((widthShape * 1.1) @ height) andColor: (dictColor at: 'border').	RSLocation new top right offset: 0@5 negated; move: border on: canvas shapes.	canvas addShape: border.	"add descriptive text on canvas"	self addDescriptiveTextOn: canvas ofColor: (dictColor at: 'font') and: (Array with: ((infoMethodShape width / 10) negated ) with: -200).	self addLegendOn: canvas with: dictColor.	canvas @ RSCanvasController.	^ canvas	! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!infoMethodShapesOn: canvas ofColor: dictColor highlight: highlights	| generationGroup filteredList memo scaleColorBlock set barGroup shapes ys |	generationGroup := RSGroup new.	barGroup := RSGroup new.	filteredList := OrderedCollection new.	set := Set new.	ys := OrderedCollection new.	logs first population do: [ :tC | self addSurvivorTestCase: tC on: filteredList using: set and: logs size ].	filteredList sort: [ :tC1 :tC2 | (tC1 generationNumber < tC2 generationNumber) or: [ (tC1 generationNumber = tC2 generationNumber) and: [  tC1 children size < tC2 children size ] ] ].  memo := SMemo new.	scaleColorBlock := self scaleColorBlock: (self methodColorDictionary: (dictColor at: 'rangeMethodColor')).	generationGroup addAll: (		(filteredList groupedBy: [:tC | tC generationNumber]) collect: [ :testCases | 			| group generationNumber |			group := RSGroup new.			group addAll: (testCases collect: [ :testCase | 				(self testCaseShape: testCase 					ofColor: dictColor 					with: memo					highlight: highlights second					scale: scaleColorBlock) @ highlights first; yourself.			]).			RSHorizontalLineLayout new gapSize: 20; on: group.			generationNumber := testCases first generationNumber.			barGroup add: (self progressBarFrom: testCases size value to: (logs at: generationNumber) population size ofColor: dictColor).			group	]).	RSVerticalLineLayout new gapSize: 100;  on: generationGroup.	shapes := generationGroup flatCollect: #yourself.	shapes collect: [ :s | s encompassingRectangle origin y ] 		thenDo: [:y | (ys includes: y) ifFalse: [ys add: y]].	RSEdgeBuilder verticalBezier  		shapes: shapes;		canvas: canvas;		width: 5;		color: (dictColor at: 'edge');		connectFromAll: [ :testCase | testCase parents ].	^ Array with: shapes with: barGroup with: ys! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!isCoverage: coverage ofSummaryMethod: summaryMethod in: testCase newOrHigher: memo	| previousValues |	testCase parents ifEmpty: [ ^ true ].	previousValues := testCase parents 		collect: [ :tC | memo at: summaryMethod of: tC generationNumber and: tC idPopulation ]		thenSelect: [ :val | val isNotNil ].	^ previousValues 		ifNotEmpty: [ previousValues max < coverage ] 		ifEmpty: [ testCase parents allSatisfy: [ :tC |				self isCoverage: coverage ofSummaryMethod: summaryMethod in: tC newOrHigher: memo ] ]! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!methodColorDictionary: rangeColor	| typeInfoClass color methodColorList index scale sizeRangeColor |	typeInfoClass := typeInfo classAt: self targetClassName.	methodColorList := OrderedCollection new.	sizeRangeColor := rangeColor size.	scale := NSScale linear range: (Array with: 1 with: typeInfoClass allMethods size); domain: (Array with: 1 with: sizeRangeColor).	color := NSScale linear range: rangeColor; domain: ((1 to: sizeRangeColor) collect: [:n | scale scale: n]).	index := 0.	methodColorList addAll: (typeInfoClass methodTypes collect: [:method | 		index := index + 1.		(targetClassName -> method selector) -> (color scale: index)		]).	methodColorList addAll: (typeInfoClass classMethodTypes collect: [:method | 		index := index + 1.		(targetClassName, ' class' -> method selector) -> (color scale: index)]).	^ methodColorList asDictionary ! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!methodShape: summaryExecMethod withGradientFrom: darkColor to: lightColor	| gradient group |	gradient := LinearGradientPaint fromArray: (Array with: 0->darkColor with: 1->lightColor).	gradient start: -50@0; stop: 50@0.	group := RSGroup new.	RSVerticalLineLayout new on: group; gapSize: 0.	^ RSComposite new size: 50;				color: gradient; 				border: RSBorder new;				model: summaryExecMethod;				popupText: [ :summary |  String streamContents: [ :stream | 							stream nextPutAll: summary executorClass;							nextPutAll: '->';							nextPutAll: summary selector.							summaryExecMethod summaryStatements 								select: #executed 								thenDo: [:sSt | stream nextPut: Character cr;									nextPutAll: sSt code] ] ];				shapes: (group collect: #yourself);				yourself.						! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!methodShapeGroup: testCase with: memo highlight: highlight scale: scaleColorBlock	| group |	group := RSGroup new.	group addAll: ((self summaryMethodsOfTargetClass: testCase summaryExecutionMethods)		select: [:summary |			| coverage |			coverage := self fitnessOf: summary.			memo at: summary of: testCase generationNumber and: testCase idPopulation put: coverage.			self isCoverage: coverage ofSummaryMethod: summary in: testCase newOrHigher: memo ]		thenCollect: [:summary | 			| scaleColor |			scaleColor := scaleColorBlock value: summary executorClass -> summary selector.			(self methodShape: summary withGradientFrom: (scaleColor scale: (self fitnessOf: summary)) to: (scaleColor scale: 100)) @ highlight; yourself.		]).	RSGridLayout on: group.	^ group! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!progressBarFrom: progressValue to: maxValue ofColor: dictColor	| groupBox groupData bar scale |	groupBox := RSGroup new.	groupData := RSGroup new.	scale := NSScale linear domain: (Array with: 0 with: maxValue);		range: (Array with: 0 with: 200).	groupBox 		add: (RSBox new height: 50; color: (dictColor at: 'baseBar'); width: (scale scale: progressValue));		add: (RSBox new height: 50; color: (dictColor at: 'forwardBar'); width: (scale scale: (maxValue - progressValue)); withBorder).	RSHorizontalLineLayout new gapSize: 0; on: groupBox.	bar := RSComposite new		shapes: groupBox;		yourself.	groupData 		add: bar;		add: (RSLabel new text: (maxValue - progressValue) asString; color: (dictColor at: 'fontMethodBox'); fontSize: 30).	RSHorizontalLineLayout new gapSize: 10; on: groupData.	^ RSComposite new shapes: groupData! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!scaleColorBlock: methodColorDictionary	^ [:key | 		| color |		color := [ methodColorDictionary at: key] on: KeyNotFound do: [ Color black ].		NSScale linear 		range: (Array with: (color alphaMixed: 0.6 with: Color black) with: color);		domain: #(0 100)].! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!setPositions: barGroup using: ys	ys doWithIndex: [ :y :index | 		(barGroup at: index) translateTo: 0@y ].	^ barGroup! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!sparkCircleGroupOfColor: dictColor andSize: size	| block dictPrevData totalClasses totalMethods |	dictPrevData := Dictionary new 		at: 'classCoverage' put: 0;		at: 'methodCoverage' put: 0;		at: 'branchCoverage' put: 0;		yourself.	totalClasses := self typeInfo classes size.	totalMethods := (self typeInfo types flatCollect: #allMethods) size.	block := [ :log | (log population flatCollect: [ :t | 			(t summaryExecutionMethods collect: [:summary | 				(summary executorClass -> summary selector)]) asSet ]) asSet ].	^ logs collect: [ :log | 		| spark group |		group := RSGroup new.		spark := RSSparkCircle new			objects: log;			container: group;			slices: (Array 				with: [:model | | numClasses difference |					numClasses := ((block value: model ) collect: [ :assoc | (assoc key splitOn: ' ') first ]) asSet size.					difference := numClasses - (dictPrevData at: 'classCoverage').					dictPrevData at: 'classCoverage' put: numClasses.					difference / totalClasses ] 				with: [:model | | numberMethods difference |					numberMethods := (block value: model) size.					difference := numberMethods - (dictPrevData at: 'methodCoverage').					dictPrevData at: 'methodCoverage' put: numberMethods.					difference / totalMethods]				with: [:model | | coverage difference |					coverage := model fitness values first.					difference := coverage - (dictPrevData at: 'branchCoverage').					dictPrevData at: 'branchCoverage' put: coverage.					difference / 100  ]);		sliceColor: [ :shape | (dictColor at: shape index) value ].		spark scaleTo: size.		spark build.		RSComposite new			shapes: group;			yourself ] as: RSGroup! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!summaryMethodsOfTargetClass: summaryMethods	^ summaryMethods select: [ :summary | 		(summary executorClass = self targetClassName) or: 		[ (summary executorClass splitOn: ' ') first = self targetClassName ] ]! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization'!testCaseShape: testCase ofColor: dictColor with: memo highlight: highlight scale: scaleColorBlock	| group higher block progressValue methodGroup contribute |	block := [ :tC | [ tC fitnessByClass values first at: self targetClassName ifAbsent: 0 ] on: SubscriptOutOfBounds do: [ 0 ] ].	progressValue := block value: testCase.	higher := testCase parents ifEmpty: [ false ] 		ifNotEmpty: [ testCase parents allSatisfy: [ :tC | (block value: tC) < progressValue ] ].	group := RSGroup new.	methodGroup := self methodShapeGroup: testCase with: memo highlight: highlight scale: scaleColorBlock.	contribute := methodGroup isNotEmpty or: [ higher ].	group add: methodGroup;		add: (RSGroup new 			add: (RSComposite new 				addShape: (RSLabel new text: progressValue asString, '%'; bold; 					color: ((dictColor at: 'fontMethodBox') alpha: (contribute ifFalse: [ 0.5 ] ifTrue: [ 1 ])); fontSize: 20); 					padding: (Margin left: 10 right: 10 top: 1 bottom: 1)); yourself).	RSVerticalLineLayout on: group.	^ RSComposite new 		shapes: (group flatCollect: #yourself);		paint: ((dictColor at: 'backgroundTestCase') alpha: (contribute ifFalse: [ 0.5 ] ifTrue: [ 1 ]));		model: testCase;		border: (RSBorder new width: (higher ifTrue: [ 8 ] ifFalse: [ 1 ]); color: (dictColor at: 'borderTestCase'));		padding: 10;		popupText: testCase asString;		draggable ! !!SMemoTest methodsFor: 'running'!setUp 	memo := SMemo new! !!SMemoTest methodsFor: 'tests'!testAtOfAnd	| summaryExecMethod |	summaryExecMethod := SLSummaryExecutionMethod new 			executed: true;		executorClass: #SSTeacher.	self assert: (memo at: summaryExecMethod of: 1 and: 1) isNil.! !!SMemoTest methodsFor: 'tests'!testAtOfAndIfPresentIfAbsent	| summaryExecMethod generationNumber idPopulation result |	generationNumber := 1.	idPopulation := 1.	summaryExecMethod := SLSummaryExecutionMethod new 			executed: true;		executorClass: #SSTeacher.	result := memo at: summaryExecMethod of: generationNumber and: idPopulation ifPresent: [:value | value > 0 ] ifAbsent: [ false ].	self deny: result.	memo at: summaryExecMethod of: generationNumber and: idPopulation put: 50.	result := memo at: summaryExecMethod of: generationNumber and: idPopulation ifPresent: [:value | value > 0 ] ifAbsent: [ false ].	self assert: result! !!SMemoTest methodsFor: 'tests'!testAtOfAndPut	| summaryExecMethod generationNumber idPopulation |	generationNumber := 1.	idPopulation := 1.	summaryExecMethod := SLSummaryExecutionMethod new 			executed: true;		selector: #idTeacher;		executorClass: #SSTeacher.	memo at: summaryExecMethod of: generationNumber and: idPopulation put: 50.	self assert: (memo at: summaryExecMethod of: generationNumber and: idPopulation) equals: 50.! !"SmallSuiteGenerator-Visualization"!!SUtilityTypeInfo commentStamp: '' prior: 0!SUtilityTypeInfo is a class which declares typeInfos for tests. !!ManifestSmallSuiteGeneratorTests commentStamp: '' prior: 0!Tests of SmallSuiteGenerator!!SClassInfoTest methodsFor: 'tests'!testEquals	self		assert: (STypeClassInfo type: #SFoo -> #(#() #()))		equals: (STypeClassInfo type: #SFoo -> #(#() #())).	self		assert:			(STypeClassInfo				type:					#SStudent						->							(Array								with: (Array with: #name -> #(#SStudent #ByteString #() false))								with: #()))		equals:			(STypeClassInfo				type:					#SStudent						->							(Array								with: (Array with: #name -> #(#SStudent #ByteString #() false))								with: #())).	self		assert:			(STypeClassInfo				type:					#SFoo						->							(Array								with: (Array with: #score -> #(#SFoo #SmallInteger #() false))								with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false))))		equals:			(STypeClassInfo				type:					#SFoo						->							(Array								with: (Array with: #score -> #(#SFoo #SmallInteger #() false))								with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false))))! !!SClassInfoTest methodsFor: 'tests'!testFromString	| typeClass |	typeClass := STypeClassInfo		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #return: -> #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false))).	self		assert:			(STON				fromString:					'STypeClassInfo {						#typeName: #SFoo,						#methodTypes: {							#returnFloat: STypeMethodInfo {#selector: #returnFloat, #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SmallFloat64], #argTypes: [], #isQuick: false}, 							#''return:'': STypeMethodInfo {#selector: #''return:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [SMultiTypeInfo [#ByteString]], #isQuick: false}}, 						#classMethodTypes: { 							#''score:'': STypeMethodInfo {#selector: #''score:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SFoo], #argTypes: [SMultiTypeInfo [#SmallInteger]], #isQuick: false}				}}')		equals: typeClass! !!SClassInfoTest methodsFor: 'tests'!testToString	| string |	string := STON toString: (STypeClassInfo		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #return: -> #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false)))).	self		assert: (STON fromString: string) equals: (STypeClassInfo		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #return: -> #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false))))! !!SClassInfoTest methodsFor: 'tests'!testType	| classInfo methodInfo |	classInfo := STypeClassInfo		type:			#SFoo				->					(Array						with:							(Array								with:									#returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #returnString -> #(#SFoo #ByteString #() false)								with:									#return: -> #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with:									#score: -> #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -> #(#SFoo #SmallInteger #() true))						with:							(Array with:								#score: -> #(#SFoo #SFoo #(#SmallInteger) false))).	classInfo typeMethod: #returnNum -> #(#SFoo #SmallInteger #() false).	self assert: classInfo methodTypes size equals: 6.	self assert: classInfo classMethodTypes size equals: 1.	methodInfo := classInfo methodTypes at: #return:.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self		assert: (classInfo methodTypes at: #returnFloat) returnType type		equals: #SmallFloat64.	self		assert: (classInfo methodTypes at: #returnString) returnType type		equals: #ByteString.	self		assert: (classInfo methodTypes at: #score) returnType type		equals: #SmallInteger.	methodInfo := classInfo methodTypes at: #score:.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self		assert: (classInfo classMethodTypes at: #score:) returnType type		equals: #SFoo.	self		assert: (classInfo methodTypes at: #returnNum) returnType type		equals: #SmallInteger! !!SConfigurationTest methodsFor: 'running'!tearDown	SPlatform clearLog.	SPlatform cleanAllLogs! !!SConfigurationTest methodsFor: 'as yet unclassified'!testFileLogger	self		shouldnt: (SPlatform fileLogger: 'STestLog.log')		raise: Error! !!SCoverageTest methodsFor: 'running'!fitnessClass	^ self subclassResponsibility.! !!SCoverageTest methodsFor: 'tests'!fitnessOf: aTestCase	^ aTestCase fitness at: (fitness functionName).! !!SCoverageTest methodsFor: 'running'!installOn: aPackageName	fitness tagetPackagesRegex: aPackageName.	profiler := self aSLProfilerCoverage profilerForPackagesMatching: aPackageName.	fitness profiler: profiler.	profiler uninstall.	profiler beforeProfiling ! !!SCoverageTest methodsFor: 'running'!setUp	utility := SUtilityTypeInfo new.	fitness := self fitnessClass new.	profiler := self aSLProfilerCoverage new! !!SCoverageTest methodsFor: 'running'!tearDown	! !!SCoverageTest methodsFor: 'tests'!testCase: typeInfo withNumStatements: aNumber andTargetClassName: symbol	^ (SSTestCase with: typeInfo)		numMaxStatements: aNumber;		addTargetClassName: symbol;			generateStatements! !!SCoverageTest methodsFor: 'running'!uninstall	profiler uninstall! !!SMethodCoverageTest methodsFor: 'running'!fitnessClass	^ SMethodCoverage! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageClassSEvent	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSEvent2		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SEvent).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 83.33 ])	"83.33 = (5/6) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageClassSFoo	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SFoo).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 77.78 ])	"77.78 = (7/9) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnClassSSTeacher	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSSTeacher3		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SSTeacher).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 60.0 ])	"60.0 = (3/5) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnClassSStack	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SStack).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 57.14 ])	"57.14 = (4/7) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnClassSStudent	| testCase valueFitness |	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SStudent).	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 80.0 ])	"80.0 = (4/5) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSEvent	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSEventOnPackage1 " (STON fromString: utility typeInfoStringSEvent)"		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SEvent).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 83.33 ])! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSFoo	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSFooOnPackage2  "(STON fromString: utility typeInfoStringSFoo2)".	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 77.78 ])	"77.78 = (7/9) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSSTeacher	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSSTeacherOnPackage2."(STON fromString: utility typeInfoStringSSTeacher2)."	testCase		addTargetClassName: (self fullSymbolOf: #SSTeacher);		addFactoryMessage: (self fullSymbolOf: #SSTeacher);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 77.78 ])	"77.78 = (7/9) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSStack	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSStackOnPackage1. "(STON fromString: utility typeInfoStringSStack2)."	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addFactoryMessage: (self fullSymbolOf: #SStack);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 57.14 ])	"57.14 = (4/7) * 100 round: 2"! !!SMethodCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSStudent	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSStudentOnPackage1. "(STON fromString: utility typeInfoStringSStudent1)."	testCase		addTargetClassName: (self fullSymbolOf: #SStudent);		addFactoryMessage: (self fullSymbolOf: #SStudent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 80.0 ])! !!SStatementCoverageTest methodsFor: 'tests'!fitnessClass	^ SStatementCoverage! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageClassSEvent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSEvent2.	testCase		addTargetClassName: (self fullSymbolOf: #SEvent);		addFactoryMessage: (self fullSymbolOf: #SEvent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SEvent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 75.0 ])	"75.0 = (6/8) * 100 round: 2"! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageClassSFoo	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SFoo).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 71.43 ])	"71.43 = (10/14) * 100 round: 2"! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnClassSSTeacher	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SFoo).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SFoo).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 75.0 ])	"75.0 = (6/8) * 100 round: 2"! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnClassSStack	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SStack).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SStack).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 73.68 ])	"73.68 = (14/19) * 100 round: 2"! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnClassSStudent	| testCase valueFitness |	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: (self fullSymbolOf:#SStudent).	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: (self fullSymbolOf:#SStudent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 75.0 ])	"75.0 = (6/8) * 100 round: 2"! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSEvent	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSEventOnPackage1." (STON fromString: utility typeInfoStringSEvent)."	testCase		addTargetClassName: (self fullSymbolOf:#SEvent);		addFactoryMessage: (self fullSymbolOf:#SEvent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf:#SEvent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 75.0 ])! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSFoo	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSFooOnPackage2. "(STON fromString: utility typeInfoStringSFoo2)."	testCase		addTargetClassName: (self fullSymbolOf:#SFoo);		addFactoryMessage: (self fullSymbolOf:#SFoo);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf:#SFoo).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 71.43 ])	"71.43 = (10/14) * 100 round: 2"! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSSTeacher	| testCase |	testCase := SSTestCase		with: utility typeInfoSSTeacherOnPackage2.	"(STON fromString: utility typeInfoStringSSTeacher2)."	testCase		addTargetClassName: (self fullSymbolOf:#SSTeacher);		addFactoryMessage: (self fullSymbolOf:#SSTeacher);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf:#SSTeacher).	fitness compute: (Array with: testCase).	self uninstall.	self assert: (self fitnessOf: testCase) <= 75.0! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSStack	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSStackOnPackage1. "(STON fromString: utility typeInfoStringSStack2)"	testCase		addTargetClassName: (self fullSymbolOf:#SStack);		addFactoryMessage: (self fullSymbolOf:#SStack);		generateStatements: 19.	testCase inspect.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf:#SStack).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 73.68 ])	"73.68 = (14/19) * 100 round: 2"! !!SStatementCoverageTest methodsFor: 'tests'!testCoverageOnPackagesSStudent	| testCase valueFitness |	testCase := SSTestCase		with: utility typeInfoSStudentOnPackage1."(STON fromString: utility typeInfoStringSStudent1)."	testCase		addTargetClassName: (self fullSymbolOf:#SStudent);		addFactoryMessage: (self fullSymbolOf:#SStudent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: (self fullSymbolOf:#SStudent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness > 0 and: [ valueFitness <= 75.0 ])! !!SAssertionTest methodsFor: 'tests'!testAssertComparison	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 1.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: _var1.'.	self		assert: test assertions second printString		equals: 'self assert: _var2 equals: _var3.'! !!SAssertionTest methodsFor: 'tests'!testAssertComparison2	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self deny: _var0 equals: _var1.'.	self		assert: test assertions second printString		equals: 'self deny: _var2 equals: _var3.'! !!SAssertionTest methodsFor: 'tests'!testAssertInspector	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SInspectorAssertion).	self assert: test assertions size equals: 2.	self assertCollection: (test assertions collect: #printString) hasSameElements: #('self assert: _var3 x equals: 2.' 'self assert: _var3 y equals: 1.').! !!SAssertionTest methodsFor: 'tests'!testAssertPrimitive	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SPrimitiveAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: 1.'.	self		assert: test assertions second printString		equals: 'self assert: _var1 equals: 2.'! !!SAssertionTest methodsFor: 'tests'!testAssertString	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SStringAssertion).	self assert: test assertions size equals: 1.	self		assert: test assertions first printString		equals: 'self assert: _var3 printString equals: ''(2@1)''.'! !!SAssertionTest methodsFor: 'tests'!testExecutionContext	|test context|	test := SSTestCase new.	test addStatements: (self parse:			'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.').	context := test analyze.	self assert: (context at:'_var0') equals: 1.	self assert: (context at:'_var1') equals: 2.	self assert: (context at:'_var2') equals: (1@2).! !!SExpressionTest methodsFor: 'parsing'!parse: anExpresion	| sequence |	sequence := SPlatform rbParserClass parseExpression: anExpresion.	^ sequence statements		collect: [ :assig | 			SAssignment new				variable: (SVariable name: assig variable name asString);				value: (self parseMessage: assig value);				yourself ]! !!SExpressionTest methodsFor: 'parsing'!parseMessage: aRBMessageNode	aRBMessageNode isLiteralNode		ifTrue: [ ^ SLiteral value: aRBMessageNode value ].	^ SMessage new		receiver: (SVariable name: aRBMessageNode receiver name);		selector: aRBMessageNode selector;		args:			(aRBMessageNode arguments				collect: [ :arg | self parseVariableOrValue: arg ]) yourself! !!SExpressionTest methodsFor: 'parsing'!parseVariableOrValue: aRBVariableOrLiteral	^ aRBVariableOrLiteral isVariable		ifTrue: [ SVariable name: aRBVariableOrLiteral name ]		ifFalse: [ SLiteral value: aRBVariableOrLiteral value ]! !!SExpressionTest methodsFor: 'running'!setUp	super setUp.	utility := SUtilityTypeInfo new.	SPlatform resetRandomGenerator! !!SExpressionTest methodsFor: 'running'!tearDown	SPlatform resetRandomGenerator! !!SFactoryMessageTest methodsFor: 'tests'!testCopy	| expression copy |	expression := SFactoryMessage new		receiver: (SVariable name: #SFoo);		selector: #score:;		args: (Array with: (SVariable new id: 0));		yourself.	self assert: expression printString equals: 'SFoo score: _var0'.	copy := expression copy.	self assert: copy printString equals: expression printString.	copy value args first id: 1.	self assert: copy printString equals: 'SFoo score: _var1'.	copy value receiver varName: #SStudent.	self assert: copy printString equals: 'SStudent score: _var1'.	copy value selector: #name:.	self assert: copy printString equals: 'SStudent name: _var1'.	self assert: expression printString equals: 'SFoo score: _var0'! !!SFactoryMessageTest methodsFor: 'tests'!testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addFactoryMessage: (self fullSymbolOf: #SFoo).	testCase addMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: ('_var0 := ', (self fullNameOfClass: 'SFoo') asString, ' new.') 									with: ('_var1 := ', (self fullNameOfClass: 'SFoo') asString, ' new.') 									with: '_var2 := _var0 return: _var0.').	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert:			(#('_var2 := _var0 return: _var0.')				includes: insertedExpression printString)! !!SFactoryMessageTest methodsFor: 'tests'!testInsertMethodMessageUsing	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addFactoryMessage: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: ('_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.')).	self		should: [ expression insertMethodMessage: expression using: testCase ]		raise: SError! !!SFactoryMessageTest methodsFor: 'tests'!testInsertRandomMessageUsing	| testCase factoryMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	factoryMessage := testCase addFactoryMessage: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.' 									with: ('_var1 := ', (self fullNameOfClass: 'SFoo')asString, ' score: _var0.')).	factoryMessage insertRandomMessage: factoryMessage using: testCase.	self		assertCollection: (testCase statements collect: #printString)		includesAll: (Array 									with: '_var0 := 7.3.' 									with: ('_var2 := ', (self fullNameOfClass: 'SFoo')asString, ' score: _var0.')									with: ('_var1 := ', (self fullNameOfClass: 'SFoo')asString, ' score: _var0.')).! !!SFieldAccessMessageTest methodsFor: 'tests'!testCopy	| expression copy |	expression := SFieldAccessMessage new		receiver:			(SVariable new				id: 0;				returnType: #SStack);		selector: #firstLinkStack.	self assert: expression printString equals: '_var0 firstLinkStack'.	copy := expression copy.	copy value receiver varName: '_sstack'.	copy value receiver id: 4.	self assert: copy printString equals: '_sstack4 firstLinkStack'.	copy value selector: #lastLinkStack.	self assert: copy printString equals: '_sstack4 lastLinkStack'.	self assert: expression printString equals: '_var0 firstLinkStack'! !!SFieldAccessMessageTest methodsFor: 'tests'!testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := (SSTestCase with: utility typeInfoSStack4)		addTargetClassName: (self fullSymbolOf: #SStack).	testCase addFactoryMessage: (self fullSymbolOf: #SStack) ofSelector: #newStackWith:.	expression := testCase		addFieldAccessMessage: #firstLinkStack		from: (self fullSymbolOf: #SStack).	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 								with: '_var0 := #(1 4 5 ).'								with: ('_var1 := ', (self fullNameOfClass: 'SStack')asString,' newStackWith: _var0.')								with: '_var2 := _var1 firstLinkStack.' 								with: '_var3 := 5.').	testCase addMessage: #push: from: (self fullSymbolOf: #SStack).	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert: insertedExpression printString		equals: '_var5 := _var1 push: _var2.'! !!SFieldAccessMessageTest methodsFor: 'tests'!testInsertRandomMessageUsing	| testCase aExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFactoryMessage: (self fullSymbolOf: #SFoo).	aExpression := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: ('_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.')									with: '_var2 := _var1 score.').	aExpression insertRandomMessage: aExpression using: testCase.	self		assertCollection: (testCase statements collect: #printString)		includesAll: (Array 								with: '_var0 := 7.3.'								with: ('_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.')								with: '_var2 := _var1 score.'								with: '_var3 := _var1 score.')! !!SLiteralTest methodsFor: 'tests'!testCopy	| literal copy |	literal := (SLiteral value: 'hello') returnType: #ByteString.	self assert: literal printString equals: '''hello'''.	copy := literal copy.	copy value: 'world'.	self assert: copy printString equals: '''world'''! !!SLiteralTest methodsFor: 'tests'!testEqual	|literal|	literal := SLiteral value: 1.	self assert: (SLiteral value: 1) equals: literal.	literal value: 3.	self deny: (SLiteral value: -3) equals: literal.	literal value: #().	self assert: (SLiteral value: #()) equals: literal.	literal value: SStudent new.	self assert: (SLiteral value: SStudent new) equals: literal! !!SLiteralTest methodsFor: 'tests'!testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addLiteral: (self fullSymbolOf: #ByteString).	expression := testCase addLiteral: (self fullSymbolOf: #ByteString).	testCase addFactoryMessage: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := ''hello''.'									with: '_var1 := ''hello''.'									with: '_var2 := 7.3.'									with: ('_var3 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var2.')).	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert: insertedExpression printString		equals: '_var5 := _var3 return: _var1.'! !!SLiteralTest methodsFor: 'tests'!testInsertParameterOn	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase addTargetClassName: (self fullSymbolOf: #SFoo); 	addLiteral: (self fullSymbolOf: #SStudent); 	addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , SStudent new storeString , '.'				with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' new.'				with: '_var2 := _var1 return: _var0.').	expression := testCase addLiteral: (self fullSymbolOf: #SStudent).	self		should: [ insertedExpression := expression				insertAsParameter: expression				using: testCase ]		raise: SError.	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		shouldnt: [ insertedExpression := expression				insertAsParameter: expression				using: testCase ]		raise: SError.	self		assert: insertedExpression printString		equals: '_var5 := _var1 return: _var3.'! !!SLiteralTest methodsFor: 'tests'!testReferenceTo	|literal|	literal := SLiteral value: 1.	self assert: ((SLiteral new value: 1) referenceTo: #SmallInteger).	literal value: SStudent new.	self		assert: ((SLiteral new value: SStudent new) referenceTo: #SStudent)! !!SMessageTest methodsFor: 'tests'!testCopy	| message copy |	message := SMessage new		receiver: (SVariable new id: 1; returnType: #SFoo);		selector: #return:;		args:			(Array				with:					(SVariable new						id: 2;						returnType: #ByteString));		returnType: #ByteString.	self assert: message printString equals: '_var1 return: _var2'.	copy := message copy.	copy value args first id: 5.	self assert: copy printString equals: '_var1 return: _var5'.	copy value receiver varName: '_sfoo'.	copy value receiver id: 4.	self assert: copy printString equals: '_sfoo4 return: _var5'.	copy value selector: #returnValue:.	self assert: copy printString equals: '_sfoo4 returnValue: _var5'.	self assert: message printString equals: '_var1 return: _var2'! !!SMessageTest methodsFor: 'tests'!testInsertAsParameterUsing	| testCase aExpression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo); 	addFactoryMessage: (self fullSymbolOf: #SFoo); addLiteral: (self fullSymbolOf: #ByteString).	aExpression := testCase addMessage: #returnString from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: ('_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.')									with: '_var2 := ''hello''.'									with: '_var3 := _var1 returnString.').	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	insertedExpression := aExpression		insertAsParameter: aExpression		using: testCase.	self		assert:			(#('_var4 := _var1 return: _var3.')				includes: insertedExpression printString)! !!SMessageTest methodsFor: 'tests'!testInsertMethodMessageUsing	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	message := testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: ('_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.')									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	message insertMethodMessage: message using: testCase.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: ('_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.')									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.'									with: '_var4 := _var1 return: _var2.').! !!SExtensionsTest methodsFor: 'tests'!createStudent	^ (SStudent new				name: 'Pedro';				id: 5)! !!SExtensionsTest methodsFor: 'tests'!testMutateToChange	self assert: true mutateToChange equals: false.	self assert: false mutateToChange equals: true.	self deny: 1234 mutateToChange equals: 1234.	self deny: 23.34 mutateToChange equals: 23.34.	self deny: $e mutateToChange equals: $e.	self deny: '$character' mutateToChange equals: '$character'.	self deny: 'hello' mutateToChange equals: 'hello'.	self assert: #(1 2 5 6) mutateToChange equals: #(1 2 5 6).	self deny: '#(1 2 5 6' mutateToChange equals: '#(1 2 5 6'.	self		assert: (SStack newStackWith: #(1 6 2 4)) mutateToChange		equals: (SStack newStackWith: #(1 6 2 4)).	self		assert: self createStudent mutateToChange storeString		equals: self createStudent storeString! !!SExtensionsTest methodsFor: 'tests'!testStoreString	self assert: 1 storeString equals: '1'.	self assert: 4.6 storeString equals: '4.6'.	self assert: true storeString equals: 'true'.	self assert: false storeString equals: 'false'.	self assert: 'hello' storeString equals: '''hello'''.	self assert: $d storeString equals: '$d'.	self assert: (SSTeacher new name: 'Mary') storeString isNotEmpty.	self assert: (SStudent new name: 'Alan') storeString isNotEmpty! !!SGACrossoverOperationTest methodsFor: 'tests'!crossOver: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size >= 2.	offSprings := operation		crossover: listTestCase first		with: listTestCase second.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences.! !!SGACrossoverOperationTest methodsFor: 'tests'!crossOverWithMutation: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size >= 2.	self assert: listTestCase first validReferences.	self assert: listTestCase second validReferences.	offSpring1 := mutationOperation mutate: listTestCase first.	offSpring2 := mutationOperation mutate: listTestCase second.	offSprings := operation crossover: offSpring1 with: offSpring2.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	offSpring1 := mutationOperation mutate: offSpring1.	offSpring2 := mutationOperation mutate: offSpring2.	offSprings := operation crossover: offSpring1 with: offSpring2.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences! !!SGACrossoverOperationTest methodsFor: 'running'!setUp	super setUp.	SPlatform resetRandomGenerator .	operation := SGACrossoverOperation new.	mutationOperation := SGAMutationOperation new.	utility := SUtilityTypeInfo new! !!SGACrossoverOperationTest methodsFor: 'tests'!testCrossOverToSStack	self crossOver: utility testSuiteSStack .	self crossOverWithMutation: utility testSuiteSStack ! !!SGACrossoverOperationTest methodsFor: 'tests'!testCrossOverToSStudent	self crossOver: utility testSuiteSStudent ! !!SGACrossoverOperationTest methodsFor: 'tests'!testCrossOverToSStudent2	self crossOver: utility testSuiteSStudentManual.	self crossOverWithMutation: utility testSuiteSStudentManual! !!SGAEngineTest methodsFor: 'as yet unclassified'!profilerOf: string	profiler := self aSLProfilerCoverage profilerForPackagesMatching: string.	profiler beforeProfiling! !!SGAEngineTest methodsFor: 'running'!setUp	super setUp.	engine := SGAEngine new.	profiler := self aSLProfilerCoverage new.	utility := SUtilityTypeInfo new! !!SGAEngineTest methodsFor: 'running'!tearDown	[profiler uninstall] on: Error do: [].	super tearDown! !!SGAEngineTest methodsFor: 'tests'!testRunOnClassSStudentManual	"| testSuite block utility |	utility := SUtilityTypeInfo new.	block := [ SStudent new		scoreStudent: 34;		scoreStudent;		idStudent ].	testSuite := utility testSuiteSStudentManual.	engine		populationSize: 3;		numberOfStatements: 10;		blockToExecute: block;		endForMaxNumberOfGeneration: 10;		typeInfo: utility typeInfosSStudent first;		initializePopulationWith: testSuite;		fitness: (SStatementCoverage coverageOf: block onClass: SStudent).	engine run"! !!SGAEngineTest methodsFor: 'tests'!testRunOnPackagesMatchingSFoo	| first last functionFitness  targetPackageRegex typeInfo |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	typeInfo := utility typeInfoSFooOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness tagetPackagesRegex: targetPackageRegex;	 targetClass: (self fullSymbolOf: #SFoo);	 typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo; 	" STON fromString: utility typeInfoStringSFoo3."		targetClassName: (self fullSymbolOf: #SFoo);		fitness: functionFitness;		populationSize: 5;		numberOfGenerations: 5;		populationSize: 10;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first > 0.	self assert: first <= last! !!SGAEngineTest methodsFor: 'tests'!testRunOnPackagesSSTeacherUsingMethodCoverage	| first last functionFitness targetPackageRegex typeInfo |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.			typeInfo := utility typeInfoSSTeacherOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness tagetPackagesRegex: targetPackageRegex;	 targetClass: (self fullSymbolOf: #SSTeacher);	 typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo; "STON fromString: utility typeInfoStringSSTeacher1."		fitness: functionFitness;		targetClassName: (self fullSymbolOf: #SSTeacher);		populationSize: 10;		numberOfGenerations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first > 0.	"20 = (1/5) * 100"	self assert: first <= last	"80 = (4/5) * 100"! !!SGAEngineTest methodsFor: 'tests'!testRunOnPackagesSSTeacherUsingStatementCoverage	| first last functionFitness targetPackageRegex typeInfo |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.		typeInfo := utility typeInfoSSTeacherOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SStatementCoverage new profiler: profiler.	functionFitness tagetPackagesRegex: targetPackageRegex.	functionFitness targetClass: (self fullSymbolOf: #SSTeacher).	functionFitness typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo;		fitness: functionFitness;		targetClassName: (self fullSymbolOf: #SSTeacher);		populationSize: 10;		numberOfGenerations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first > 0.	"37.5 = (3/8) * 100"	self assert: first <= last	"87.5 = (7/8) * 100"! !!SGAMutationOperationTest methodsFor: 'running'!setUp	super setUp.	SPlatform resetRandomGenerator.	operation := SGAMutationOperation new.	utility := SUtilityTypeInfo new! !!SGAMutationOperationTest methodsFor: 'tests'!testMutation	| testCase mutatedTestCase |	testCase := SSTestCase with: utility typeInfoSStack3.	testCase numMaxStatements: 10.	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences! !!SGAMutationOperationTest methodsFor: 'tests'!testMutationSSteacher	| typeInfo testCase mutatedTestCase |	typeInfo := utility typeInfoSSTeacher1.	testCase := SSTestCase with: typeInfo.	testCase addTargetClassName: (self fullSymbolOf: #SSTeacher);	generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences! !!SGAMutationOperationTest methodsFor: 'tests'!testMutationSStudentManual	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite first.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite second.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences! !!SGAMutationOperationTest methodsFor: 'tests'!testMutationSStudentWithValidReferences	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences! !!SMethodInfoTest methodsFor: 'tests'!testEquals	self		assert: (STypeMethodInfo type: #name -> #(#SStudent #ByteString #() false))		equals: (STypeMethodInfo type: #name -> #(#SStudent #ByteString #() false)).	self assert: (STypeMethodInfo		type: #return: -> #(#SFoo #ByteString #(#ByteString) false)) equals: (STypeMethodInfo		type: #return: -> #(#SFoo #ByteString #(#ByteString) false))! !!SMethodInfoTest methodsFor: 'tests'!testFromSton	| typeMethod |	typeMethod := STypeMethodInfo		type: #name -> #(#SStudent #ByteString #() true).	self		assert:			(STON				fromString:					'STypeMethodInfo {#selector: #name, #receiver: SMultiTypeInfo [#SStudent], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [], #isQuick: true}')		equals: typeMethod.	typeMethod := STypeMethodInfo		type: #return: -> #(#SFoo #ByteString #(#ByteString) false).	self		assert:			(STON				fromString:					'STypeMethodInfo {#selector: #''return:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [SMultiTypeInfo [#ByteString]], #isQuick: false}')		equals: typeMethod! !!SMethodInfoTest methodsFor: 'tests'!testToString	| string typeMethod |	typeMethod := STypeMethodInfo type: #name -> #(#SStudent #ByteString #() true).	string := STON		toString: typeMethod.	self		assert: (STON fromString: string)		equals:			typeMethod.	typeMethod := (STypeMethodInfo				type: #return: -> #(#SFoo #ByteString #(#ByteString) false)).	string := STON toString: typeMethod.	self		assert: (STON fromString: string)		equals:			typeMethod! !!SMethodInfoTest methodsFor: 'tests'!testType	| methodInfo |	methodInfo := STypeMethodInfo		type: #returnFloat -> #(#SFoo #SmallFloat64 #() false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SmallFloat64.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	self deny: methodInfo isDeprecated.	methodInfo := STypeMethodInfo		type: #returnString -> #(#SFoo #ByteString #() false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #ByteString.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #return: -> #(#SFoo #OrderedCollection #(#OrderedCollection) false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #score: -> #(#SFoo #SFoo #(#SmallInteger) false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #score -> #(#SFoo #SmallInteger #() true).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SmallInteger.	self assert: methodInfo argTypes isEmpty.	self assert: methodInfo isQuick! !!SMultiFitnessFunctionTest methodsFor: 'running'!setUp	super setUp.	"function := SMultiFitnessFunction.	function clean.	fitnessFunctions := Array		with: SMethodCoverage		with: SStatementCoverage.	utility := SUtilityTypeInfo new"! !!SMultiFitnessFunctionTest methodsFor: 'running'!tearDown	"fitnessFunctions do: #clean.	function		clean;		reset."	super tearDown! !!SMultiFitnessFunctionTest methodsFor: 'tests'!testComputeFitnessOnFactoryMessage	"| aTestCase res fitness |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFactoryMessage.	fitness := SStatementCoverage new.	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(33.33 28.57)"! !!SMultiFitnessFunctionTest methodsFor: 'tests'!testComputeFitnessOnFieldAccessMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFieldAccessMessage: #score from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 35.71)"! !!SMultiFitnessFunctionTest methodsFor: 'tests'!testComputeFitnessOnLiteral	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addLiteral.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(0 0)"! !!SMultiFitnessFunctionTest methodsFor: 'tests'!testComputeFitnessOnMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addMessage: #returnFloat from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 42.86)"! !!SMultiFitnessFunctionTest methodsFor: 'tests'!testIsBetterThan	"| testCase1 testCase2 functions |	testCase1 := utility testSuiteSStudentManual second.	testCase2 := utility testSuiteSStudentManual second.	""testCase2 addFieldAccessMessage: #scoreStudent from: #SStudent.	functions := SStatementCoverage new, SMethodCoverage new.""	testCase1 computeFitness: functions first.	testCase1 computeFitness: functions second.	testCase2 computeFitness: functions first.	testCase2 computeFitness: functions second	""self deny: (function is: testCase1 betterThan: testCase2).	self assert: (function is: testCase2 betterThan: testCase1)"""! !!SMultiTypeInfoTest methodsFor: 'tests'!testEqual 	self assert: (SMultiTypeInfo new type: #ByteString) equals: (SMultiTypeInfo new type: #ByteString)! !!SMultiTypeInfoTest methodsFor: 'tests'!testFromSton	| multiTypeInfo |	multiTypeInfo := SMultiTypeInfo new type: #ByteString.	self		assert: (STON fromString: 'SMultiTypeInfo [#ByteString]')		equals: multiTypeInfo.	multiTypeInfo := SMultiTypeInfo new		type: #ByteString;		type: #SmallInteger.	self		assert: (STON fromString: 'SMultiTypeInfo [#ByteString, #SmallInteger]')		equals: multiTypeInfo.	multiTypeInfo := SMultiTypeInfo new		type: #ByteString;		type: #SmallInteger;		type: #SStudent.	self		assert:			(STON				fromString: 'SMultiTypeInfo [#ByteString, #SmallInteger, #SStudent, #ByteString]')		equals: multiTypeInfo! !!SMultiTypeInfoTest methodsFor: 'tests'!testToString	| string multiType |	multiType :=  (SMultiTypeInfo new type: #ByteString).	string := STON toString: multiType.	self assert: (STON fromString:string) equals: multiType.		multiType := 			(SMultiTypeInfo new				type: #ByteString;				type: #SmallInteger).	string := STON toString: multiType.	self		assert: (STON fromString: string)		equals: multiType.	multiType := (SMultiTypeInfo new				type: #ByteString;				type: #SmallInteger;				type: #SStudent).	string := STON		toString:			multiType.	self		assert: (STON fromString: string)		equals: multiType! !!SMutatorTestCaseTest methodsFor: 'running'!setUp	utility := SUtilityTypeInfo new.! !!SMutatorTestCaseTest methodsFor: 'tests'!testRemoveArgsMethod	| testCase expression numExprsBefore numExprsAfter |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	numExprsBefore := testCase length.	expression := testCase statementOfVarName: '_var2'.	testCase removeExpression: expression.	numExprsAfter := testCase length.	self assert: numExprsAfter equals: numExprsBefore! !!SMutatorTestCaseTest methodsFor: 'tests'!testRemoveExpression	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	expression := testCase addLiteral.	testCase removeExpression: expression.	self assert: testCase statements isEmpty! !!SMutatorTestCaseTest methodsFor: 'tests'!testRemoveExpressionWithoutRepairing	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	expression := testCase statementOfVarName: '_var2'.	testCase removeExpressionWithoutRepairing: expression.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with:  '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.')! !!SMutatorTestCaseTest methodsFor: 'tests'!testRemoveInEmptyTestCase	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	self should: [ testCase removeExpression: nil ] raise: SError! !!SMutatorTestCaseTest methodsFor: 'tests'!testRepair	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	expression := testCase statementOfVarName: '_var2'.	self should: [ testCase repair: expression ] raise: SError.	testCase removeFromStatements: expression.	self assert: (testCase repair: expression) isEmpty.	expression := testCase statementOfVarName: '_var3'.	self		assertCollection: (expression value args collect: #printString)		hasSameElements: #('_var4').	self		assert:			(((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)				includesAny: #('_var4 := ''hello''.' '_var4 := _var1 returnString.'))! !!SRandomTest methodsFor: 'running'!setUp	super setUp.	utility := SUtilityTypeInfo new! !!SRandomTest methodsFor: 'tests'!testCollectAtRandom	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self assertCollection: (generator collectAtRandom: array) hasSameElements: array! !!SRandomTest methodsFor: 'tests'!testCollectAtRandomOnStatements	| generator testCase |	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage;		addMessage: #returnNum from: (self fullSymbolOf: #SFoo);		addFieldAccessMessage: #score from: (self fullSymbolOf: #SFoo).	self		assertCollection: testCase printStatements		hasSameElements:			((generator collectAtRandom: testCase statements)				collect: #printString)! !!SRandomTest methodsFor: 'tests'!testSelectAtRandom	|generator array|	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self assert: ((generator selectAtRandom: array) between: 1 and: 10)! !!SRandomTest methodsFor: 'tests'!testSelectAtRandomOnStatements	| generator testCase stringStatements statements |	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName:(self fullSymbolOf: #SFoo);		addFactoryMessage;		addMessage: #returnNum from: (self fullSymbolOf: #SFoo);		addFieldAccessMessage: #score from: (self fullSymbolOf: #SFoo).	stringStatements := testCase printStatements.	statements := testCase statements.	100 timesRepeat: [		self		assert:			(stringStatements 				includes: (generator selectAtRandom: statements) printString)]! !!SRandomTest methodsFor: 'tests'!testShuffleCollection	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self		assertCollection: (generator shuffleCollection: 10)		hasSameElements: array! !!SChangeTest methodsFor: 'mutation-change'!testChangeStatementOfFactoryMessageWithAbstractClass	| testCase changed |	testCase := (SSTestCase with: utility typeInfoArrayedCollection).	testCase		addTargetClassName: (self fullSymbolOf: #ArrayedCollection);		addFactoryMessage;		addLiteral;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: ('_var0 := ', (self fullNameOfClass: 'ArrayedCollection')asString,' new.')									with: '_var1 := ''hello''.'									with: ('_var2 := ', (self fullNameOfClass: 'ArrayedCollection')asString,' new.')).	changed := testCase changeStatementOfClassName: (self fullSymbolOf: #ArrayedCollection).	self assert: changed equals: false.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var1 := ''hello''.')! !!SChangeTest methodsFor: 'mutation-change'!testChangeStatementOfFactoryMessageWithMoreThanOneLiteral	| testCase expression expressionChanged |	testCase := (SSTestCase with: utility typeInfoSFoo1) addTargetClassName: (self fullSymbolOf: #SFoo).	testCase		addLiteral: (self fullSymbolOf: #SmallFloat64);		addLiteral: (self fullSymbolOf: #SmallFloat64).	expression := testCase addFactoryMessage: (self fullSymbolOf: #SFoo) ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		includesAll: #('_var0 := 7.3.' '_var1 := 7.3.').	self		assert:			((Array with: '_var3 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var2.')				includes: expression printString).	expressionChanged := testCase changeStatementOfVarName: '_var2'.	self		assert:			(#('_var2 := 679.9.')				includes: expressionChanged printString).	self assert: testCase validReferences! !!SChangeTest methodsFor: 'mutation-change'!testChangeStatementOfFactoryMessageWithOneLiteral	| testCase expressionChanged |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: ('_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.')).	expressionChanged := testCase changeStatementOfVarName: '_var1'.	self		assert: ((Array									with: ('_var0 := ',(self fullNameOfClass: 'SFoo')asString,' new.')									with: ('_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var2.'))				includes: expressionChanged printString).				self assert: testCase validReferences! !!SChangeTest methodsFor: 'mutation-change'!testChangeStatementOfFieldAccessMessage	| testCase exprField exprFieldChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase addTargetClassName: (self fullSymbolOf: #SStack);	addFactoryMessage: (self fullSymbolOf: #SStack) ofSelector: #newStack.	exprField := (testCase		addFieldAccessMessage: #firstLinkStack		from: (self fullSymbolOf: #SStack)) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: ('_var0 := ',(self fullNameOfClass: 'SStack')asString,' newStack.')									with: '_var1 := _var0 firstLinkStack.').	exprFieldChanged := testCase changeStatement: exprField.	self		assert:			(#('_var1 := _var0 lastLinkStack.' '_var1 := _var3 firstLinkStack.' '_var1 := _var2 firstLinkStack.')				includes: exprFieldChanged printString).	self assert: testCase validReferences! !!SChangeTest methodsFor: 'mutation-change'!testChangeStatementOfLiteral	| testCase exprLiteral exprLiteralChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	exprLiteral := (testCase addLiteral: (self fullSymbolOf: #SmallInteger)) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 5.').	exprLiteralChanged := testCase changeStatementOfVarName: '_var0'.	self deny: exprLiteral equals: exprLiteralChanged.	self assert: testCase validReferences! !!SChangeTest methodsFor: 'mutation-change'!testChangeStatementOfMessage	| testCase exprMessage exprLiteralChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase addTargetClassName: (self fullSymbolOf: #SStack);	addFactoryMessage: (self fullSymbolOf: #SStack) ofSelector: #newStack.	exprMessage := (testCase addMessage: #pop from: (self fullSymbolOf: #SStack)) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: ('_var0 := ',(self fullNameOfClass: 'SStack')asString,' newStack.')									with: '_var1 := _var0 pop.').	exprLiteralChanged := testCase changeStatement: exprMessage.	self		assert:			(#('_var1 := _var0 top.' '_var1 := _var0 push: _var2.' '_var1 := _var3 pop.' '_var1 := _var2 pop.')				includes: exprLiteralChanged printString).	self assert: testCase validReferences! !!SInsertTest methodsFor: 'tests'!setUp 	super setUp.	SPlatform fileLogger: 'SInsertTestLogger.log'! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementAsParameterInMessage	| testCase anExpression |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFactoryMessage: (self fullSymbolOf: #SFoo);	addLiteral;	addMessage: #return: from: (self fullSymbolOf: #SFoo).	anExpression := testCase addLiteral.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ', (self fullNameOfClass: 'SFoo')asString,' new.'				with: '_var1 := ' , SStudent new storeString , '.'				with: '_var2 := ' , SStudent new storeString , '.'				with: '_var3 := _var0 return: _var2.'				with: '_var4 := ' , SStudent new storeString , '.').	self		should: [ testCase				perform: #insertAsParameter:using:				inStatement: anExpression copy ]		raise: SError.	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	testCase		perform: #insertAsParameter:using:		inStatement: anExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ', (self fullNameOfClass: 'SFoo')asString,' new.'				with: '_var1 := ' , SStudent new storeString , '.'				with: '_var2 := ' , SStudent new storeString , '.'				with: '_var3 := _var0 return: _var2.'				with: '_var4 := ' , SStudent new storeString , '.'				with: '_var5 := _var0 return: _var4.')! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfMixingSelectors	| testCase fieldAccess message |	testCase := (SSTestCase with: utility typeInfosSStudent first)		addTargetClassName: (self fullSymbolOf: #SStudent);		addLiteral: (self fullSymbolOf: #SmallInteger);		addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;		addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);		addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;		addFieldAccessMessage: #idStudent from: (self fullSymbolOf: #SStudent);		yourself.	self		assertCollection: (testCase statements collect: #printString) allButLast		hasSameElements: (Array									with: '_var0 := 1.'									with: '_var1 := ',(self fullNameOfClass: 'SStudent')asString,' new.'									with: '_var2 := 1.'									with: '_var3 := _var1 scoreStudent: _var2.'									with: '_var4 := ',(self fullNameOfClass: 'SStudent')asString,' new.').	self		assert:			(#('_var5 := _var4 idStudent.')				includes: (testCase statementOfVarName: '_var5') printString).	fieldAccess := testCase statementOfVarName: '_var5'.	message := (testCase statementOfVarName: '_var2') value.	message := testCase insertExpression: message copy after: fieldAccess.	self		assert: message printString		equals: '_var6 := 1.'.	"message := testCase		perform: #insertAsParameter:using:		inStatement: fieldAccess.	self		assert: message printString		equals: '_var5 := _var1 scoreStudent: _var4.'"! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorAsParameterInFactoryMessage	| testCase auxExpr expression |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addFactoryMessage.	testCase addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: ('_var0 := ', (self fullNameOfClass: 'SFoo')asString,' new.')									with: ('_var1 := ', (self fullNameOfClass: 'SFoo')asString,' new.')).	auxExpr := testCase addMessage.	auxExpr value		receiver: (testCase statementOfVarName: '_var1') variable.	auxExpr := testCase		perform: #insertAsParameter:using:		inStatement: expression.	self		assert: auxExpr printString		equals: '_var3 := _var1 return: _var0.'! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorAsParameterInFieldMessage	| testCase aExpression |	testCase := (SSTestCase with: utility typeInfoSStack4) addTargetClassName: (self fullSymbolOf: #SStack).	testCase addFactoryMessage: (self fullSymbolOf: #SStack) ofSelector: #newStack.	aExpression := testCase		addFieldAccessMessage: #lastLinkStack		from: (self fullSymbolOf: #SStack).	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 										with: ('_var0 := ', (self fullNameOfClass: 'SStack')asString,' newStack.')									with: '_var1 := _var0 lastLinkStack.'									with: '_var2 := 5.').	testCase addMessage: #push: from: (self fullSymbolOf: #SStack).	testCase		perform: #insertAsParameter:using:		inStatement: aExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 										with: ('_var0 := ', (self fullNameOfClass: 'SStack')asString,' newStack.')									with: '_var1 := _var0 lastLinkStack.'									with: '_var2 := 5.'									with: '_var3 := 5.'									with: '_var4 := _var0 push: _var1.')! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorAsParameterInMessage	| testCase aExpression |	testCase := (SSTestCase with: utility typeInfoSStack4) addTargetClassName: (self fullSymbolOf: #SStack).	testCase addFactoryMessage: (self fullSymbolOf: #SStack) ofSelector: #newStackWith:.	aExpression := testCase addMessage: #pop from: (self fullSymbolOf: #SStack).	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := #(1 4 5 ).'									with: '_var1 := ', (self fullNameOfClass: 'SStack')asString,' newStackWith: _var0.'									with: '_var2 := _var1 pop.' 									with: '_var3 := 5.').	testCase addMessage: #push: from: (self fullSymbolOf: #SStack).	testCase		perform: #insertAsParameter:using:		inStatement: aExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := #(1 4 5 ).'									with: '_var1 := ', (self fullNameOfClass: 'SStack')asString,' newStackWith: _var0.'									with: '_var2 := _var1 pop.'									with: '_var3 := 5.'									with: '_var4 := _var1 push: _var2.')! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorMethodMessageInFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.' 									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.').	self		should: [ testCase insertStatementOfSelector: #insertMethodMessage:using: ]		raise: SError! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorMethodMessageInFieldMessage	| testCase fieldMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	fieldMessage := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 score.').	self		should: [ testCase				perform: #insertMethodMessage:using:				inStatement: fieldMessage copy ]		raise: SError! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorMethodMessageInLiteral	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 5.').	self		should: [ testCase insertStatementOfSelector: #insertMethodMessage:using: ]		raise: SError! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorMethodMessageInMessage	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	message := testCase addMessage: #returnNum from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.' 									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 returnNum.').	testCase		perform: #insertMethodMessage:using:		inStatement: message copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 returnNum.'									with: '_var3 := _var1 returnNum.')! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorRandomMessageInFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with:	'_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.').	testCase insertStatementOfSelector: #insertRandomMessage:using:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.')! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorRandomMessageInFieldMessage	| testCase fieldMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	fieldMessage := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 score.').	testCase		perform: #insertRandomMessage:using:		inStatement: fieldMessage copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 score.'									with: '_var3 := _var1 score.')! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorRandomMessageInLiteral	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addLiteral: (self fullSymbolOf: #SmallFloat64).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.').	self		should: [ testCase insertStatementOfSelector: #insertRandomMessage:using: ]		raise: SError! !!SInsertTest methodsFor: 'mutation-insert'!testInsertStatementOfSelectorRandomMessageInMessage	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	message := testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	testCase		perform: #insertRandomMessage:using:		inStatement: message copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.'									with: '_var4 := _var1 return: _var2.')! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveArgsFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.').	testCase removeStatementOfVarName: '_var0'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var2 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var2.').	self assert: testCase validReferences! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveArgsMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var2'.	self		assert:			(#('_var4 := ''hello''.' '_var4 := _var1 returnString.')				includes: (testCase statementOfVarName: '_var4') printString).	self		assert: (testCase statementOfVarName: '_var3') printString		equals: '_var3 := _var1 return: _var4.'.	self assert: testCase validReferences! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.')! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 score.').	testCase removeStatementOfVarName: '_var2'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.')! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var3'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.')! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveReceiverFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 score.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var2 := _var4 score.'									with: '_var3 := 7.3.'									with: '_var4 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.')! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveReceiverMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 7.3.'									with: '_var4 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := ''hello''.'									with: '_var3 := _var4 return: _var2.')! !!SRemoveTest methodsFor: 'mutation-remove'!testRemoveStatementNoRepairing	| testCase statement |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	statement := testCase addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.').	testCase removeStatementNoRepairing: statement.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.').	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName:  (self fullSymbolOf: #SFoo).	statement := testCase addFactoryMessage.	testCase addMessage: #returnFloat from:  (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 returnFloat.').	testCase removeStatementNoRepairing: statement.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.')! !!SSTestCaseTest methodsFor: 'tests'!setUp	utility := SUtilityTypeInfo new.	SPlatform resetRandomGenerator.	SPlatform fileLogger: 'STestCaseTestLogger.log'! !!SSTestCaseTest methodsFor: 'running'!tearDown	"SConfiguration clearFileLog: 'STestCaseTestLogger.log'"		SPlatform resetRandomGenerator! !!SSTestCaseTest methodsFor: 'tests'!testCopy	| testCase typeInfo otherTestCase |	typeInfo := self typeInfo.	testCase := SSTestCase with: typeInfo.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #returnNum from: (self fullSymbolOf: #SFoo);		addFieldAccessMessage: #score from: (self fullSymbolOf: #SFoo);		addLiteral: (self fullSymbolOf: #SmallInteger).	otherTestCase := testCase copy.	self assert: testCase length equals: 5.	self assert: testCase equals: otherTestCase.	self		assertCollection: testCase targetClassesNames		hasSameElements: (Array with: (self fullSymbolOf: #SFoo)).	testCase addLiteral: (self fullSymbolOf: #ByteString).	otherTestCase addMessage: #returnFloat from: (self fullSymbolOf: #SFoo).	otherTestCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array									with: '_var0 := 7.3.'									with: '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 returnNum.'									with: '_var3 := _var1 score.'									with: '_var4 := 5.'									with: '_var5 := ''hello''.').	self		assertCollection: (otherTestCase statements collect: #printString)		hasSameElements: (OrderedCollection new 									add: '_var0 := 7.3.';									add: '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.';									add: '_var2 := _var1 returnNum.';									add: '_var3 := _var1 score.';									add: '_var4 := 5.';									add: '_var5 := _var1 returnFloat.';									add: '_var6 := ''hello''.';									add: '_var7 := _var1 return: _var6.';									yourself)! !!SSTestCaseTest methodsFor: 'tests'!testFieldAccessMessage	| testCase |	testCase := SSTestCase		with:			(STypeInfo new				type:					(self fullSymbolOf: #SFoo)						->							(Array								with:									(Array										with: #score -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)										with: #score: -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: (Array with: (self fullSymbolOf: #SFoo))																with: false))								with: (Array with: #score: -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false)));				scalar: (self fullSymbolOf: #SmallInteger) with: #(5)).	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFieldAccessMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array 									with: '_var0 := 5.'									with: '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.'									with: '_var2 := _var1 score.')! !!SSTestCaseTest methodsFor: 'tests'!testGenerateStatements	| testCase  |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo);	numMaxStatements: 30.	self shouldnt: [ testCase generateStatements ] raise: SError! !!SSTestCaseTest methodsFor: 'tests'!testPickAccessorsOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1 .	self assert: (testCase pickAccessorsOf: (self fullSymbolOf: #SEvent)) isEmpty.	self		assertCollection: ((testCase pickAccessorsOf: (self fullSymbolOf: #SConference)) collect: #selector)		hasSameElements: #(#discount #offerPrice)! !!SSTestCaseTest methodsFor: 'tests'!testPickMessagesOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1 .	self assert: (testCase pickMessagesOf: (self fullSymbolOf: #SEvent)) isEmpty.	self		assertCollection: ((testCase pickMessagesOf: (self fullSymbolOf: #SConference)) collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price)! !!SSTestCaseTest methodsFor: 'tests'!typeInfo 	|typeInfo|	typeInfo := STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #returnNum -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: false)								with: #returnFloat -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallFloat64)																with: #()																with: false)								with: #score -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #return: -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #ByteString)																with: (Array with: (self fullSymbolOf: #ByteString))																with: false))						with: (Array with: #score: -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf: #SmallFloat64))																with: false))).	typeInfo scalar: (self fullSymbolOf: #ByteString) with: #('hello').	typeInfo scalar: (self fullSymbolOf: #SmallInteger) with: #(5).	typeInfo scalar: (self fullSymbolOf: #SmallFloat64) with: #(7.3).	^ typeInfo! !!SSTestShifterTest methodsFor: 'running'!setUp	SPlatform resetRandomGenerator.	utility := SUtilityTypeInfo new.	SPlatform fileLogger: 'STestShifterTestLogger.log'! !!SSTestShifterTest methodsFor: 'running'!tearDown 	SPlatform resetRandomGenerator! !!SSTestShifterTest methodsFor: 'tests'!testAddAssignment	| testCase expression |	testCase := SSTestCase new.	expression := testCase addAssignment: (SLiteral new value: 3).	self assert: expression printString equals: '_var0 := 3.'.	expression := testCase		addAssignment:			(SMessage new				receiver: (SVariable new id: 0);				selector: #foo;				yourself).	self assert: expression printString equals: '_var1 := _var0 foo.'! !!SSTestShifterTest methodsFor: 'tests'!testAddFactoryMessage	| testCase aTypeInfo |	aTypeInfo := utility typeInfoSFoo3.	testCase := SSTestCase with: aTypeInfo.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo).	self assert: testCase statements size equals: 2.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var0 := 4.'									with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.').	self should: [ testCase addFactoryMessage: (self fullSymbolOf: #SStack) ] raise: SError.	aTypeInfo		type:			(self fullSymbolOf: #SStack)				->					(Array						with: (Array with: #top -> (Array																with: (self fullSymbolOf: #SStack)																with: nil 																with: #()																with: false))						with: (Array with: #newStack: -> (Array																with: (self fullSymbolOf: #SStack)																with: (self fullSymbolOf: #SStack)																with: (Array with: (self fullSymbolOf: #Array))																with: false)));		scalar: (self fullSymbolOf:#Array) with: #(#(1 3 2)).	testCase		addTargetClassName: (self fullSymbolOf:#SStack);		addFactoryMessage: (self fullSymbolOf:#SStack).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array with: '_var0 := 4.'					with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.'					with: '_var2 := #(1 3 2 ).'					with: '_var3 := ', (self fullNameOfClass: 'SStack')asString,' newStack: _var2.')! !!SSTestShifterTest methodsFor: 'tests'!testAddFactoryMessageOfInexistentSelector	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo) ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var0 := ', (self fullNameOfClass: 'SFoo')asString,' new.')! !!SSTestShifterTest methodsFor: 'tests'!testAddFactoryMessageOfSelector	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo) ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with:'_var0 := 4.'		with: '_var1 := ', (self fullNameOfClass: 'SFoo')asString,' score: _var0.')! !!SSTestShifterTest methodsFor: 'tests'!testAddFactoryMessageOnPackage	| testCase expression |	testCase := SSTestCase with: utility typeInfoOnPackage3.	self should: [ testCase addFactoryMessage: (self fullSymbolOf: #SSTeacher) ] raise: SError.	testCase addTargetClassName:  (self fullSymbolOf: #SSTeacher).	expression := testCase addFactoryMessage:  (self fullSymbolOf: #SSTeacher).	self		assert:			((Array with: '_var2 := ', (self fullNameOfClass: 'SSTeacher')asString,' name: _var0 with: _var1.'			with: '_var2 := ', (self fullNameOfClass: 'SSTeacher')asString,' name: _var1 with: _var0.')				includes: expression printString).	self		shouldnt: [ expression := testCase addFactoryMessage: (self fullSymbolOf: #SConference) ]		raise: SError.	self		assert: expression printString		equals: '_var3 := ', (self fullNameOfClass: 'SConference')asString,' new.'! !!SSTestShifterTest methodsFor: 'tests'!testAddFactoryMessageWithAbstractClasses	| testCase |	testCase := SSTestCase with: utility typeInfoSSPerson1.	self should: [ testCase addFactoryMessage ] raise: SError.	self should: [ testCase addFactoryMessage: (self fullNameOfClass: #SSPerson) ] raise: SError.	testCase := SSTestCase with: utility typeInfoSAbstractClass.	self should: [ testCase addFactoryMessage ] raise: SError.	self		should: [ testCase addFactoryMessage: (self fullNameOfClass: #SAbstractClass) ]		raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testAddFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher2.	self should: [ testCase addFieldAccessMessage ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SSTeacher).	self		assert: testCase addFieldAccessMessage printString		equals: '_var1 := _var0 idTeacher.'.! !!SSTestShifterTest methodsFor: 'tests'!testAddFieldAccessMessageFrom	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	self		should: [ testCase addFieldAccessMessage: #score from: (self fullSymbolOf:#SFoo) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf:#SFoo).	self		assert: (testCase addFieldAccessMessage: #score from: (self fullSymbolOf:#SFoo)) printString		equals: '_var2 := _var1 score.'! !!SSTestShifterTest methodsFor: 'tests'!testAddFieldAccessMessageFromWithError	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo2.	self		should: [ testCase addFieldAccessMessage: #score from: (self fullSymbolOf:#SFoo) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf:#SFoo).	self		should: [testCase addFieldAccessMessage: #score from: (self fullSymbolOf:#SFoo)]		raise: SError.	self		should: [ testCase addFieldAccessMessage: #return: from: (self fullSymbolOf:#SFoo) ]		raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testAddFieldAccessMessageFromWithInvalidClassName	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase addTargetClassName: (self fullSymbolOf:#SFoo).	self		should: [ testCase addFieldAccessMessage: #score from: (self fullSymbolOf:#SStudent) ]		raise: SError.! !!SSTestShifterTest methodsFor: 'tests'!testAddFieldAccessMessageWithLackTypeInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self should: [ testCase addFieldAccessMessage ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf:#SSTeacher).	self should: [testCase addFieldAccessMessage] raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testAddFieldAccessMessageWithReceiver	| testCase typeInfo receiver |	typeInfo := utility typeInfoSFoo1.	testCase := (SSTestCase with: typeInfo) addTargetClassName: (self fullSymbolOf: #SFoo).	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addFieldAccessMessage: (typeInfo accessMessagesFrom: (self fullSymbolOf: #SFoo)) first				withReceiver: receiver) printString		equals: '_var2 := _var1 score.'! !!SSTestShifterTest methodsFor: 'tests'!testAddInvalidAssignment	| testCase |	testCase := SSTestCase new.	self should: [ testCase addAssignment: 3 ] raise: SError.	self should: [ testCase addAssignment: 'hello' ] raise: SError.	self should: [ testCase addAssignment: #name ] raise: SError.	self should: [ testCase addAssignment: 3.4 ] raise: SError.	self should: [ testCase addAssignment: #() ] raise: SError.! !!SSTestShifterTest methodsFor: 'tests'!testAddLiteral	| testCase aTypeInfo |	aTypeInfo := STypeInfo new.	aTypeInfo		scalar: #OrderedCollection			with: (Array with: (OrderedCollection newFrom: #(1 4)));		scalar: #ByteString with: #('World');		scalar: #SmallInteger with: #(2);		scalar: #SStudent with: (Array with: SStudent new).	testCase := SSTestCase with: aTypeInfo.	testCase		addLiteral: #ByteString;		addLiteral: #OrderedCollection;		addLiteral: #SmallInteger;		addLiteral: #SStudent.	self assert: testCase statements size equals: 4.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ''World''.'				with:					'_var1 := '						,							(OrderedCollection new								add: 1;								add: 4;								yourself) storeString , '.'				with: '_var2 := 2.'				with: '_var3 := ' , SStudent new storeString , '.')! !!SSTestShifterTest methodsFor: 'tests'!testAddLiteralWithError	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase addLiteral ] raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testAddLiteralWithWrongClassName	| testCase aTypeInfo |	aTypeInfo := STypeInfo new.	aTypeInfo scalar: #SmallInteger with: #(2).	testCase := SSTestCase with: aTypeInfo.	self should: [ testCase addLiteral: #ByteString ] raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testAddMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo5.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ',(self fullNameOfClass: 'SFoo')asString,' new.'				with: '_var1 := ' , (OrderedCollection newFrom: #(1 4 5)) storeString , '.'				with: '_var2 := _var0 return: _var1.')! !!SSTestShifterTest methodsFor: 'tests'!testAddMessageFrom	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #returnFloat from: (self fullSymbolOf: #SFoo).	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4.'				with: '_var1 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var0.'				with: '_var2 := _var1 returnFloat.').	self		assert: (testCase addMessage: #returnNum from: (self fullSymbolOf: #SFoo)) printString		equals: '_var3 := _var1 returnNum.'.	self		assert:			(#('_var4 := _var1 score: _var0.' '_var4 := _var1 score: _var3.' '_var5 := _var1 score: _var3.' '_var5 := _var1 score: _var4.')				includes: (testCase addMessage: #score: from:  (self fullSymbolOf: #SFoo)) printString)! !!SSTestShifterTest methodsFor: 'tests'!testAddMessageFromDifferentReceiver	| testCase |	testCase := (SSTestCase		with: utility typeInfoOnPackage1)		addTargetClassName: (self fullSymbolOf: #SEvent).	self		should: [ testCase addMessage: #canRegister: from: (self fullSymbolOf: #SEvent) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SConference).	testCase addMessage: #canRegister: from:  (self fullSymbolOf: #SConference).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ',(self fullNameOfClass: 'SConference')asString,' new.'				with: '_var1 := ' , (SStudent new name: 'Mary') storeString , '.'				with: '_var2 := _var0 canRegister: _var1.')! !!SSTestShifterTest methodsFor: 'tests'!testAddMessageWithEmptyTypeMethodInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSFooEmpty.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	self should: [ testCase addMessage ] raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testAddMessageWithReceiver	| testCase typeInfo receiver |	typeInfo := utility typeInfoSFoo2.	testCase := (SSTestCase with: typeInfo) addTargetClassName: (self fullSymbolOf: #SFoo).	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addMessage: (typeInfo messagesFrom: (self fullSymbolOf: #SFoo)) first				withReceiver: receiver) printString		equals: '_var1 := _var0 return: _var0.'! !!SSTestShifterTest methodsFor: 'tests'!testAddMessageWithTwoDeepScalarSFoo	| testCase |	testCase := SSTestCase		with: utility typeInfoSFooOnPackage3."(STON fromString: utility typeInfoStringSFoo6)."	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(OrderedCollection new				add: '_var0 := ', (self fullNameOfClass: 'SFoo')asString,' new.';				add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , '.';				add: '_var2 := ', (self fullNameOfClass: 'SStack')asString,' new.';				add: '_var3 := _var2 push: _var1.';				add: '_var4 := ' , (SStudent name: 'Josh' with: 2) storeString , '.';				add: '_var5 := _var2 push: _var4.';				add: '_var6 := ' , (SStudent name: 'Mery' with: 5) storeString , '.';				add: '_var7 := ((OrderedCollection new) add: _var6; yourself).';				add:					'_var8 := ((Dictionary new) add: (1->_var5); add: (2->_var7); yourself).';				add: '_var9 := _var0 return: _var8.';				yourself)! !!SSTestShifterTest methodsFor: 'tests'!testAddMessageWithTwoDeepScalarSStack	| testCase |	testCase := SSTestCase		with: utility typeInfoSStackOnPackage2."(STON fromString: utility typeInfoStringSStack1)".	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addMessage: #push: from: (self fullSymbolOf: #SStack).	self assert: testCase statements size equals: 3.	self		assert:			((testCase statements collect: #printString)				includesAny:					(Array						with:							(OrderedCollection new								add: '_var0 := SStack new.';								add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , '.';								add: '_var2 := ' , (SStudent name: 'Josh' with: 2) storeString , '.';								add: '_var3 := ((OrderedCollection new) add: _var1; add: _var2; yourself).';								add: '_var4 := _var0 push: _var3.';								yourself)						with:							(OrderedCollection new								add: '_var0 := SStack new.';								add: '_var1 := ' , (SStudent name: 'Mery' with: 5) storeString , '.';								add: '_var2 := ((OrderedCollection new) add: _var1; yourself).';								add: '_var3 := _var0 push: _var2.';								yourself)))! !!SSTestShifterTest methodsFor: 'tests'!testAddStatementAfter	| testCase expression1 expression2 |	testCase := SSTestCase with: utility typeInfoSSTeacher1.	expression1 := SAssignment		name: (SVariable new id: 0)		value: ((SLiteral value: 2) returnType: (self fullSymbolOf: #SmallInteger)).	self		assert: (testCase addStatement: expression1 after: nil) printString		equals: '_var0 := 2.'.	expression2 := SAssignment		name: (SVariable new id: 1)		value: (SFactoryMessage default: (self fullSymbolOf: #SSTeacher)).	self		assert: (testCase addStatement: expression2 after: expression1) printString		equals: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var0 := 2.'									with: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.').	expression1 := expression2.	expression2 := SAssignment		name: (SVariable new id: 2)		value:			(SMessage new				selector: #yearsWorkExperience;				receiver: expression1 variable;				yourself).	testCase addStatement: expression2 after: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var0 := 2.'									with: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.'									with: '_var2 := _var1 yearsWorkExperience.').	expression2 := SAssignment		name: (SVariable new id: 3)		value: (SLiteral value: 4).	testCase addStatement: expression2 after: expression1.	self		assert:			((Array				with:					(Array with: '_var0 := 2.'						with: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.'						with: '_var2 := _var1 yearsWorkExperience.'						with: '_var3 := 4.')				with:					(Array with: '_var0 := 2.'						with: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.'						with: '_var3 := 4.'						with: '_var2 := _var1 yearsWorkExperience.'))				includes: (testCase statements collect: #printString) asArray)! !!SSTestShifterTest methodsFor: 'tests'!testAddStatementBefore	| testCase expression1 expression2 |	testCase := SSTestCase new.	expression1 := SAssignment		name: (SVariable new id: 0)		value: ((SLiteral value: 2) returnType:  (self fullSymbolOf:#SmallInteger)).	testCase addStatement: expression1 before: nil.	expression2 := SAssignment		name: (SVariable new id: 1)		value: (SFactoryMessage default:  (self fullSymbolOf:#SSTeacher)).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.'									with: '_var0 := 2.').	expression1 := expression2.	expression2 := SAssignment		name: (SVariable new id: 2)		value: ((SLiteral value: 100) returnType:  (self fullSymbolOf:#SmallInteger)).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var2 := 100.'									with: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.'									with: '_var0 := 2.').	expression1 := testCase statements last.	"_var0"	expression2 := SAssignment		name: (SVariable new id: 3)		value:			(SMessage new				selector: #yearsWorkExperience;				receiver: testCase statements second variable;				yourself).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array with: '_var2 := 100.'				with: '_var1 := ',(self fullNameOfClass: 'SSTeacher')asString,' new.'				with: '_var3 := _var1 yearsWorkExperience.'				with: '_var0 := 2.')! !!SSTestShifterTest methodsFor: 'tests'!testAddStatetementOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf:#SEvent).	expression := testCase addStatementOfType: (self fullSymbolOf:#SEvent) before: nil.	self		assert: expression printString		equals: '_var1 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var0.'.	expression := testCase		addStatementOfType: (self fullSymbolOf:#SmallInteger)		before: expression.	self assert: expression printString equals: '_var2 := 8.'.	"change the form to select randomly"	self		assert:			((Array with: (Array with: '_var0 := 8.'						with: '_var2 := 8.'						with: '_var1 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var0.') 					with: (Array with: '_var2 := 8.'						with: '_var0 := 8.'						with: '_var1 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var0.'))				includes: (testCase statements collect: #printString) asArray)! !!SSTestShifterTest methodsFor: 'tests'!testAddStatetementOfTypeBeforeFactoryMessage	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf:#SEvent).	expression := testCase addFactoryMessage.	expression := testCase addStatementOfType: (self fullSymbolOf:#SEvent) before: expression.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array with: '_var0 := 8.'				with: '_var2 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var0.'				with: '_var1 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var0.')! !!SSTestShifterTest methodsFor: 'tests'!testAddTargetClassName	| testCase expression |	testCase := SSTestCase with: utility typeInfoOnPackage3.	self should: [testCase addTargetClassName: (self fullSymbolOf:#SEvent)] raise: SError.	self shouldnt: [testCase addTargetClassName: (self fullSymbolOf:#SSTeacher)] raise: SError.	expression := testCase addFactoryMessage: (self fullSymbolOf:#SSTeacher).	self		assert:			((Array with:'_var2 := ',(self fullNameOfClass: 'SSTeacher')asString,' name: _var0 with: _var1.'			with: '_var2 := ',(self fullNameOfClass: 'SSTeacher')asString,' name: _var1 with: _var0.')				includes: expression printString).! !!SSTestShifterTest methodsFor: 'tests'!testBuildArgsBefore	| testCase typeInfo expression |	typeInfo := utility typeInfoSEvent1.	testCase := SSTestCase with: typeInfo.	testCase addTargetClassName: (self fullSymbolOf:#SEvent).	expression := testCase addLiteral.	testCase buildArgs: ((typeInfo factoryMessagesFrom: (self fullSymbolOf:#SEvent)) first argTypes)  before: expression.	self		assertCollection: (testCase printStatements )		hasSameElements: #('_var1 := 8.' '_var0 := 8.')! !!SSTestShifterTest methodsFor: 'tests'!testNewFactoryMessageBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf:#SEvent).	expression := testCase addLiteral.	self		assert: (testCase newFactoryMessage: (self fullSymbolOf:#SEvent) before: expression) printString		equals: (self fullNameOfClass: 'SEvent')asString,' price: _var1'.	"default factoryMessage"	testCase := SSTestCase with: utility typeInfoSFoo5.	testCase addTargetClassName: (self fullSymbolOf:#SFoo).	self		assert: (testCase newFactoryMessage: (self fullSymbolOf:#SFoo) before: nil) printString		equals: (self fullNameOfClass: 'SFoo')asString,' new'! !!SSTestShifterTest methodsFor: 'tests'!testNewFactoryMessageUsingAnd	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName:  (self fullSymbolOf:#SEvent).	expression := testCase addLiteral.	self		assert: (testCase newFactoryMessageUsing:  (self fullSymbolOf:#SEvent) and: expression) printString		equals: (self fullNameOfClass: 'SEvent')asString,' price: _var1'.	self assertCollection: testCase printStatements  hasSameElements: #('_var1 := 8.' '_var0 := 8.')! !!SSTestShifterTest methodsFor: 'tests'!testNewFieldAccessMessageOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf:#SFoo).	expression := testCase addLiteral:(self fullSymbolOf: #SmallInteger).	self		should: [ testCase newFieldAccessMessageOfType: (self fullSymbolOf:#SmallInteger) before: expression ]		raise: SError.	testCase		addStatement:			(testCase				newAssignment: (testCase newFactoryMessage: (self fullSymbolOf:#SFoo) before: expression))		before: expression.	self		assert:			(testCase newFieldAccessMessageOfType: (self fullSymbolOf:#SmallFloat64) before: expression)				printString		equals: '_var2 score'.	self		assertCollection: testCase printStatements		hasSameElements: (Array with: '_var1 := 7.3.'									with: '_var2 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var1.'									with: '_var0 := 5.')! !!SSTestShifterTest methodsFor: 'tests'!testNewMessageOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		should: [ testCase newMessageOfType: (self fullSymbolOf:#SmallInteger) before: expression ]		raise: SError.	testCase		addStatement:			(testCase				newAssignment: (testCase newFactoryMessage: (self fullSymbolOf:#SFoo) before: expression))		before: expression.	self		assert:			(testCase newMessageOfType: (self fullSymbolOf:#SmallInteger) before: expression)				printString		equals: '_var2 returnNum'.	self		assertCollection: testCase printStatements		hasSameElements: (Array with: '_var1 := 7.3.'									with: '_var2 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var1.'									with: '_var0 := 5.')! !!SSTestShifterTest methodsFor: 'tests'!testNewStatementOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	expression := testCase		newAssignment: (testCase newStatementOfType: (self fullSymbolOf: #SmallInteger) before: nil).	testCase addStatement: expression before: nil.	self		assertCollection: testCase printStatements		hasSameElements: #('_var0 := 8.').	expression := testCase newStatementOfType: (self fullSymbolOf: #SEvent) before: expression.	self assert: expression printString equals: (self fullNameOfClass: 'SEvent')asString,' price: _var1'.	expression := testCase newAssignment: expression.	testCase		addStatement: expression		before: (testCase statementOfVarName: '_var0').	self		assertCollection: testCase printStatements		hasSameElements: (Array with: '_var1 := 8.'									with: '_var2 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var1.'									with: '_var0 := 8.')! !!SSTestShifterTest methodsFor: 'tests'!testObjectVariables	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self assert: testCase objectVariables isEmpty.	testCase		addTargetClassName: (self fullSymbolOf:#SSTeacher);		addFactoryMessage.	self		assertCollection: (testCase objectVariables collect: #printString)		hasSameElements: #('_var0')! !!SSTestShifterTest methodsFor: 'tests'!testPickAccessorsOf	| testCase |	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		addTargetClassName: (self fullSymbolOf:#SSTeacher).	self		assertCollection: ((testCase pickAccessorsOf: (self fullSymbolOf:#SSTeacher)) collect: #selector)		hasSameElements: #(#yearsWorkExperience #idTeacher).	testCase := (SSTestCase with: utility typeInfoSSTeacher3)		addTargetClassName: (self fullSymbolOf:#SSTeacher).	self assert: (testCase pickAccessorsOf: (self fullSymbolOf:#SSTeacher)) isEmpty.	! !!SSTestShifterTest methodsFor: 'tests'!testPickAccessorsOfWithInvalidClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		addTargetClassName: (self fullSymbolOf:#SSTeacher).	self assert: (testCase pickAccessorsOf: (self fullSymbolOf:#SStudent)) isEmpty! !!SSTestShifterTest methodsFor: 'tests'!testPickAnObjectVariable	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self should: [testCase  pickAnObjectVariable ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf:#SSTeacher).	self assert: testCase pickAnObjectVariable printString equals: '_var0'! !!SSTestShifterTest methodsFor: 'tests'!testPickFactoryMessagesFrom	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage2 .	self		should: [ testCase addMessage: #price: from: (self fullSymbolOf:#SEvent) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf:#SConference).	testCase addFactoryMessage: (self fullSymbolOf:#SConference) ofSelector: #price:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var0 := 95.'		with: '_var1 := ',(self fullNameOfClass: 'SConference')asString,' price: _var0.')! !!SSTestShifterTest methodsFor: 'tests'!testPickMessagesOf	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self		assert: ((testCase pickMessagesOf: (self fullSymbolOf:#SEvent)) collect: #selector) isEmpty.	self		assertCollection: ((testCase pickMessagesOf: (self fullSymbolOf:#SConference)) collect: #selector)		hasSameElements: #(#price: #initialize).	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		assertCollection: ((testCase pickMessagesOf: (self fullSymbolOf:#SSTeacher)) collect: #selector)		hasSameElements: #(#name: #id: #nickname: #initialize #nickname)! !!SSTestShifterTest methodsFor: 'tests'!testPickMessagesOfWrongClassName	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self assert: (testCase pickMessagesOf: (self fullSymbolOf:#SSTeacher)) isEmpty.	testCase := SSTestCase with: utility typeInfoOnPackage3.	self assert: (testCase pickMessagesOf: (self fullSymbolOf:#SSPerson)) isEmpty.	self assert: (testCase pickMessagesOf: (self fullSymbolOf:#SStudent)) isEmpty! !!SSTestShifterTest methodsFor: 'tests'!testPickOrCreateObjectVariableOf	| testCase |	testCase := (SSTestCase with: utility typeInfoSFoo2)		addTargetClassName: (self fullSymbolOf:#SFoo).	self assert: testCase statements isEmpty.	self		assert: (testCase pickOrCreateObjectVariableOf: (self fullSymbolOf:#SFoo)) printString		equals: '_var0'.	self assertCollection: (testCase statements collect: #printString) hasSameElements: (Array with: '_var0 := ',(self fullNameOfClass: 'SFoo')asString,' new.').	testCase pickOrCreateObjectVariableOf: (self fullSymbolOf:#SFoo).	self assert: testCase statements size equals: 1! !!SSTestShifterTest methodsFor: 'tests'!testPickOrCreateObjectVariableOfWrongClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSFoo2)		addTargetClassName: (self fullSymbolOf:#SFoo).	self		should: [ testCase pickOrCreateObjectVariableOf: (self fullSymbolOf:#SSTeacher) ]		raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testRandomLiteralClassName	| testCase |	testCase := SSTestCase		with: (STypeInfo new scalar: (self fullSymbolOf:#SmallInteger) with: #(1 3 4)).	self assert: testCase randomLiteralClassName equals: (self fullSymbolOf:#SmallInteger).	testCase := SSTestCase		with:			(STypeInfo new				scalar: (self fullSymbolOf:#ByteString) with: #('hello');				scalar: (self fullSymbolOf:#SmallInteger) with: #(1 5 6)).	self		assert:			((Array with: (self fullSymbolOf:#ByteString) with: (self fullSymbolOf:#SmallInteger))				includes: testCase randomLiteralClassName)! !!SSTestShifterTest methodsFor: 'tests'!testRandomLiteralClassNameWithEmptyScalars	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase randomLiteralClassName ] raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testSubStatementsFromToPrevIndexOf	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf:#SEvent).	self		assert: (testCase subStatementsFrom: 1 toPrevIndexOf: nil) isEmpty.	expression := testCase addLiteral.	self		assert: (testCase subStatementsFrom: 1 toPrevIndexOf: expression) isEmpty.	expression := testCase addFactoryMessage.	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements: #('_var0 := 8.' '_var1 := 8.').	expression := testCase addMessage: #discount: from: (self fullSymbolOf:#SEvent).	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements: (Array with: '_var0 := 8.'									with: '_var1 := 8.'									with: '_var2 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var0.'									with: '_var3 := 8.').	expression := testCase addFieldAccessMessage: #price from: (self fullSymbolOf:#SEvent).	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements: (OrderedCollection new add: '_var0 := 8.';									add: '_var1 := 8.';									add: '_var2 := ',(self fullNameOfClass: 'SEvent')asString,' price: _var0.';									add: '_var3 := 8.';									add: '_var4 := _var2 discount: _var1.'; yourself).! !!SSTestShifterTest methodsFor: 'tests'!testValidTargetClassName	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage1.	self should: [ testCase validTargetClassName: (self fullSymbolOf:#SEvent) ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf:#SEvent).	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf:#SEvent) ]		raise: SError.	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf:#SConference) ]		raise: SError.	self shouldnt: [ testCase validTargetClassName: (self fullSymbolOf:#SStudent) ] raise: SError! !!SSTestShifterTest methodsFor: 'tests'!testValidTargetClassNameWithLackTypeInfo	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage4.	self should: [ testCase validTargetClassName: (self fullSymbolOf:#SEvent) ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf:#SEvent).	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf:#SEvent) ]		raise: SError.	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf:#SConference) ]		raise: SError.	self		should: [ testCase validTargetClassName: (self fullSymbolOf:#SParty) ]		raise: SError.! !!STypeInfoTest methodsFor: 'tests'!nameOf: aClass	^ aClass name! !!STypeInfoTest methodsFor: 'tests'!testAccesssMessagesFrom	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with:							(Array								with: #returnString -> #(#SFoo #ByteString #() false)								with: #score -> #(#SFoo #SmallInteger #() true))						with: #()).	self		assertCollection: ((typeInfo accessMessagesFrom: #SFoo) collect: #selector)		hasSameElements: #(#score)! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoSConferenceOnPackagesMatching	| typeInfo messages |	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	messages := typeInfo messagesFrom: (self nameOf: SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #price:).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = (self nameOf: SConference) ]).	self assert: ((typeInfo messagesFrom: (self nameOf: SEvent)) allSatisfy: #isUnary).	self assert: (typeInfo messagesFrom: (self nameOf: SParty)) isEmpty.	messages := typeInfo factoryMessagesFrom: (self nameOf:  SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#price:)! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoSEventOnPackagesMatching	| typeInfo messages methodInfo classNameSEvent classNameSConference classNameSParty classNameByteString classNameSmallInteger classNameSStudent |	classNameSEvent := self nameOf: SEvent.	classNameSConference := self nameOf: SConference.	classNameSParty := self nameOf: SParty.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameSStudent := self nameOf: SStudent.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ | aConference aPerson |			aConference := SConference new offerPrice: 95.			aPerson := SStudent new name: 'Mary'.			aConference canRegister: aPerson ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assert: (typeInfo types at: classNameSEvent) methodTypes size		equals: 4.	self		assert: (typeInfo types at: classNameSEvent) classMethodTypes isEmpty.	self		assert: (typeInfo types at: classNameSConference) methodTypes size		equals: 5.	self		assert: (typeInfo types at: classNameSConference) classMethodTypes isEmpty.	self assert: ((typeInfo types at: classNameSParty) methodTypes allSatisfy: #isUnary).	self		assert: (typeInfo types at: classNameSParty) classMethodTypes isEmpty.	messages := typeInfo messagesFrom: classNameSConference.	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = classNameSConference ]).	methodInfo := messages		detect: [ :aMessage | aMessage selector = #canRegister: ].	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: False)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSStudent).	self		assertCollection: methodInfo allReceivers		hasSameElements: (Array with: classNameSConference).	self		assertCollection: typeInfo scalars keys		hasSameElements:			(Array				with: (self nameOf: (SUndefinedObject basicNew) class)				with: classNameSStudent				with: classNameSmallInteger				with: (self nameOf: False)				with: classNameByteString				with: (self nameOf: 2.3 class))! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoSFoo	| profile typeInfo methodInfo classNameSFoo classNameOrderedCollection classNameSmallFloat64 classNameByteString classNameSmallInteger classNameDictionary |	classNameSFoo := self nameOf: SFoo.	classNameOrderedCollection := self nameOf: OrderedCollection.	classNameSmallFloat64 := self nameOf: SmallFloat64.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameDictionary := self nameOf: Dictionary.	profile := self aSTypeCollectorClass		profile: [ SFoo new				return: Dictionary new;				return: OrderedCollection new;				returnFloat;				returnString;				returnCollection;				returnNum;				score;				score: 5 ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 8.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes size		equals: 0.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assert:			(typeInfo methodType: #returnFloat from: classNameSFoo) returnType				type		equals: classNameSmallFloat64.	self		assert:			(typeInfo methodType: #returnCollection from: classNameSFoo)				returnType type		equals: classNameOrderedCollection.	self		assert:			(typeInfo methodType: #returnString from: classNameSFoo) returnType				type		equals: classNameByteString.	self		assert: (typeInfo methodType: #returnNum from: classNameSFoo) returnType type		equals: classNameSmallInteger.	self		assert: (typeInfo methodType: #score from: classNameSFoo) returnType type		equals: classNameSmallInteger.	methodInfo := typeInfo methodType: #score: from: classNameSFoo.	self assert: methodInfo returnType type equals: classNameSFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSmallInteger).	self assert: (typeInfo factoryMessagesFrom: classNameSFoo) isEmpty.	"the factoryMessage has not been executed"	self		assertCollection: typeInfo scalars keys		hasSameElements:			(Array				with: classNameOrderedCollection				with: classNameDictionary				with: classNameByteString				with: classNameSmallInteger				with: classNameSmallFloat64)! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoSFooOnClass	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := self aSTypeCollectorClass		profile: [ SFoo new return: OrderedCollection ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 7.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#returnFloat #returnCollection #initialize #returnNum #returnString #return:)! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoSFooWithNil	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := self aSTypeCollectorClass		profile: [ SFoo new return: nil ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 7.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#returnFloat #returnCollection #initialize #returnNum #returnString #return:)! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoSTeacherOnClass	| typeInfo classNameSTeacher |	classNameSTeacher := self nameOf: SSTeacher.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		forClassNamed: classNameSTeacher).	self		assertCollection:			((typeInfo types at: classNameSTeacher) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assert: (typeInfo types at: classNameSTeacher) classMethodTypes isEmpty.	self		assertCollection: ((typeInfo messagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#initialize #nickname).	self		assertCollection: ((typeInfo accessMessagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience)! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoSTeacherOnPackagesMatching	| typeInfo |	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection:			((typeInfo types at: (self nameOf: SSTeacher)) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assertCollection:			((typeInfo factoryMessagesFrom: (self nameOf: SSTeacher))				collect: #selector)		hasSameElements: #(#name:with:).	self		assertCollection: ((typeInfo messagesFrom: (self nameOf: SSTeacher)) collect: #selector)		hasSameElements: #(#initialize #nickname #id: #nickname: #name:).	self		assertCollection:			((typeInfo accessMessagesFrom: (self nameOf: SSTeacher))				collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience #name #id)! !!STypeInfoTest methodsFor: 'tests'!testAsTypeInfoScalars	| typeInfo |	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: (typeInfo scalars values flatCollect: [ :val | val ])		hasSameElements: #(95 0 100 nil).	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ SFoo new				returnCollection;				returnFloat;				returnNum;				returnString ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: typeInfo scalars associations		hasSameElements:			(Array				with: (self nameOf: (SUndefinedObject basicNew) class) -> #(nil)				with: (self nameOf: SmallInteger) -> #(0 4)				with: (self nameOf: OrderedCollection) -> (Array with: OrderedCollection new)				with: (self nameOf: ByteString) -> #('Hello')				with: (self nameOf: 2.3 class) -> #(2.3))! !!STypeInfoTest methodsFor: 'tests'!testClassMethodTypeFrom	| typeInfo |	typeInfo := STypeInfo new		type: #SFoo -> (Array with: #() with: #()).	self		should: [ typeInfo classMethodType: #new from: #SFoo ]		raise: SError.	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with: (Array with: #initialize -> #(#SFoo #SFoo #() false))						with: #()).	self		shouldnt: [ typeInfo classMethodType: #new from: #SFoo ]		raise: SError! !!STypeInfoTest methodsFor: 'tests'!testEquals	self		assert: (STypeInfo new type: #SFoo -> #(#() #()))		equals: (STypeInfo new type: #SFoo -> #(#() #())).	self		assert:			(STypeInfo new				type:					#SStudent						->							(Array								with: (Array with: #name -> #(#SStudent #ByteString #() false))								with: #());				scalar: #ByteString with: #('Abi'))		equals:			(STypeInfo new				type:					#SStudent						->							(Array								with: (Array with: #name -> #(#SStudent #ByteString #() false))								with: #());				scalar: #ByteString with: #('Abi')).	self		assert:			(STypeInfo new				type:					#SFoo						->							(Array								with: (Array with: #return: -> #(#SFoo #SStudent #(#SStudent) false))								with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false)));				scalar: #SmallInteger with: #(1 3 4);				scalar: #SStudent with: (Array with: (SStudent name: 'Nilson')))		equals:			(STypeInfo new				type:					#SFoo						->							(Array								with: (Array with: #return: -> #(#SFoo #SStudent #(#SStudent) false))								with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false)));				scalar: #SmallInteger with: #(1 3 4);				scalar: #SStudent with: (Array with: (SStudent name: 'Nilson')))! !!STypeInfoTest methodsFor: 'tests'!testFactoryMessages	| typeInfo classNameStudent |	classNameStudent := self nameOf: SStudent.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ SStudent name: 'Mary' ]		forClassNamed: classNameStudent).	self assert: (typeInfo factoryMessagesFrom: #SStudent) isEmpty.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ SStudent name: 'Mary' ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: ((typeInfo factoryMessagesFrom: #SStudent) collect: #selector)		hasSameElements: #(#name:).	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: ((typeInfo factoryMessagesFrom: #SConference) collect: #selector)		hasSameElements: #(#price:)! !!STypeInfoTest methodsFor: 'tests'!testFactoryMessagesFrom	"self halt"! !!STypeInfoTest methodsFor: 'tests'!testFromString	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #return: -> #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false)));		scalar: #SmallFloat64 with: #(2.3 4.6);		scalar: #ByteString with: #('hello' 'Abi').	self		assert:			(STON				fromString:					'STypeInfo {						#types: { 							#SFoo: STypeClassInfo { 							#typeName: #SFoo,							#methodTypes: {								#returnFloat: STypeMethodInfo {#selector: #returnFloat, #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SmallFloat64], #argTypes: [], #isQuick: false}, 								#''return:'': STypeMethodInfo {#selector: #''return:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [SMultiTypeInfo [#ByteString]], #isQuick: false}}, 							#classMethodTypes: { 								#''score:'': STypeMethodInfo {#selector: #''score:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SFoo], #argTypes: [SMultiTypeInfo [#SmallInteger]], #isQuick: false}							}}						},					#scalars: {						#SmallFloat64: [ 2.3, 4.6 ],						#ByteString: [ ''hello'', ''Abi'' ]					}}')		equals: typeInfo! !!STypeInfoTest methodsFor: 'tests'!testIsAbstracClass	| typeInfo |	typeInfo := STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				->					(Array						with:							(Array								with: #name -> (Array with: (self fullSymbolOf: #SSPerson)									with: (self fullSymbolOf:#ByteString)									with: #()									with: true)								with: #id ->  (Array with: (self fullSymbolOf: #SSPerson)									with: (self fullSymbolOf:#SmallInteger)									with: #()									with: false))						with:							(Array								with:									#name:with:										->  (Array with: (self fullSymbolOf: #SSPerson)									with: (self fullSymbolOf:#SSPerson)									with: (Array with: (self fullSymbolOf:#ByteString) with:  (self fullSymbolOf:#SmallInteger))									with: false)));		scalar: (self fullSymbolOf:#SmallInteger) with: #(50);		scalar: (self fullSymbolOf:#ByteString) with: #('Ann').	self assert: (typeInfo isAbstractClass:  (self fullSymbolOf:#SSPerson) )! !!STypeInfoTest methodsFor: 'tests'!testJoinWith	| typeInfo methodInfo otherTypeInfo |	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with:							(Array								with: #return: -> #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -> #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false))).	otherTypeInfo := STypeInfo new		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #returnString -> #(#SFoo #ByteString #() false)								with: #return: -> #(#SFoo #Stack #(#Stack) false))						with: #()).	typeInfo joinWith: otherTypeInfo.	self assert: (typeInfo types at: #SFoo) methodTypes size equals: 5.	self		assert: (typeInfo types at: #SFoo) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self		assertCollection: #(#OrderedCollection #Stack)		hasSameElements: methodInfo returnType types.	self		assertCollection: #(#OrderedCollection #Stack)		hasSameElements: (methodInfo argTypes flatCollect: [ :argType | argType types ]).	self		assert: (typeInfo methodType: #returnFloat from: #SFoo) returnType type		equals: #SmallFloat64.	self		assert: (typeInfo methodType: #returnString from: #SFoo) returnType type		equals: #ByteString.	self		assert: (typeInfo methodType: #score from: #SFoo) returnType type		equals: #SmallInteger.	methodInfo := typeInfo methodType: #score: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: (methodInfo argTypes flatCollect: [ :argType | argType types ])		hasSameElements: #(#SmallInteger).	self		assert: (typeInfo classMethodType: #score: from: #SFoo) returnType type		equals: #SFoo! !!STypeInfoTest methodsFor: 'tests'!testMessagesFrom	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #returnString -> #(#SFoo #ByteString #() false)								with: #score -> #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false))).	self		assertCollection: ((typeInfo messagesFrom: #SFoo) collect: #selector)		hasSameElements: #(#returnFloat #returnString)	"self assertCollection: ((typeInfo accessMessagesFrom: #SFoo) collect: #selector) hasSameElements: #(#score)."! !!STypeInfoTest methodsFor: 'tests'!testNoneAbstractClasses	| typeInfo |	typeInfo := STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				->					(Array						with:							(Array								with: #name -> (Array with:(self fullSymbolOf: #SSPerson) 													with: (self fullSymbolOf: #ByteString)													with: #()													with: true)								with: #id -> (Array with:(self fullSymbolOf: #SSPerson) 													with: (self fullSymbolOf: #SmallInteger)													with: #()													with: false))						with:							(Array								with:									#name:with:										-> (Array with:(self fullSymbolOf: #SSPerson) 													with: (self fullSymbolOf: #SSPerson)													with: (Array with: (self fullSymbolOf: #ByteString) with:(self fullSymbolOf: #SmallInteger) )													with: false)));		type:			(self fullSymbolOf: #SAbstractClass)				->					(Array						with: (Array with: #id ->  (Array with:(self fullSymbolOf: #SAbstractClass) 													with: (self fullSymbolOf: #SmallInteger)													with: #()													with: true))						with: #());		type:			(self fullSymbolOf: #SStudent)				->					(Array						with: (Array with: #scoreStudent ->  (Array with:(self fullSymbolOf: #SStudent) 													with: (self fullSymbolOf: #SmallInteger)													with: #()													with: true))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(50 1);		scalar: (self fullSymbolOf: #ByteString) with: #('Ann').	self		assertCollection: (typeInfo noneAbstractClasses collect: #name) asArray		hasSameElements:( Array with:  #SStudent)! !!STypeInfoTest methodsFor: 'tests'!testScalar	| typeInfo |	typeInfo := STypeInfo new		scalar: #SmallInteger with: #(1 5 6);		scalar: #ByteString with: #('hello' 'world');		scalar: #Dictionary			with:			(Array				with: Dictionary new				with:					(Dictionary new						at: 2 put: 3;						yourself)).	self		assertCollection: typeInfo scalars keys		hasSameElements: #(#Dictionary #ByteString #SmallInteger).	self		assertCollection: (typeInfo scalars at: #ByteString)		hasSameElements: #('hello' 'world').	self		assertCollection: (typeInfo scalars at: #SmallInteger)		hasSameElements: #(1 5 6).	self		assertCollection: ((typeInfo scalars at: #Dictionary) collect: #className)		hasSameElements: #('Dictionary' 'Dictionary')! !!STypeInfoTest methodsFor: 'tests'!testToString	| string typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #return: -> #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false)));		scalar: #SmallFloat64 with: #(2.3 4.6);		scalar: #ByteString with: #('hello' 'Abi').	string := STON toString: typeInfo.	self assert: (STON fromString: string) equals: typeInfo! !!STypeInfoTest methodsFor: 'tests'!testToStringComplexScalar	| string typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with: (Array with: #return: -> #(#SFoo #ByteString #(#ByteString) false))						with: #());		scalar: #SStudent with: (Array with: (SStudent name: 'Abi')).	string := STON toString: typeInfo.	self assert: (STON fromString: string) equals: typeInfo! !!STypeInfoTest methodsFor: 'tests'!testType	| typeInfo methodInfo |	typeInfo := STypeInfo new		type:			#SFoo				->					(Array						with:							(Array								with: #returnFloat -> #(#SFoo #SmallFloat64 #() false)								with: #returnString -> #(#SFoo #ByteString #() false)								with: #return: -> #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -> #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -> #(#SFoo #SFoo #(#SmallInteger) false))).	self assert: (typeInfo types at: #SFoo) methodTypes size equals: 5.	self		assert: (typeInfo types at: #SFoo) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self		assert: (typeInfo methodType: #returnFloat from: #SFoo) returnType type		equals: #SmallFloat64.	self		assert: (typeInfo methodType: #returnString from: #SFoo) returnType type		equals: #ByteString.	self		assert: (typeInfo methodType: #score from: #SFoo) returnType type		equals: #SmallInteger.	methodInfo := typeInfo methodType: #score: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self		assert: (typeInfo classMethodType: #score: from: #SFoo) returnType type		equals: #SFoo! !!SmallTypeCollectorTest methodsFor: 'tests'!testAnInteger	self assert:#Integer equals: (self typeFor:'anInteger').! !!SmallTypeCollectorTest methodsFor: 'tests'!testInteger	self assert:#Integer equals: (self typeFor:'integer').! !!SmallTypeCollectorTest methodsFor: 'tests'!typeFor: aName	^ SmallTypeCollector new typeFor: aName.! !!TestCase methodsFor: '*SmallSuiteGenerator-Tests'!fullNameOfClass: aString	^ aString ! !!TestCase methodsFor: '*SmallSuiteGenerator-Tests'!fullSymbolOf: aSymbol	^ aSymbol ! !!SUtilityTypeInfo methodsFor: 'tests'!testSuiteOf: aCollection withTargetClassName: symbol	self		assert: aCollection size >= 2		description: 'list must have at least two or more testCases.'.	^ OrderedCollection new		add: ((SSTestCase with: aCollection first) addTargetClassName: symbol; generateStatements);		add: ((SSTestCase with: aCollection second) addTargetClassName: symbol; generateStatements);		yourself! !!SUtilityTypeInfo methodsFor: 'tests'!testSuiteSSTeacher	^ self		testSuiteOf:			(Array				with: self typeInfoSSTeacher1				with: self typeInfoSSTeacher2				with: self typeInfoSSTeacher3) withTargetClassName: (self fullSymbolOf: #SSTeacher)! !!SUtilityTypeInfo methodsFor: 'tests'!testSuiteSStack	^ self		testSuiteOf:			(Array				with: self typeInfoSStack1				with: self typeInfoSStack2				with: self typeInfoSStack3				with: self typeInfoSStack4) withTargetClassName: (self fullSymbolOf: #SStack)! !!SUtilityTypeInfo methodsFor: 'tests'!testSuiteSStudent	^ self testSuiteOf: self typeInfosSStudent withTargetClassName: (self fullSymbolOf: #SStudent)! !!SUtilityTypeInfo methodsFor: 'tests'!testSuiteSStudentManual	^ OrderedCollection new		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;				addLiteral: (self fullSymbolOf: #ByteString);				addFieldAccessMessage: #idStudent from: (self fullSymbolOf: #SStudent);				addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;				addFieldAccessMessage: #scoreStudent from: (self fullSymbolOf: #SStudent);				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: (self fullSymbolOf: #SStudent);				addLiteral: (self fullSymbolOf: #SmallInteger);				addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;				addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;				addFieldAccessMessage: #idStudent from: (self fullSymbolOf: #SStudent);				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;				addLiteral: (self fullSymbolOf: #SmallInteger);				addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);				addLiteral: (self fullSymbolOf: #SmallInteger);				addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;				yourself);		yourself! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoArrayedCollection	^ STypeInfo new		type:			(self fullSymbolOf: #ArrayedCollection)				->					(Array						with:							(Array								with: #add -> #(#AthensCairoCanvas #nil #() false)								with: #size -> #(#AthensCairoCanvas #nil #() false))						with: #());		scalar: (self fullSymbolOf: #ByteString) with: #('hello')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoOnPackage1	"the first typeInfo is about a class has as argument other class from other package"	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				->					(Array						with:							(Array								with: #canRegister: -> (Array 									with: (self fullSymbolOf: #SConference) 									with: (self fullSymbolOf: #False) 									with: (Array with: (self fullSymbolOf: #SStudent))									with: false)								with: #price -> (Array 									with: (self fullSymbolOf: #SConference) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: false))						with: #());		type:			(self fullSymbolOf: #SConference)				->					(Array						with:							(Array								with: #initialize -> (Array 									with: (self fullSymbolOf: #SConference) 									with: (self fullSymbolOf: #SConference) 									with: #()									with: false)								with: #offerPrice -> (Array 									with: (self fullSymbolOf: #SConference) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true)								with: #offerPrice: -> (Array 									with: (self fullSymbolOf: #SConference) 									with: (self fullSymbolOf: #SConference) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)								with: #discount -> (Array 									with: (self fullSymbolOf: #SConference) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95 100);		scalar: (self fullSymbolOf: #False) with: #(false);		scalar: (self fullSymbolOf: #SStudent) with: (Array with: (SStudent new name: 'Mary'))! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoOnPackage2	"the first typeInfo is about a class has as argument other class from other package"	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				->					(Array						with:							(Array								with: #price: -> (Array with: (self fullSymbolOf:#SConference) 															with: (self fullSymbolOf:#SConference)															with: (Array with: (self fullSymbolOf:#SmallInteger))															with: false))						with:							(Array								with: #price: -> (Array with: (self fullSymbolOf:#SConference)															with: (self fullSymbolOf:#SConference)															with: (Array with: (self fullSymbolOf:#SmallInteger))															with: false)));		type:			(self fullSymbolOf: #SConference)				->					(Array						with: (Array with: #initialize -> (Array with: (self fullSymbolOf:#SConference)															with: (self fullSymbolOf:#SConference)															with: #()															with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoOnPackage3	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				->					(Array						with:							(OrderedCollection new								add: #name: -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf: #SSTeacher)														with: (Array with: (self fullSymbolOf: #ByteString))														with: false);								add: #id: -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf: #SSTeacher)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false);								add: #nickname: -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf:  #SSTeacher)														with: (Array with: (self fullSymbolOf: #ByteString))														with: false);								add: #initialize -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf: #SSTeacher)														with: #()														with: false);								add: #nickname -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf: #ByteString)														with: #()														with: false);								add: #name -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf: #ByteString)														with: #()														with: true);								add: #id -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf:  #SmallInteger)														with: #()														with: true);								add: #yearsWorkExperience -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf:  #SmallInteger)														with: #()														with: true);								add: #idTeacher -> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf:  #SmallInteger)														with: #()														with: true);								yourself)						with:							(Array								with:									#name:with:										-> (Array with: (self fullSymbolOf: #SSTeacher)														with: (self fullSymbolOf:  #SSTeacher)														with: (Array with: (self fullSymbolOf: #ByteString) with: (self fullSymbolOf: #SmallInteger))														with: false)));		type:			(self fullSymbolOf: #SConference)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SConference)														with: (self fullSymbolOf:  #SConference)														with: #()														with: false)								with: #offerPrice -> (Array with: (self fullSymbolOf: #SConference)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: true)								with: #offerPrice: -> (Array with: (self fullSymbolOf: #SConference)														with: (self fullSymbolOf:  #SConference)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false)								with: #discount -> (Array with: (self fullSymbolOf: #SConference)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: true))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95);		scalar: (self fullSymbolOf: #False) with: #(false);		scalar: (self fullSymbolOf: #SStudent) with: (Array with: (SStudent new name: 'Mary'));		scalar: (self fullSymbolOf: #ByteString) with: #('Mary')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoOnPackage4	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				->					(Array						with:							(Array								with: #price: -> (Array with: (self fullSymbolOf:#SConference)															with: (self fullSymbolOf:#SConference)															with: (Array with: (self fullSymbolOf:#SmallInteger))															with: false))						with:							(Array								with: #price: -> (Array with: (self fullSymbolOf:#SConference)															with: (self fullSymbolOf: #SConference)															with: (Array with: (self fullSymbolOf:#SmallInteger))															with: false)));		type:			(self fullSymbolOf: #SConference)				->					(Array						with: (Array with: #initialize -> (Array with: (self fullSymbolOf:#SConference)															with: (self fullSymbolOf:#SConference)															with: #() 															with: false))						with: #());		type: (self fullSymbolOf: #SParty) -> #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSAbstractClass	^ STypeInfo new		type:			(self fullSymbolOf: #SAbstractClass)				->					(Array						with: (Array with: #id -> (Array with: (self fullSymbolOf: #SAbstractClass)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSEvent1	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SEvent)																with: #()																with: false)								with: #discount -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #discount: -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SEvent)																with: (Array with: (self fullSymbolOf: #SmallInteger)) 																with: false)								with: #price -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SmallInteger)																with: #() 																with: true)								with: #price: -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SEvent)																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false))						with: (Array with: #price: -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SEvent)																with: (Array with: (self fullSymbolOf: #SmallInteger)) 																with: false)));		scalar: (self fullSymbolOf: #SmallInteger) with: #(8)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSEvent2	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SEvent)																with: #()																with: false)								with: #discount -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #price -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true))						with: (Array with: #price: -> (Array with: (self fullSymbolOf: #SEvent)																with: (self fullSymbolOf: #SEvent) 																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false)));		scalar: (self fullSymbolOf: #SmallInteger) with: #(0 15)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSEventOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				->					(Array						with:							(Array								with: #price -> (Array with: (self fullSymbolOf:#SEvent)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: false)								with: #discount -> (Array with: (self fullSymbolOf:#SEvent)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: true)								with: #initialize -> (Array with: (self fullSymbolOf:#SEvent)														with: (self fullSymbolOf: #SEvent)														with: #()														with: false)								with: #price: -> (Array with: (self fullSymbolOf:#SEvent)														with: (self fullSymbolOf:#SEvent)														with: (Array with: (self fullSymbolOf:#SmallInteger))														with: false))						with: (Array with: #price: -> (Array with: (self fullSymbolOf:#SEvent)														with: (self fullSymbolOf: #SEvent)														with: (Array with: (self fullSymbolOf:#SmallInteger))														with: false)));		type: (self fullSymbolOf: #SSTeacher) -> #(#() #());		type: (self fullSymbolOf: #SSPerson )-> #(#() #());		type: (self fullSymbolOf: #SStack) -> #(#() #());		type: (self fullSymbolOf: #SConference) -> #(#() #());		type: (self fullSymbolOf: #SFoo) -> #(#() #());		type: (self fullSymbolOf: #SParty) -> #(#() #());		type: (self fullSymbolOf: #SEventTest) -> #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(15 0)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFoo1	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #returnNum -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: false)								with: #returnFloat -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SmallFloat64) 									with: #()									with: false)								with: #returnString -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #ByteString) 									with: #()									with: false)								with: #score -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SmallFloat64) 									with: #()									with: true)								with: #return: -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #ByteString) 									with: (Array with: (self fullSymbolOf: #ByteString))									with: false))						with: (Array with: #score: -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SFoo) 									with: (Array with: (self fullSymbolOf: #SmallFloat64))									with: false)));		scalar: (self fullSymbolOf: #ByteString) with: #('hello');		scalar: (self fullSymbolOf: #SmallInteger) with: #(5);		scalar: (self fullSymbolOf: #SmallFloat64) with: #(7.3)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFoo2	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with: (Array with: #return: -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SFoo) 									with: (Array with: (self fullSymbolOf: #SFoo))									with: false))						with: #())! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFoo3	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #returnNum -> (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: false)								with: #returnFloat -> (Array																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf:#SmallFloat64)																with: #()																with: false)								with: #returnString -> (Array																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf:#ByteString)																with: #()																with: false)								with: #score -> (Array 																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #score: -> (Array																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf: #SFoo) 																with: (Array with: (self fullSymbolOf:#SmallInteger))																with: false))						with: (Array with: #score: -> (Array 																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf:#SmallInteger))																with: false)));		scalar: (self fullSymbolOf: #ByteString) with: #('Hello');		scalar: (self fullSymbolOf: #SmallInteger) with: #(4);		scalar: (self fullSymbolOf: #SmallFloat64) with: #(2.3)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFoo4	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #initialize -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SFoo) 									with: #()									with: false)								with: #return: ->  (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #SStudent))									with: false))						with: #());		scalar: (self fullSymbolOf: #SStudent) with: (Array with: SStudent new)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFoo5	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #return: -> (Array with: (self fullSymbolOf: #SFoo)															with: (self fullSymbolOf: #OrderedCollection)															with: (Array with: (self fullSymbolOf: #OrderedCollection))															with:  false))						with: #());		scalar: (self fullSymbolOf: #OrderedCollection)			with:			(Array				with:					(OrderedCollection new						addAll: #(1 4 5);						yourself))! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFooEmpty	^ STypeInfo new type: (self fullSymbolOf: #SFoo) -> (Array with: #() with: #())! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFooOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #returnCollection -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #OrderedCollection) 									with: #()									with: false)								with: #returnString -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #ByteString) 									with: #()									with: false)								with: #score -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true)								with: #score: -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SFoo) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)								with: #return: -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #SStudent))									with: false))						with: (Array with: #score: -> (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SFoo) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)));		type:			(self fullSymbolOf: #SSPerson)				->					(Array						with:							(Array								with: #id: -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)								with: #nickname: -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #ByteString))									with: false)								with: #name: -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #ByteString))									with: false))						with: (Array with: #name: -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #ByteString))									with: false)));		type: (self fullSymbolOf: #SStack) -> #(#() #());		type: (self fullSymbolOf: #SConference) -> #(#() #());		type: (self fullSymbolOf: #SEvent) -> #(#() #());		type: (self fullSymbolOf: #SSTeacher) -> #(#() #());		type: (self fullSymbolOf: #SParty) -> #(#() #());		type: (self fullSymbolOf: #SEventTest) -> #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(5 1 4);		scalar: (self fullSymbolOf: #ByteString) with: #('Emily' 'Hello');		scalar: (self fullSymbolOf: #OrderedCollection)			with: (Array with: OrderedCollection new);		scalar: (self fullSymbolOf: #SStudent)			with:			(Array				with:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself))! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFooOnPackage2	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #returnFloat -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallFloat64)																with: #()																with: false)								with: #returnCollection -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #OrderedCollection)																with: #()																with: false)								with: #initialize -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: #()																with: false)								with: #score -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #score: -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false)								with: #return: -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SStudent)																with: (Array with: (self fullSymbolOf: #SStudent))																with: false))						with: (Array with: #score: -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false)));		type: (self fullSymbolOf: #SSPerson) -> #(#() #());		type: (self fullSymbolOf: #SStack) -> #(#() #());		type: (self fullSymbolOf: #SConference) -> #(#() #());		type: (self fullSymbolOf: #SEvent) -> #(#() #());		type: (self fullSymbolOf: #SSTeacher) -> #(#() #());		type: (self fullSymbolOf: #SParty) -> #(#() #());		type: (self fullSymbolOf: #SEventTest) -> #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(15);		scalar: (self fullSymbolOf: #SmallFloat64) with: #(2.3);		scalar: (self fullSymbolOf: #OrderedCollection)			with: (Array with: OrderedCollection new);		scalar: (self fullSymbolOf: #Array) with: #(#(1 5 6))! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSFooOnPackage3	^ STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				->					(Array						with:							(Array								with: #id: -> (Array with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SStudent)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false)								with: #nickname: -> (Array with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SStudent)														with: (Array with: (self fullSymbolOf: #ByteString))														with: false)								with: #name: -> (Array with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SStudent)														with: (Array with: (self fullSymbolOf: #ByteString))														with: false))						with:							(Array								with:									#name:with:										-> (Array with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #ByteString) with: (self fullSymbolOf:  #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SFoo)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf:  #SFoo)																with: #()																with: false)								with: #return: -> (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #Dictionary)																with: (Array with: (self fullSymbolOf: #Dictionary))																with: false))						with: #());		type:			(self fullSymbolOf: #SStack)				->					(Array						with: (Array with: #push: -> (Array with: (self fullSymbolOf: #SStack)																with: (self fullSymbolOf: #SStudent)																with: (Array with: (self fullSymbolOf: #SStudent))																with: false))						with: #());		type: (self fullSymbolOf: #SConference) -> #(#() #());		type: (self fullSymbolOf: #SEvent) -> #(#() #());		type: (self fullSymbolOf: #SParty) -> #(#() #());		type: (self fullSymbolOf: #SSTeacher) -> #(#() #());		type: (self fullSymbolOf: #SEventTest) -> #(#() #());		scalar: (self fullSymbolOf: #SStudent)			with:			(Array				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Lian'));		scalar: (self fullSymbolOf: #Dictionary)			with:			(Array				with:					(Dictionary new						at: 1							put:							(SStack new								push: (SStudent name: 'Josh' with: 2);								push: (SStudent name: 'Lian');								yourself);						at: 2							put:							(OrderedCollection new								add: (SStudent name: 'Mery' with: 5);								yourself);						yourself));		scalar: (self fullSymbolOf: #SmallInteger) with: #(5 1 2);		scalar: (self fullSymbolOf: #ByteString) with: #('Josh' 'Lian' 'Mery')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSSPerson1	^ STypeInfo new		type:			(self fullNameOfClass: #SSPerson)				->					(Array						with:							(Array								with: #name -> (Array with: (self fullNameOfClass: #SSPerson)														with: (self fullNameOfClass:  #ByteString)														with: #()														with: true)								with: #id -> (Array with: (self fullNameOfClass: #SSPerson)														with: (self fullNameOfClass:  #SmallInteger)														with:  #()														with: false))						with:							(Array								with:									#name:with:										-> (Array with: (self fullNameOfClass: #SSPerson)													with: (self fullNameOfClass: #SSPerson)													with: (Array with: (self fullNameOfClass: #ByteString)with: (self fullNameOfClass: #SmallInteger))													with: false)));		scalar: (self fullNameOfClass: #SmallInteger) with: #(50);		scalar: (self fullNameOfClass: #ByteString) with: #('Ann')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSSTeacher1	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SSTeacher)																with: (self fullSymbolOf: #SSTeacher)																with: #()																with: false)								with: #yearsWorkExperience -> (Array with: (self fullSymbolOf: #SSTeacher)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with:									#yearsWorkExperience:										-> (Array with: (self fullSymbolOf:#SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with: #());		scalar: #SmallInteger with: #(0 100);		scalar: #ByteString with: #('teacher_Ann')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSSTeacher2	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SSTeacher)																with: (self fullSymbolOf:  #SSTeacher)																with: #()																with: false)								with: #idTeacher -> (Array with: (self fullSymbolOf: #SSTeacher)																with: (self fullSymbolOf:  #SmallInteger)																with: #()																with: true)								with:									#yearsWorkExperience:										-> (Array with: (self fullSymbolOf: #SSTeacher)													with: (self fullSymbolOf: #SSTeacher)													with: (Array with: (self fullSymbolOf: #SmallInteger))													with: false)								with: #nickname -> (Array with: (self fullSymbolOf: #SSTeacher)													with: (self fullSymbolOf: #ByteString)													with: #()													with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 29 -7 9);		scalar: (self fullSymbolOf: #ByteString) with: #('teacher_Amy' 'teacher_Mark')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSSTeacher3	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SSTeacher)																with: (self fullSymbolOf: #SSTeacher)																with: #()																with: false)								with: #yearsWorkExperience -> (Array with: (self fullSymbolOf: #SSTeacher)																with: (self fullSymbolOf:  #SmallInteger)																with: #()																with: false)								with: #nickname -> (Array with: (self fullSymbolOf: #SSTeacher)																with: (self fullSymbolOf: #ByteString) 																with: #()																with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 10);		scalar: (self fullSymbolOf: #ByteString) with: #('teacher_Amy' 'teacher_Mark')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSSTeacher4	^ STypeInfo new		type:			(self fullSymbolOf:#SSTeacher)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf:#SSTeacher)																with: (self fullSymbolOf: #SSTeacher)																with: #()																with: false)								with: #idTeacher -> (Array with: (self fullSymbolOf:#SSTeacher)																with: (self fullSymbolOf:#SmallInteger)																with: #()																with: true)								with: #yearsWorkExperience -> (Array with: (self fullSymbolOf:#SSTeacher)																with: (self fullSymbolOf: #SSTeacher)																with: #()																with: true))						with: #());		scalar: (self fullSymbolOf:#SmallInteger) with: #(1 29 9);		scalar: (self fullSymbolOf:#ByteString) with: #('teacher_Amy' 'teacher_Mark')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSSTeacherOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				->					(Array						with:							(Array								with: #id: -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SSTeacher) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)								with: #nickname: -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SSTeacher) 									with: (Array with: (self fullSymbolOf: #ByteString))									with: false)								with: #name -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #ByteString) 									with: #()									with: true)								with: #id -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true)								with: #name: -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SSTeacher) 									with: (Array with: (self fullSymbolOf: #ByteString))									with: false))						with:							(Array								with:									#name:with:										-> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SSTeacher) 									with: (Array with: (self fullSymbolOf: #ByteString) with: (self fullSymbolOf: #SmallInteger))									with: false)));		type:			(self fullSymbolOf: #SSTeacher)				->					(Array						with:							(Array								with: #initialize -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SSTeacher) 									with: #()									with: false)								with: #idTeacher -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true)								with:									#yearsWorkExperience:										-> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #SSTeacher) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)								with: #nickname -> (Array 									with: (self fullSymbolOf: #SSTeacher) 									with: (self fullSymbolOf: #ByteString) 									with: #()									with: false))						with: #());		type: (self fullSymbolOf: #SStack) -> #(#() #());		type: (self fullSymbolOf: #SConference) -> #(#() #());		type: (self fullSymbolOf: #SEvent) -> #(#() #());		type: (self fullSymbolOf: #SFoo) -> #(#() #());		type: (self fullSymbolOf: #SParty) -> #(#() #());		type: (self fullSymbolOf: #SEventTest) -> #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(0 100 34);		scalar: (self fullSymbolOf: #ByteString) with: #('Ann' 'teacher_Ann')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSSTeacherOnPackage2	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf:#SSTeacher)																with: (self fullSymbolOf: #SSTeacher)																with: #()																with: false)								with: #nickname -> (Array with: (self fullSymbolOf:#SSTeacher)																with: (self fullSymbolOf: #SSTeacher)																with: #()																with: false)								with: #yearsWorkExperience -> (Array with: (self fullSymbolOf:#SSTeacher)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true))						with: #());		type: (self fullSymbolOf:#SSPerson) -> #(#() #());		type: (self fullSymbolOf:#SStack) -> #(#() #());		type: (self fullSymbolOf:#SConference) -> #(#() #());		type: (self fullSymbolOf:#SEvent) -> #(#() #());		type: (self fullSymbolOf:#SFoo) -> #(#() #());		type: (self fullSymbolOf:#SParty) -> #(#() #());		type: (self fullSymbolOf:#SEventTest) -> #(#() #());		scalar: (self fullSymbolOf:#SmallInteger) with: #(0);		scalar: (self fullSymbolOf:#ByteString) with: #('teacher_1')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSStack1	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				->					(Array						with:							(Array								with: #firstLinkStack -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SmallInteger)																	with: #()																	with: true)								with: #pop -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SmallInteger)																	with: #()																	with: false)								with: #push: -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SmallInteger)																	with: (Array with: (self fullSymbolOf: #SmallInteger))																	with: false))						with: (Array with: #newStackWith: -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SStack)																	with: (Array with: (self fullSymbolOf: #Array))																	with: false)));		scalar: (self fullSymbolOf: #Array) with: #(#(2 4 6 1));		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 2 4 6 8)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSStack2	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				->					(Array						with:							(Array								with: #lastLinkStack -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SmallInteger)																	with: #()																	with: true)								with: #pop -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SmallInteger)																	with: #()																	with: false)								with: #top -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SmallInteger)																	with: #()																	with: false))						with:							(Array								with: #newStack -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SStack)																	with: #()																	with: false)								with: #newStackWith: -> (Array with: (self fullSymbolOf: #SStack)																	with: (self fullSymbolOf: #SStack)																	with: (Array with: (self fullSymbolOf: #Array))																	with: false)));		scalar: (self fullSymbolOf: #Array) with: #(#(2 4 6 1) #(5 7 9 0));		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 2 5 8 9)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSStack3	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				->					(Array						with:							(Array								with: #pop -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: false)								with: #push: -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SmallInteger)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false)								with: #top -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: false))						with: (Array with: #newStackWith: -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SStack)														with: (Array with: (self fullSymbolOf: #Array))														with: false)));		scalar: (self fullSymbolOf: #Array) with: (Array with: #(2 4 6 1));		scalar: (self fullSymbolOf: #SmallInteger) with: #(7 5 9 1)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSStack4	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				->					(Array						with:							(Array								with: #firstLinkStack -> (Array 									with: (self fullSymbolOf: #SStack) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true)								with: #lastLinkStack -> (Array 									with: (self fullSymbolOf: #SStack) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true)								with: #pop -> (Array 									with: (self fullSymbolOf: #SStack) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: false)								with: #push: -> (Array 									with: (self fullSymbolOf: #SStack) 									with: (self fullSymbolOf: #SmallInteger) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)								with: #top -> (Array 									with: (self fullSymbolOf: #SStack) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: false))						with:							(Array								with: #newStack -> (Array 									with: (self fullSymbolOf: #SStack) 									with: (self fullSymbolOf: #SStack) 									with: #()									with: false)								with: #newStackWith: -> (Array 									with: (self fullSymbolOf: #SStack) 									with: (self fullSymbolOf: #SStack) 									with: (Array with: (self fullSymbolOf: #Array))									with: false)));		scalar: (self fullSymbolOf: #SmallInteger) with: #(5);		scalar: (self fullSymbolOf: #Array) with: #(#(1 4 5))! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSStackOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				->					(Array						with:							(Array								with: #pop -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: false)								with: #push: -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SmallInteger)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false)								with: #top -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: false))						with: (Array with: #newStackWith: -> (Array with: (self fullSymbolOf: #SStack)														with: (self fullSymbolOf: #SStack)														with: (Array with: (self fullSymbolOf: #Array))														with: false)));		type: (self fullSymbolOf: #SSPerson) -> #(#() #());		type: (self fullSymbolOf: #SSTeacher) -> #(#() #());		type: (self fullSymbolOf: #SConference) -> #(#() #());		type: (self fullSymbolOf: #SEvent) -> #(#() #());		type: (self fullSymbolOf: #SFoo) -> #(#() #());		type: (self fullSymbolOf: #SParty) -> #(#() #());		type: (self fullSymbolOf: #SEventTest) -> #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 2 4 6 8);		scalar: (self fullSymbolOf: #Array) with: #(#(2 4 6 1))! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSStackOnPackage2	^ STypeInfo new		type:			#SSPerson				->					(Array						with:							(Array								with: #id: -> #(#SStudent #SStudent #(#SmallInteger) false)								with: #nickname: -> #(#SStudent #SStudent #(#ByteString) false)								with: #name: -> #(#SStudent #SStudent #(#ByteString) false))						with:							(Array								with:									#name:with:										-> #(#SStudent #SStudent #(#ByteString #SMallInteger) false)));		type:			#SStack				->					(Array						with:							(Array								with: #push: -> #(#SStack #OrderedCollection #(#OrderedCollection) false))						with: #());		type: #SFoo -> #(#() #());		type: #SConference -> #(#() #());		type: #SEvent -> #(#() #());		type: #SParty -> #(#() #());		type: #SSTeacher -> #(#() #());		type: #SEventTest -> #(#() #());		scalar: #SStudent			with:			(Array				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Lian'));		scalar: #OrderedCollection			with:			(Array				with:					(OrderedCollection new						add: (SStudent name: 'Mery' with: 5);						yourself)				with:					(OrderedCollection new						add: (SStudent name: 'Lian');						add: (SStudent name: 'Josh' with: 2);						yourself));		scalar: #SmallInteger with: #(5 1 2);		scalar: #ByteString with: #('Josh' 'Lian' 'Mery')! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoSStudentOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SStudent)				->					(Array						with:							(Array								with: #initialize -> (Array with: (self fullSymbolOf: #SStudent)																with: (self fullSymbolOf: #SStudent)																with: #()																with: false)								with: #idStudent -> (Array with: (self fullSymbolOf: #SStudent)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #scoreStudent -> (Array with: (self fullSymbolOf: #SStudent)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #scoreStudent: -> (Array with: (self fullSymbolOf: #SStudent)																with: (self fullSymbolOf: #SmallInteger)																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false))						with: #());		type: (self fullSymbolOf:#SAbstractClass) -> #(#() #());		scalar: (self fullSymbolOf:#SmallInteger) with: #(10 1)! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSEvent	"(SSTypeCollector				profile: [ (SEvent price: 15)						price;						discount ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario')"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : {				#price : STypeMethodInfo {					#selector : #price,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#discount : STypeMethodInfo {					#selector : #discount,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SEvent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			},			#classMethodTypes : {				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			}		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			15,			0		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSFoo2	"SSTypeCollector				profile: [ (SFoo score: 15)						returnCollection;						returnFloat;						score;						return: #(1 5 6) ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#returnFloat : STypeMethodInfo {					#selector : #returnFloat,					#returnType : SMultiTypeInfo [ #SmallFloat64 ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Array ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#Array : [			[				1,				5,				6			]		],		#SmallInteger : [			15		],		#SmallFloat64 : [			2.3		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSFoo3	"SSTypeCollector profile:[ (SFoo score: 4)				score;				returnCollection;				returnString;				score: 5;				return:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnString : STypeMethodInfo {					#selector : #returnString,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#SmallInteger : [			5,			1,			4		],		#ByteString : [			''Emily'',			''Hello''		],		#SStudent : [			SStudent {				#name : ''Emily'',				#id : 1,				#nickname : ''Emily'',				#scoreStudent : 1			}		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSFoo6	"SSTypeCollector profile: [ SFoo new return: (Dictionary new at: 1 put: (SStack new push: (SStudent  name: 'Lian' with: 1); push: (SStudent name: 'Josh' with: 2); yourself ); at: 2 put: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Dictionary ],					#argTypes : [						SMultiTypeInfo [ #Dictionary ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#Dictionary : [			{				1 : SStack [					SStudent {						#name : ''Josh'',						#id : 2,						#nickname : ''Josh'',						#scoreStudent : 1,						#idStudent : 1					},					SStudent {						#name : ''Lian'',						#id : 1,						#nickname : ''Lian'',						#scoreStudent : 1,						#idStudent : 1					}				],				2 : OrderedCollection [					SStudent {						#name : ''Mery'',						#id : 5,						#nickname : ''Mery'',						#scoreStudent : 1,						#idStudent : 1					}				]			}		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@65,			@68,			@66		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSSTeacher1	"SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#name : STypeMethodInfo {					#selector : #name,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#id : STypeMethodInfo {					#selector : #id,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#idTeacher : STypeMethodInfo {					#selector : #idTeacher,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''Ann'',			''teacher_Ann''		],		#SmallInteger : [			0,			100,			34		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSSTeacher2	"SSTypeCollector				profile: [ SSTeacher new						nickname;						yearsWorkExperience ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''teacher_1''		],		#SmallInteger : [			0		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSStack1	"SSTypeCollector profile: [ SStack new push: (OrderedCollection new add: (SStudent  name: 'Lian' with: 1); add: (SStudent name: 'Josh' with: 2); yourself); push: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#argTypes : [						SMultiTypeInfo [ #OrderedCollection ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [				SStudent {					#name : ''Mery'',					#id : 5,					#nickname : ''Mery'',					#scoreStudent : 1,					#idStudent : 1				}			],			OrderedCollection [				SStudent {					#name : ''Lian'',					#id : 1,					#nickname : ''Lian'',					#scoreStudent : 1,					#idStudent : 1				},				SStudent {					#name : ''Josh'',					#id : 2,					#nickname : ''Josh'',					#scoreStudent : 1,					#idStudent : 1				}			]		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@56,			@59,			@58		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSStack2	"SSTypeCollector				profile: [ (SStack newStackWith: #(2 4 6 1))						push: 8;						pop;						top ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SmallInteger ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#pop : STypeMethodInfo {					#selector : #pop,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#top : STypeMethodInfo {					#selector : #top,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : {				#''newStackWith:'' : STypeMethodInfo {					#selector : #''newStackWith:'',					#returnType : SMultiTypeInfo [ #SStack ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			}		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#Array : [			[				2,				4,				6,				1			]		],		#SmallInteger : [			1,			2,			4,			6,			8		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfoStringSStudent1	"SSTypeCollector				profile: [ SStudent new						idStudent;						scoreStudent: 10;						scoreStudent ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario2'"	^ 'STypeInfo {	#types : {		#SAbstractClass : STypeClassInfo {			#typeName : #SAbstractClass,			#methodTypes : { },			#classMethodTypes : { }		},		#SStudent : STypeClassInfo {			#typeName : #SStudent,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SStudent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#idStudent : STypeMethodInfo {					#selector : #idStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#scoreStudent : STypeMethodInfo {					#selector : #scoreStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''scoreStudent:'' : STypeMethodInfo {					#selector : #''scoreStudent:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			10,			1		]	}}'! !!SUtilityTypeInfo methodsFor: 'examples'!typeInfosSStudent	^ OrderedCollection new		add:			(STypeInfo new				type:					(self fullSymbolOf: #SStudent)						->							(Array								with:									(Array										with: #initialize -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SStudent) 									with: #()									with: false)										with: #scoreStudent -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true)										with: #scoreStudent: -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)										with: #idStudent -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: true))								with: #());				scalar: (self fullSymbolOf: #SmallInteger) with: #(1);				scalar: (self fullSymbolOf: #ByteString) with: #('student_Jane'));		add:			(STypeInfo new				type:					(self fullSymbolOf: #SStudent)						->							(Array								with:									(Array										with: #scoreStudent: -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #SStudent) 									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)										with: #nickname -> (Array 									with: (self fullSymbolOf: #SStudent) 									with: (self fullSymbolOf: #ByteString) 									with: #()									with: false))								with: #());				scalar: (self fullSymbolOf: #SmallInteger) with: #(1 6 8);				scalar: (self fullSymbolOf: #ByteString) with: #('Jane' 'Ann' 'Peter'));		yourself! !"SmallSuiteGenerator-Tests"!!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization' stamp: '' prior: 35672238!generationVisualization: fitnessSeed ofColor: dictColor	| canvas contributionShape infoMethodShape evolutionShape highlightTestCase highlightMethod ys border widthShape barGroup height |	canvas := RSCanvas new 		color: (dictColor at: 'background').	highlightTestCase := RSHighlightable new 		highlightColor: (dictColor at: 'highlightTestCase');		yourself.	highlightMethod := RSHighlightable new 		highlightColor: (dictColor at: 'highlightMethod');		yourself.	infoMethodShape := self infoMethodShapesOn: canvas ofColor: dictColor highlight: (Array with: highlightTestCase with: highlightMethod).		ys := infoMethodShape at: 3.	barGroup := infoMethodShape at: 2.	infoMethodShape := infoMethodShape at: 1.	height := infoMethodShape height.	contributionShape := self contributionShapeOfHeight: height color: dictColor and: ys.	barGroup := RSComposite new shapes: (self setPositions: barGroup using: ys).	"align the contribution element"	contributionShape translateTo: infoMethodShape encompassingRectangle topLeft x - (contributionShape encompassingRectangle width) @ contributionShape position y.	"add contributionShape on canvas"	canvas addShape: contributionShape.	"add infoMethodShapeGroup on canvas"	canvas addAll: infoMethodShape.	"add barGroup on canvas"	RSLocation new right offset: ((barGroup width * 1.2)@0); move: barGroup on: canvas shapes.	canvas addShape: barGroup.	"addition of highlight"	self addHighlightTestCaseEvent: highlightTestCase on: canvas ofColor: (dictColor at: 'highlightTestCase').	self addHighlightMethodEvent: highlightMethod on: canvas ofColor: (dictColor at: 'highlightMethod').	widthShape := 800.	evolutionShape := self evolutionShapeWith: ys ofColor: dictColor size: widthShape @height negated.	height := (Array with: contributionShape height with: height with: evolutionShape height) max + ((infoMethodShape select: [:e | (e model isKindOf: SSTestCase) and: [ e model generationNumber == (numberOfGenerations + 1)  ] ] thenCollect: #height) max).	"addition of contributionShape border"	border := self borderOfSize: contributionShape width @ (height+ 20) andColor: (dictColor at: 'border').	border translateTo: infoMethodShape encompassingRectangle topLeft x - (contributionShape encompassingRectangle width) @ contributionShape position y.	canvas addShape: border.	"addition of infoMethodShape border"	border := self borderOfSize: (infoMethodShape width + (barGroup width * 1.3)) @ (height + 20) andColor: (dictColor at: 'border').	RSLocation new middle offset: 120@0; move: border on: canvas shapes. 	canvas addShape: border.	"add evolutionShape on canvas"	evolutionShape translateTo: (barGroup encompassingRectangle topRight x + 500) @ (contributionShape position y + 25).	canvas addShape: evolutionShape.	"border of evolutionShape"	border := self borderOfSize: ((widthShape * 1.1) @ (height + 20)) andColor: (dictColor at: 'border').	RSLocation new top right offset: 0@5 negated; move: border on: canvas shapes.	canvas addShape: border.	"add descriptive text on canvas"	self addDescriptiveTextOn: canvas ofColor: (dictColor at: 'font') and: (Array with: ((infoMethodShape width / 10) negated ) with: -200).	self addLegendOn: canvas with: dictColor.	canvas @ RSCanvasController.	^ canvas	! !!SGAEngine methodsFor: '*SmallSuiteGenerator-Visualization' stamp: '' prior: 35682034!sparkCircleGroupOfColor: dictColor andSize: size	| block dictPrevData totalClasses totalMethods |	dictPrevData := Dictionary new 		at: 'classCoverage' put: 0;		at: 'methodCoverage' put: 0;		at: 'branchCoverage' put: 0;		yourself.	totalClasses := self typeInfo classes size.	totalMethods := (self typeInfo types flatCollect: #allMethods) size.	block := [ :log | (log population flatCollect: [ :t | 			(t summaryExecutionMethods collect: [:summary | 				(summary executorClass -> summary selector)]) asSet ]) asSet ].	^ logs collect: [ :log | 		| spark group |		group := RSGroup new.		spark := RSSparkCircle new			objects: log;			container: group;			slices: (Array 				with: [:model | | numClasses difference previous |					numClasses := ((block value: model ) collect: [ :assoc | (assoc key splitOn: ' ') first ]) asSet size.					previous := dictPrevData at: 'classCoverage'.					difference := numClasses - previous.					dictPrevData at: 'classCoverage' put: numClasses.					[difference / previous] on: ZeroDivide do: [ difference / totalClasses ] ] 				with: [:model | | numberMethods difference previous |					numberMethods := (block value: model) size.					previous := dictPrevData at: 'methodCoverage'.					difference := numberMethods - previous.					dictPrevData at: 'methodCoverage' put: numberMethods.					[ difference / previous] on: ZeroDivide do: [difference / totalMethods ]]				with: [:model | | coverage difference previous |					coverage := model fitness values first.					previous := dictPrevData at: 'branchCoverage'.					difference := coverage - previous.					dictPrevData at: 'branchCoverage' put: coverage.					[ difference / previous ] on: ZeroDivide do: [ difference / 100 ]]);		sliceColor: [ :shape | (dictColor at: shape index) value ].		spark scaleTo: size.		spark build.		RSComposite new			shapes: group;			yourself ] as: RSGroup! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!name  #metaObject count: 1.  nil.  ^name! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!age: aNumber  #metaObject count: 1.  nil.  ^aNumber! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!id  #metaObject count: 1.  nil.  ^id! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!identifier  #metaObject count: 1.  nil.  ^name , id printString! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!canRegister: aConference  #metaObject count: 1.  nil.  ^aConference price - aConference offerPrice > (aConference price * 0.05)! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!name: anObject  #metaObject count: 1.  nil.  name := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!id: anObject  #metaObject count: 1.  nil.  id := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!nickname  #metaObject count: 1.  nil.  self subclassResponsibility! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!nickname: anObject  #metaObject count: 1.  nil.  nickname := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!fullIdentifier  #metaObject count: 1.  nil.  ^name , '_' , nickname , '_' , id printString! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624372!name: aString with: aNumber  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: aNumber;     nickname: aString.  ^inst! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!name: aString  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: 1;     nickname: aString.  ^inst! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!offerPrice  #metaObject count: 1.  nil.  ^offerPrice! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!speaker: anObject  #metaObject count: 1.  nil.  speaker := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 100.  discount := 0.  offerPrice := price.  date := Date today! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!offerPrice: aNumber  #metaObject count: 1.  nil.  offerPrice := aNumber! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!speaker  #metaObject count: 1.  nil.  ^speaker! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!canRegister: aPerson  #metaObject count: 1.  nil.  ^aPerson canRegister: self! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!price  #metaObject count: 1.  nil.  ^price - (discount * price / 100)! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!discount  #metaObject count: 1.  nil.  ^discount! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  price := aNumber! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 0.  discount := 0! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!discount: aNumber  #metaObject count: 1.  nil.  price > 0 ifTrue: [ #metaObject count: 2.        nil.        discount := aNumber ]! !!SEvent class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  ^self new price: aNumber! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!yearsWorkExperience  #metaObject count: 1.  nil.  ^yearsWorkExperience! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  idTeacher := 100 + (id ifNil: [ #metaObject count: 2.              nil.              0 ]).  yearsWorkExperience := 0! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!idTeacher  #metaObject count: 1.  nil.  ^idTeacher! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!yearsWorkExperience: anObject  #metaObject count: 1.  nil.  yearsWorkExperience := anObject! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!nickname  #metaObject count: 1.  nil.  ^'teacher_' , (nickname ifNil: [ #metaObject count: 2.              nil.              '1' ])! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!testPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  self assert: event price equals: 80! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!testDiscountWithZeroPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event discount: 20.  self assert: event discount equals: 0.  self assert: event price equals: 0! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!testDiscount  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  event discount: 20.  self assert: event discount equals: 20.  self assert: event price equals: 64! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnFloat  | a |  #metaObject count: 1.  nil.  a := 2.3.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnCollection  | a |  #metaObject count: 1.  nil.  a := OrderedCollection new.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  score := 0! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!score: aNumber  #metaObject count: 1.  nil.  score := aNumber! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnNum  | a |  #metaObject count: 1.  nil.  a := 4.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnString  | a |  #metaObject count: 1.  nil.  a := 'Hello'.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!return: aType  #metaObject count: 1.  nil.  ^aType! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!score  #metaObject count: 1.  nil.  ^score! !!SFoo class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!score: aNumber  | ins |  #metaObject count: 1.  nil.  ins := self new score: aNumber.  ^ins! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!name  #metaObject count: 1.  nil.  ^name! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!age: aNumber  #metaObject count: 1.  nil.  ^aNumber! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!id  #metaObject count: 1.  nil.  ^id! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!identifier  #metaObject count: 1.  nil.  ^name , id printString! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!canRegister: aConference  #metaObject count: 1.  nil.  ^aConference price - aConference offerPrice > (aConference price * 0.05)! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!name: anObject  #metaObject count: 1.  nil.  name := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!id: anObject  #metaObject count: 1.  nil.  id := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!nickname  #metaObject count: 1.  nil.  self subclassResponsibility! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!nickname: anObject  #metaObject count: 1.  nil.  nickname := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!fullIdentifier  #metaObject count: 1.  nil.  ^name , '_' , nickname , '_' , id printString! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624372!name: aString with: aNumber  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: aNumber;     nickname: aString.  ^inst! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!name: aString  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: 1;     nickname: aString.  ^inst! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!offerPrice  #metaObject count: 1.  nil.  ^offerPrice! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!speaker: anObject  #metaObject count: 1.  nil.  speaker := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 100.  discount := 0.  offerPrice := price.  date := Date today! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!offerPrice: aNumber  #metaObject count: 1.  nil.  offerPrice := aNumber! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!speaker  #metaObject count: 1.  nil.  ^speaker! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!canRegister: aPerson  #metaObject count: 1.  nil.  ^aPerson canRegister: self! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!price  #metaObject count: 1.  nil.  ^price - (discount * price / 100)! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!discount  #metaObject count: 1.  nil.  ^discount! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  price := aNumber! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 0.  discount := 0! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!discount: aNumber  #metaObject count: 1.  nil.  price > 0 ifTrue: [ #metaObject count: 2.        nil.        discount := aNumber ]! !!SEvent class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  ^self new price: aNumber! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!yearsWorkExperience  #metaObject count: 1.  nil.  ^yearsWorkExperience! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  idTeacher := 100 + (id ifNil: [ #metaObject count: 2.              nil.              0 ]).  yearsWorkExperience := 0! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!idTeacher  #metaObject count: 1.  nil.  ^idTeacher! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!yearsWorkExperience: anObject  #metaObject count: 1.  nil.  yearsWorkExperience := anObject! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!nickname  #metaObject count: 1.  nil.  ^'teacher_' , (nickname ifNil: [ #metaObject count: 2.              nil.              '1' ])! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!testPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  self assert: event price equals: 80! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!testDiscountWithZeroPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event discount: 20.  self assert: event discount equals: 0.  self assert: event price equals: 0! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!testDiscount  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  event discount: 20.  self assert: event discount equals: 20.  self assert: event price equals: 64! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnFloat  | a |  #metaObject count: 1.  nil.  a := 2.3.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnCollection  | a |  #metaObject count: 1.  nil.  a := OrderedCollection new.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!initialize  #metaObject count: 1.  nil.  score := 0! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!score: aNumber  #metaObject count: 1.  nil.  score := aNumber! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnNum  | a |  #metaObject count: 1.  nil.  a := 4.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!returnString  | a |  #metaObject count: 1.  nil.  a := 'Hello'.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!return: aType  #metaObject count: 1.  nil.  ^aType! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!score  #metaObject count: 1.  nil.  ^score! !!SFoo class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!score: aNumber  | ins |  #metaObject count: 1.  nil.  ins := self new score: aNumber.  ^ins! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35642366!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: #nameOf.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35926584!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35926983!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35927476!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: #nameOf.var at: 14 put: ((var at: 1) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35928103!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35928848!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: -2.var at: 7 put: ((var at: 1) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35929124!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35929551!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35929926!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35930349!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35930930!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 12 put: #nameOf.var at: 13 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35931560!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 12 put: #nameOf.var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35932264!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35933043!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35933318!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35933594!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35933942!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35934528!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35935207!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35935541!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35935923!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35936353!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 10 put: 12.var at: 11 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35936916!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35937548!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35937886!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35938272!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: '1'.var at: 8 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35938706!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: '1'.var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35939208!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35939791!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35940015!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35940739!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35941431!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35942048!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35942774!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35943063!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35943690!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35944481!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35944668!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35945203!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35945994!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35946611!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35947146!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35947872!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35948596!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35949223!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35949915!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35950204!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35950428!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35952137!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35952928!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35953545!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35954080!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35954806!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35955530!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35956157!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35956849!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35957138!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35957362!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35957549!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35957868!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35958119!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35958412!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35958773!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35959176!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35959621!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35960108!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35960627!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.var at: 11 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35961179!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 5 put: OrderedCollection new.var at: 6 put: (SStack newStackWith: (var at: 5)).var at: 3 put: ((var at: 6) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35961775!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 5 put: OrderedCollection new.var at: 6 put: (SStack newStackWith: (var at: 5)).var at: 3 put: ((var at: 6) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35962183!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35962563!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35963067!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35963468!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35963912!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35964399!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35964928!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35965490!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35966095!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35966744!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35967436!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35968171!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35968949!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35969344!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35969787!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35970273!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35970801!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35971378!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35972004!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35972673!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35973385!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35974130!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35974919!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35975752!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35976545!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35977570!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35978335!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35979332!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35979909!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35980216!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35980555!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35980937!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35981486!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35981840!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35982179!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35982560!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35982983!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35983478!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 3) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35984017!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35984626!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35985250!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35985734!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35986330!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35986786!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35987104!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35987464!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35987866!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35988340!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35988856!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35989415!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35990044!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35990717!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35991440!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35991777!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35992156!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35992607!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35993100!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35993635!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35994213!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35994824!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35995468!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 15 put: OrderedCollection new.var at: 16 put: (SStack newStackWith: (var at: 15)).var at: 4 put: (var at: 16) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35996156!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 14 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 14) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35996972!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 15 put: OrderedCollection new.var at: 16 put: (SStack newStackWith: (var at: 15)).var at: 4 put: (var at: 16) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35997651!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 14 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 14) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35998439!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35999090!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 35999881!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36000498!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36001002!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36001999!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36002764!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36003381!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36003735!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36004331!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36004787!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36006926!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36007923!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36008688!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36009479!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36010075!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36010692!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36011309!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36011926!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36012280!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36012784!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36013240!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36013996!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36014473!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36014992!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36015749!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36016554!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36017331!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36017822!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36018073!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36018366!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36018731!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36019138!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36019587!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36020078!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36020601!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36021157!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36021433!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36021741!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36022081!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36022464!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36022879!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36023407!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36023794!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 11 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 11)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36024532!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36025042!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 11 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 11)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36025752!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36026234!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36026801!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36027401!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36028045!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36028612!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36029212!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36029856!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36030472!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36031088!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36031881!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36032646!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36033263!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36034260!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36035037!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36035802!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36036156!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36036543!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36037253!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36037870!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36038486!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36039102!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36041389!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36042386!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36043096!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36043861!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36044626!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36045403!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36046019!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36046635!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36047252!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36047606!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36047993!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36048340!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36048754!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36049216!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36049721!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36050268!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36050864!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36051529!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36052237!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36052988!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36053772!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.var at: 18 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36054600!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36055472!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36056231!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36057033!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36057903!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36058816!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36059772!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36060771!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36061803!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36062868!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.var at: 18 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36063977!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36064762!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36065686!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36066488!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36067334!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36068225!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: 'Johan'.var at: 15 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36069159!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36070168!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36070830!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36071535!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36072283!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36073064!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.var at: 17 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36073889!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36074758!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36075791!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36076796!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36077593!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36077919!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36078277!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36078667!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36079100!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36079381!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36079793!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36080247!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36080768!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36081332!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36081939!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36082589!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36083272!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36083988!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.var at: 8 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36084748!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36085134!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36085866!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36086399!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36086964!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36087572!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36087889!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36088248!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36088649!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36089082!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36089547!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36090055!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36090707!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36091359!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36092079!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36092703!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36093395!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36094005!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36094658!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36095397!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36096180!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36096964!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36097781!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36098406!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36099195!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36100192!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36101116!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36102113!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36103110!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36104115!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36104825!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36105557!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36106249!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36106873!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36109184!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36109876!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36110800!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36111797!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36112794!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36113791!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36114415!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36115125!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36115857!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36116646!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36117651!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36118115!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36118647!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36119223!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36119843!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36120532!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36121297!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36122106!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36122958!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36123843!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36124773!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36125747!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36126329!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36126955!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36127624!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36128326!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36129070!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36129859!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36130691!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36131557!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36132456!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36133400!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36134349!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36135270!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36136186!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36136948!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36137753!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36138601!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36139483!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36140399!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36141359!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36141954!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36142598!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36143285!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36144015!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36144778!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.var at: 17 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36145585!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36146436!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.var at: 17 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36147342!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36148140!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36148680!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36149268!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36149922!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36150619!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36151358!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36152146!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36153009!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36153906!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36154846!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36155830!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 19 put: #nameOf.var at: 20 put: ((var at: 1) push: (var at: 12)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36156857!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36157959!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36158498!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36159086!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36159755!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36160468!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36161223!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36162028!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36162883!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36163782!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36164725!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36165701!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36166721!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36167786!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).var at: 22 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36168912!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).var at: 22 put: ((var at: 1) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36170087!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 19 put: nil.var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: ((var at: 18) push: (var at: 19)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36171234!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36172261!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36173021!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36173713!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36174445!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36174802!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36175253!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36175746!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36176281!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36176859!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36177470!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36178114!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36178802!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36179307!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36179854!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36180471!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36181131!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36181824!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.var at: 15 put: (var at: 7) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36182550!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36183320!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36183966!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36184612!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.var at: 15 put: (var at: 7) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36185230!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36185951!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36186643!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36187559!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36188556!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36189462!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36190459!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36191456!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36192461!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36193153!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36193845!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36195991!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36196907!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36197813!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36198505!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36199197!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36199889!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36200886!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36201883!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36202880!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36203504!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36204509!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36205073!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36205679!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36206327!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36207007!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36207720!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36208477!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36209004!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36209573!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36210184!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36210827!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36211502!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36212221!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36212913!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36213604!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36214315!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36215068!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36215854!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36216673!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36217537!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36218099!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36218703!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36219350!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36220040!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36220763!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36221520!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 15 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36222321!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 15 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36223229!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36224109!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 11) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36224839!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36225555!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 11) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36226523!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36227211!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36228151!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36228913!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36229718!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36230567!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36231460!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36232386!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36233345!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36234348!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36235076!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36235853!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36236674!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36237538!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36238436!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36239379!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36240367!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36241371!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36242419!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36243379!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36244399!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36245331!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36246008!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36246718!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36247471!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36248268!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36249109!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36249983!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36250891!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36251844!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36252513!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36253224!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36254003!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36254852!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36255744!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36256679!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36257648!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.var at: 19 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36258662!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 19 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 19)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36259720!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 19 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 19)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36260783!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.var at: 19 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36261818!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36262827!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36263743!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36264434!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36265126!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36266042!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36266734!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36267640!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36268580!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36269486!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36270506!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36272944!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36273860!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36274776!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36275692!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36276598!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36277504!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36278444!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36279464!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36280156!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36280848!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test1  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36281539!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test2  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36285285!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test3  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36289031!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test4  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36292777!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test5  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36296888!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test6  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 20 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 20) equals: #nameOf.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36300999!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test7  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 6 put: ((var at: 1) push: (var at: 4)).  var at: 7 put: ((var at: 1) push: (var at: 6)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 18) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 18) lastLinkStack.  var at: 12 put: (var at: 18) lastLinkStack.  var at: 19 put: (var at: 18) lastLinkStack.  var at: 13 put: (var at: 1) top.  var at: 14 put: (var at: 1) pop.  var at: 15 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 12).  self deny: (var at: 2) equals: (var at: 15).  self deny: (var at: 2) equals: (var at: 19).  self assert: (var at: 5) equals: (var at: 8).  self deny: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self deny: (var at: 5) equals: (var at: 11).  self deny: (var at: 5) equals: (var at: 12).  self assert: (var at: 5) equals: (var at: 15).  self deny: (var at: 5) equals: (var at: 19).  self deny: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self deny: (var at: 8) equals: (var at: 11).  self deny: (var at: 8) equals: (var at: 12).  self assert: (var at: 8) equals: (var at: 15).  self deny: (var at: 8) equals: (var at: 19).  self deny: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 12).  self deny: (var at: 9) equals: (var at: 15).  self assert: (var at: 9) equals: (var at: 19).  self deny: (var at: 10) equals: (var at: 11).  self deny: (var at: 10) equals: (var at: 12).  self assert: (var at: 10) equals: (var at: 15).  self deny: (var at: 10) equals: (var at: 19).  self assert: (var at: 11) equals: (var at: 12).  self deny: (var at: 11) equals: (var at: 15).  self assert: (var at: 11) equals: (var at: 19).  self deny: (var at: 12) equals: (var at: 15).  self assert: (var at: 12) equals: (var at: 19).  self deny: (var at: 15) equals: (var at: 19).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 9) value equals: 12.  self assert: (var at: 11) value equals: 12.  self assert: (var at: 12) value equals: 12.  self assert: (var at: 19) value equals: 12.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 6) printString equals: 'nil'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(12)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(12)'.  self assert: (var at: 12) printString equals: 'ValueLink(12)'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'nil'.  self assert: (var at: 15) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(0 #nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'ValueLink(12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36305217!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test8  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 10 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 11 put: (SStack newStackWith: (var at: 10)).  var at: 4 put: (var at: 11) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 1) top.  var at: 8 put: (var at: 1) pop.  var at: 9 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 11).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 8).  self assert: (var at: 3) equals: (var at: 7).  self assert: (var at: 3) equals: (var at: 8).  self deny: (var at: 4) equals: (var at: 5).  self deny: (var at: 4) equals: (var at: 6).  self assert: (var at: 5) equals: (var at: 6).  self assert: (var at: 7) equals: (var at: 8).  self assert: (var at: 4) value equals: 12.  self assert: (var at: 5) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 7) equals: 0.  self assert: (var at: 8) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 4) printString equals: 'ValueLink(12)'.  self assert: (var at: 5) printString equals: 'ValueLink(0)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 11) printString equals: 'a SStack(0 #nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36310560!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test9  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 13 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 5 put: (SStack newStackWith: (var at: 13)).  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 5) lastLinkStack.  var at: 8 put: (var at: 5) lastLinkStack.  var at: 9 put: (var at: 1) top.  var at: 11 put: (var at: 5) pop.  var at: 12 put: (var at: 5) firstLinkStack.  self deny: (var at: 1) equals: (var at: 5).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 9).  self assert: (var at: 2) equals: (var at: 11).  self assert: (var at: 3) equals: (var at: 9).  self assert: (var at: 3) equals: (var at: 11).  self deny: (var at: 6) equals: (var at: 7).  self deny: (var at: 6) equals: (var at: 8).  self deny: (var at: 6) equals: (var at: 12).  self assert: (var at: 7) equals: (var at: 8).  self deny: (var at: 7) equals: (var at: 12).  self deny: (var at: 8) equals: (var at: 12).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 8) value equals: 12.  self assert: (var at: 12) value equals: #nameOf.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 9) equals: 0.  self assert: (var at: 11) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(0)'.  self assert: (var at: 5) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 8) printString equals: 'ValueLink(12)'.  self assert: (var at: 12) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 13) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05' prior: 36313330!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:05'!test10  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 10 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 4 put: (SStack newStackWith: (var at: 10)).  var at: 5 put: (var at: 4) lastLinkStack.  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 4) lastLinkStack.  var at: 8 put: (var at: 4) top.  var at: 9 put: (var at: 4) pop.  var at: 11 put: (var at: 4) firstLinkStack.  self deny: (var at: 1) equals: (var at: 4).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 8).  self assert: (var at: 2) equals: (var at: 9).  self assert: (var at: 3) equals: (var at: 8).  self assert: (var at: 3) equals: (var at: 9).  self deny: (var at: 5) equals: (var at: 6).  self assert: (var at: 5) equals: (var at: 7).  self deny: (var at: 5) equals: (var at: 11).  self deny: (var at: 6) equals: (var at: 7).  self deny: (var at: 6) equals: (var at: 11).  self deny: (var at: 7) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 5) value equals: 12.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 11) value equals: #nameOf.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 8) equals: 0.  self assert: (var at: 9) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(0)'.  self assert: (var at: 4) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 5) printString equals: 'ValueLink(12)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 10) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 11) printString equals: 'ValueLink(#nameOf)'! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!name  #metaObject count: 1.  nil.  ^name! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!age: aNumber  #metaObject count: 1.  nil.  ^aNumber! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!id  #metaObject count: 1.  nil.  ^id! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!identifier  #metaObject count: 1.  nil.  ^name , id printString! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!canRegister: aConference  #metaObject count: 1.  nil.  ^aConference price - aConference offerPrice > (aConference price * 0.05)! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!name: anObject  #metaObject count: 1.  nil.  name := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!id: anObject  #metaObject count: 1.  nil.  id := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!nickname  #metaObject count: 1.  nil.  self subclassResponsibility! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!nickname: anObject  #metaObject count: 1.  nil.  nickname := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!fullIdentifier  #metaObject count: 1.  nil.  ^name , '_' , nickname , '_' , id printString! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624372!name: aString with: aNumber  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: aNumber;     nickname: aString.  ^inst! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!name: aString  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: 1;     nickname: aString.  ^inst! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!offerPrice  #metaObject count: 1.  nil.  ^offerPrice! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!speaker: anObject  #metaObject count: 1.  nil.  speaker := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 100.  discount := 0.  offerPrice := price.  date := Date today! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!offerPrice: aNumber  #metaObject count: 1.  nil.  offerPrice := aNumber! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!speaker  #metaObject count: 1.  nil.  ^speaker! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!canRegister: aPerson  #metaObject count: 1.  nil.  ^aPerson canRegister: self! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!price  #metaObject count: 1.  nil.  ^price - (discount * price / 100)! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!discount  #metaObject count: 1.  nil.  ^discount! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  price := aNumber! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 0.  discount := 0! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!discount: aNumber  #metaObject count: 1.  nil.  price > 0 ifTrue: [ #metaObject count: 2.        nil.        discount := aNumber ]! !!SEvent class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  ^self new price: aNumber! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!yearsWorkExperience  #metaObject count: 1.  nil.  ^yearsWorkExperience! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  idTeacher := 100 + (id ifNil: [ #metaObject count: 2.              nil.              0 ]).  yearsWorkExperience := 0! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!idTeacher  #metaObject count: 1.  nil.  ^idTeacher! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!yearsWorkExperience: anObject  #metaObject count: 1.  nil.  yearsWorkExperience := anObject! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!nickname  #metaObject count: 1.  nil.  ^'teacher_' , (nickname ifNil: [ #metaObject count: 2.              nil.              '1' ])! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!testPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  self assert: event price equals: 80! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!testDiscountWithZeroPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event discount: 20.  self assert: event discount equals: 0.  self assert: event price equals: 0! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!testDiscount  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  event discount: 20.  self assert: event discount equals: 20.  self assert: event price equals: 64! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnFloat  | a |  #metaObject count: 1.  nil.  a := 2.3.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnCollection  | a |  #metaObject count: 1.  nil.  a := OrderedCollection new.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  score := 0! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!score: aNumber  #metaObject count: 1.  nil.  score := aNumber! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnNum  | a |  #metaObject count: 1.  nil.  a := 4.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnString  | a |  #metaObject count: 1.  nil.  a := 'Hello'.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!return: aType  #metaObject count: 1.  nil.  ^aType! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!score  #metaObject count: 1.  nil.  ^score! !!SFoo class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!score: aNumber  | ins |  #metaObject count: 1.  nil.  ins := self new score: aNumber.  ^ins! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!name  #metaObject count: 1.  nil.  ^name! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!age: aNumber  #metaObject count: 1.  nil.  ^aNumber! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!id  #metaObject count: 1.  nil.  ^id! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!identifier  #metaObject count: 1.  nil.  ^name , id printString! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!canRegister: aConference  #metaObject count: 1.  nil.  ^aConference price - aConference offerPrice > (aConference price * 0.05)! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!name: anObject  #metaObject count: 1.  nil.  name := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!id: anObject  #metaObject count: 1.  nil.  id := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!nickname  #metaObject count: 1.  nil.  self subclassResponsibility! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!nickname: anObject  #metaObject count: 1.  nil.  nickname := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!fullIdentifier  #metaObject count: 1.  nil.  ^name , '_' , nickname , '_' , id printString! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624372!name: aString with: aNumber  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: aNumber;     nickname: aString.  ^inst! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!name: aString  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: 1;     nickname: aString.  ^inst! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!offerPrice  #metaObject count: 1.  nil.  ^offerPrice! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!speaker: anObject  #metaObject count: 1.  nil.  speaker := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 100.  discount := 0.  offerPrice := price.  date := Date today! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!offerPrice: aNumber  #metaObject count: 1.  nil.  offerPrice := aNumber! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!speaker  #metaObject count: 1.  nil.  ^speaker! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!canRegister: aPerson  #metaObject count: 1.  nil.  ^aPerson canRegister: self! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!price  #metaObject count: 1.  nil.  ^price - (discount * price / 100)! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!discount  #metaObject count: 1.  nil.  ^discount! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  price := aNumber! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 0.  discount := 0! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!discount: aNumber  #metaObject count: 1.  nil.  price > 0 ifTrue: [ #metaObject count: 2.        nil.        discount := aNumber ]! !!SEvent class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  ^self new price: aNumber! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!yearsWorkExperience  #metaObject count: 1.  nil.  ^yearsWorkExperience! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  idTeacher := 100 + (id ifNil: [ #metaObject count: 2.              nil.              0 ]).  yearsWorkExperience := 0! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!idTeacher  #metaObject count: 1.  nil.  ^idTeacher! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!yearsWorkExperience: anObject  #metaObject count: 1.  nil.  yearsWorkExperience := anObject! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!nickname  #metaObject count: 1.  nil.  ^'teacher_' , (nickname ifNil: [ #metaObject count: 2.              nil.              '1' ])! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!testPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  self assert: event price equals: 80! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!testDiscountWithZeroPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event discount: 20.  self assert: event discount equals: 0.  self assert: event price equals: 0! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!testDiscount  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  event discount: 20.  self assert: event discount equals: 20.  self assert: event price equals: 64! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnFloat  | a |  #metaObject count: 1.  nil.  a := 2.3.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnCollection  | a |  #metaObject count: 1.  nil.  a := OrderedCollection new.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!initialize  #metaObject count: 1.  nil.  score := 0! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!score: aNumber  #metaObject count: 1.  nil.  score := aNumber! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnNum  | a |  #metaObject count: 1.  nil.  a := 4.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!returnString  | a |  #metaObject count: 1.  nil.  a := 'Hello'.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!return: aType  #metaObject count: 1.  nil.  ^aType! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!score  #metaObject count: 1.  nil.  ^score! !!SFoo class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!score: aNumber  | ins |  #metaObject count: 1.  nil.  ins := self new score: aNumber.  ^ins! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36316311!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: #nameOf.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36339117!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36339516!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36340009!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: #nameOf.var at: 14 put: ((var at: 1) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36340636!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36341381!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: -2.var at: 7 put: ((var at: 1) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36341657!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36342084!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36342459!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36342882!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36343463!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 12 put: #nameOf.var at: 13 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36344093!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 12 put: #nameOf.var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36344797!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36345576!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36345851!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36346127!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36346475!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36347061!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36347740!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36348074!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36348456!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36348886!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 10 put: 12.var at: 11 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36349449!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36350081!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36350419!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36350805!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: '1'.var at: 8 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36351239!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: '1'.var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36351741!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36352324!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36352548!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36353272!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36353964!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36354581!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36355307!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36355596!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36356223!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36357014!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36357201!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36357736!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36358527!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36359144!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36359679!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36360405!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36361129!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36361756!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36362448!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36362737!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36362961!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36364670!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36365461!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36366078!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36366613!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36367339!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36368063!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36368690!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36369382!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36369671!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36369895!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36370082!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36370401!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36370652!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36370945!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36371306!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36371709!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36372154!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36372641!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36373160!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.var at: 11 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36373712!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 5 put: OrderedCollection new.var at: 6 put: (SStack newStackWith: (var at: 5)).var at: 3 put: ((var at: 6) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36374308!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 5 put: OrderedCollection new.var at: 6 put: (SStack newStackWith: (var at: 5)).var at: 3 put: ((var at: 6) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36374716!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36375096!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36375600!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36376001!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36376445!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36376932!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36377461!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36378023!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36378628!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36379277!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36379969!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36380704!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36381482!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36381877!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36382320!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36382806!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36383334!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36383911!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36384537!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36385206!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36385918!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36386663!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36387452!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36388285!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36389078!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36390103!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36390868!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36391865!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36392442!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36392749!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36393088!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36393470!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36394019!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36394373!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36394712!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36395093!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36395516!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36396011!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 3) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36396550!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36397159!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36397783!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36398267!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36398863!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36399319!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36399637!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36399997!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36400399!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36400873!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36401389!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36401948!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36402577!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36403250!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36403973!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36404310!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36404689!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36405140!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36405633!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36406168!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36406746!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36407357!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36408001!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 15 put: OrderedCollection new.var at: 16 put: (SStack newStackWith: (var at: 15)).var at: 4 put: (var at: 16) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36408689!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 14 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 14) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36409505!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 15 put: OrderedCollection new.var at: 16 put: (SStack newStackWith: (var at: 15)).var at: 4 put: (var at: 16) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36410184!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 14 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 14) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36410972!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36411623!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36412414!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36413031!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36413535!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36414532!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36415297!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36415914!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36416268!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36416864!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36417320!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36419459!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36420456!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36421221!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36422012!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36422608!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36423225!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36423842!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36424459!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36424813!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36425317!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36425773!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36426529!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36427006!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36427525!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36428282!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36429087!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36429864!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36430355!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36430606!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36430899!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36431264!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36431671!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36432120!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36432611!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36433134!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36433690!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36433966!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36434274!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36434614!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36434997!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36435412!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36435940!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36436327!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 11 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 11)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36437065!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36437575!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 11 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 11)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36438285!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36438767!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36439334!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36439934!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36440578!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36441145!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36441745!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36442389!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36443005!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36443621!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36444414!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36445179!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36445796!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36446793!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36447570!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36448335!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36448689!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36449076!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36449786!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36450403!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36451019!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36451635!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36453922!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36454919!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36455629!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36456394!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36457159!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36457936!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36458552!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36459168!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36459785!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36460139!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36460526!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36460873!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36461287!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36461749!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36462254!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36462801!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36463397!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36464062!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36464770!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36465521!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36466305!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.var at: 18 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36467133!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36468005!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36468764!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36469566!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36470436!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36471349!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36472305!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36473304!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36474336!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36475401!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.var at: 18 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36476510!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36477295!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36478219!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36479021!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36479867!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36480758!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: 'Johan'.var at: 15 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36481692!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36482701!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36483363!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36484068!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36484816!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36485597!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.var at: 17 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36486422!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36487291!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36488324!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36489329!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36490126!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36490452!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36490810!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36491200!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36491633!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36491914!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36492326!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36492780!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36493301!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36493865!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36494472!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36495122!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36495805!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36496521!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.var at: 8 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36497281!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36497667!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36498399!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36498932!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36499497!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36500105!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36500422!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36500781!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36501182!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36501615!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36502080!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36502588!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36503240!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36503892!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36504612!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36505236!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36505928!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36506538!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36507191!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36507930!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36508713!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36509497!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36510314!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36510939!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36511728!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36512725!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36513649!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36514646!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36515643!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36516648!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36517358!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36518090!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36518782!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36519406!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36521717!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36522409!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36523333!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36524330!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36525327!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36526324!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36526948!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36527658!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36528390!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36529179!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36530184!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36530648!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36531180!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36531756!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36532376!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36533065!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36533830!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36534639!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36535491!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36536376!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36537306!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36538280!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36538862!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36539488!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36540157!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36540859!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36541603!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36542392!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36543224!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36544090!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36544989!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36545933!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36546882!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36547803!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36548719!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36549481!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36550286!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36551134!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36552016!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36552932!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36553892!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36554487!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36555131!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36555818!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36556548!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36557311!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.var at: 17 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36558118!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36558969!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.var at: 17 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36559875!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36560673!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36561213!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36561801!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36562455!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36563152!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36563891!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36564679!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36565542!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36566439!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36567379!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36568363!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 19 put: #nameOf.var at: 20 put: ((var at: 1) push: (var at: 12)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36569390!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36570492!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36571031!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36571619!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36572288!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36573001!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36573756!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36574561!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36575416!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36576315!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36577258!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36578234!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36579254!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36580319!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).var at: 22 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36581445!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).var at: 22 put: ((var at: 1) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36582620!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 19 put: nil.var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: ((var at: 18) push: (var at: 19)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36583767!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36584794!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36585554!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36586246!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36586978!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36587335!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36587786!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36588279!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36588814!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36589392!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36590003!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36590647!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36591335!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36591840!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36592387!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36593004!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36593664!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36594357!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.var at: 15 put: (var at: 7) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36595083!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36595853!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36596499!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36597145!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.var at: 15 put: (var at: 7) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36597763!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36598484!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36599176!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36600092!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36601089!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36601995!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36602992!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36603989!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36604994!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36605686!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36606378!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36608524!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36609440!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36610346!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36611038!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36611730!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36612422!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36613419!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36614416!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36615413!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36616037!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36617042!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36617606!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36618212!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36618860!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36619540!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36620253!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36621010!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36621537!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36622106!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36622717!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36623360!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36624035!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36624754!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36625446!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36626137!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36626848!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36627601!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36628387!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36629206!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36630070!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36630632!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36631236!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36631883!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36632573!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36633296!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36634053!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 15 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36634854!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 15 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36635762!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36636642!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 11) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36637372!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36638088!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 11) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36639056!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36639744!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36640684!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36641446!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36642251!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36643100!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36643993!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36644919!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36645878!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36646881!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36647609!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36648386!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36649207!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36650071!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36650969!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36651912!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36652900!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36653904!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36654952!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36655912!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36656932!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36657864!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36658541!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36659251!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36660004!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36660801!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36661642!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36662516!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36663424!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36664377!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36665046!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36665757!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36666536!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36667385!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36668277!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36669212!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36670181!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.var at: 19 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36671195!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 19 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 19)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36672253!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 19 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 19)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36673316!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.var at: 19 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36674351!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36675360!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36676276!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36676967!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36677659!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36678575!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36679267!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36680173!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36681113!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36682019!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36683039!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36685477!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36686393!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36687309!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36688225!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36689131!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36690037!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36690977!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36691997!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36692689!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36693381!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36282467!test1  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36694072!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36286213!test2  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36697834!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36289959!test3  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36701596!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36293695!test4  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36705358!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36297806!test5  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36709485!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36301951!test6  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 20 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 20) equals: #nameOf.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36713612!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36306249!test7  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 6 put: ((var at: 1) push: (var at: 4)).  var at: 7 put: ((var at: 1) push: (var at: 6)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 18) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 18) lastLinkStack.  var at: 12 put: (var at: 18) lastLinkStack.  var at: 19 put: (var at: 18) lastLinkStack.  var at: 13 put: (var at: 1) top.  var at: 14 put: (var at: 1) pop.  var at: 15 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 12).  self deny: (var at: 2) equals: (var at: 15).  self deny: (var at: 2) equals: (var at: 19).  self assert: (var at: 5) equals: (var at: 8).  self deny: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self deny: (var at: 5) equals: (var at: 11).  self deny: (var at: 5) equals: (var at: 12).  self assert: (var at: 5) equals: (var at: 15).  self deny: (var at: 5) equals: (var at: 19).  self deny: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self deny: (var at: 8) equals: (var at: 11).  self deny: (var at: 8) equals: (var at: 12).  self assert: (var at: 8) equals: (var at: 15).  self deny: (var at: 8) equals: (var at: 19).  self deny: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 12).  self deny: (var at: 9) equals: (var at: 15).  self assert: (var at: 9) equals: (var at: 19).  self deny: (var at: 10) equals: (var at: 11).  self deny: (var at: 10) equals: (var at: 12).  self assert: (var at: 10) equals: (var at: 15).  self deny: (var at: 10) equals: (var at: 19).  self assert: (var at: 11) equals: (var at: 12).  self deny: (var at: 11) equals: (var at: 15).  self assert: (var at: 11) equals: (var at: 19).  self deny: (var at: 12) equals: (var at: 15).  self assert: (var at: 12) equals: (var at: 19).  self deny: (var at: 15) equals: (var at: 19).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 9) value equals: 12.  self assert: (var at: 11) value equals: 12.  self assert: (var at: 12) value equals: 12.  self assert: (var at: 19) value equals: 12.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 6) printString equals: 'nil'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(12)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(12)'.  self assert: (var at: 12) printString equals: 'ValueLink(12)'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'nil'.  self assert: (var at: 15) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(0 #nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'ValueLink(12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36717846!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36311264!test8  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 10 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 11 put: (SStack newStackWith: (var at: 10)).  var at: 4 put: (var at: 11) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 1) top.  var at: 8 put: (var at: 1) pop.  var at: 9 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 11).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 8).  self assert: (var at: 3) equals: (var at: 7).  self assert: (var at: 3) equals: (var at: 8).  self deny: (var at: 4) equals: (var at: 5).  self deny: (var at: 4) equals: (var at: 6).  self assert: (var at: 5) equals: (var at: 6).  self assert: (var at: 7) equals: (var at: 8).  self assert: (var at: 4) value equals: 12.  self assert: (var at: 5) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 7) equals: 0.  self assert: (var at: 8) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 4) printString equals: 'ValueLink(12)'.  self assert: (var at: 5) printString equals: 'ValueLink(0)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 11) printString equals: 'a SStack(0 #nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36723205!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36314034!test9  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 13 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 5 put: (SStack newStackWith: (var at: 13)).  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 5) lastLinkStack.  var at: 8 put: (var at: 5) lastLinkStack.  var at: 9 put: (var at: 1) top.  var at: 11 put: (var at: 5) pop.  var at: 12 put: (var at: 5) firstLinkStack.  self deny: (var at: 1) equals: (var at: 5).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 9).  self assert: (var at: 2) equals: (var at: 11).  self assert: (var at: 3) equals: (var at: 9).  self assert: (var at: 3) equals: (var at: 11).  self deny: (var at: 6) equals: (var at: 7).  self deny: (var at: 6) equals: (var at: 8).  self deny: (var at: 6) equals: (var at: 12).  self assert: (var at: 7) equals: (var at: 8).  self deny: (var at: 7) equals: (var at: 12).  self deny: (var at: 8) equals: (var at: 12).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 8) value equals: 12.  self assert: (var at: 12) value equals: #nameOf.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 9) equals: 0.  self assert: (var at: 11) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(0)'.  self assert: (var at: 5) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 8) printString equals: 'ValueLink(12)'.  self assert: (var at: 12) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 13) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36725991!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:08' prior: 36317014!test10  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 10 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 4 put: (SStack newStackWith: (var at: 10)).  var at: 5 put: (var at: 4) lastLinkStack.  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 4) lastLinkStack.  var at: 8 put: (var at: 4) top.  var at: 9 put: (var at: 4) pop.  var at: 11 put: (var at: 4) firstLinkStack.  self deny: (var at: 1) equals: (var at: 4).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 8).  self assert: (var at: 2) equals: (var at: 9).  self assert: (var at: 3) equals: (var at: 8).  self assert: (var at: 3) equals: (var at: 9).  self deny: (var at: 5) equals: (var at: 6).  self assert: (var at: 5) equals: (var at: 7).  self deny: (var at: 5) equals: (var at: 11).  self deny: (var at: 6) equals: (var at: 7).  self deny: (var at: 6) equals: (var at: 11).  self deny: (var at: 7) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 5) value equals: 12.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 11) value equals: #nameOf.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 8) equals: 0.  self assert: (var at: 9) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(0)'.  self assert: (var at: 4) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 5) printString equals: 'ValueLink(12)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 10) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 11) printString equals: 'ValueLink(#nameOf)'! !!STestCaseFactory methodsFor: '*SmallSuiteGenerator-Visualization' stamp: '' prior: 35660020!gtInspectorViewIn: composite	"<gtInspectorPresentationOrder: -10>	composite roassal3		title: 'Evolution';		initializeCanvas: [ self visualizeEvolutionFitness ]"! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!name  #metaObject count: 1.  nil.  ^name! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!age: aNumber  #metaObject count: 1.  nil.  ^aNumber! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!id  #metaObject count: 1.  nil.  ^id! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!identifier  #metaObject count: 1.  nil.  ^name , id printString! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!canRegister: aConference  #metaObject count: 1.  nil.  ^aConference price - aConference offerPrice > (aConference price * 0.05)! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!name: anObject  #metaObject count: 1.  nil.  name := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!id: anObject  #metaObject count: 1.  nil.  id := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!nickname  #metaObject count: 1.  nil.  self subclassResponsibility! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!nickname: anObject  #metaObject count: 1.  nil.  nickname := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!fullIdentifier  #metaObject count: 1.  nil.  ^name , '_' , nickname , '_' , id printString! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624372!name: aString with: aNumber  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: aNumber;     nickname: aString.  ^inst! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!name: aString  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: 1;     nickname: aString.  ^inst! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!offerPrice  #metaObject count: 1.  nil.  ^offerPrice! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!speaker: anObject  #metaObject count: 1.  nil.  speaker := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 100.  discount := 0.  offerPrice := price.  date := Date today! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!offerPrice: aNumber  #metaObject count: 1.  nil.  offerPrice := aNumber! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!speaker  #metaObject count: 1.  nil.  ^speaker! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!canRegister: aPerson  #metaObject count: 1.  nil.  ^aPerson canRegister: self! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!price  #metaObject count: 1.  nil.  ^price - (discount * price / 100)! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!discount  #metaObject count: 1.  nil.  ^discount! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  price := aNumber! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 0.  discount := 0! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!discount: aNumber  #metaObject count: 1.  nil.  price > 0 ifTrue: [ #metaObject count: 2.        nil.        discount := aNumber ]! !!SEvent class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  ^self new price: aNumber! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!yearsWorkExperience  #metaObject count: 1.  nil.  ^yearsWorkExperience! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  idTeacher := 100 + (id ifNil: [ #metaObject count: 2.              nil.              0 ]).  yearsWorkExperience := 0! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!idTeacher  #metaObject count: 1.  nil.  ^idTeacher! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!yearsWorkExperience: anObject  #metaObject count: 1.  nil.  yearsWorkExperience := anObject! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!nickname  #metaObject count: 1.  nil.  ^'teacher_' , (nickname ifNil: [ #metaObject count: 2.              nil.              '1' ])! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!testPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  self assert: event price equals: 80! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!testDiscountWithZeroPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event discount: 20.  self assert: event discount equals: 0.  self assert: event price equals: 0! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!testDiscount  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  event discount: 20.  self assert: event discount equals: 20.  self assert: event price equals: 64! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnFloat  | a |  #metaObject count: 1.  nil.  a := 2.3.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnCollection  | a |  #metaObject count: 1.  nil.  a := OrderedCollection new.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  score := 0! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!score: aNumber  #metaObject count: 1.  nil.  score := aNumber! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnNum  | a |  #metaObject count: 1.  nil.  a := 4.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnString  | a |  #metaObject count: 1.  nil.  a := 'Hello'.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!return: aType  #metaObject count: 1.  nil.  ^aType! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!score  #metaObject count: 1.  nil.  ^score! !!SFoo class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!score: aNumber  | ins |  #metaObject count: 1.  nil.  ins := self new score: aNumber.  ^ins! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!name  #metaObject count: 1.  nil.  ^name! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!age: aNumber  #metaObject count: 1.  nil.  ^aNumber! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!id  #metaObject count: 1.  nil.  ^id! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!identifier  #metaObject count: 1.  nil.  ^name , id printString! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!canRegister: aConference  #metaObject count: 1.  nil.  ^aConference price - aConference offerPrice > (aConference price * 0.05)! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!name: anObject  #metaObject count: 1.  nil.  name := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!id: anObject  #metaObject count: 1.  nil.  id := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!nickname  #metaObject count: 1.  nil.  self subclassResponsibility! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!nickname: anObject  #metaObject count: 1.  nil.  nickname := anObject! !!SSPerson methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!fullIdentifier  #metaObject count: 1.  nil.  ^name , '_' , nickname , '_' , id printString! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624372!name: aString with: aNumber  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: aNumber;     nickname: aString.  ^inst! !!SSPerson class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!name: aString  | inst |  #metaObject count: 1.  nil.  inst := self new     name: aString;     id: 1;     nickname: aString.  ^inst! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!offerPrice  #metaObject count: 1.  nil.  ^offerPrice! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!speaker: anObject  #metaObject count: 1.  nil.  speaker := anObject! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 100.  discount := 0.  offerPrice := price.  date := Date today! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!offerPrice: aNumber  #metaObject count: 1.  nil.  offerPrice := aNumber! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!speaker  #metaObject count: 1.  nil.  ^speaker! !!SConference methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!canRegister: aPerson  #metaObject count: 1.  nil.  ^aPerson canRegister: self! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!price  #metaObject count: 1.  nil.  ^price - (discount * price / 100)! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!discount  #metaObject count: 1.  nil.  ^discount! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  price := aNumber! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  price := 0.  discount := 0! !!SEvent methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!discount: aNumber  #metaObject count: 1.  nil.  price > 0 ifTrue: [ #metaObject count: 2.        nil.        discount := aNumber ]! !!SEvent class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!price: aNumber  #metaObject count: 1.  nil.  ^self new price: aNumber! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!yearsWorkExperience  #metaObject count: 1.  nil.  ^yearsWorkExperience! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  idTeacher := 100 + (id ifNil: [ #metaObject count: 2.              nil.              0 ]).  yearsWorkExperience := 0! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!idTeacher  #metaObject count: 1.  nil.  ^idTeacher! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!yearsWorkExperience: anObject  #metaObject count: 1.  nil.  yearsWorkExperience := anObject! !!SSTeacher methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!nickname  #metaObject count: 1.  nil.  ^'teacher_' , (nickname ifNil: [ #metaObject count: 2.              nil.              '1' ])! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!date  #metaObject count: 1.  nil.  ^date! !!SParty methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!date: anObject  #metaObject count: 1.  nil.  date := anObject! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!testPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  self assert: event price equals: 80! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!testDiscountWithZeroPrice  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event discount: 20.  self assert: event discount equals: 0.  self assert: event price equals: 0! !!SEventTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!testDiscount  | event |  #metaObject count: 1.  nil.  event := SEvent new.  event price: 80.  event discount: 20.  self assert: event discount equals: 20.  self assert: event price equals: 64! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnFloat  | a |  #metaObject count: 1.  nil.  a := 2.3.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnCollection  | a |  #metaObject count: 1.  nil.  a := OrderedCollection new.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!initialize  #metaObject count: 1.  nil.  score := 0! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!score: aNumber  #metaObject count: 1.  nil.  score := aNumber! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnNum  | a |  #metaObject count: 1.  nil.  a := 4.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!returnString  | a |  #metaObject count: 1.  nil.  a := 'Hello'.  ^a! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!return: aType  #metaObject count: 1.  nil.  ^aType! !!SFoo methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!score  #metaObject count: 1.  nil.  ^score! !!SFoo class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!score: aNumber  | ins |  #metaObject count: 1.  nil.  ins := self new score: aNumber.  ^ins! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36728988!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: #nameOf.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36752072!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36752471!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36752964!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: #nameOf.var at: 14 put: ((var at: 1) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36753591!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36754336!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: -2.var at: 7 put: ((var at: 1) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36754612!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36755039!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36755414!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36755837!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36756418!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 12 put: #nameOf.var at: 13 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36757048!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 12 put: #nameOf.var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36757752!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36758531!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36758806!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36759082!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36759430!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: 'Johan'.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36760016!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36760695!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36761029!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36761411!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36761841!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 10 put: 12.var at: 11 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36762404!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36763036!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36763374!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36763760!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: '1'.var at: 8 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36764194!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: '1'.var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36764696!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36765279!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36765503!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36766227!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36766919!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36767536!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36768262!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36768551!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36769178!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36769969!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36770156!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36770691!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36771482!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36772099!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36772634!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36773360!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36774084!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36774711!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36775403!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36775692!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36775916!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36777625!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36778416!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: 'Johan'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 8 put: ((var at: 2) push: (var at: 6)).var at: 9 put: (var at: 2) top.var at: 10 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36779033!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: (var at: 2) lastLinkStack.var at: 4 put: -2.var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) lastLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: #nameOf.var at: 10 put: ((var at: 2) push: (var at: 9)).var at: 11 put: ((var at: 2) push: (var at: 5)).var at: 13 put: ((var at: 2) push: (var at: 5)).var at: 14 put: 'hello'.var at: 15 put: ((var at: 2) push: (var at: 14))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36779568!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36780294!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: ''.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) firstLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: 50.var at: 11 put: ((var at: 1) push: (var at: 5)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: ((var at: 1) push: (var at: 10))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36781018!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: ((var at: 1) push: (var at: 8)).var at: 12 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 8))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36781645!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36782337!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36782626!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36782850!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36783037!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36783356!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36783607!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36783900!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36784261!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36784664!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36785109!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36785596!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36786115!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: nil.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.var at: 11 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36786667!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 5 put: OrderedCollection new.var at: 6 put: (SStack newStackWith: (var at: 5)).var at: 3 put: ((var at: 6) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36787263!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 5 put: OrderedCollection new.var at: 6 put: (SStack newStackWith: (var at: 5)).var at: 3 put: ((var at: 6) push: (var at: 2)).var at: 4 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36787671!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36788051!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36788555!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36788956!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36789400!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36789887!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36790416!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36790978!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36791583!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36792232!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36792924!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: 50.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36793659!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36794437!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36794832!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36795275!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36795761!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36796289!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36796866!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36797492!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36798161!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36798873!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36799618!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: nil.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36800407!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36801240!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36802033!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36803058!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36803823!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36804820!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36805397!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36805704!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36806043!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36806425!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36806974!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36807328!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36807667!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36808048!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36808471!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36808966!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.var at: 8 put: 'Johan'.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 3) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36809505!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36810114!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36810738!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36811222!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36811818!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36812274!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36812592!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36812952!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36813354!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36813828!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36814344!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36814903!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36815532!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36816205!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36816928!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36817265!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36817644!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36818095!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36818588!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36819123!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36819701!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36820312!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36820956!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 15 put: OrderedCollection new.var at: 16 put: (SStack newStackWith: (var at: 15)).var at: 4 put: (var at: 16) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36821644!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 14 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 14) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36822460!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 15 put: OrderedCollection new.var at: 16 put: (SStack newStackWith: (var at: 15)).var at: 4 put: (var at: 16) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: #nameOf.var at: 8 put: ((var at: 1) push: (var at: 7)).var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: nil.var at: 12 put: ((var at: 1) push: (var at: 2)).var at: 13 put: (var at: 1) firstLinkStack.var at: 14 put: ((var at: 1) push: (var at: 11))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36823139!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 14 put: SStack newStack.var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 14) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: #nameOf.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36823927!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36824578!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36825369!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36825986!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36826490!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36827487!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36828252!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36828869!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36829223!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36829819!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36830275!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36832414!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36833411!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 2) push: (var at: 4)).var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 2) lastLinkStack.var at: 9 put: ((var at: 2) push: (var at: 3)).var at: 11 put: ((var at: 2) push: (var at: 3)).var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) pop.var at: 15 put: (var at: 2) firstLinkStack.var at: 16 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36834176!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 7 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 8 put: (SStack newStackWith: (var at: 7)).var at: 2 put: (var at: 8) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36834967!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36835563!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36836180!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36836797!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36837414!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 5 put: ((var at: 1) push: (var at: 2)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36837768!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36838272!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36838728!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36839484!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36839961!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 10)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36840480!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36841237!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36842042!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 2)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 1 put: (var at: 3) lastLinkStack.var at: 7 put: (var at: 3) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36842819!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36843310!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36843561!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36843854!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36844219!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36844626!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36845075!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36845566!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36846089!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36846645!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36846921!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36847229!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36847569!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36847952!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: (var at: 1) lastLinkStack.var at: 3 put: (var at: 1) lastLinkStack.var at: 4 put: #nameOf.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 10 put: (var at: 1) pop! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36848367!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36848895!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36849282!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 11 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 11)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36850020!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36850530!performTest	| var |var := Dictionary new.var at: 2 put: #nameOf.var at: 11 put: #nameOf.var at: 3 put: SStack newStack.var at: 4 put: nil.var at: 5 put: ((var at: 3) push: (var at: 11)).var at: 6 put: (var at: 3) lastLinkStack.var at: 9 put: ((var at: 3) push: (var at: 4)).var at: 10 put: (var at: 3) firstLinkStack.var at: 12 put: ((var at: 3) push: (var at: 5))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36851240!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36851722!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36852289!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36852889!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36853533!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36854100!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36854700!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36855344!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36855960!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36856576!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36857369!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36858134!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36858751!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36859748!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36860525!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36861290!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36861644!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36862031!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36862741!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36863358!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36863974!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36864590!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36866877!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36867874!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 4)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36868584!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 14 put: (var at: 2) lastLinkStack.var at: 15 put: (var at: 2) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36869349!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 16) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: ((var at: 2) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36870114!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36870891!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36871507!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36872123!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36872740!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 7 put: SStack newStack.var at: 2 put: 50.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 7) top.var at: 5 put: (var at: 1) pop.var at: 6 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36873094!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36873481!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36873828!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36874242!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36874704!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36875209!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36875756!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36876352!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:12' prior: 36877017!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36877725!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36878476!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36879260!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 11 put: 12.var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.var at: 18 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36880088!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36880960!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36881719!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36882521!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36883391!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36884304!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36885260!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36886259!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36887291!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36888356!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) top.var at: 5 put: 50.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 4)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 3)).var at: 12 put: ((var at: 1) push: (var at: 5)).var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) lastLinkStack.var at: 16 put: (var at: 1) pop.var at: 17 put: (var at: 1) firstLinkStack.var at: 18 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36889465!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36890250!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36891174!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36891976!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36892822!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36893713!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: 'Johan'.var at: 15 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36894647!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36895656!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36896318!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36897023!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36897771!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36898552!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.var at: 17 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36899377!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36900246!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36901279!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 15 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 5 put: 100.var at: 10 put: ((var at: 2) push: (var at: 5)).var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) lastLinkStack.var at: 13 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36902284!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36903081!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36903407!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36903765!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36904155!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36904588!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36904869!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36905281!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36905735!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36906256!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36906820!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36907427!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36908077!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36908760!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36909476!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 3 put: SStack newStack.var at: 4 put: 0.var at: 5 put: ((var at: 3) push: (var at: 4)).var at: 6 put: (var at: 1) top.var at: 7 put: (var at: 1) pop.var at: 8 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36910236!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36910622!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36911354!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36911887!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36912452!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36913060!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36913377!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36913736!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36914137!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36914570!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36915035!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36915543!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36916195!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36916847!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36917567!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36918191!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36918883!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36919493!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36920146!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 2) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36920885!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36921668!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36922452!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36923269!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36923894!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36924683!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36925680!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36926604!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36927601!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36928598!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36929603!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36930313!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36931045!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36931737!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36932361!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36934672!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: (SStack newStackWith: (var at: 17)).var at: 6 put: (var at: 18) lastLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: nil.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 5) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36935364!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36936288!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36937285!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36938282!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36939279!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36939903!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36940613!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 7 put: (var at: 2) firstLinkStack.var at: 8 put: (var at: 16) firstLinkStack.var at: 9 put: (var at: 16) lastLinkStack.var at: 10 put: (var at: 2) top.var at: 11 put: (var at: 2) lastLinkStack.var at: 12 put: (var at: 2) firstLinkStack.var at: 13 put: (var at: 2) lastLinkStack.var at: 5 put: (var at: 2) pop.var at: 17 put: (var at: 2) pop.var at: 14 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36941345!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36942134!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36943139!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36943603!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36944135!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36944711!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36945331!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36946020!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36946785!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36947594!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36948446!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36949331!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 13 put: #nameOf.var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36950261!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36951235!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36951817!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36952443!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36953112!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36953814!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36954558!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36955347!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36956179!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36957045!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36957944!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36958888!performTest	| var |var := Dictionary new.var at: 1 put: OrderedCollection new.var at: 2 put: (SStack newStackWith: (var at: 1)).var at: 3 put: '1'.var at: 4 put: ((var at: 2) push: (var at: 3)).var at: 16 put: SStack newStack.var at: 6 put: ((var at: 2) push: (var at: 3)).var at: 5 put: ((var at: 16) push: (var at: 4)).var at: 7 put: nil.var at: 8 put: ((var at: 2) push: (var at: 7)).var at: 9 put: (var at: 16) firstLinkStack.var at: 10 put: (var at: 16) lastLinkStack.var at: 11 put: 12.var at: 12 put: ((var at: 2) push: (var at: 8)).var at: 14 put: ((var at: 16) push: (var at: 11)).var at: 15 put: (var at: 16) lastLinkStack.var at: 17 put: (var at: 2) lastLinkStack.var at: 18 put: (var at: 2) pop.var at: 19 put: (var at: 16) firstLinkStack.var at: 20 put: (var at: 2) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36959837!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36960758!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36961674!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36962436!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36963241!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36964089!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36964971!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36965887!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36966847!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36967442!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36968086!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36968773!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36969503!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36970266!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: #nameOf.var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.var at: 17 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36971073!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36971924!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 11 put: ((var at: 1) push: (var at: 9)).var at: 12 put: ((var at: 5) push: (var at: 9)).var at: 13 put: (var at: 5) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) pop.var at: 16 put: (var at: 5) firstLinkStack.var at: 17 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36972830!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36973628!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36974168!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36974756!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36975410!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36976107!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36976846!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36977634!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36978497!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36979394!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36980334!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36981318!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 19 put: #nameOf.var at: 20 put: ((var at: 1) push: (var at: 12)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36982345!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36983447!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36983986!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36984574!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36985243!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36985956!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36986711!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36987516!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36988371!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36989270!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36990213!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36991189!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: ((var at: 18) push: (var at: 4)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36992209!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36993274!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).var at: 22 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36994400!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 18) top.var at: 5 put: ((var at: 1) push: (var at: 4)).var at: 6 put: 0.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: 'hello'.var at: 12 put: ((var at: 1) push: (var at: 11)).var at: 13 put: (var at: 18) top.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) lastLinkStack.var at: 20 put: ((var at: 1) push: (var at: 12)).var at: 21 put: ((var at: 1) push: (var at: 6)).var at: 22 put: ((var at: 1) push: (var at: 6))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36995575!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 19 put: nil.var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 5 put: ((var at: 18) push: (var at: 19)).var at: 6 put: 'teacher_Johan'.var at: 7 put: ((var at: 18) push: (var at: 6)).var at: 8 put: (var at: 18) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 18) push: (var at: 7)).var at: 11 put: ((var at: 18) push: (var at: 9)).var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 18) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36996722!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36997749!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36998509!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: 12.var at: 9 put: ((var at: 5) push: (var at: 8)).var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 5) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36999201!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36999933!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37000290!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37000741!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37001234!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37001769!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37002347!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37002958!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 4 put: (var at: 1) lastLinkStack.var at: 5 put: 12.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37003602!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37004290!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37004795!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37005342!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37005959!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37006619!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37007312!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 10 put: 100.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.var at: 15 put: (var at: 7) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37008038!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37008808!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37009454!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: -2.var at: 14 put: 15.var at: 3 put: ((var at: 1) push: (var at: 14)).var at: 4 put: (var at: 1) lastLinkStack.var at: 6 put: 'teacher_'.var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) top.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37010100!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: #nameOf.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 5) lastLinkStack.var at: 7 put: (SStack newStackWith: (var at: 4)).var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 7) lastLinkStack.var at: 11 put: ((var at: 5) push: (var at: 2)).var at: 12 put: (var at: 7) lastLinkStack.var at: 13 put: (var at: 7) top.var at: 14 put: (var at: 5) pop.var at: 15 put: (var at: 7) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37010718!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37011439!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37012131!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37013047!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37014044!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37014950!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37015947!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37016944!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37017949!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37018641!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37019333!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37021479!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37022395!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37023301!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37023993!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37024685!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37025377!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37026374!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 11 put: ((var at: 1) push: (var at: 7)).var at: 12 put: (var at: 1) lastLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.var at: 16 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37027371!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: -2.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 14 put: OrderedCollection new.var at: 15 put: (SStack newStackWith: (var at: 14)).var at: 4 put: (var at: 15) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 7 put: ((var at: 1) push: (var at: 3)).var at: 12 put: (var at: 15) lastLinkStack.var at: 6 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37028368!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 19 put: ((var at: 1) push: (var at: 6)).var at: 10 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 18) top.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) firstLinkStack.var at: 13 put: (var at: 1) lastLinkStack.var at: 15 put: ((var at: 18) push: (var at: 4))! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37028992!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37029997!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37030561!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37031167!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37031815!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37032495!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: OrderedCollection new.var at: 5 put: (SStack newStackWith: (var at: 4)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37033208!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37033965!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37034492!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37035061!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37035672!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37036315!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37036990!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37037709!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37038401!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37039092!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37039803!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37040556!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37041342!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37042161!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37043025!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37043587!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37044191!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37044838!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37045528!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37046251!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.var at: 13 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37047008!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 15 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37047809!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 15 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) top.var at: 11 put: (var at: 1) pop.var at: 12 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37048717!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 11) top.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 11) lastLinkStack.var at: 9 put: (var at: 11) pop.var at: 12 put: (var at: 11) pop.var at: 13 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37049597!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 11) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37050327!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37051043!performTest	| var |var := Dictionary new.var at: 1 put: SStack new.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 11) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37052011!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37052699!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37053639!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37054401!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37055206!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37056055!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37056948!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37057874!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37058833!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37059836!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37060564!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37061341!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37062162!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37063026!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37063924!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 5 put: 'teacher_'.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37064867!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37065855!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37066859!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37067907!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37068867!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 1) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 6 put: ((var at: 1) push: (var at: 19)).var at: 9 put: ((var at: 18) push: (var at: 4)).var at: 10 put: (var at: 18) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 18) firstLinkStack.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37069887!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37070819!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37071496!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37072206!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37072959!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37073756!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37074597!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37075471!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37076379!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37077332!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37078001!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37078712!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37079491!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37080340!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37081232!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37082167!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37083136!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 11 put: 100.var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.var at: 19 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37084150!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 19 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 19)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37085208!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 19 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 19)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 5 put: (var at: 1) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 18) lastLinkStack.var at: 10 put: (var at: 1) firstLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 1) pop.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37086271!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 1) firstLinkStack.var at: 8 put: (var at: 1) lastLinkStack.var at: 9 put: ''.var at: 10 put: ((var at: 1) push: (var at: 5)).var at: 12 put: ((var at: 1) push: (var at: 9)).var at: 13 put: (var at: 1) lastLinkStack.var at: 14 put: (var at: 1) lastLinkStack.var at: 15 put: (var at: 18) pop.var at: 16 put: (var at: 18) firstLinkStack.var at: 19 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37087306!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37088315!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37089231!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37089922!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37090614!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37091530!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37092222!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37093128!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37094068!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37094974!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!lastLinkStack  #metaObject count: 1.  nil.  ^lastLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33624245!push: anObject  #metaObject count: 1.  nil.  self addFirst: anObject.  ^anObject! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!pop  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self removeFirst ]! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!firstLinkStack  #metaObject count: 1.  nil.  ^firstLink! !!SStack methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!top  #metaObject count: 1.  nil.  self isEmpty ifTrue: [ #metaObject count: 2.        nil.        ^nil ] ifFalse: [ #metaObject count: 3.        nil.        ^self firstLink value ]! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33624245!newStackWith: aList  | inst |  #metaObject count: 1.  nil.  inst := self newStack.  aList do: [:element |  #metaObject count: 2.        nil.        inst push: element ].  ^inst! !!SStack class methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 33622550!newStack  #metaObject count: 1.  nil.  ^self new! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37095994!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37098432!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37099348!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37100264!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37101180!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37102086!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37102992!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37103932!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37104952!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37105644!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37106336!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36695016!test1  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37107027!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36698778!test2  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37110789!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 5 put: (var at: 1) firstLinkStack.var at: 6 put: (var at: 18) firstLinkStack.var at: 7 put: (var at: 18) lastLinkStack.var at: 8 put: (var at: 18) top.var at: 9 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 18) firstLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) pop.var at: 13 put: (var at: 1) pop.var at: 14 put: (var at: 18) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36702540!test3  "Fitness: block-coverage: 100.0"  "This test covers: block-coverageSStack:100.0%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 5 put: (var at: 1) firstLinkStack.  var at: 6 put: (var at: 18) firstLinkStack.  var at: 7 put: (var at: 18) lastLinkStack.  var at: 8 put: (var at: 18) top.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 18) firstLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) pop.  var at: 13 put: (var at: 1) pop.  var at: 14 put: (var at: 18) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self assert: (var at: 2) equals: (var at: 6).  self deny: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 14).  self deny: (var at: 6) equals: (var at: 7).  self assert: (var at: 6) equals: (var at: 10).  self deny: (var at: 6) equals: (var at: 14).  self deny: (var at: 7) equals: (var at: 10).  self deny: (var at: 7) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 12).  self deny: (var at: 10) equals: (var at: 14).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 10) value equals: 0.  self assert: (var at: 14) value equals: #nameOf.  self assert: (var at: 8) equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'nil'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'ValueLink(0)'.  self assert: (var at: 11) printString equals: 'nil'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37114551!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36706292!test4  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37118313!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36710419!test5  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37122440!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 19 put: nil.var at: 7 put: ((var at: 1) push: (var at: 19)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 1) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 1) lastLinkStack.var at: 12 put: (var at: 18) top.var at: 13 put: (var at: 18) pop.var at: 20 put: (var at: 18) pop.var at: 14 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36714580!test6  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 19 put: nil.  var at: 7 put: ((var at: 1) push: (var at: 19)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 1) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 1) lastLinkStack.  var at: 12 put: (var at: 18) top.  var at: 13 put: (var at: 18) pop.  var at: 20 put: (var at: 18) pop.  var at: 14 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 14).  self assert: (var at: 5) equals: (var at: 8).  self assert: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self assert: (var at: 5) equals: (var at: 11).  self assert: (var at: 5) equals: (var at: 14).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self assert: (var at: 8) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 14).  self assert: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 14).  self assert: (var at: 10) equals: (var at: 11).  self assert: (var at: 10) equals: (var at: 14).  self assert: (var at: 11) equals: (var at: 14).  self assert: (var at: 12) equals: (var at: 13).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 12) equals: 0.  self assert: (var at: 13) equals: 0.  self assert: (var at: 20) equals: #nameOf.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(nil)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(nil)'.  self assert: (var at: 14) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'nil'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37126567!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 17 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 18 put: (SStack newStackWith: (var at: 17)).var at: 2 put: (var at: 18) firstLinkStack.var at: 3 put: (var at: 1) firstLinkStack.var at: 4 put: (var at: 1) top.var at: 6 put: ((var at: 1) push: (var at: 4)).var at: 7 put: ((var at: 1) push: (var at: 6)).var at: 8 put: (var at: 1) firstLinkStack.var at: 9 put: (var at: 18) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 10 put: (var at: 1) lastLinkStack.var at: 11 put: (var at: 18) lastLinkStack.var at: 12 put: (var at: 18) lastLinkStack.var at: 19 put: (var at: 18) lastLinkStack.var at: 13 put: (var at: 1) top.var at: 14 put: (var at: 1) pop.var at: 15 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36718894!test7  "Fitness: block-coverage: 93.333"  "This test covers: block-coverageSStack:93.333%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 17 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 18 put: (SStack newStackWith: (var at: 17)).  var at: 2 put: (var at: 18) firstLinkStack.  var at: 3 put: (var at: 1) firstLinkStack.  var at: 4 put: (var at: 1) top.  var at: 6 put: ((var at: 1) push: (var at: 4)).  var at: 7 put: ((var at: 1) push: (var at: 6)).  var at: 8 put: (var at: 1) firstLinkStack.  var at: 9 put: (var at: 18) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 10 put: (var at: 1) lastLinkStack.  var at: 11 put: (var at: 18) lastLinkStack.  var at: 12 put: (var at: 18) lastLinkStack.  var at: 19 put: (var at: 18) lastLinkStack.  var at: 13 put: (var at: 1) top.  var at: 14 put: (var at: 1) pop.  var at: 15 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 18).  self deny: (var at: 2) equals: (var at: 5).  self deny: (var at: 2) equals: (var at: 8).  self deny: (var at: 2) equals: (var at: 9).  self deny: (var at: 2) equals: (var at: 10).  self deny: (var at: 2) equals: (var at: 11).  self deny: (var at: 2) equals: (var at: 12).  self deny: (var at: 2) equals: (var at: 15).  self deny: (var at: 2) equals: (var at: 19).  self assert: (var at: 5) equals: (var at: 8).  self deny: (var at: 5) equals: (var at: 9).  self assert: (var at: 5) equals: (var at: 10).  self deny: (var at: 5) equals: (var at: 11).  self deny: (var at: 5) equals: (var at: 12).  self assert: (var at: 5) equals: (var at: 15).  self deny: (var at: 5) equals: (var at: 19).  self deny: (var at: 8) equals: (var at: 9).  self assert: (var at: 8) equals: (var at: 10).  self deny: (var at: 8) equals: (var at: 11).  self deny: (var at: 8) equals: (var at: 12).  self assert: (var at: 8) equals: (var at: 15).  self deny: (var at: 8) equals: (var at: 19).  self deny: (var at: 9) equals: (var at: 10).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 9) equals: (var at: 12).  self deny: (var at: 9) equals: (var at: 15).  self assert: (var at: 9) equals: (var at: 19).  self deny: (var at: 10) equals: (var at: 11).  self deny: (var at: 10) equals: (var at: 12).  self assert: (var at: 10) equals: (var at: 15).  self deny: (var at: 10) equals: (var at: 19).  self assert: (var at: 11) equals: (var at: 12).  self deny: (var at: 11) equals: (var at: 15).  self assert: (var at: 11) equals: (var at: 19).  self deny: (var at: 12) equals: (var at: 15).  self assert: (var at: 12) equals: (var at: 19).  self deny: (var at: 15) equals: (var at: 19).  self assert: (var at: 2) value equals: 0.  self assert: (var at: 9) value equals: 12.  self assert: (var at: 11) value equals: 12.  self assert: (var at: 12) value equals: 12.  self assert: (var at: 19) value equals: 12.  self assert: (var at: 1) printString equals: 'a SStack(nil)'.  self assert: (var at: 2) printString equals: 'ValueLink(0)'.  self assert: (var at: 3) printString equals: 'nil'.  self assert: (var at: 4) printString equals: 'nil'.  self assert: (var at: 5) printString equals: 'ValueLink(nil)'.  self assert: (var at: 6) printString equals: 'nil'.  self assert: (var at: 7) printString equals: 'nil'.  self assert: (var at: 8) printString equals: 'ValueLink(nil)'.  self assert: (var at: 9) printString equals: 'ValueLink(12)'.  self assert: (var at: 10) printString equals: 'ValueLink(nil)'.  self assert: (var at: 11) printString equals: 'ValueLink(12)'.  self assert: (var at: 12) printString equals: 'ValueLink(12)'.  self assert: (var at: 13) printString equals: 'nil'.  self assert: (var at: 14) printString equals: 'nil'.  self assert: (var at: 15) printString equals: 'ValueLink(nil)'.  self assert: (var at: 17) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 18) printString equals: 'a SStack(0 #nameOf ''hello'' -2 12)'.  self assert: (var at: 19) printString equals: 'ValueLink(12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37130801!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 11 put: (SStack newStackWith: (var at: 10)).var at: 4 put: (var at: 11) lastLinkStack.var at: 5 put: (var at: 1) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 1) top.var at: 8 put: (var at: 1) pop.var at: 9 put: (var at: 1) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36723925!test8  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 10 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 11 put: (SStack newStackWith: (var at: 10)).  var at: 4 put: (var at: 11) lastLinkStack.  var at: 5 put: (var at: 1) lastLinkStack.  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 1) top.  var at: 8 put: (var at: 1) pop.  var at: 9 put: (var at: 1) firstLinkStack.  self deny: (var at: 1) equals: (var at: 11).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 7).  self assert: (var at: 2) equals: (var at: 8).  self assert: (var at: 3) equals: (var at: 7).  self assert: (var at: 3) equals: (var at: 8).  self deny: (var at: 4) equals: (var at: 5).  self deny: (var at: 4) equals: (var at: 6).  self assert: (var at: 5) equals: (var at: 6).  self assert: (var at: 7) equals: (var at: 8).  self assert: (var at: 4) value equals: 12.  self assert: (var at: 5) value equals: 0.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 7) equals: 0.  self assert: (var at: 8) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack()'.  self assert: (var at: 4) printString equals: 'ValueLink(12)'.  self assert: (var at: 5) printString equals: 'ValueLink(0)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 9) printString equals: 'nil'.  self assert: (var at: 10) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 11) printString equals: 'a SStack(0 #nameOf ''hello'' -2 12)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37136160!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 13 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 5 put: (SStack newStackWith: (var at: 13)).var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 5) lastLinkStack.var at: 8 put: (var at: 5) lastLinkStack.var at: 9 put: (var at: 1) top.var at: 11 put: (var at: 5) pop.var at: 12 put: (var at: 5) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36726711!test9  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 13 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 5 put: (SStack newStackWith: (var at: 13)).  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 5) lastLinkStack.  var at: 8 put: (var at: 5) lastLinkStack.  var at: 9 put: (var at: 1) top.  var at: 11 put: (var at: 5) pop.  var at: 12 put: (var at: 5) firstLinkStack.  self deny: (var at: 1) equals: (var at: 5).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 9).  self assert: (var at: 2) equals: (var at: 11).  self assert: (var at: 3) equals: (var at: 9).  self assert: (var at: 3) equals: (var at: 11).  self deny: (var at: 6) equals: (var at: 7).  self deny: (var at: 6) equals: (var at: 8).  self deny: (var at: 6) equals: (var at: 12).  self assert: (var at: 7) equals: (var at: 8).  self deny: (var at: 7) equals: (var at: 12).  self deny: (var at: 8) equals: (var at: 12).  self assert: (var at: 9) equals: (var at: 11).  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 8) value equals: 12.  self assert: (var at: 12) value equals: #nameOf.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 9) equals: 0.  self assert: (var at: 11) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(0)'.  self assert: (var at: 5) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 8) printString equals: 'ValueLink(12)'.  self assert: (var at: 12) printString equals: 'ValueLink(#nameOf)'.  self assert: (var at: 13) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'! !!SSTestRunner methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 37138946!performTest	| var |var := Dictionary new.var at: 1 put: SStack newStack.var at: 2 put: 0.var at: 3 put: ((var at: 1) push: (var at: 2)).var at: 10 put: (OrderedCollection new         add: 12;         add: -2;         add: 'hello';         add: #nameOf;         add: 0;         yourself).var at: 4 put: (SStack newStackWith: (var at: 10)).var at: 5 put: (var at: 4) lastLinkStack.var at: 6 put: (var at: 1) lastLinkStack.var at: 7 put: (var at: 4) lastLinkStack.var at: 8 put: (var at: 4) top.var at: 9 put: (var at: 4) pop.var at: 11 put: (var at: 4) firstLinkStack.^self analyze: thisContext! !!GASStackTest methodsFor: 'as yet unclassified' stamp: 'AndreinaCota 7/31/2020 06:13' prior: 36729707!test10  "Fitness: block-coverage: 86.667"  "This test covers: block-coverageSStack:86.667%"  | var |  var := Dictionary new.  var at: 1 put: SStack newStack.  var at: 2 put: 0.  var at: 3 put: ((var at: 1) push: (var at: 2)).  var at: 10 put: (OrderedCollection new           add: 12;           add: -2;           add: 'hello';           add: #nameOf;           add: 0;           yourself).  var at: 4 put: (SStack newStackWith: (var at: 10)).  var at: 5 put: (var at: 4) lastLinkStack.  var at: 6 put: (var at: 1) lastLinkStack.  var at: 7 put: (var at: 4) lastLinkStack.  var at: 8 put: (var at: 4) top.  var at: 9 put: (var at: 4) pop.  var at: 11 put: (var at: 4) firstLinkStack.  self deny: (var at: 1) equals: (var at: 4).  self assert: (var at: 2) equals: (var at: 3).  self assert: (var at: 2) equals: (var at: 8).  self assert: (var at: 2) equals: (var at: 9).  self assert: (var at: 3) equals: (var at: 8).  self assert: (var at: 3) equals: (var at: 9).  self deny: (var at: 5) equals: (var at: 6).  self assert: (var at: 5) equals: (var at: 7).  self deny: (var at: 5) equals: (var at: 11).  self deny: (var at: 6) equals: (var at: 7).  self deny: (var at: 6) equals: (var at: 11).  self deny: (var at: 7) equals: (var at: 11).  self assert: (var at: 8) equals: (var at: 9).  self assert: (var at: 5) value equals: 12.  self assert: (var at: 6) value equals: 0.  self assert: (var at: 7) value equals: 12.  self assert: (var at: 11) value equals: #nameOf.  self assert: (var at: 2) equals: 0.  self assert: (var at: 3) equals: 0.  self assert: (var at: 8) equals: 0.  self assert: (var at: 9) equals: 0.  self assert: (var at: 1) printString equals: 'a SStack(0)'.  self assert: (var at: 4) printString equals: 'a SStack(#nameOf ''hello'' -2 12)'.  self assert: (var at: 5) printString equals: 'ValueLink(12)'.  self assert: (var at: 6) printString equals: 'ValueLink(0)'.  self assert: (var at: 7) printString equals: 'ValueLink(12)'.  self assert: (var at: 10) printString equals: 'an OrderedCollection(12 -2 ''hello'' #nameOf 0)'.  self assert: (var at: 11) printString equals: 'ValueLink(#nameOf)'! !----SNAPSHOT----2020-07-31T06:14:27.054458-04:00 Pharo9_330.image priorSource: 100!----QUIT----2020-07-31T06:14:40.667246-04:00 Pharo9_330.image priorSource: 3590399!