OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.725597-04:00' ],		#prior : OmReference [ 'Pharo9.0-SNAPSHOT-64bit-1570116.e7xhkagfflhfl5s53tmkdfqn0', '1' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2\r  ^\'<an unprintable nonliteral value>\' run: #groupBy:aggregateUsing: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2\r  #metaObject count: 1.\r  nil.\r  ^self groupBy: arg1 aggregateUsing: arg2 as: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.729491-04:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  ^\'<an unprintable nonliteral value>\' run: #valueCounts with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  #metaObject count: 1.\r  nil.\r  ^(self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.733748-04:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  ^\'<an unprintable nonliteral value>\' run: #makeCategorical with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := false',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.737653-04:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndexDo: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keys withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.740128-04:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  ^\'<an unprintable nonliteral value>\' run: #select: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super select: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.74385-04:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  ^\'<an unprintable nonliteral value>\' run: #replaceNilsWithMedian with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) median.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.746225-04:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  ^\'<an unprintable nonliteral value>\' run: #at:transform: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  self at: arg1 transform: arg2 ifAbsent: NotFoundError',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.748498-04:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  ^\'<an unprintable nonliteral value>\' run: #defaultPrecision with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  #metaObject count: 1.\r  nil.\r  ^0.0001',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.753636-04:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: arg1\r  ^\'<an unprintable nonliteral value>\' run: #crossTabulateWith: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := DataFrame withRows: (self uniqueValues collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              arg1 uniqueValues collect: [:arg3 |  #metaObject count: 4.\r                    nil.\r                    (1 to: self size) inject: 0 into: [:arg4 :arg5 |  #metaObject count: 5.\r                          nil.\r                          ((self atIndex: arg5) = arg2 and: (arg1 atIndex: arg5) = arg3) ifTrue: [ #metaObject count: 6.\r                                nil.\r                                arg4 + 1 ] ifFalse: [ #metaObject count: 7.\r                                nil.\r                                arg4 ] ] ] ]).\r  tmp1\r     rowNames: self uniqueValues;\r     columnNames: arg1 uniqueValues.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.755417-04:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  ^\'<an unprintable nonliteral value>\' run: #eighth with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 8',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.757493-04:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  ^\'<an unprintable nonliteral value>\' run: #head with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.759245-04:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeAtIndex: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeAt: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.761743-04:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: arg1 andSend: arg2\r  ^\'<an unprintable nonliteral value>\' run: #adaptToCollection:andSend: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: arg1 andSend: arg2\r  #metaObject count: 1.\r  nil.\r  (arg1 isSequenceable and: [ #metaObject count: 2.\r        nil.\r        self isSequenceable ]) ifFalse: [ #metaObject count: 3.\r        nil.\r        self error: \'Only sequenceable collections may be combined arithmetically\' ].\r  ^arg1 withSeries: self collect: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        arg3 perform: arg2 with: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.764027-04:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: arg1\r  ^\'<an unprintable nonliteral value>\' run: #sort: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  self sortAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.765975-04:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: arg1\r  ^\'<an unprintable nonliteral value>\' run: #sortedAssociations: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  tmp3 := tmp1 asDataSeries.\r  tmp3 name: self name.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.768156-04:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withKeyCollect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg2 key) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.770402-04:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  ^\'<an unprintable nonliteral value>\' run: #isNumerical with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := forcedIsNumerical.\r  ^tmp2 ifNil: [ #metaObject count: 2.\r        nil.\r        self uniqueValues allSatisfy: [:arg1 |  #metaObject count: 3.\r              nil.\r              arg1 isNumber ] ] ifNotNil: [ #metaObject count: 4.\r        nil.\r        tmp2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.772317-04:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg1\r  ^\'<an unprintable nonliteral value>\' run: #> with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.774534-04:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  ^\'<an unprintable nonliteral value>\' run: #thirdQuartile with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.776002-04:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  ^\'<an unprintable nonliteral value>\' run: #defaultHeadTailSize with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.777651-04:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withKeyDetect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeyDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.778949-04:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  ^\'<an unprintable nonliteral value>\' run: #hasNil with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  #metaObject count: 1.\r  nil.\r  ^self includes: nil',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.780226-04:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  ^\'<an unprintable nonliteral value>\' run: #sixth with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 6',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.78208-04:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #collect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super collect: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.784869-04:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2 as: arg3\r  ^\'<an unprintable nonliteral value>\' run: #groupBy:aggregateUsing:as: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2 as: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg1 uniqueValues.\r  tmp2 := tmp1 collect: [:arg4 |  #metaObject count: 3.\r        nil.\r        (1 to: self size) select: [:arg5 |  #metaObject count: 4.\r              nil.\r              (arg1 atIndex: arg5) = arg4 ] thenCollect: [:arg6 |  #metaObject count: 5.\r              nil.\r              self atIndex: arg6 ] ].\r  ^DataSeries withKeys: tmp1 values: (tmp2 collect: arg2) name: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.7862-04:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  ^\'<an unprintable nonliteral value>\' run: #isCategorical with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  #metaObject count: 1.\r  nil.\r  ^self isNumerical not',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.788281-04:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: arg1\r  ^\'<an unprintable nonliteral value>\' run: #collectWithNotNils: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifFalse: [ #metaObject count: 3.\r              nil.\r              arg1 value: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.789981-04:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  ^\'<an unprintable nonliteral value>\' run: #second with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.792135-04:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withKeySelect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ].\r  ^DataSeries withKeys: tmp1 values: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self at: arg3 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.79344-04:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  ^\'<an unprintable nonliteral value>\' run: #fourthQuartile with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 4',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.794988-04:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  ^\'<an unprintable nonliteral value>\' run: #sort with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.796913-04:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: arg1\r  ^\'<an unprintable nonliteral value>\' run: #quantile: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self sorted.\r  arg1 = 0 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^tmp1 first ].\r  tmp2 := (tmp1 size * (arg1 / 100)) ceiling.\r  ^tmp1 atIndex: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.800384-04:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1 precision: arg2\r  ^\'<an unprintable nonliteral value>\' run: #closeTo:precision: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1 precision: arg2\r  #metaObject count: 1.\r  nil.\r  self == arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^true ].\r  (self species == arg1 species and: [ #metaObject count: 3.\r        nil.\r        self size = arg1 size ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 name = self name ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 6.\r        nil.\r        ^false ].\r  ^(1 to: self values size) detect: [:arg3 |  #metaObject count: 7.\r        nil.\r        ((self atIndex: arg3) closeTo: (arg1 atIndex: arg3) precision: arg2) not ] ifFound: [ #metaObject count: 8.\r        nil.\r        false ] ifNone: [ #metaObject count: 9.\r        nil.\r        true ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.802489-04:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 put: arg2\r  ^\'<an unprintable nonliteral value>\' run: #atIndex:put: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1) put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.803689-04:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  ^\'<an unprintable nonliteral value>\' run: #defaultName with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  #metaObject count: 1.\r  nil.\r  ^\'(no name)\'',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.805604-04:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1 ifNone: arg2\r  ^\'<an unprintable nonliteral value>\' run: #withKeyDetect:ifNone: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self at: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.807776-04:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  ^\'<an unprintable nonliteral value>\' run: #= with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  super = arg1 ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  ^arg1 name = self name and: [ #metaObject count: 3.\r        nil.\r        arg1 keys = self keys ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.80916-04:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: arg1\r  ^\'<an unprintable nonliteral value>\' run: #quartile: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: arg1\r  #metaObject count: 1.\r  nil.\r  ^self quantile: 25 * arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.810443-04:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  ^\'<an unprintable nonliteral value>\' run: #replaceNilsWithZero with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  #metaObject count: 1.\r  nil.\r  self replaceNilsWith: 0',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.81224-04:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: arg1\r  ^\'<an unprintable nonliteral value>\' run: #replaceNilsWith: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: arg1\r  #metaObject count: 1.\r  nil.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              self atIndex: arg3 put: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.813433-04:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  ^\'<an unprintable nonliteral value>\' run: #secondQuartile with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.814945-04:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  ^\'<an unprintable nonliteral value>\' run: #first with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.81656-04:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndexReject: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.817746-04:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  ^\'<an unprintable nonliteral value>\' run: #firstQuartile with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.81944-04:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2 ifAbsent: arg3\r  ^\'<an unprintable nonliteral value>\' run: #at:transform:ifAbsent: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        arg3 value.\r        ^self ].\r  self at: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.820651-04:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  ^\'<an unprintable nonliteral value>\' run: #errorKeysMismatch with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  #metaObject count: 1.\r  nil.\r  Error signal: \'Keys of two series do not match\'',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.822251-04:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  ^\'<an unprintable nonliteral value>\' run: #initialize: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  self initialize.\r  ^super initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.823705-04:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: arg1\r  ^\'<an unprintable nonliteral value>\' run: #head: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: 1 to: arg1) values: (self values copyFrom: 1 to: arg1) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.825277-04:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  ^\'<an unprintable nonliteral value>\' run: #replaceNilsWithAverage with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) average.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.826529-04:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  ^\'<an unprintable nonliteral value>\' run: #interquartileRange with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self thirdQuartile - self firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.828114-04:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  ^\'<an unprintable nonliteral value>\' run: #closeTo: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  #metaObject count: 1.\r  nil.\r  ^self closeTo: arg1 precision: self defaultPrecision',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.830741-04:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: arg1\r  ^\'<an unprintable nonliteral value>\' run: #sorted: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  ^self sortedAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.833515-04:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: arg1\r  ^\'<an unprintable nonliteral value>\' run: #keys: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 asArray deepCopy.\r  dictionary := self dictionaryClass newFromKeys: tmp1 andValues: self values.\r  orderedKeys := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.834996-04:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: arg1\r  ^\'<an unprintable nonliteral value>\' run: #name: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: arg1\r  #metaObject count: 1.\r  nil.\r  name := arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.836639-04:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  ^\'<an unprintable nonliteral value>\' run: #replaceNilsWithMode with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) mode.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.83833-04:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  ^\'<an unprintable nonliteral value>\' run: #uniqueValues with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asSet asArray.\r  ^[ #metaObject count: 2.\r  nil.\r  tmp1 sort ] on: Error do: [ #metaObject count: 3.\r        nil.\r        tmp1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.83949-04:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  ^\'<an unprintable nonliteral value>\' run: #fourth with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 4',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.840715-04:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  ^\'<an unprintable nonliteral value>\' run: #makeNumerical with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.842158-04:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndexDetect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.843598-04:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  ^\'<an unprintable nonliteral value>\' run: #asDataFrame with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  #metaObject count: 1.\r  nil.\r  ^DataFrame withColumns: {self values} rowNames: self keys columnNames: {self name}',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.845061-04:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg1\r  ^\'<an unprintable nonliteral value>\' run: #< with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.846405-04:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  ^\'<an unprintable nonliteral value>\' run: #valueFrequencies with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 / self size.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.848539-04:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: arg1 collect: arg2\r  ^\'<an unprintable nonliteral value>\' run: #with:collect: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keys withIndexDo: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg4)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.850051-04:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: arg1\r  ^\'<an unprintable nonliteral value>\' run: #log: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 log: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.851549-04:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  ^\'<an unprintable nonliteral value>\' run: #sortedDescending with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.853321-04:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg1\r  ^\'<an unprintable nonliteral value>\' run: #>= with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>=',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.856564-04:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndexSelect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg2) value: arg2 ].\r  ^DataSeries withKeys: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self keys at: arg3 ]) values: (tmp1 collect: [:arg4 |  #metaObject count: 4.\r              nil.\r              self atIndex: arg4 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.859908-04:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withKeyDo: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keysDo: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.861545-04:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  ^\'<an unprintable nonliteral value>\' run: #third with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.863179-04:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg1\r  ^\'<an unprintable nonliteral value>\' run: #<= with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<=',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.865181-04:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1 ifNone: arg2\r  ^\'<an unprintable nonliteral value>\' run: #withIndexDetect:ifNone: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self atIndex: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.866441-04:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  ^\'<an unprintable nonliteral value>\' run: #isSequenceable with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  #metaObject count: 1.\r  nil.\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.867936-04:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  ^\'<an unprintable nonliteral value>\' run: #removeNils with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  #metaObject count: 1.\r  nil.\r  ^self reject: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNil ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.869185-04:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  ^\'<an unprintable nonliteral value>\' run: #tail with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.870984-04:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndexCollect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations withIndexCollect: [:arg2 :arg3 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg3) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.872512-04:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: arg1\r  ^\'<an unprintable nonliteral value>\' run: #sortAssociations: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  self\r     removeAll;\r     addAll: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.874222-04:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: arg1\r  ^\'<an unprintable nonliteral value>\' run: #reject: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super reject: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.875491-04:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1\r  ^\'<an unprintable nonliteral value>\' run: #atIndex: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.876631-04:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  ^\'<an unprintable nonliteral value>\' run: #fifth with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.877958-04:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  ^\'<an unprintable nonliteral value>\' run: #mode with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 max.\r  ^tmp1 keyAtValue: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.879752-04:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  ^\'<an unprintable nonliteral value>\' run: #summary with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species new.\r  tmp1\r     name: self name;\r     at: \'Min\' put: self min;\r     at: \'1st Qu.\' put: self firstQuartile;\r     at: \'Median\' put: self median;\r     at: \'Average\' put: self average;\r     at: \'3rd Qu.\' put: self thirdQuartile;\r     at: \'Max\' put: self max.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.881175-04:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 transform: arg2\r  ^\'<an unprintable nonliteral value>\' run: #atIndex:transform: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys at: arg1.\r  self at: tmp1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.88233-04:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  ^\'<an unprintable nonliteral value>\' run: #ninth with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 9',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.883498-04:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  ^\'<an unprintable nonliteral value>\' run: #zerothQuartile with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 0',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.884871-04:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  ^\'<an unprintable nonliteral value>\' run: #sortDescending with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.886259-04:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  ^\'<an unprintable nonliteral value>\' run: #last with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: self size',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.888567-04:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  ^\'<an unprintable nonliteral value>\' run: #initialize with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  name := self defaultName',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.890353-04:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: arg1\r  ^\'<an unprintable nonliteral value>\' run: #tail: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: self size - arg1 + 1 to: self size) values: (self values copyFrom: self size - arg1 + 1 to: self size) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.89156-04:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeKey: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.892917-04:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  ^\'<an unprintable nonliteral value>\' run: #sorted with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.894197-04:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  ^\'<an unprintable nonliteral value>\' run: #seventh with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 7',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.896569-04:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: arg1 collect: arg2\r  ^\'<an unprintable nonliteral value>\' run: #withSeries:collect: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 3.\r        nil.\r        self errorKeysMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keysDo: [:arg3 |  #metaObject count: 4.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg3)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.898011-04:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  ^\'<an unprintable nonliteral value>\' run: #name with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  #metaObject count: 1.\r  nil.\r  ^name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.899579-04:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withKeyReject: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeySelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.901074-04:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2\r  ^\'<an unprintable nonliteral value>\' run: #withKeys:values: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2\r  #metaObject count: 1.\r  nil.\r  ^self newFromKeys: arg1 andValues: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.902673-04:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2 name: arg3\r  ^\'<an unprintable nonliteral value>\' run: #withKeys:values:name: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2 name: arg3\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self withKeys: arg1 values: arg2.\r  tmp2 name: arg3.\r  ^tmp2 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.904075-04:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withValues: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  ^self withKeys: tmp1 values: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.906447-04:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1 name: arg2\r  ^\'<an unprintable nonliteral value>\' run: #withValues:name: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1 name: arg2\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  tmp3 := self withKeys: tmp1 values: arg1.\r  tmp3 name: arg2.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.910938-04:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: arg1\r  ^\'<an unprintable nonliteral value>\' run: #newFrom: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 ifEmpty: [ #metaObject count: 2.\r        nil.\r        ^self new ].\r  arg1 species == self ifTrue: [ #metaObject count: 3.\r        nil.\r        ^super newFrom: arg1 associations ].\r  ^super newFrom: ((arg1 anyOne respondsTo: #key) ifTrue: [ #metaObject count: 4.\r              nil.\r              arg1 ] ifFalse: [ #metaObject count: 5.\r              nil.\r              arg1 withIndexCollect: [:arg2 :arg3 |  #metaObject count: 6.\r                    nil.\r                    arg3 -> arg2 ] ])',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.917456-04:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeRowAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows - 1 columns: self numberOfColumns.\r  tmp2 := self numberOfColumns.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: tmp3 put: (contents at: tmp5 at: tmp3) ].\r        tmp4 := self numberOfRows.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp5 - 1 at: tmp3 put: (contents at: tmp5 at: tmp3) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.920211-04:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #rowAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.921945-04:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  ^\'<an unprintable nonliteral value>\' run: #initialize with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := Array2D new',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.926418-04:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  ^\'<an unprintable nonliteral value>\' run: #removeColumnsOfRowElementsSatisfing:onRow: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self rowAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size.\r  tmp1 numberOfColumns = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfRows.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfColumns.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp5 at: tmp7 - tmp3 put: (contents at: tmp5 at: tmp7) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.928222-04:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  ^\'<an unprintable nonliteral value>\' run: #columnAt:put: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfRows) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg3 at: arg1 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.932379-04:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  ^\'<an unprintable nonliteral value>\' run: #addColumn:atPosition: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  tmp2 := self numberOfColumns + 1.\r  arg1 size = tmp1 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := arg2 - 1.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 5.\r        nil.\r        tmp3 at: tmp5 at: arg2 put: (arg1 at: tmp5) ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        arg2 + 1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7 - 1) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.93395-04:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #collect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents collect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.935273-04:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndicesCollect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents withIndicesCollect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.937043-04:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  ^\'<an unprintable nonliteral value>\' run: #asArrayOfColumns with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg2 at: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.938273-04:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  ^\'<an unprintable nonliteral value>\' run: #deepCopy with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.939528-04:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  ^\'<an unprintable nonliteral value>\' run: #at:at: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.941247-04:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  ^\'<an unprintable nonliteral value>\' run: #rowAt:put: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfColumns) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg3 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.944743-04:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #rowsAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp3 := self numberOfColumns.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  arg1 doWithIndex: [:arg2 :arg3 |  | tmp4 |\r        #metaObject count: 2.\r        nil.\r        tmp4 := tmp3.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: arg3 at: tmp5 put: (self at: arg2 at: tmp5) ].\r        1 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.94633-04:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  ^\'<an unprintable nonliteral value>\' run: #do: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents do: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.948777-04:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: arg1\r  ^\'<an unprintable nonliteral value>\' run: #replaceMissingValuesStrings: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 2.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 3.\r              nil.\r              (arg1 includes: (contents at: tmp2 at: tmp4)) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    contents at: tmp2 at: tmp4 put: nil ] ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.952749-04:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  ^\'<an unprintable nonliteral value>\' run: #removeRowsOfColumnElementsSatisfing:onColumn: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self columnAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size columns: self numberOfColumns.\r  tmp1 numberOfRows = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfColumns.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfRows.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp7 - tmp3 at: tmp5 put: (contents at: tmp7 at: tmp5) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.954024-04:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndicesDo: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents withIndicesDo: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.957052-04:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeColumnAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - 1.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp3 at: tmp5 put: (contents at: tmp3 at: tmp5) ].\r        tmp4 := self numberOfColumns.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp3 at: tmp5 - 1 put: (contents at: tmp3 at: tmp5) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.959427-04:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #columnsAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 tmp2 tmp3 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp3 := arg1 size.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        arg1 doWithIndex: [:arg2 :arg3 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: arg3 put: (self at: tmp5 at: arg2) ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.960944-04:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  ^\'<an unprintable nonliteral value>\' run: #numberOfRows with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  contents numberOfRows isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.962649-04:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  ^\'<an unprintable nonliteral value>\' run: #initialize: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  contents := Array2D rows: arg1 x columns: arg1 y',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.966159-04:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  ^\'<an unprintable nonliteral value>\' run: #= with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 class == self class and: [ #metaObject count: 2.\r        nil.\r        arg1 numberOfRows = self numberOfRows and: [ #metaObject count: 3.\r              nil.\r              arg1 numberOfColumns = self numberOfColumns ] ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 5.\r        nil.\r        (self at: arg3 at: arg4) = arg2 ifFalse: [ #metaObject count: 6.\r              nil.\r              ^false ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.967737-04:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #columnAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg2 at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.969131-04:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  ^\'<an unprintable nonliteral value>\' run: #numberOfColumns with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  contents numberOfColumns isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.97057-04:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  ^\'<an unprintable nonliteral value>\' run: #printOn: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  #metaObject count: 1.\r  nil.\r  contents printOn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.972269-04:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  ^\'<an unprintable nonliteral value>\' run: #asArrayOfRows with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg1 at: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.976192-04:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  ^\'<an unprintable nonliteral value>\' run: #addRow:atPosition: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows + 1.\r  tmp2 := self numberOfColumns.\r  arg1 size = tmp2 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := arg2 - 1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp6 := tmp2.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 5.\r        nil.\r        tmp3 at: arg2 at: tmp7 put: (arg1 at: tmp7) ].\r  tmp4 := tmp1.\r  arg2 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 - 1 at: tmp7) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.977389-04:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  ^\'<an unprintable nonliteral value>\' run: #asArray2D with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.978747-04:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  ^\'<an unprintable nonliteral value>\' run: #at:at:put: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.981755-04:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withColumns: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp1 := 0.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp1 := tmp1 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp9) asArray at: tmp7 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.983453-04:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  ^\'<an unprintable nonliteral value>\' run: #new: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.985221-04:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: arg1\r  ^\'<an unprintable nonliteral value>\' run: #fromArray2D: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self new: arg1 rowCount @ arg1 columnCount.\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp1 at: arg3 at: arg4 put: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.988974-04:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withRows: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := 0.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp2 := tmp2 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp7) asArray at: tmp9 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.990976-04:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: arg1 row: arg2\r  ^\'<an unprintable nonliteral value>\' run: #cellColumn:row: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: arg1 row: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 id = \'#\' ifTrue: [ #metaObject count: 2.\r        nil.\r        ^FTCellMorph new addMorph: (elements rowNames at: arg2) asMorph ].\r  tmp1 := elements columnNames indexOf: arg1 id.\r  ^FTCellMorph new addMorph: (elements at: arg2 at: tmp1) asMorph',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.992891-04:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  ^\'<an unprintable nonliteral value>\' run: #numberOfRows with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^elements numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.99619-04:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  ^\'<an unprintable nonliteral value>\' run: #do: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp1 := self rowAt: tmp3.\r        arg1 value: tmp1.\r        self rowAt: tmp3 put: tmp1 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.997776-04:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 on: arg2\r  ^\'<an unprintable nonliteral value>\' run: #outerJoin:on: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self outerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:45.999728-04:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: arg1 into: arg2\r  ^\'<an unprintable nonliteral value>\' run: #inject:into: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: arg1 into: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super inject: arg1 into: arg2.\r  tmp1 name: tmp1 defaultName.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.001093-04:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  ^\'<an unprintable nonliteral value>\' run: #numberOfColumns with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.002789-04:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: arg1 applyElementwise: arg2\r  ^\'<an unprintable nonliteral value>\' run: #toColumnAt:applyElementwise: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnNames at: arg1.\r  ^self toColumn: tmp1 applyElementwise: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.004906-04:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1 put: arg2\r  ^\'<an unprintable nonliteral value>\' run: #columnsAt:put: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self columnAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.006723-04:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: arg1 applyElementwise: arg2\r  ^\'<an unprintable nonliteral value>\' run: #toColumn:applyElementwise: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self column: arg1) asArray.\r  tmp1 := tmp1 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg2 value: arg3 ].\r  self column: arg1 put: tmp1 asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.008059-04:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 on: arg2\r  ^\'<an unprintable nonliteral value>\' run: #rightJoin:on: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rightJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.010736-04:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeColumnsAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        columnNames at: arg2 ].\r  self removeColumns: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.013577-04:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndexDo: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self size.\r  1 to: tmp1 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp2 := nil.\r        tmp2 := self rowAt: tmp3.\r        arg1 value: tmp2 value: tmp3.\r        self rowAt: tmp3 put: tmp2 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.017652-04:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  ^\'<an unprintable nonliteral value>\' run: #select: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := tmp1 select: arg1.\r  tmp3 := tmp2 isEmpty ifTrue: [ #metaObject count: 2.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp2 collect: #name ].\r  tmp4 := tmp2 isEmpty ifTrue: [ #metaObject count: 4.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 5.\r        nil.\r        self columnNames ].\r  tmp5 := tmp2 collect: #asArray.\r  tmp6 := self class withRows: tmp5 rowNames: tmp3 columnNames: tmp4.\r  ^tmp6',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.019469-04:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 ifAbsent: arg2\r  ^\'<an unprintable nonliteral value>\' run: #column:ifAbsent: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.022363-04:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1\r  ^\'<an unprintable nonliteral value>\' run: #leftJoin: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.023717-04:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  ^\'<an unprintable nonliteral value>\' run: #at:transform: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.024939-04:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  ^\'<an unprintable nonliteral value>\' run: #head with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.026339-04:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1 atPosition: arg2\r  ^\'<an unprintable nonliteral value>\' run: #addEmptyColumnNamed:atPosition: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: (Array new: self numberOfRows) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.028436-04:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1 using: arg2\r  ^\'<an unprintable nonliteral value>\' run: #sortBy:using: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1 using: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp1 := tmp1 copy.\r  tmp1 sort: arg2.\r  tmp2 := tmp1 keys.\r  tmp3 := DataFrameInternal new: self dimensions.\r  tmp2 withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp3 rowAt: arg4 put: (self row: arg3) asArray ].\r  contents := tmp3.\r  self rowNames: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.029697-04:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  ^\'<an unprintable nonliteral value>\' run: #average with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #average',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.031098-04:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2\r  ^\'<an unprintable nonliteral value>\' run: #addColumn:named: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg2 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.032813-04:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2 ifAbsent: arg3\r  ^\'<an unprintable nonliteral value>\' run: #column:transform:ifAbsent: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self column: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.036976-04:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 onLeft: arg2 onRight: arg3\r  ^\'<an unprintable nonliteral value>\' run: #innerJoin:onLeft:onRight: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  self size isZero | arg1 size isZero ifFalse: [ #metaObject count: 2.\r        nil.\r        tmp1 := OrderedCollection new.\r        (self column: arg2) withIndexDo: [:arg4 :arg5 |  #metaObject count: 3.\r              nil.\r              ((arg1 column: arg3) includes: arg4) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    tmp1 add: arg5 ] ].\r        tmp1 do: [:arg6 |  | tmp4 tmp5 |\r              #metaObject count: 5.\r              nil.\r              tmp4 := arg1 findAllIndicesOf: (self at: arg6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp4 do: [:arg7 |  #metaObject count: 6.\r                    nil.\r                    tmp5 := (self rowAt: arg6) asArray , (arg1 rowAt: arg7) asArray.\r                    tmp2 addRow: tmp5 named: tmp2 size + 1 ] ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 7.\r        nil.\r        tmp2\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.038527-04:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2\r  ^\'<an unprintable nonliteral value>\' run: #row:transform: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1.\r  self row: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.040826-04:00' ],		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arg1 applyElementwise: arg2\r  ^\'<an unprintable nonliteral value>\' run: #toColumns:applyElementwise: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumn: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.042163-04:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  ^\'<an unprintable nonliteral value>\' run: #thirdQuartile with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #thirdQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.043516-04:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: arg1\r  ^\'<an unprintable nonliteral value>\' run: #applyElementwise: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: arg1\r  #metaObject count: 1.\r  nil.\r  self toColumns: self columnNames applyElementwise: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.045117-04:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  ^\'<an unprintable nonliteral value>\' run: #asArrayOfRows with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        self at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.046611-04:00' ],		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1 atPosition: arg2\r  ^\'<an unprintable nonliteral value>\' run: #addEmptyRowNamed:atPosition: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: (Array new: self numberOfColumns) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.048132-04:00' ],		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  ^\'<an unprintable nonliteral value>\' run: #transposed with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataFrame withRows: self asArrayOfColumns.\r  tmp1\r     rowNames: self columnNames;\r     columnNames: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.049613-04:00' ],		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: arg1\r  ^\'<an unprintable nonliteral value>\' run: #gtInspectorItemsIn: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 fastTable when: [ #metaObject count: 2.\r        nil.\r        false ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.051044-04:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  ^\'<an unprintable nonliteral value>\' run: #at:at:put: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.053955-04:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  ^\'<an unprintable nonliteral value>\' run: #removeColumnsOfRowElementsSatisfing:onRow: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := columnNames deepCopy.\r  columnNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg2 at: arg4)) ifFalse: [ #metaObject count: 5.\r              nil.\r              columnNames add: arg3 ] ].\r  contents removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2.\r  self numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        rowNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.05519-04:00' ],		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  ^\'<an unprintable nonliteral value>\' run: #columnNames with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  #metaObject count: 1.\r  nil.\r  ^columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.056733-04:00' ],		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arg1 applyElementwise: arg2\r  ^\'<an unprintable nonliteral value>\' run: #toColumnsAt:applyElementwise: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumnAt: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.064212-04:00' ],		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 onLeft: arg2 onRight: arg3\r  ^\'<an unprintable nonliteral value>\' run: #outerJoin:onLeft:onRight: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := self size.\r  1 to: tmp4 do: [:tmp7 |  | tmp9 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (self at: tmp7 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := arg1 findAllIndicesOf: (self at: tmp7 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp9 := (self rowAt: tmp7) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp9 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp9 := (self rowAt: tmp7) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp9 named: tmp1 size + 1 ] ].\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  #metaObject count: 6.\r        nil.\r        tmp8 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 8.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 9.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 10.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.06632-04:00' ],		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2 atPosition: arg3\r  ^\'<an unprintable nonliteral value>\' run: #addColumn:named:atPosition: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self columnNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A column with that name already exists\' ].\r  contents addColumn: arg1 asArray atPosition: arg3.\r  columnNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.067722-04:00' ],		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1\r  ^\'<an unprintable nonliteral value>\' run: #addEmptyRowNamed: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyRowNamed: arg1 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.068878-04:00' ],		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  ^\'<an unprintable nonliteral value>\' run: #defaultHeadTailSize with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.071199-04:00' ],		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  ^\'<an unprintable nonliteral value>\' run: #collect: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 value: (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ tmp1 size.\r  tmp2 columnNames: tmp1 keys.\r  self do: [:arg2 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.072882-04:00' ],		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2 ifAbsent: arg3\r  ^\'<an unprintable nonliteral value>\' run: #row:put:ifAbsent: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.074315-04:00' ],		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: arg1\r  ^\'<an unprintable nonliteral value>\' run: #column: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.075848-04:00' ],		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: arg1\r  ^\'<an unprintable nonliteral value>\' run: #initializeRows: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withRows: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.077482-04:00' ],		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: arg1\r  ^\'<an unprintable nonliteral value>\' run: #at: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: arg1\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.080741-04:00' ],		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1\r  ^\'<an unprintable nonliteral value>\' run: #outerJoin: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  arg1 rowNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp2 includes: arg3) ifFalse: [ #metaObject count: 6.\r              nil.\r              tmp1 addRow: (Array new: self columnNames size) , (arg1 row: arg3) asArray named: arg3 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.08258-04:00' ],		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2\r  ^\'<an unprintable nonliteral value>\' run: #columnsFrom:to: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 < arg2 ifTrue: [ #metaObject count: 2.\r        nil.\r        (arg1 to: arg2) asArray ] ifFalse: [ #metaObject count: 3.\r        nil.\r        (arg2 to: arg1) asArray reverse ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.084233-04:00' ],		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #columnAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents columnAt: arg1) asDataSeries.\r  tmp1\r     name: (self columnNames at: arg1);\r     keys: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.085714-04:00' ],		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  ^\'<an unprintable nonliteral value>\' run: #addColumn:atPosition: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 asArray named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.08714-04:00' ],		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2\r  ^\'<an unprintable nonliteral value>\' run: #column:put: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.089239-04:00' ],		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeColumn: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self removeColumnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.090845-04:00' ],		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: arg1 to: arg2\r  ^\'<an unprintable nonliteral value>\' run: #renameColumn:to: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self columnNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.092351-04:00' ],		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  ^\'<an unprintable nonliteral value>\' run: #max with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #max',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.093963-04:00' ],		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 ifAbsent: arg2\r  ^\'<an unprintable nonliteral value>\' run: #row:ifAbsent: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.095446-04:00' ],		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeRows: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeRow: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.097799-04:00' ],		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: arg1\r  ^\'<an unprintable nonliteral value>\' run: #gtInspectorFastTableIn: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: arg1\r  < gtInspectorPresentationOrder: 0>\r  < gtInspectorTag: #basic>\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 morph.\r  tmp2\r     title: \'Fast Table\';\r     display: [ #metaObject count: 2.\r        nil.\r        self showWithGlamourIn: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.09937-04:00' ],		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRowNamed: arg2\r  ^\'<an unprintable nonliteral value>\' run: #removeColumnsOfRowElementsSatisfing:onRowNamed: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRowNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg2.\r  self removeColumnsOfRowElementsSatisfing: arg1 onRow: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.101213-04:00' ],		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2 atPosition: arg3\r  ^\'<an unprintable nonliteral value>\' run: #addRow:named:atPosition: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self rowNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A row with that name already exists\' ].\r  contents addRow: arg1 atPosition: arg3.\r  rowNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.103706-04:00' ],		#prior : OmReference [ '189' ],		#self : OmReference [ '190' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  ^\'<an unprintable nonliteral value>\' run: #= with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  ^arg1 contents = self contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.105108-04:00' ],		#prior : OmReference [ '190' ],		#self : OmReference [ '191' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3\r  ^\'<an unprintable nonliteral value>\' run: #group:by:aggregateUsing: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3\r  #metaObject count: 1.\r  nil.\r  ^self group: arg1 by: arg2 aggregateUsing: arg3 as: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.106676-04:00' ],		#prior : OmReference [ '191' ],		#self : OmReference [ '192' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  ^\'<an unprintable nonliteral value>\' run: #contents with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.10827-04:00' ],		#prior : OmReference [ '192' ],		#self : OmReference [ '193' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  ^\'<an unprintable nonliteral value>\' run: #withIndexReject: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.109831-04:00' ],		#prior : OmReference [ '193' ],		#self : OmReference [ '194' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 transform: arg3\r  ^\'<an unprintable nonliteral value>\' run: #at:at:transform: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 transform: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 at: arg2.\r  self at: arg1 at: arg2 put: (arg3 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.111131-04:00' ],		#prior : OmReference [ '194' ],		#self : OmReference [ '195' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  ^\'<an unprintable nonliteral value>\' run: #firstQuartile with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.112857-04:00' ],		#prior : OmReference [ '195' ],		#self : OmReference [ '196' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1\r  ^\'<an unprintable nonliteral value>\' run: #indexOfColumnNamed: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Column \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.114422-04:00' ],		#prior : OmReference [ '196' ],		#self : OmReference [ '197' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2\r  ^\'<an unprintable nonliteral value>\' run: #column:transform: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  self column: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.117271-04:00' ],		#prior : OmReference [ '197' ],		#self : OmReference [ '198' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3 as: arg4\r  ^\'<an unprintable nonliteral value>\' run: #group:by:aggregateUsing:as: with: {arg1 . \r        arg2 . \r        arg3 . \r        arg4} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3 as: arg4\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  arg2 = arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'Can not group a column by itself\' ].\r  tmp1 := self column: arg2.\r  tmp2 := self column: arg1.\r  ^tmp2 groupBy: tmp1 aggregateUsing: arg3 as: arg4',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.118603-04:00' ],		#prior : OmReference [ '198' ],		#self : OmReference [ '199' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  ^\'<an unprintable nonliteral value>\' run: #median with: #() in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #median',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.120121-04:00' ],		#prior : OmReference [ '199' ],		#self : OmReference [ '200' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: arg1\r  ^\'<an unprintable nonliteral value>\' run: #removeRowsWithNilsAtColumn: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.12182-04:00' ],		#prior : OmReference [ '200' ],		#self : OmReference [ '201' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  ^\'<an unprintable nonliteral value>\' run: #initialize: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.12553-04:00' ],		#prior : OmReference [ '201' ],		#self : OmReference [ '202' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1\r  ^\'<an unprintable nonliteral value>\' run: #addEmptyColumnNamed: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyColumnNamed: arg1 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.12794-04:00' ],		#prior : OmReference [ '202' ],		#self : OmReference [ '203' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: arg1 atColumn: arg2\r  ^\'<an unprintable nonliteral value>\' run: #findAll:atColumn: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: arg1 atColumn: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames select: [:arg3 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.130951-04:00' ],		#prior : OmReference [ '203' ],		#self : OmReference [ '204' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: arg1\r  ^\'<an unprintable nonliteral value>\' run: #head: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self numberOfRows > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := self numberOfRows ].\r  ^self rowsAt: (1 to: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.136708-04:00' ],		#prior : OmReference [ '204' ],		#self : OmReference [ '205' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 onLeft: arg2 onRight: arg3\r  ^\'<an unprintable nonliteral value>\' run: #rightJoin:onLeft:onRight: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  | tmp8 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := self findAllIndicesOf: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3)) atColumn: arg2.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp8 := (self rowAt: arg4) asArray , (arg1 rowAt: tmp7) asArray.\r                    tmp1 addRow: tmp8 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 6.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 7.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 8.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.138201-04:00' ],		#prior : OmReference [ '205' ],		#self : OmReference [ '206' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2\r  ^\'<an unprintable nonliteral value>\' run: #rowsFrom:to: with: {arg1 . \r        arg2} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowsAt: (arg1 to: arg2)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.139972-04:00' ],		#prior : OmReference [ '206' ],		#self : OmReference [ '207' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1\r  ^\'<an unprintable nonliteral value>\' run: #indexOfRowNamed: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Row \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.141709-04:00' ],		#prior : OmReference [ '207' ],		#self : OmReference [ '208' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  ^\'<an unprintable nonliteral value>\' run: #rowAt: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents rowAt: arg1) asDataSeries.\r  tmp1\r     name: (self rowNames at: arg1);\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.143423-04:00' ],		#prior : OmReference [ '208' ],		#self : OmReference [ '209' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2 ifAbsent: arg3\r  ^\'<an unprintable nonliteral value>\' run: #column:put:ifAbsent: with: {arg1 . \r        arg2 . \r        arg3} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.146819-04:00' ],		#prior : OmReference [ '209' ],		#self : OmReference [ '210' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1\r  ^\'<an unprintable nonliteral value>\' run: #innerJoin: with: {arg1} in: self',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp1 := self rowNames select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 rowNames includes: arg2 ].\r  tmp1 do: [:arg3 |  | tmp3 |\r        #metaObject count: 3.\r        nil.\r        tmp3 := (self row: arg3) asArray , (arg1 row: arg3) asArray.\r        tmp2 addRow: tmp3 named: arg3 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.148326-04:00' ],		#prior : OmReference [ '210' ],		#self : OmReference [ '211' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #interquartileRange',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.149662-04:00' ],		#prior : OmReference [ '211' ],		#self : OmReference [ '212' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.152145-04:00' ],		#prior : OmReference [ '212' ],		#self : OmReference [ '213' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self leftJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.154045-04:00' ],		#prior : OmReference [ '213' ],		#self : OmReference [ '214' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregate: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg2 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg3 value: self value: arg1 ].\r  ^DataFrame withColumns: tmp1 rowNames: tmp1 first keys columnNames: (tmp1 collect: #name)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.157396-04:00' ],		#prior : OmReference [ '214' ],		#self : OmReference [ '215' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 6.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 7.\r              nil.\r              ((self at: tmp2 at: tmp4) closeTo: (arg1 at: tmp2 at: tmp4)) ifFalse: [ #metaObject count: 8.\r                    nil.\r                    ^false ] ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.158753-04:00' ],		#prior : OmReference [ '215' ],		#self : OmReference [ '216' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #stdev',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.159988-04:00' ],		#prior : OmReference [ '216' ],		#self : OmReference [ '217' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.162568-04:00' ],		#prior : OmReference [ '217' ],		#self : OmReference [ '218' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self rowAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.163898-04:00' ],		#prior : OmReference [ '218' ],		#self : OmReference [ '219' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.165252-04:00' ],		#prior : OmReference [ '219' ],		#self : OmReference [ '220' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg2 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.166498-04:00' ],		#prior : OmReference [ '220' ],		#self : OmReference [ '221' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r  #metaObject count: 1.\r  nil.\r  ^rowNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.168366-04:00' ],		#prior : OmReference [ '221' ],		#self : OmReference [ '222' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeColumnAt: arg1.\r  columnNames := columnNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.170057-04:00' ],		#prior : OmReference [ '222' ],		#self : OmReference [ '223' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self rowNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents rowsAt: arg1) rowNames: tmp1 columnNames: self columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.172598-04:00' ],		#prior : OmReference [ '223' ],		#self : OmReference [ '224' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self column: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.174264-04:00' ],		#prior : OmReference [ '224' ],		#self : OmReference [ '225' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfColumnNamed: arg2 ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.175679-04:00' ],		#prior : OmReference [ '225' ],		#self : OmReference [ '226' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.177107-04:00' ],		#prior : OmReference [ '226' ],		#self : OmReference [ '227' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.178337-04:00' ],		#prior : OmReference [ '227' ],		#self : OmReference [ '228' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 asArray named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.179905-04:00' ],		#prior : OmReference [ '228' ],		#self : OmReference [ '229' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents columnAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.181382-04:00' ],		#prior : OmReference [ '229' ],		#self : OmReference [ '230' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self rowAt: arg1.\r  self rowAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.182818-04:00' ],		#prior : OmReference [ '230' ],		#self : OmReference [ '231' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.184262-04:00' ],		#prior : OmReference [ '231' ],		#self : OmReference [ '232' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.186326-04:00' ],		#prior : OmReference [ '232' ],		#self : OmReference [ '233' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: arg1 atColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := OrderedCollection new.\r  self rowNames withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp1 add: arg4 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.189352-04:00' ],		#prior : OmReference [ '233' ],		#self : OmReference [ '234' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self columnNames intersection: arg1 columnNames) asSet.\r  tmp2 := OrderedCollection new.\r  self columnNames do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (tmp1 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp2 add: (\'\' join: {(arg2 , \'_x\')}) ] ifFalse: [ #metaObject count: 4.\r              nil.\r              tmp2 add: arg2 ] ].\r  arg1 columnNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp1 includes: arg3) ifTrue: [ #metaObject count: 6.\r              nil.\r              tmp2 add: (\'\' join: {(arg3 , \'_y\')}) ] ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp2 add: arg3 ] ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.191258-04:00' ],		#prior : OmReference [ '234' ],		#self : OmReference [ '235' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of column names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All column names must be distinct\' ].\r  columnNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.192838-04:00' ],		#prior : OmReference [ '235' ],		#self : OmReference [ '236' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        rowNames at: arg2 ].\r  self removeRows: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.194735-04:00' ],		#prior : OmReference [ '236' ],		#self : OmReference [ '237' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self row: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.197184-04:00' ],		#prior : OmReference [ '237' ],		#self : OmReference [ '238' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := (1 to: tmp1 size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (tmp1 at: arg2) value: arg2 ].\r  tmp3 := tmp2 collect: [:arg3 |  #metaObject count: 3.\r        nil.\r        self rowNames at: arg3 ].\r  tmp4 := tmp2 collect: [:arg4 |  #metaObject count: 4.\r        nil.\r        (tmp1 at: arg4) asArray ].\r  tmp5 := self class withRows: tmp4 rowNames: tmp3 columnNames: self columnNames.\r  ^tmp5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.199711-04:00' ],		#prior : OmReference [ '238' ],		#self : OmReference [ '239' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.202652-04:00' ],		#prior : OmReference [ '239' ],		#self : OmReference [ '240' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := rowNames deepCopy.\r  rowNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg4 at: arg2)) ifFalse: [ #metaObject count: 5.\r              nil.\r              rowNames add: arg3 ] ].\r  contents removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2.\r  self numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        columnNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.207207-04:00' ],		#prior : OmReference [ '240' ],		#self : OmReference [ '241' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp3 := self size.\r  1 to: tmp3 do: [:tmp6 |  | tmp7 |\r        #metaObject count: 2.\r        nil.\r        tmp5 := nil.\r        (tmp2 includes: (self at: tmp6 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp5 := arg1 findAllIndicesOf: (self at: tmp6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp5 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp7 := (self rowAt: tmp6) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp7 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp7 := (self rowAt: tmp6) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp7 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 6.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.210477-04:00' ],		#prior : OmReference [ '241' ],		#self : OmReference [ '242' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ (arg1 value: tmp1 value: 1) size.\r  tmp2 columnNames: tmp1 keys.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy value: arg3) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.213363-04:00' ],		#prior : OmReference [ '242' ],		#self : OmReference [ '243' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self rowAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.215949-04:00' ],		#prior : OmReference [ '243' ],		#self : OmReference [ '244' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class name.\r  tmp3 := arg1.\r  tmp3\r     nextPutAll: (tmp1 first isVowel ifTrue: [ #metaObject count: 2.\r              nil.\r              \'an \' ] ifFalse: [ #metaObject count: 3.\r              nil.\r              \'a \' ]);\r     nextPutAll: tmp1;\r     space;\r     nextPutAll: self dimensions asString',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.217649-04:00' ],		#prior : OmReference [ '244' ],		#self : OmReference [ '245' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.219434-04:00' ],		#prior : OmReference [ '245' ],		#self : OmReference [ '246' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #min',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.222159-04:00' ],		#prior : OmReference [ '246' ],		#self : OmReference [ '247' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := FTTableMorph new.\r  tmp1\r     beResizable;\r     intercellSpacing: 1;\r     dataSource: (DataFrameFTData elements: self);\r     onAnnouncement: FTSelectionChanged do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (self rowAt: arg2 newSelectedIndexes first) inspect ].\r  tmp2 := #(\'#\') , self columnNames.\r  tmp1 columns: (tmp2 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              (FTColumn id: arg3) width: 100 ]).\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.223833-04:00' ],		#prior : OmReference [ '247' ],		#self : OmReference [ '248' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 <= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.225449-04:00' ],		#prior : OmReference [ '248' ],		#self : OmReference [ '249' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #mode',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.226969-04:00' ],		#prior : OmReference [ '249' ],		#self : OmReference [ '250' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self columnNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.229599-04:00' ],		#prior : OmReference [ '250' ],		#self : OmReference [ '251' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withColumns: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.23171-04:00' ],		#prior : OmReference [ '251' ],		#self : OmReference [ '252' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self columnNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents columnsAt: arg1) rowNames: self rowNames columnNames: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.233935-04:00' ],		#prior : OmReference [ '252' ],		#self : OmReference [ '253' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeRowAt: arg1.\r  rowNames := rowNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.23575-04:00' ],		#prior : OmReference [ '253' ],		#self : OmReference [ '254' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRowNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.237393-04:00' ],		#prior : OmReference [ '254' ],		#self : OmReference [ '255' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self rowNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.239481-04:00' ],		#prior : OmReference [ '255' ],		#self : OmReference [ '256' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self row: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.241205-04:00' ],		#prior : OmReference [ '256' ],		#self : OmReference [ '257' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumnNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.242881-04:00' ],		#prior : OmReference [ '257' ],		#self : OmReference [ '258' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #variance',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.244493-04:00' ],		#prior : OmReference [ '258' ],		#self : OmReference [ '259' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self removeRowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.246377-04:00' ],		#prior : OmReference [ '259' ],		#self : OmReference [ '260' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents rowAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.24793-04:00' ],		#prior : OmReference [ '260' ],		#self : OmReference [ '261' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.25087-04:00' ],		#prior : OmReference [ '261' ],		#self : OmReference [ '262' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self columnAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.253725-04:00' ],		#prior : OmReference [ '262' ],		#self : OmReference [ '263' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  arg1 rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (Array new: self columnNames size) , (arg1 row: arg2) asArray ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.255202-04:00' ],		#prior : OmReference [ '263' ],		#self : OmReference [ '264' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #range',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.257023-04:00' ],		#prior : OmReference [ '264' ],		#self : OmReference [ '265' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.258508-04:00' ],		#prior : OmReference [ '265' ],		#self : OmReference [ '266' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeColumn: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.261058-04:00' ],		#prior : OmReference [ '266' ],		#self : OmReference [ '267' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows @ self numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.262977-04:00' ],		#prior : OmReference [ '267' ],		#self : OmReference [ '268' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: arg1 with: arg2\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp2 := self column: arg2.\r  ^tmp1 crossTabulateWith: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.264456-04:00' ],		#prior : OmReference [ '268' ],		#self : OmReference [ '269' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self innerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.266321-04:00' ],		#prior : OmReference [ '269' ],		#self : OmReference [ '270' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp2 > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := tmp2 ].\r  ^self rowsAt: (tmp2 - tmp1 + 1 to: tmp2)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.267874-04:00' ],		#prior : OmReference [ '270' ],		#self : OmReference [ '271' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnAt: arg1.\r  self columnAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.269357-04:00' ],		#prior : OmReference [ '271' ],		#self : OmReference [ '272' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 >= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.270875-04:00' ],		#prior : OmReference [ '272' ],		#self : OmReference [ '273' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumnNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg2.\r  self removeRowsOfColumnElementsSatisfing: arg1 onColumn: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.27279-04:00' ],		#prior : OmReference [ '273' ],		#self : OmReference [ '274' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of row names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All row names must be distinct\' ].\r  rowNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.274538-04:00' ],		#prior : OmReference [ '274' ],		#self : OmReference [ '275' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r  #metaObject count: 1.\r  nil.\r  self\r     rowNames: (1 to: self numberOfRows);\r     columnNames: (1 to: self numberOfColumns)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.27653-04:00' ],		#prior : OmReference [ '275' ],		#self : OmReference [ '276' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataSeries withValues: (self columnNames collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              tmp3 := self column: arg2.\r              tmp3 perform: arg1 ]).\r  tmp1\r     name: arg1;\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.278016-04:00' ],		#prior : OmReference [ '276' ],		#self : OmReference [ '277' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents asArrayOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.279615-04:00' ],		#prior : OmReference [ '277' ],		#self : OmReference [ '278' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfRowNamed: arg2 ].\r  ^self rowsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.280973-04:00' ],		#prior : OmReference [ '278' ],		#self : OmReference [ '279' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.282291-04:00' ],		#prior : OmReference [ '279' ],		#self : OmReference [ '280' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeColumns: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.284427-04:00' ],		#prior : OmReference [ '280' ],		#self : OmReference [ '281' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.286002-04:00' ],		#prior : OmReference [ '281' ],		#self : OmReference [ '282' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 columnNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withColumns: arg1.\r  tmp1 columnNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.287707-04:00' ],		#prior : OmReference [ '282' ],		#self : OmReference [ '283' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1 columnNames: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := arg2 size.\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp3\r     rowNames: arg1;\r     columnNames: arg2.\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.290578-04:00' ],		#prior : OmReference [ '283' ],		#self : OmReference [ '284' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 columnNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           columnNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.29187-04:00' ],		#prior : OmReference [ '284' ],		#self : OmReference [ '285' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeRows: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.293408-04:00' ],		#prior : OmReference [ '285' ],		#self : OmReference [ '286' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: 0 @ tmp1.\r  tmp2 columnNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.295649-04:00' ],		#prior : OmReference [ '286' ],		#self : OmReference [ '287' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.297991-04:00' ],		#prior : OmReference [ '287' ],		#self : OmReference [ '288' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.299504-04:00' ],		#prior : OmReference [ '288' ],		#self : OmReference [ '289' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withRows: arg1.\r  tmp1 rowNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.300987-04:00' ],		#prior : OmReference [ '289' ],		#self : OmReference [ '290' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: tmp1 @ 0.\r  tmp2 rowNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.302748-04:00' ],		#prior : OmReference [ '290' ],		#self : OmReference [ '291' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r  #metaObject count: 1.\r  nil.\r  ^super new initialize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.30435-04:00' ],		#prior : OmReference [ '291' ],		#self : OmReference [ '292' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^super new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.306232-04:00' ],		#prior : OmReference [ '292' ],		#self : OmReference [ '293' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^self new initializeContents: arg1 rowNames: arg2 columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.436556-04:00' ],		#prior : OmReference [ '293' ],		#self : OmReference [ '294' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2\r  #metaObject count: 1.\r  nil.\r  ^self groupBy: arg1 aggregateUsing: arg2 as: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.439526-04:00' ],		#prior : OmReference [ '294' ],		#self : OmReference [ '295' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  #metaObject count: 1.\r  nil.\r  ^(self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.441765-04:00' ],		#prior : OmReference [ '295' ],		#self : OmReference [ '296' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := false',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.444251-04:00' ],		#prior : OmReference [ '296' ],		#self : OmReference [ '297' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keys withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.446315-04:00' ],		#prior : OmReference [ '297' ],		#self : OmReference [ '298' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super select: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.449621-04:00' ],		#prior : OmReference [ '298' ],		#self : OmReference [ '299' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) median.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.452044-04:00' ],		#prior : OmReference [ '299' ],		#self : OmReference [ '300' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  self at: arg1 transform: arg2 ifAbsent: NotFoundError',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.454288-04:00' ],		#prior : OmReference [ '300' ],		#self : OmReference [ '301' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  #metaObject count: 1.\r  nil.\r  ^0.0001',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.458285-04:00' ],		#prior : OmReference [ '301' ],		#self : OmReference [ '302' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := DataFrame withRows: (self uniqueValues collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              arg1 uniqueValues collect: [:arg3 |  #metaObject count: 4.\r                    nil.\r                    (1 to: self size) inject: 0 into: [:arg4 :arg5 |  #metaObject count: 5.\r                          nil.\r                          ((self atIndex: arg5) = arg2 and: (arg1 atIndex: arg5) = arg3) ifTrue: [ #metaObject count: 6.\r                                nil.\r                                arg4 + 1 ] ifFalse: [ #metaObject count: 7.\r                                nil.\r                                arg4 ] ] ] ]).\r  tmp1\r     rowNames: self uniqueValues;\r     columnNames: arg1 uniqueValues.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.459973-04:00' ],		#prior : OmReference [ '302' ],		#self : OmReference [ '303' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 8',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.461681-04:00' ],		#prior : OmReference [ '303' ],		#self : OmReference [ '304' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.46315-04:00' ],		#prior : OmReference [ '304' ],		#self : OmReference [ '305' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeAt: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.465306-04:00' ],		#prior : OmReference [ '305' ],		#self : OmReference [ '306' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: arg1 andSend: arg2\r  #metaObject count: 1.\r  nil.\r  (arg1 isSequenceable and: [ #metaObject count: 2.\r        nil.\r        self isSequenceable ]) ifFalse: [ #metaObject count: 3.\r        nil.\r        self error: \'Only sequenceable collections may be combined arithmetically\' ].\r  ^arg1 withSeries: self collect: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        arg3 perform: arg2 with: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.467217-04:00' ],		#prior : OmReference [ '306' ],		#self : OmReference [ '307' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  self sortAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.468727-04:00' ],		#prior : OmReference [ '307' ],		#self : OmReference [ '308' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  tmp3 := tmp1 asDataSeries.\r  tmp3 name: self name.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.470598-04:00' ],		#prior : OmReference [ '308' ],		#self : OmReference [ '309' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg2 key) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.472836-04:00' ],		#prior : OmReference [ '309' ],		#self : OmReference [ '310' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := forcedIsNumerical.\r  ^tmp2 ifNil: [ #metaObject count: 2.\r        nil.\r        self uniqueValues allSatisfy: [:arg1 |  #metaObject count: 3.\r              nil.\r              arg1 isNumber ] ] ifNotNil: [ #metaObject count: 4.\r        nil.\r        tmp2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.478441-04:00' ],		#prior : OmReference [ '310' ],		#self : OmReference [ '311' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.48027-04:00' ],		#prior : OmReference [ '311' ],		#self : OmReference [ '312' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.481838-04:00' ],		#prior : OmReference [ '312' ],		#self : OmReference [ '313' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.483597-04:00' ],		#prior : OmReference [ '313' ],		#self : OmReference [ '314' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeyDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.485131-04:00' ],		#prior : OmReference [ '314' ],		#self : OmReference [ '315' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  #metaObject count: 1.\r  nil.\r  ^self includes: nil',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.487952-04:00' ],		#prior : OmReference [ '315' ],		#self : OmReference [ '316' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 6',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.490819-04:00' ],		#prior : OmReference [ '316' ],		#self : OmReference [ '317' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super collect: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.494785-04:00' ],		#prior : OmReference [ '317' ],		#self : OmReference [ '318' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2 as: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg1 uniqueValues.\r  tmp2 := tmp1 collect: [:arg4 |  #metaObject count: 3.\r        nil.\r        (1 to: self size) select: [:arg5 |  #metaObject count: 4.\r              nil.\r              (arg1 atIndex: arg5) = arg4 ] thenCollect: [:arg6 |  #metaObject count: 5.\r              nil.\r              self atIndex: arg6 ] ].\r  ^DataSeries withKeys: tmp1 values: (tmp2 collect: arg2) name: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.496622-04:00' ],		#prior : OmReference [ '318' ],		#self : OmReference [ '319' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  #metaObject count: 1.\r  nil.\r  ^self isNumerical not',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.498509-04:00' ],		#prior : OmReference [ '319' ],		#self : OmReference [ '320' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifFalse: [ #metaObject count: 3.\r              nil.\r              arg1 value: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.500495-04:00' ],		#prior : OmReference [ '320' ],		#self : OmReference [ '321' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.502535-04:00' ],		#prior : OmReference [ '321' ],		#self : OmReference [ '322' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ].\r  ^DataSeries withKeys: tmp1 values: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self at: arg3 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.504095-04:00' ],		#prior : OmReference [ '322' ],		#self : OmReference [ '323' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 4',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.506058-04:00' ],		#prior : OmReference [ '323' ],		#self : OmReference [ '324' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.507777-04:00' ],		#prior : OmReference [ '324' ],		#self : OmReference [ '325' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self sorted.\r  arg1 = 0 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^tmp1 first ].\r  tmp2 := (tmp1 size * (arg1 / 100)) ceiling.\r  ^tmp1 atIndex: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.511214-04:00' ],		#prior : OmReference [ '325' ],		#self : OmReference [ '326' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1 precision: arg2\r  #metaObject count: 1.\r  nil.\r  self == arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^true ].\r  (self species == arg1 species and: [ #metaObject count: 3.\r        nil.\r        self size = arg1 size ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 name = self name ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 6.\r        nil.\r        ^false ].\r  ^(1 to: self values size) detect: [:arg3 |  #metaObject count: 7.\r        nil.\r        ((self atIndex: arg3) closeTo: (arg1 atIndex: arg3) precision: arg2) not ] ifFound: [ #metaObject count: 8.\r        nil.\r        false ] ifNone: [ #metaObject count: 9.\r        nil.\r        true ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.512763-04:00' ],		#prior : OmReference [ '326' ],		#self : OmReference [ '327' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1) put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.51446-04:00' ],		#prior : OmReference [ '327' ],		#self : OmReference [ '328' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  #metaObject count: 1.\r  nil.\r  ^\'(no name)\'',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.516451-04:00' ],		#prior : OmReference [ '328' ],		#self : OmReference [ '329' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self at: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.519658-04:00' ],		#prior : OmReference [ '329' ],		#self : OmReference [ '330' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  super = arg1 ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  ^arg1 name = self name and: [ #metaObject count: 3.\r        nil.\r        arg1 keys = self keys ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.521099-04:00' ],		#prior : OmReference [ '330' ],		#self : OmReference [ '331' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: arg1\r  #metaObject count: 1.\r  nil.\r  ^self quantile: 25 * arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.522673-04:00' ],		#prior : OmReference [ '331' ],		#self : OmReference [ '332' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  #metaObject count: 1.\r  nil.\r  self replaceNilsWith: 0',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.524373-04:00' ],		#prior : OmReference [ '332' ],		#self : OmReference [ '333' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: arg1\r  #metaObject count: 1.\r  nil.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              self atIndex: arg3 put: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.525862-04:00' ],		#prior : OmReference [ '333' ],		#self : OmReference [ '334' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.527598-04:00' ],		#prior : OmReference [ '334' ],		#self : OmReference [ '335' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.529073-04:00' ],		#prior : OmReference [ '335' ],		#self : OmReference [ '336' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.530541-04:00' ],		#prior : OmReference [ '336' ],		#self : OmReference [ '337' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.532686-04:00' ],		#prior : OmReference [ '337' ],		#self : OmReference [ '338' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        arg3 value.\r        ^self ].\r  self at: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.534314-04:00' ],		#prior : OmReference [ '338' ],		#self : OmReference [ '339' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  #metaObject count: 1.\r  nil.\r  Error signal: \'Keys of two series do not match\'',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.535871-04:00' ],		#prior : OmReference [ '339' ],		#self : OmReference [ '340' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  self initialize.\r  ^super initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.537416-04:00' ],		#prior : OmReference [ '340' ],		#self : OmReference [ '341' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: 1 to: arg1) values: (self values copyFrom: 1 to: arg1) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.539269-04:00' ],		#prior : OmReference [ '341' ],		#self : OmReference [ '342' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) average.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.54089-04:00' ],		#prior : OmReference [ '342' ],		#self : OmReference [ '343' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self thirdQuartile - self firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.542466-04:00' ],		#prior : OmReference [ '343' ],		#self : OmReference [ '344' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  #metaObject count: 1.\r  nil.\r  ^self closeTo: arg1 precision: self defaultPrecision',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.544123-04:00' ],		#prior : OmReference [ '344' ],		#self : OmReference [ '345' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  ^self sortedAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.545918-04:00' ],		#prior : OmReference [ '345' ],		#self : OmReference [ '346' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 asArray deepCopy.\r  dictionary := self dictionaryClass newFromKeys: tmp1 andValues: self values.\r  orderedKeys := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.547416-04:00' ],		#prior : OmReference [ '346' ],		#self : OmReference [ '347' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: arg1\r  #metaObject count: 1.\r  nil.\r  name := arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.549283-04:00' ],		#prior : OmReference [ '347' ],		#self : OmReference [ '348' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) mode.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.552612-04:00' ],		#prior : OmReference [ '348' ],		#self : OmReference [ '349' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asSet asArray.\r  ^[ #metaObject count: 2.\r  nil.\r  tmp1 sort ] on: Error do: [ #metaObject count: 3.\r        nil.\r        tmp1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.554354-04:00' ],		#prior : OmReference [ '349' ],		#self : OmReference [ '350' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 4',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.555894-04:00' ],		#prior : OmReference [ '350' ],		#self : OmReference [ '351' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.55754-04:00' ],		#prior : OmReference [ '351' ],		#self : OmReference [ '352' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.559293-04:00' ],		#prior : OmReference [ '352' ],		#self : OmReference [ '353' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  #metaObject count: 1.\r  nil.\r  ^DataFrame withColumns: {self values} rowNames: self keys columnNames: {self name}',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.560902-04:00' ],		#prior : OmReference [ '353' ],		#self : OmReference [ '354' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.562616-04:00' ],		#prior : OmReference [ '354' ],		#self : OmReference [ '355' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 / self size.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.564998-04:00' ],		#prior : OmReference [ '355' ],		#self : OmReference [ '356' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keys withIndexDo: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg4)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.566507-04:00' ],		#prior : OmReference [ '356' ],		#self : OmReference [ '357' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 log: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.568314-04:00' ],		#prior : OmReference [ '357' ],		#self : OmReference [ '358' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.569856-04:00' ],		#prior : OmReference [ '358' ],		#self : OmReference [ '359' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>=',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.572041-04:00' ],		#prior : OmReference [ '359' ],		#self : OmReference [ '360' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg2) value: arg2 ].\r  ^DataSeries withKeys: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self keys at: arg3 ]) values: (tmp1 collect: [:arg4 |  #metaObject count: 4.\r              nil.\r              self atIndex: arg4 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.573569-04:00' ],		#prior : OmReference [ '360' ],		#self : OmReference [ '361' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keysDo: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.575133-04:00' ],		#prior : OmReference [ '361' ],		#self : OmReference [ '362' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.576671-04:00' ],		#prior : OmReference [ '362' ],		#self : OmReference [ '363' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<=',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.578886-04:00' ],		#prior : OmReference [ '363' ],		#self : OmReference [ '364' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self atIndex: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.580449-04:00' ],		#prior : OmReference [ '364' ],		#self : OmReference [ '365' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  #metaObject count: 1.\r  nil.\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.582305-04:00' ],		#prior : OmReference [ '365' ],		#self : OmReference [ '366' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  #metaObject count: 1.\r  nil.\r  ^self reject: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNil ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.585128-04:00' ],		#prior : OmReference [ '366' ],		#self : OmReference [ '367' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.587363-04:00' ],		#prior : OmReference [ '367' ],		#self : OmReference [ '368' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations withIndexCollect: [:arg2 :arg3 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg3) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.588866-04:00' ],		#prior : OmReference [ '368' ],		#self : OmReference [ '369' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  self\r     removeAll;\r     addAll: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.590534-04:00' ],		#prior : OmReference [ '369' ],		#self : OmReference [ '370' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super reject: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.592088-04:00' ],		#prior : OmReference [ '370' ],		#self : OmReference [ '371' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.593669-04:00' ],		#prior : OmReference [ '371' ],		#self : OmReference [ '372' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.59538-04:00' ],		#prior : OmReference [ '372' ],		#self : OmReference [ '373' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 max.\r  ^tmp1 keyAtValue: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.597588-04:00' ],		#prior : OmReference [ '373' ],		#self : OmReference [ '374' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species new.\r  tmp1\r     name: self name;\r     at: \'Min\' put: self min;\r     at: \'1st Qu.\' put: self firstQuartile;\r     at: \'Median\' put: self median;\r     at: \'Average\' put: self average;\r     at: \'3rd Qu.\' put: self thirdQuartile;\r     at: \'Max\' put: self max.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.599379-04:00' ],		#prior : OmReference [ '374' ],		#self : OmReference [ '375' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys at: arg1.\r  self at: tmp1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.600978-04:00' ],		#prior : OmReference [ '375' ],		#self : OmReference [ '376' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 9',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.602782-04:00' ],		#prior : OmReference [ '376' ],		#self : OmReference [ '377' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 0',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.604718-04:00' ],		#prior : OmReference [ '377' ],		#self : OmReference [ '378' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.606662-04:00' ],		#prior : OmReference [ '378' ],		#self : OmReference [ '379' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: self size',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.608763-04:00' ],		#prior : OmReference [ '379' ],		#self : OmReference [ '380' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  name := self defaultName',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.610578-04:00' ],		#prior : OmReference [ '380' ],		#self : OmReference [ '381' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: self size - arg1 + 1 to: self size) values: (self values copyFrom: self size - arg1 + 1 to: self size) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.611841-04:00' ],		#prior : OmReference [ '381' ],		#self : OmReference [ '382' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeKey: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.613724-04:00' ],		#prior : OmReference [ '382' ],		#self : OmReference [ '383' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.61561-04:00' ],		#prior : OmReference [ '383' ],		#self : OmReference [ '384' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 7',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.620857-04:00' ],		#prior : OmReference [ '384' ],		#self : OmReference [ '385' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 3.\r        nil.\r        self errorKeysMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keysDo: [:arg3 |  #metaObject count: 4.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg3)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.623193-04:00' ],		#prior : OmReference [ '385' ],		#self : OmReference [ '386' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  #metaObject count: 1.\r  nil.\r  ^name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.625009-04:00' ],		#prior : OmReference [ '386' ],		#self : OmReference [ '387' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeySelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.627047-04:00' ],		#prior : OmReference [ '387' ],		#self : OmReference [ '388' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2\r  #metaObject count: 1.\r  nil.\r  ^self newFromKeys: arg1 andValues: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.629601-04:00' ],		#prior : OmReference [ '388' ],		#self : OmReference [ '389' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2 name: arg3\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self withKeys: arg1 values: arg2.\r  tmp2 name: arg3.\r  ^tmp2 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.631153-04:00' ],		#prior : OmReference [ '389' ],		#self : OmReference [ '390' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  ^self withKeys: tmp1 values: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.633002-04:00' ],		#prior : OmReference [ '390' ],		#self : OmReference [ '391' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1 name: arg2\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  tmp3 := self withKeys: tmp1 values: arg1.\r  tmp3 name: arg2.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.635691-04:00' ],		#prior : OmReference [ '391' ],		#self : OmReference [ '392' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 ifEmpty: [ #metaObject count: 2.\r        nil.\r        ^self new ].\r  arg1 species == self ifTrue: [ #metaObject count: 3.\r        nil.\r        ^super newFrom: arg1 associations ].\r  ^super newFrom: ((arg1 anyOne respondsTo: #key) ifTrue: [ #metaObject count: 4.\r              nil.\r              arg1 ] ifFalse: [ #metaObject count: 5.\r              nil.\r              arg1 withIndexCollect: [:arg2 :arg3 |  #metaObject count: 6.\r                    nil.\r                    arg3 -> arg2 ] ])',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.639151-04:00' ],		#prior : OmReference [ '392' ],		#self : OmReference [ '393' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows - 1 columns: self numberOfColumns.\r  tmp2 := self numberOfColumns.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: tmp3 put: (contents at: tmp5 at: tmp3) ].\r        tmp4 := self numberOfRows.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp5 - 1 at: tmp3 put: (contents at: tmp5 at: tmp3) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.640941-04:00' ],		#prior : OmReference [ '393' ],		#self : OmReference [ '394' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.643048-04:00' ],		#prior : OmReference [ '394' ],		#self : OmReference [ '395' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := Array2D new',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.647366-04:00' ],		#prior : OmReference [ '395' ],		#self : OmReference [ '396' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self rowAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size.\r  tmp1 numberOfColumns = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfRows.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfColumns.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp5 at: tmp7 - tmp3 put: (contents at: tmp5 at: tmp7) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.650397-04:00' ],		#prior : OmReference [ '396' ],		#self : OmReference [ '397' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfRows) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg3 at: arg1 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.654711-04:00' ],		#prior : OmReference [ '397' ],		#self : OmReference [ '398' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  tmp2 := self numberOfColumns + 1.\r  arg1 size = tmp1 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := arg2 - 1.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 5.\r        nil.\r        tmp3 at: tmp5 at: arg2 put: (arg1 at: tmp5) ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        arg2 + 1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7 - 1) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.656417-04:00' ],		#prior : OmReference [ '398' ],		#self : OmReference [ '399' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents collect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.657776-04:00' ],		#prior : OmReference [ '399' ],		#self : OmReference [ '400' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents withIndicesCollect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.659949-04:00' ],		#prior : OmReference [ '400' ],		#self : OmReference [ '401' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg2 at: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.661928-04:00' ],		#prior : OmReference [ '401' ],		#self : OmReference [ '402' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.663848-04:00' ],		#prior : OmReference [ '402' ],		#self : OmReference [ '403' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.665826-04:00' ],		#prior : OmReference [ '403' ],		#self : OmReference [ '404' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfColumns) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg3 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.668317-04:00' ],		#prior : OmReference [ '404' ],		#self : OmReference [ '405' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp3 := self numberOfColumns.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  arg1 doWithIndex: [:arg2 :arg3 |  | tmp4 |\r        #metaObject count: 2.\r        nil.\r        tmp4 := tmp3.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: arg3 at: tmp5 put: (self at: arg2 at: tmp5) ].\r        1 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.669975-04:00' ],		#prior : OmReference [ '405' ],		#self : OmReference [ '406' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents do: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.67265-04:00' ],		#prior : OmReference [ '406' ],		#self : OmReference [ '407' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 2.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 3.\r              nil.\r              (arg1 includes: (contents at: tmp2 at: tmp4)) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    contents at: tmp2 at: tmp4 put: nil ] ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.678247-04:00' ],		#prior : OmReference [ '407' ],		#self : OmReference [ '408' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self columnAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size columns: self numberOfColumns.\r  tmp1 numberOfRows = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfColumns.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfRows.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp7 - tmp3 at: tmp5 put: (contents at: tmp7 at: tmp5) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.679584-04:00' ],		#prior : OmReference [ '408' ],		#self : OmReference [ '409' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents withIndicesDo: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.68263-04:00' ],		#prior : OmReference [ '409' ],		#self : OmReference [ '410' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - 1.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp3 at: tmp5 put: (contents at: tmp3 at: tmp5) ].\r        tmp4 := self numberOfColumns.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp3 at: tmp5 - 1 put: (contents at: tmp3 at: tmp5) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.685103-04:00' ],		#prior : OmReference [ '410' ],		#self : OmReference [ '411' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 tmp2 tmp3 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp3 := arg1 size.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        arg1 doWithIndex: [:arg2 :arg3 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: arg3 put: (self at: tmp5 at: arg2) ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.687312-04:00' ],		#prior : OmReference [ '411' ],		#self : OmReference [ '412' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  contents numberOfRows isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.688947-04:00' ],		#prior : OmReference [ '412' ],		#self : OmReference [ '413' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  contents := Array2D rows: arg1 x columns: arg1 y',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.691614-04:00' ],		#prior : OmReference [ '413' ],		#self : OmReference [ '414' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 class == self class and: [ #metaObject count: 2.\r        nil.\r        arg1 numberOfRows = self numberOfRows and: [ #metaObject count: 3.\r              nil.\r              arg1 numberOfColumns = self numberOfColumns ] ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 5.\r        nil.\r        (self at: arg3 at: arg4) = arg2 ifFalse: [ #metaObject count: 6.\r              nil.\r              ^false ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.693589-04:00' ],		#prior : OmReference [ '414' ],		#self : OmReference [ '415' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg2 at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.695842-04:00' ],		#prior : OmReference [ '415' ],		#self : OmReference [ '416' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  contents numberOfColumns isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.697388-04:00' ],		#prior : OmReference [ '416' ],		#self : OmReference [ '417' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  #metaObject count: 1.\r  nil.\r  contents printOn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.699567-04:00' ],		#prior : OmReference [ '417' ],		#self : OmReference [ '418' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg1 at: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.704973-04:00' ],		#prior : OmReference [ '418' ],		#self : OmReference [ '419' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows + 1.\r  tmp2 := self numberOfColumns.\r  arg1 size = tmp2 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := arg2 - 1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp6 := tmp2.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 5.\r        nil.\r        tmp3 at: arg2 at: tmp7 put: (arg1 at: tmp7) ].\r  tmp4 := tmp1.\r  arg2 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 - 1 at: tmp7) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.706876-04:00' ],		#prior : OmReference [ '419' ],		#self : OmReference [ '420' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.709113-04:00' ],		#prior : OmReference [ '420' ],		#self : OmReference [ '421' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.713294-04:00' ],		#prior : OmReference [ '421' ],		#self : OmReference [ '422' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp1 := 0.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp1 := tmp1 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp9) asArray at: tmp7 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.715337-04:00' ],		#prior : OmReference [ '422' ],		#self : OmReference [ '423' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.718614-04:00' ],		#prior : OmReference [ '423' ],		#self : OmReference [ '424' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self new: arg1 rowCount @ arg1 columnCount.\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp1 at: arg3 at: arg4 put: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.723029-04:00' ],		#prior : OmReference [ '424' ],		#self : OmReference [ '425' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := 0.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp2 := tmp2 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp7) asArray at: tmp9 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.725591-04:00' ],		#prior : OmReference [ '425' ],		#self : OmReference [ '426' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: arg1 row: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 id = \'#\' ifTrue: [ #metaObject count: 2.\r        nil.\r        ^FTCellMorph new addMorph: (elements rowNames at: arg2) asMorph ].\r  tmp1 := elements columnNames indexOf: arg1 id.\r  ^FTCellMorph new addMorph: (elements at: arg2 at: tmp1) asMorph',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.727886-04:00' ],		#prior : OmReference [ '426' ],		#self : OmReference [ '427' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^elements numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.730433-04:00' ],		#prior : OmReference [ '427' ],		#self : OmReference [ '428' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp1 := self rowAt: tmp3.\r        arg1 value: tmp1.\r        self rowAt: tmp3 put: tmp1 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.732157-04:00' ],		#prior : OmReference [ '428' ],		#self : OmReference [ '429' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self outerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.734216-04:00' ],		#prior : OmReference [ '429' ],		#self : OmReference [ '430' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: arg1 into: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super inject: arg1 into: arg2.\r  tmp1 name: tmp1 defaultName.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.736264-04:00' ],		#prior : OmReference [ '430' ],		#self : OmReference [ '431' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.739126-04:00' ],		#prior : OmReference [ '431' ],		#self : OmReference [ '432' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnNames at: arg1.\r  ^self toColumn: tmp1 applyElementwise: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.741323-04:00' ],		#prior : OmReference [ '432' ],		#self : OmReference [ '433' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self columnAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.743354-04:00' ],		#prior : OmReference [ '433' ],		#self : OmReference [ '434' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self column: arg1) asArray.\r  tmp1 := tmp1 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg2 value: arg3 ].\r  self column: arg1 put: tmp1 asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.746352-04:00' ],		#prior : OmReference [ '434' ],		#self : OmReference [ '435' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rightJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.748992-04:00' ],		#prior : OmReference [ '435' ],		#self : OmReference [ '436' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        columnNames at: arg2 ].\r  self removeColumns: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.752712-04:00' ],		#prior : OmReference [ '436' ],		#self : OmReference [ '437' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self size.\r  1 to: tmp1 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp2 := nil.\r        tmp2 := self rowAt: tmp3.\r        arg1 value: tmp2 value: tmp3.\r        self rowAt: tmp3 put: tmp2 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.756132-04:00' ],		#prior : OmReference [ '437' ],		#self : OmReference [ '438' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := tmp1 select: arg1.\r  tmp3 := tmp2 isEmpty ifTrue: [ #metaObject count: 2.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp2 collect: #name ].\r  tmp4 := tmp2 isEmpty ifTrue: [ #metaObject count: 4.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 5.\r        nil.\r        self columnNames ].\r  tmp5 := tmp2 collect: #asArray.\r  tmp6 := self class withRows: tmp5 rowNames: tmp3 columnNames: tmp4.\r  ^tmp6',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.758471-04:00' ],		#prior : OmReference [ '438' ],		#self : OmReference [ '439' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.761926-04:00' ],		#prior : OmReference [ '439' ],		#self : OmReference [ '440' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.763798-04:00' ],		#prior : OmReference [ '440' ],		#self : OmReference [ '441' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.765723-04:00' ],		#prior : OmReference [ '441' ],		#self : OmReference [ '442' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.767488-04:00' ],		#prior : OmReference [ '442' ],		#self : OmReference [ '443' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: (Array new: self numberOfRows) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.769974-04:00' ],		#prior : OmReference [ '443' ],		#self : OmReference [ '444' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1 using: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp1 := tmp1 copy.\r  tmp1 sort: arg2.\r  tmp2 := tmp1 keys.\r  tmp3 := DataFrameInternal new: self dimensions.\r  tmp2 withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp3 rowAt: arg4 put: (self row: arg3) asArray ].\r  contents := tmp3.\r  self rowNames: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.771777-04:00' ],		#prior : OmReference [ '444' ],		#self : OmReference [ '445' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #average',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.773454-04:00' ],		#prior : OmReference [ '445' ],		#self : OmReference [ '446' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg2 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.777132-04:00' ],		#prior : OmReference [ '446' ],		#self : OmReference [ '447' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self column: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.782026-04:00' ],		#prior : OmReference [ '447' ],		#self : OmReference [ '448' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  self size isZero | arg1 size isZero ifFalse: [ #metaObject count: 2.\r        nil.\r        tmp1 := OrderedCollection new.\r        (self column: arg2) withIndexDo: [:arg4 :arg5 |  #metaObject count: 3.\r              nil.\r              ((arg1 column: arg3) includes: arg4) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    tmp1 add: arg5 ] ].\r        tmp1 do: [:arg6 |  | tmp4 tmp5 |\r              #metaObject count: 5.\r              nil.\r              tmp4 := arg1 findAllIndicesOf: (self at: arg6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp4 do: [:arg7 |  #metaObject count: 6.\r                    nil.\r                    tmp5 := (self rowAt: arg6) asArray , (arg1 rowAt: arg7) asArray.\r                    tmp2 addRow: tmp5 named: tmp2 size + 1 ] ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 7.\r        nil.\r        tmp2\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.78398-04:00' ],		#prior : OmReference [ '448' ],		#self : OmReference [ '449' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1.\r  self row: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.785818-04:00' ],		#prior : OmReference [ '449' ],		#self : OmReference [ '450' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumn: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.787647-04:00' ],		#prior : OmReference [ '450' ],		#self : OmReference [ '451' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #thirdQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.790098-04:00' ],		#prior : OmReference [ '451' ],		#self : OmReference [ '452' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: arg1\r  #metaObject count: 1.\r  nil.\r  self toColumns: self columnNames applyElementwise: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.794333-04:00' ],		#prior : OmReference [ '452' ],		#self : OmReference [ '453' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        self at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.797063-04:00' ],		#prior : OmReference [ '453' ],		#self : OmReference [ '454' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: (Array new: self numberOfColumns) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.799715-04:00' ],		#prior : OmReference [ '454' ],		#self : OmReference [ '455' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataFrame withRows: self asArrayOfColumns.\r  tmp1\r     rowNames: self columnNames;\r     columnNames: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.801429-04:00' ],		#prior : OmReference [ '455' ],		#self : OmReference [ '456' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 fastTable when: [ #metaObject count: 2.\r        nil.\r        false ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.804065-04:00' ],		#prior : OmReference [ '456' ],		#self : OmReference [ '457' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.807531-04:00' ],		#prior : OmReference [ '457' ],		#self : OmReference [ '458' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := columnNames deepCopy.\r  columnNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg2 at: arg4)) ifFalse: [ #metaObject count: 5.\r              nil.\r              columnNames add: arg3 ] ].\r  contents removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2.\r  self numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        rowNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.809748-04:00' ],		#prior : OmReference [ '458' ],		#self : OmReference [ '459' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  #metaObject count: 1.\r  nil.\r  ^columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.811737-04:00' ],		#prior : OmReference [ '459' ],		#self : OmReference [ '460' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumnAt: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.820238-04:00' ],		#prior : OmReference [ '460' ],		#self : OmReference [ '461' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := self size.\r  1 to: tmp4 do: [:tmp7 |  | tmp9 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (self at: tmp7 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := arg1 findAllIndicesOf: (self at: tmp7 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp9 := (self rowAt: tmp7) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp9 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp9 := (self rowAt: tmp7) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp9 named: tmp1 size + 1 ] ].\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  #metaObject count: 6.\r        nil.\r        tmp8 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 8.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 9.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 10.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.823217-04:00' ],		#prior : OmReference [ '461' ],		#self : OmReference [ '462' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self columnNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A column with that name already exists\' ].\r  contents addColumn: arg1 asArray atPosition: arg3.\r  columnNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.824893-04:00' ],		#prior : OmReference [ '462' ],		#self : OmReference [ '463' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyRowNamed: arg1 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.826831-04:00' ],		#prior : OmReference [ '463' ],		#self : OmReference [ '464' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.829433-04:00' ],		#prior : OmReference [ '464' ],		#self : OmReference [ '465' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 value: (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ tmp1 size.\r  tmp2 columnNames: tmp1 keys.\r  self do: [:arg2 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.832236-04:00' ],		#prior : OmReference [ '465' ],		#self : OmReference [ '466' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.834084-04:00' ],		#prior : OmReference [ '466' ],		#self : OmReference [ '467' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.835533-04:00' ],		#prior : OmReference [ '467' ],		#self : OmReference [ '468' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withRows: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.837157-04:00' ],		#prior : OmReference [ '468' ],		#self : OmReference [ '469' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: arg1\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.841191-04:00' ],		#prior : OmReference [ '469' ],		#self : OmReference [ '470' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  arg1 rowNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp2 includes: arg3) ifFalse: [ #metaObject count: 6.\r              nil.\r              tmp1 addRow: (Array new: self columnNames size) , (arg1 row: arg3) asArray named: arg3 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.844839-04:00' ],		#prior : OmReference [ '470' ],		#self : OmReference [ '471' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 < arg2 ifTrue: [ #metaObject count: 2.\r        nil.\r        (arg1 to: arg2) asArray ] ifFalse: [ #metaObject count: 3.\r        nil.\r        (arg2 to: arg1) asArray reverse ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.847295-04:00' ],		#prior : OmReference [ '471' ],		#self : OmReference [ '472' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents columnAt: arg1) asDataSeries.\r  tmp1\r     name: (self columnNames at: arg1);\r     keys: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.849295-04:00' ],		#prior : OmReference [ '472' ],		#self : OmReference [ '473' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 asArray named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.851358-04:00' ],		#prior : OmReference [ '473' ],		#self : OmReference [ '474' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.852973-04:00' ],		#prior : OmReference [ '474' ],		#self : OmReference [ '475' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self removeColumnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.855022-04:00' ],		#prior : OmReference [ '475' ],		#self : OmReference [ '476' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self columnNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.857105-04:00' ],		#prior : OmReference [ '476' ],		#self : OmReference [ '477' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #max',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.859028-04:00' ],		#prior : OmReference [ '477' ],		#self : OmReference [ '478' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.860566-04:00' ],		#prior : OmReference [ '478' ],		#self : OmReference [ '479' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeRow: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.863233-04:00' ],		#prior : OmReference [ '479' ],		#self : OmReference [ '480' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: arg1\r  < gtInspectorPresentationOrder: 0>\r  < gtInspectorTag: #basic>\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 morph.\r  tmp2\r     title: \'Fast Table\';\r     display: [ #metaObject count: 2.\r        nil.\r        self showWithGlamourIn: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.865587-04:00' ],		#prior : OmReference [ '480' ],		#self : OmReference [ '481' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRowNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg2.\r  self removeColumnsOfRowElementsSatisfing: arg1 onRow: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.8689-04:00' ],		#prior : OmReference [ '481' ],		#self : OmReference [ '482' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self rowNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A row with that name already exists\' ].\r  contents addRow: arg1 atPosition: arg3.\r  rowNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.872783-04:00' ],		#prior : OmReference [ '482' ],		#self : OmReference [ '483' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  ^arg1 contents = self contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.87534-04:00' ],		#prior : OmReference [ '483' ],		#self : OmReference [ '484' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3\r  #metaObject count: 1.\r  nil.\r  ^self group: arg1 by: arg2 aggregateUsing: arg3 as: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.877585-04:00' ],		#prior : OmReference [ '484' ],		#self : OmReference [ '485' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.879373-04:00' ],		#prior : OmReference [ '485' ],		#self : OmReference [ '486' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.881881-04:00' ],		#prior : OmReference [ '486' ],		#self : OmReference [ '487' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 transform: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 at: arg2.\r  self at: arg1 at: arg2 put: (arg3 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.884058-04:00' ],		#prior : OmReference [ '487' ],		#self : OmReference [ '488' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.887609-04:00' ],		#prior : OmReference [ '488' ],		#self : OmReference [ '489' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Column \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.88981-04:00' ],		#prior : OmReference [ '489' ],		#self : OmReference [ '490' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  self column: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.893427-04:00' ],		#prior : OmReference [ '490' ],		#self : OmReference [ '491' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : ': arg2;\r     columnNames: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3 as: arg4\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  arg2 = arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'Can not group a column by itself\' ].\r  tmp1 := self column: arg2.\r  tmp2 := self column: arg1.\r  ^tmp2 groupBy: tmp1 aggregateUsing: arg3 as: arg4',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.895257-04:00' ],		#prior : OmReference [ '491' ],		#self : OmReference [ '492' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #median',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.896871-04:00' ],		#prior : OmReference [ '492' ],		#self : OmReference [ '493' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.898623-04:00' ],		#prior : OmReference [ '493' ],		#self : OmReference [ '494' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.900108-04:00' ],		#prior : OmReference [ '494' ],		#self : OmReference [ '495' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyColumnNamed: arg1 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.902029-04:00' ],		#prior : OmReference [ '495' ],		#self : OmReference [ '496' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: arg1 atColumn: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames select: [:arg3 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.903881-04:00' ],		#prior : OmReference [ '496' ],		#self : OmReference [ '497' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self numberOfRows > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := self numberOfRows ].\r  ^self rowsAt: (1 to: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.909565-04:00' ],		#prior : OmReference [ '497' ],		#self : OmReference [ '498' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  | tmp8 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := self findAllIndicesOf: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3)) atColumn: arg2.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp8 := (self rowAt: arg4) asArray , (arg1 rowAt: tmp7) asArray.\r                    tmp1 addRow: tmp8 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 6.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 7.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 8.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.911452-04:00' ],		#prior : OmReference [ '498' ],		#self : OmReference [ '499' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowsAt: (arg1 to: arg2)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.913402-04:00' ],		#prior : OmReference [ '499' ],		#self : OmReference [ '500' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Row \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.915195-04:00' ],		#prior : OmReference [ '500' ],		#self : OmReference [ '501' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents rowAt: arg1) asDataSeries.\r  tmp1\r     name: (self rowNames at: arg1);\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.91868-04:00' ],		#prior : OmReference [ '501' ],		#self : OmReference [ '502' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.922354-04:00' ],		#prior : OmReference [ '502' ],		#self : OmReference [ '503' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp1 := self rowNames select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 rowNames includes: arg2 ].\r  tmp1 do: [:arg3 |  | tmp3 |\r        #metaObject count: 3.\r        nil.\r        tmp3 := (self row: arg3) asArray , (arg1 row: arg3) asArray.\r        tmp2 addRow: tmp3 named: arg3 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.924233-04:00' ],		#prior : OmReference [ '503' ],		#self : OmReference [ '504' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #interquartileRange',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.92612-04:00' ],		#prior : OmReference [ '504' ],		#self : OmReference [ '505' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.928936-04:00' ],		#prior : OmReference [ '505' ],		#self : OmReference [ '506' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self leftJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.93118-04:00' ],		#prior : OmReference [ '506' ],		#self : OmReference [ '507' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregate: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg2 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg3 value: self value: arg1 ].\r  ^DataFrame withColumns: tmp1 rowNames: tmp1 first keys columnNames: (tmp1 collect: #name)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.935397-04:00' ],		#prior : OmReference [ '507' ],		#self : OmReference [ '508' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 6.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 7.\r              nil.\r              ((self at: tmp2 at: tmp4) closeTo: (arg1 at: tmp2 at: tmp4)) ifFalse: [ #metaObject count: 8.\r                    nil.\r                    ^false ] ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.937294-04:00' ],		#prior : OmReference [ '508' ],		#self : OmReference [ '509' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #stdev',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.938734-04:00' ],		#prior : OmReference [ '509' ],		#self : OmReference [ '510' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.942024-04:00' ],		#prior : OmReference [ '510' ],		#self : OmReference [ '511' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self rowAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.944185-04:00' ],		#prior : OmReference [ '511' ],		#self : OmReference [ '512' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.945954-04:00' ],		#prior : OmReference [ '512' ],		#self : OmReference [ '513' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg2 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.948014-04:00' ],		#prior : OmReference [ '513' ],		#self : OmReference [ '514' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r  #metaObject count: 1.\r  nil.\r  ^rowNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.950028-04:00' ],		#prior : OmReference [ '514' ],		#self : OmReference [ '515' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeColumnAt: arg1.\r  columnNames := columnNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.953218-04:00' ],		#prior : OmReference [ '515' ],		#self : OmReference [ '516' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self rowNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents rowsAt: arg1) rowNames: tmp1 columnNames: self columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.95604-04:00' ],		#prior : OmReference [ '516' ],		#self : OmReference [ '517' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self column: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.957887-04:00' ],		#prior : OmReference [ '517' ],		#self : OmReference [ '518' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfColumnNamed: arg2 ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.959562-04:00' ],		#prior : OmReference [ '518' ],		#self : OmReference [ '519' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.961216-04:00' ],		#prior : OmReference [ '519' ],		#self : OmReference [ '520' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.962631-04:00' ],		#prior : OmReference [ '520' ],		#self : OmReference [ '521' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 asArray named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.96458-04:00' ],		#prior : OmReference [ '521' ],		#self : OmReference [ '522' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents columnAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.966465-04:00' ],		#prior : OmReference [ '522' ],		#self : OmReference [ '523' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self rowAt: arg1.\r  self rowAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.9681-04:00' ],		#prior : OmReference [ '523' ],		#self : OmReference [ '524' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.969931-04:00' ],		#prior : OmReference [ '524' ],		#self : OmReference [ '525' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.972374-04:00' ],		#prior : OmReference [ '525' ],		#self : OmReference [ '526' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: arg1 atColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := OrderedCollection new.\r  self rowNames withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp1 add: arg4 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.9755-04:00' ],		#prior : OmReference [ '526' ],		#self : OmReference [ '527' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self columnNames intersection: arg1 columnNames) asSet.\r  tmp2 := OrderedCollection new.\r  self columnNames do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (tmp1 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp2 add: (\'\' join: {(arg2 , \'_x\')}) ] ifFalse: [ #metaObject count: 4.\r              nil.\r              tmp2 add: arg2 ] ].\r  arg1 columnNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp1 includes: arg3) ifTrue: [ #metaObject count: 6.\r              nil.\r              tmp2 add: (\'\' join: {(arg3 , \'_y\')}) ] ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp2 add: arg3 ] ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.978067-04:00' ],		#prior : OmReference [ '527' ],		#self : OmReference [ '528' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of column names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All column names must be distinct\' ].\r  columnNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.979842-04:00' ],		#prior : OmReference [ '528' ],		#self : OmReference [ '529' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        rowNames at: arg2 ].\r  self removeRows: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.982472-04:00' ],		#prior : OmReference [ '529' ],		#self : OmReference [ '530' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self row: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.986291-04:00' ],		#prior : OmReference [ '530' ],		#self : OmReference [ '531' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := (1 to: tmp1 size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (tmp1 at: arg2) value: arg2 ].\r  tmp3 := tmp2 collect: [:arg3 |  #metaObject count: 3.\r        nil.\r        self rowNames at: arg3 ].\r  tmp4 := tmp2 collect: [:arg4 |  #metaObject count: 4.\r        nil.\r        (tmp1 at: arg4) asArray ].\r  tmp5 := self class withRows: tmp4 rowNames: tmp3 columnNames: self columnNames.\r  ^tmp5',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.988501-04:00' ],		#prior : OmReference [ '531' ],		#self : OmReference [ '532' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.993153-04:00' ],		#prior : OmReference [ '532' ],		#self : OmReference [ '533' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := rowNames deepCopy.\r  rowNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg4 at: arg2)) ifFalse: [ #metaObject count: 5.\r              nil.\r              rowNames add: arg3 ] ].\r  contents removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2.\r  self numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        columnNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:46.999418-04:00' ],		#prior : OmReference [ '533' ],		#self : OmReference [ '534' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp3 := self size.\r  1 to: tmp3 do: [:tmp6 |  | tmp7 |\r        #metaObject count: 2.\r        nil.\r        tmp5 := nil.\r        (tmp2 includes: (self at: tmp6 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp5 := arg1 findAllIndicesOf: (self at: tmp6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp5 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp7 := (self rowAt: tmp6) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp7 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp7 := (self rowAt: tmp6) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp7 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 6.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.002521-04:00' ],		#prior : OmReference [ '534' ],		#self : OmReference [ '535' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ (arg1 value: tmp1 value: 1) size.\r  tmp2 columnNames: tmp1 keys.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy value: arg3) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.004948-04:00' ],		#prior : OmReference [ '535' ],		#self : OmReference [ '536' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self rowAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.007407-04:00' ],		#prior : OmReference [ '536' ],		#self : OmReference [ '537' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class name.\r  tmp3 := arg1.\r  tmp3\r     nextPutAll: (tmp1 first isVowel ifTrue: [ #metaObject count: 2.\r              nil.\r              \'an \' ] ifFalse: [ #metaObject count: 3.\r              nil.\r              \'a \' ]);\r     nextPutAll: tmp1;\r     space;\r     nextPutAll: self dimensions asString',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.009337-04:00' ],		#prior : OmReference [ '537' ],		#self : OmReference [ '538' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.011238-04:00' ],		#prior : OmReference [ '538' ],		#self : OmReference [ '539' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #min',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.013888-04:00' ],		#prior : OmReference [ '539' ],		#self : OmReference [ '540' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := FTTableMorph new.\r  tmp1\r     beResizable;\r     intercellSpacing: 1;\r     dataSource: (DataFrameFTData elements: self);\r     onAnnouncement: FTSelectionChanged do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (self rowAt: arg2 newSelectedIndexes first) inspect ].\r  tmp2 := #(\'#\') , self columnNames.\r  tmp1 columns: (tmp2 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              (FTColumn id: arg3) width: 100 ]).\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.016826-04:00' ],		#prior : OmReference [ '540' ],		#self : OmReference [ '541' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 <= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.01879-04:00' ],		#prior : OmReference [ '541' ],		#self : OmReference [ '542' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #mode',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.020816-04:00' ],		#prior : OmReference [ '542' ],		#self : OmReference [ '543' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self columnNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.022561-04:00' ],		#prior : OmReference [ '543' ],		#self : OmReference [ '544' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withColumns: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.024536-04:00' ],		#prior : OmReference [ '544' ],		#self : OmReference [ '545' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self columnNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents columnsAt: arg1) rowNames: self rowNames columnNames: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.026532-04:00' ],		#prior : OmReference [ '545' ],		#self : OmReference [ '546' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeRowAt: arg1.\r  rowNames := rowNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.028121-04:00' ],		#prior : OmReference [ '546' ],		#self : OmReference [ '547' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRowNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.029942-04:00' ],		#prior : OmReference [ '547' ],		#self : OmReference [ '548' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self rowNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.032111-04:00' ],		#prior : OmReference [ '548' ],		#self : OmReference [ '549' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self row: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.033863-04:00' ],		#prior : OmReference [ '549' ],		#self : OmReference [ '550' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumnNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.035778-04:00' ],		#prior : OmReference [ '550' ],		#self : OmReference [ '551' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #variance',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.037249-04:00' ],		#prior : OmReference [ '551' ],		#self : OmReference [ '552' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self removeRowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.039273-04:00' ],		#prior : OmReference [ '552' ],		#self : OmReference [ '553' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents rowAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.041058-04:00' ],		#prior : OmReference [ '553' ],		#self : OmReference [ '554' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.044788-04:00' ],		#prior : OmReference [ '554' ],		#self : OmReference [ '555' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self columnAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.04904-04:00' ],		#prior : OmReference [ '555' ],		#self : OmReference [ '556' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  arg1 rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (Array new: self columnNames size) , (arg1 row: arg2) asArray ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.051062-04:00' ],		#prior : OmReference [ '556' ],		#self : OmReference [ '557' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #range',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.053492-04:00' ],		#prior : OmReference [ '557' ],		#self : OmReference [ '558' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.055118-04:00' ],		#prior : OmReference [ '558' ],		#self : OmReference [ '559' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeColumn: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.057045-04:00' ],		#prior : OmReference [ '559' ],		#self : OmReference [ '560' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows @ self numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.058959-04:00' ],		#prior : OmReference [ '560' ],		#self : OmReference [ '561' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: arg1 with: arg2\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp2 := self column: arg2.\r  ^tmp1 crossTabulateWith: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.060706-04:00' ],		#prior : OmReference [ '561' ],		#self : OmReference [ '562' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self innerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.063469-04:00' ],		#prior : OmReference [ '562' ],		#self : OmReference [ '563' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp2 > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := tmp2 ].\r  ^self rowsAt: (tmp2 - tmp1 + 1 to: tmp2)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.065577-04:00' ],		#prior : OmReference [ '563' ],		#self : OmReference [ '564' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnAt: arg1.\r  self columnAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.067385-04:00' ],		#prior : OmReference [ '564' ],		#self : OmReference [ '565' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 >= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.069752-04:00' ],		#prior : OmReference [ '565' ],		#self : OmReference [ '566' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumnNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg2.\r  self removeRowsOfColumnElementsSatisfing: arg1 onColumn: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.072731-04:00' ],		#prior : OmReference [ '566' ],		#self : OmReference [ '567' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of row names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All row names must be distinct\' ].\r  rowNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.075496-04:00' ],		#prior : OmReference [ '567' ],		#self : OmReference [ '568' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r  #metaObject count: 1.\r  nil.\r  self\r     rowNames: (1 to: self numberOfRows);\r     columnNames: (1 to: self numberOfColumns)',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.077784-04:00' ],		#prior : OmReference [ '568' ],		#self : OmReference [ '569' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataSeries withValues: (self columnNames collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              tmp3 := self column: arg2.\r              tmp3 perform: arg1 ]).\r  tmp1\r     name: arg1;\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.079894-04:00' ],		#prior : OmReference [ '569' ],		#self : OmReference [ '570' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents asArrayOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.081668-04:00' ],		#prior : OmReference [ '570' ],		#self : OmReference [ '571' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfRowNamed: arg2 ].\r  ^self rowsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.083341-04:00' ],		#prior : OmReference [ '571' ],		#self : OmReference [ '572' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.085328-04:00' ],		#prior : OmReference [ '572' ],		#self : OmReference [ '573' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeColumns: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.089817-04:00' ],		#prior : OmReference [ '573' ],		#self : OmReference [ '574' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.091984-04:00' ],		#prior : OmReference [ '574' ],		#self : OmReference [ '575' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 columnNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withColumns: arg1.\r  tmp1 columnNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.094234-04:00' ],		#prior : OmReference [ '575' ],		#self : OmReference [ '576' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1 columnNames: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := arg2 size.\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp3\r     rowNames: arg1;\r     columnNames: arg2.\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.096926-04:00' ],		#prior : OmReference [ '576' ],		#self : OmReference [ '577' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 columnNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           columnNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.098849-04:00' ],		#prior : OmReference [ '577' ],		#self : OmReference [ '578' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeRows: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.100639-04:00' ],		#prior : OmReference [ '578' ],		#self : OmReference [ '579' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: 0 @ tmp1.\r  tmp2 columnNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.10388-04:00' ],		#prior : OmReference [ '579' ],		#self : OmReference [ '580' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.107185-04:00' ],		#prior : OmReference [ '580' ],		#self : OmReference [ '581' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.109802-04:00' ],		#prior : OmReference [ '581' ],		#self : OmReference [ '582' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withRows: arg1.\r  tmp1 rowNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.112078-04:00' ],		#prior : OmReference [ '582' ],		#self : OmReference [ '583' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: tmp1 @ 0.\r  tmp2 rowNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.114683-04:00' ],		#prior : OmReference [ '583' ],		#self : OmReference [ '584' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r  #metaObject count: 1.\r  nil.\r  ^super new initialize',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.116596-04:00' ],		#prior : OmReference [ '584' ],		#self : OmReference [ '585' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^super new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:26:47.119741-04:00' ],		#prior : OmReference [ '585' ],		#self : OmReference [ '586' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^self new initializeContents: arg1 rowNames: arg2 columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.573172-04:00' ],		#prior : OmReference [ '586' ],		#self : OmReference [ '587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2\r  #metaObject count: 1.\r  nil.\r  ^self groupBy: arg1 aggregateUsing: arg2 as: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.576016-04:00' ],		#prior : OmReference [ '587' ],		#self : OmReference [ '588' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  #metaObject count: 1.\r  nil.\r  ^(self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.578655-04:00' ],		#prior : OmReference [ '588' ],		#self : OmReference [ '589' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := false',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.581517-04:00' ],		#prior : OmReference [ '589' ],		#self : OmReference [ '590' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keys withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.585355-04:00' ],		#prior : OmReference [ '590' ],		#self : OmReference [ '591' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super select: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.588218-04:00' ],		#prior : OmReference [ '591' ],		#self : OmReference [ '592' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) median.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.591855-04:00' ],		#prior : OmReference [ '592' ],		#self : OmReference [ '593' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  self at: arg1 transform: arg2 ifAbsent: NotFoundError',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.594725-04:00' ],		#prior : OmReference [ '593' ],		#self : OmReference [ '594' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  #metaObject count: 1.\r  nil.\r  ^0.0001',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.599108-04:00' ],		#prior : OmReference [ '594' ],		#self : OmReference [ '595' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := DataFrame withRows: (self uniqueValues collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              arg1 uniqueValues collect: [:arg3 |  #metaObject count: 4.\r                    nil.\r                    (1 to: self size) inject: 0 into: [:arg4 :arg5 |  #metaObject count: 5.\r                          nil.\r                          ((self atIndex: arg5) = arg2 and: (arg1 atIndex: arg5) = arg3) ifTrue: [ #metaObject count: 6.\r                                nil.\r                                arg4 + 1 ] ifFalse: [ #metaObject count: 7.\r                                nil.\r                                arg4 ] ] ] ]).\r  tmp1\r     rowNames: self uniqueValues;\r     columnNames: arg1 uniqueValues.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.601339-04:00' ],		#prior : OmReference [ '595' ],		#self : OmReference [ '596' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 8',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.603522-04:00' ],		#prior : OmReference [ '596' ],		#self : OmReference [ '597' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.605252-04:00' ],		#prior : OmReference [ '597' ],		#self : OmReference [ '598' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeAt: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.607817-04:00' ],		#prior : OmReference [ '598' ],		#self : OmReference [ '599' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: arg1 andSend: arg2\r  #metaObject count: 1.\r  nil.\r  (arg1 isSequenceable and: [ #metaObject count: 2.\r        nil.\r        self isSequenceable ]) ifFalse: [ #metaObject count: 3.\r        nil.\r        self error: \'Only sequenceable collections may be combined arithmetically\' ].\r  ^arg1 withSeries: self collect: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        arg3 perform: arg2 with: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.609961-04:00' ],		#prior : OmReference [ '599' ],		#self : OmReference [ '600' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  self sortAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.611795-04:00' ],		#prior : OmReference [ '600' ],		#self : OmReference [ '601' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  tmp3 := tmp1 asDataSeries.\r  tmp3 name: self name.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.613755-04:00' ],		#prior : OmReference [ '601' ],		#self : OmReference [ '602' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg2 key) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.616431-04:00' ],		#prior : OmReference [ '602' ],		#self : OmReference [ '603' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := forcedIsNumerical.\r  ^tmp2 ifNil: [ #metaObject count: 2.\r        nil.\r        self uniqueValues allSatisfy: [:arg1 |  #metaObject count: 3.\r              nil.\r              arg1 isNumber ] ] ifNotNil: [ #metaObject count: 4.\r        nil.\r        tmp2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.618151-04:00' ],		#prior : OmReference [ '603' ],		#self : OmReference [ '604' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.620162-04:00' ],		#prior : OmReference [ '604' ],		#self : OmReference [ '605' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.622101-04:00' ],		#prior : OmReference [ '605' ],		#self : OmReference [ '606' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.623681-04:00' ],		#prior : OmReference [ '606' ],		#self : OmReference [ '607' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeyDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.626938-04:00' ],		#prior : OmReference [ '607' ],		#self : OmReference [ '608' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  #metaObject count: 1.\r  nil.\r  ^self includes: nil',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.628874-04:00' ],		#prior : OmReference [ '608' ],		#self : OmReference [ '609' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 6',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.630693-04:00' ],		#prior : OmReference [ '609' ],		#self : OmReference [ '610' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super collect: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.634541-04:00' ],		#prior : OmReference [ '610' ],		#self : OmReference [ '611' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2 as: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg1 uniqueValues.\r  tmp2 := tmp1 collect: [:arg4 |  #metaObject count: 3.\r        nil.\r        (1 to: self size) select: [:arg5 |  #metaObject count: 4.\r              nil.\r              (arg1 atIndex: arg5) = arg4 ] thenCollect: [:arg6 |  #metaObject count: 5.\r              nil.\r              self atIndex: arg6 ] ].\r  ^DataSeries withKeys: tmp1 values: (tmp2 collect: arg2) name: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.636423-04:00' ],		#prior : OmReference [ '611' ],		#self : OmReference [ '612' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  #metaObject count: 1.\r  nil.\r  ^self isNumerical not',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.638171-04:00' ],		#prior : OmReference [ '612' ],		#self : OmReference [ '613' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifFalse: [ #metaObject count: 3.\r              nil.\r              arg1 value: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.640318-04:00' ],		#prior : OmReference [ '613' ],		#self : OmReference [ '614' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.642317-04:00' ],		#prior : OmReference [ '614' ],		#self : OmReference [ '615' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ].\r  ^DataSeries withKeys: tmp1 values: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self at: arg3 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.6442-04:00' ],		#prior : OmReference [ '615' ],		#self : OmReference [ '616' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 4',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.646669-04:00' ],		#prior : OmReference [ '616' ],		#self : OmReference [ '617' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.648545-04:00' ],		#prior : OmReference [ '617' ],		#self : OmReference [ '618' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self sorted.\r  arg1 = 0 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^tmp1 first ].\r  tmp2 := (tmp1 size * (arg1 / 100)) ceiling.\r  ^tmp1 atIndex: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.651965-04:00' ],		#prior : OmReference [ '618' ],		#self : OmReference [ '619' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1 precision: arg2\r  #metaObject count: 1.\r  nil.\r  self == arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^true ].\r  (self species == arg1 species and: [ #metaObject count: 3.\r        nil.\r        self size = arg1 size ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 name = self name ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 6.\r        nil.\r        ^false ].\r  ^(1 to: self values size) detect: [:arg3 |  #metaObject count: 7.\r        nil.\r        ((self atIndex: arg3) closeTo: (arg1 atIndex: arg3) precision: arg2) not ] ifFound: [ #metaObject count: 8.\r        nil.\r        false ] ifNone: [ #metaObject count: 9.\r        nil.\r        true ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.653837-04:00' ],		#prior : OmReference [ '619' ],		#self : OmReference [ '620' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1) put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.655946-04:00' ],		#prior : OmReference [ '620' ],		#self : OmReference [ '621' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  #metaObject count: 1.\r  nil.\r  ^\'(no name)\'',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.658111-04:00' ],		#prior : OmReference [ '621' ],		#self : OmReference [ '622' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self at: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.661137-04:00' ],		#prior : OmReference [ '622' ],		#self : OmReference [ '623' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  super = arg1 ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  ^arg1 name = self name and: [ #metaObject count: 3.\r        nil.\r        arg1 keys = self keys ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.662562-04:00' ],		#prior : OmReference [ '623' ],		#self : OmReference [ '624' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: arg1\r  #metaObject count: 1.\r  nil.\r  ^self quantile: 25 * arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.664447-04:00' ],		#prior : OmReference [ '624' ],		#self : OmReference [ '625' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  #metaObject count: 1.\r  nil.\r  self replaceNilsWith: 0',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.666239-04:00' ],		#prior : OmReference [ '625' ],		#self : OmReference [ '626' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: arg1\r  #metaObject count: 1.\r  nil.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              self atIndex: arg3 put: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.668138-04:00' ],		#prior : OmReference [ '626' ],		#self : OmReference [ '627' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.670391-04:00' ],		#prior : OmReference [ '627' ],		#self : OmReference [ '628' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.672096-04:00' ],		#prior : OmReference [ '628' ],		#self : OmReference [ '629' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.674129-04:00' ],		#prior : OmReference [ '629' ],		#self : OmReference [ '630' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.676865-04:00' ],		#prior : OmReference [ '630' ],		#self : OmReference [ '631' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        arg3 value.\r        ^self ].\r  self at: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.678825-04:00' ],		#prior : OmReference [ '631' ],		#self : OmReference [ '632' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  #metaObject count: 1.\r  nil.\r  Error signal: \'Keys of two series do not match\'',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.680472-04:00' ],		#prior : OmReference [ '632' ],		#self : OmReference [ '633' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  self initialize.\r  ^super initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.682709-04:00' ],		#prior : OmReference [ '633' ],		#self : OmReference [ '634' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: 1 to: arg1) values: (self values copyFrom: 1 to: arg1) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.687817-04:00' ],		#prior : OmReference [ '634' ],		#self : OmReference [ '635' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) average.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.69157-04:00' ],		#prior : OmReference [ '635' ],		#self : OmReference [ '636' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self thirdQuartile - self firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.693585-04:00' ],		#prior : OmReference [ '636' ],		#self : OmReference [ '637' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  #metaObject count: 1.\r  nil.\r  ^self closeTo: arg1 precision: self defaultPrecision',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.695738-04:00' ],		#prior : OmReference [ '637' ],		#self : OmReference [ '638' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  ^self sortedAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.697931-04:00' ],		#prior : OmReference [ '638' ],		#self : OmReference [ '639' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 asArray deepCopy.\r  dictionary := self dictionaryClass newFromKeys: tmp1 andValues: self values.\r  orderedKeys := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.699644-04:00' ],		#prior : OmReference [ '639' ],		#self : OmReference [ '640' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: arg1\r  #metaObject count: 1.\r  nil.\r  name := arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.702107-04:00' ],		#prior : OmReference [ '640' ],		#self : OmReference [ '641' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) mode.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.705067-04:00' ],		#prior : OmReference [ '641' ],		#self : OmReference [ '642' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asSet asArray.\r  ^[ #metaObject count: 2.\r  nil.\r  tmp1 sort ] on: Error do: [ #metaObject count: 3.\r        nil.\r        tmp1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.708362-04:00' ],		#prior : OmReference [ '642' ],		#self : OmReference [ '643' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 4',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.710745-04:00' ],		#prior : OmReference [ '643' ],		#self : OmReference [ '644' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.712591-04:00' ],		#prior : OmReference [ '644' ],		#self : OmReference [ '645' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.71518-04:00' ],		#prior : OmReference [ '645' ],		#self : OmReference [ '646' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  #metaObject count: 1.\r  nil.\r  ^DataFrame withColumns: {self values} rowNames: self keys columnNames: {self name}',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.716976-04:00' ],		#prior : OmReference [ '646' ],		#self : OmReference [ '647' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.719311-04:00' ],		#prior : OmReference [ '647' ],		#self : OmReference [ '648' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 / self size.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.721922-04:00' ],		#prior : OmReference [ '648' ],		#self : OmReference [ '649' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keys withIndexDo: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg4)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.723492-04:00' ],		#prior : OmReference [ '649' ],		#self : OmReference [ '650' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 log: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.725579-04:00' ],		#prior : OmReference [ '650' ],		#self : OmReference [ '651' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.727175-04:00' ],		#prior : OmReference [ '651' ],		#self : OmReference [ '652' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>=',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.729427-04:00' ],		#prior : OmReference [ '652' ],		#self : OmReference [ '653' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg2) value: arg2 ].\r  ^DataSeries withKeys: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self keys at: arg3 ]) values: (tmp1 collect: [:arg4 |  #metaObject count: 4.\r              nil.\r              self atIndex: arg4 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.731092-04:00' ],		#prior : OmReference [ '653' ],		#self : OmReference [ '654' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keysDo: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.733112-04:00' ],		#prior : OmReference [ '654' ],		#self : OmReference [ '655' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.735063-04:00' ],		#prior : OmReference [ '655' ],		#self : OmReference [ '656' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<=',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.737641-04:00' ],		#prior : OmReference [ '656' ],		#self : OmReference [ '657' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self atIndex: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.73974-04:00' ],		#prior : OmReference [ '657' ],		#self : OmReference [ '658' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  #metaObject count: 1.\r  nil.\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.742187-04:00' ],		#prior : OmReference [ '658' ],		#self : OmReference [ '659' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  #metaObject count: 1.\r  nil.\r  ^self reject: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNil ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.74431-04:00' ],		#prior : OmReference [ '659' ],		#self : OmReference [ '660' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.747752-04:00' ],		#prior : OmReference [ '660' ],		#self : OmReference [ '661' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations withIndexCollect: [:arg2 :arg3 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg3) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.749355-04:00' ],		#prior : OmReference [ '661' ],		#self : OmReference [ '662' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  self\r     removeAll;\r     addAll: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.751087-04:00' ],		#prior : OmReference [ '662' ],		#self : OmReference [ '663' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super reject: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.752702-04:00' ],		#prior : OmReference [ '663' ],		#self : OmReference [ '664' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.755481-04:00' ],		#prior : OmReference [ '664' ],		#self : OmReference [ '665' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.761298-04:00' ],		#prior : OmReference [ '665' ],		#self : OmReference [ '666' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 max.\r  ^tmp1 keyAtValue: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.765848-04:00' ],		#prior : OmReference [ '666' ],		#self : OmReference [ '667' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species new.\r  tmp1\r     name: self name;\r     at: \'Min\' put: self min;\r     at: \'1st Qu.\' put: self firstQuartile;\r     at: \'Median\' put: self median;\r     at: \'Average\' put: self average;\r     at: \'3rd Qu.\' put: self thirdQuartile;\r     at: \'Max\' put: self max.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.76878-04:00' ],		#prior : OmReference [ '667' ],		#self : OmReference [ '668' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys at: arg1.\r  self at: tmp1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.771387-04:00' ],		#prior : OmReference [ '668' ],		#self : OmReference [ '669' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 9',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.773933-04:00' ],		#prior : OmReference [ '669' ],		#self : OmReference [ '670' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 0',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.77698-04:00' ],		#prior : OmReference [ '670' ],		#self : OmReference [ '671' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.780171-04:00' ],		#prior : OmReference [ '671' ],		#self : OmReference [ '672' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: self size',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.783372-04:00' ],		#prior : OmReference [ '672' ],		#self : OmReference [ '673' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  name := self defaultName',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.785665-04:00' ],		#prior : OmReference [ '673' ],		#self : OmReference [ '674' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: self size - arg1 + 1 to: self size) values: (self values copyFrom: self size - arg1 + 1 to: self size) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.787284-04:00' ],		#prior : OmReference [ '674' ],		#self : OmReference [ '675' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeKey: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.789732-04:00' ],		#prior : OmReference [ '675' ],		#self : OmReference [ '676' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.791821-04:00' ],		#prior : OmReference [ '676' ],		#self : OmReference [ '677' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 7',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.794862-04:00' ],		#prior : OmReference [ '677' ],		#self : OmReference [ '678' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 3.\r        nil.\r        self errorKeysMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keysDo: [:arg3 |  #metaObject count: 4.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg3)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.797475-04:00' ],		#prior : OmReference [ '678' ],		#self : OmReference [ '679' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  #metaObject count: 1.\r  nil.\r  ^name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.800337-04:00' ],		#prior : OmReference [ '679' ],		#self : OmReference [ '680' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeySelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.802606-04:00' ],		#prior : OmReference [ '680' ],		#self : OmReference [ '681' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2\r  #metaObject count: 1.\r  nil.\r  ^self newFromKeys: arg1 andValues: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.806965-04:00' ],		#prior : OmReference [ '681' ],		#self : OmReference [ '682' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2 name: arg3\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self withKeys: arg1 values: arg2.\r  tmp2 name: arg3.\r  ^tmp2 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.808801-04:00' ],		#prior : OmReference [ '682' ],		#self : OmReference [ '683' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  ^self withKeys: tmp1 values: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.811055-04:00' ],		#prior : OmReference [ '683' ],		#self : OmReference [ '684' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1 name: arg2\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  tmp3 := self withKeys: tmp1 values: arg1.\r  tmp3 name: arg2.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.816451-04:00' ],		#prior : OmReference [ '684' ],		#self : OmReference [ '685' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 ifEmpty: [ #metaObject count: 2.\r        nil.\r        ^self new ].\r  arg1 species == self ifTrue: [ #metaObject count: 3.\r        nil.\r        ^super newFrom: arg1 associations ].\r  ^super newFrom: ((arg1 anyOne respondsTo: #key) ifTrue: [ #metaObject count: 4.\r              nil.\r              arg1 ] ifFalse: [ #metaObject count: 5.\r              nil.\r              arg1 withIndexCollect: [:arg2 :arg3 |  #metaObject count: 6.\r                    nil.\r                    arg3 -> arg2 ] ])',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.821913-04:00' ],		#prior : OmReference [ '685' ],		#self : OmReference [ '686' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows - 1 columns: self numberOfColumns.\r  tmp2 := self numberOfColumns.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: tmp3 put: (contents at: tmp5 at: tmp3) ].\r        tmp4 := self numberOfRows.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp5 - 1 at: tmp3 put: (contents at: tmp5 at: tmp3) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.824124-04:00' ],		#prior : OmReference [ '686' ],		#self : OmReference [ '687' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.826916-04:00' ],		#prior : OmReference [ '687' ],		#self : OmReference [ '688' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := Array2D new',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.831875-04:00' ],		#prior : OmReference [ '688' ],		#self : OmReference [ '689' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self rowAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size.\r  tmp1 numberOfColumns = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfRows.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfColumns.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp5 at: tmp7 - tmp3 put: (contents at: tmp5 at: tmp7) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.834657-04:00' ],		#prior : OmReference [ '689' ],		#self : OmReference [ '690' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfRows) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg3 at: arg1 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.84103-04:00' ],		#prior : OmReference [ '690' ],		#self : OmReference [ '691' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  tmp2 := self numberOfColumns + 1.\r  arg1 size = tmp1 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := arg2 - 1.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 5.\r        nil.\r        tmp3 at: tmp5 at: arg2 put: (arg1 at: tmp5) ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        arg2 + 1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7 - 1) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.843139-04:00' ],		#prior : OmReference [ '691' ],		#self : OmReference [ '692' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents collect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.844796-04:00' ],		#prior : OmReference [ '692' ],		#self : OmReference [ '693' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents withIndicesCollect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.847438-04:00' ],		#prior : OmReference [ '693' ],		#self : OmReference [ '694' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg2 at: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.849909-04:00' ],		#prior : OmReference [ '694' ],		#self : OmReference [ '695' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.851985-04:00' ],		#prior : OmReference [ '695' ],		#self : OmReference [ '696' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.85419-04:00' ],		#prior : OmReference [ '696' ],		#self : OmReference [ '697' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfColumns) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg3 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.857029-04:00' ],		#prior : OmReference [ '697' ],		#self : OmReference [ '698' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp3 := self numberOfColumns.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  arg1 doWithIndex: [:arg2 :arg3 |  | tmp4 |\r        #metaObject count: 2.\r        nil.\r        tmp4 := tmp3.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: arg3 at: tmp5 put: (self at: arg2 at: tmp5) ].\r        1 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.859101-04:00' ],		#prior : OmReference [ '698' ],		#self : OmReference [ '699' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents do: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.862048-04:00' ],		#prior : OmReference [ '699' ],		#self : OmReference [ '700' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 2.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 3.\r              nil.\r              (arg1 includes: (contents at: tmp2 at: tmp4)) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    contents at: tmp2 at: tmp4 put: nil ] ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.866886-04:00' ],		#prior : OmReference [ '700' ],		#self : OmReference [ '701' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self columnAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size columns: self numberOfColumns.\r  tmp1 numberOfRows = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfColumns.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfRows.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp7 - tmp3 at: tmp5 put: (contents at: tmp7 at: tmp5) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.869524-04:00' ],		#prior : OmReference [ '701' ],		#self : OmReference [ '702' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents withIndicesDo: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.873139-04:00' ],		#prior : OmReference [ '702' ],		#self : OmReference [ '703' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - 1.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp3 at: tmp5 put: (contents at: tmp3 at: tmp5) ].\r        tmp4 := self numberOfColumns.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp3 at: tmp5 - 1 put: (contents at: tmp3 at: tmp5) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.875992-04:00' ],		#prior : OmReference [ '703' ],		#self : OmReference [ '704' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 tmp2 tmp3 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp3 := arg1 size.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        arg1 doWithIndex: [:arg2 :arg3 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: arg3 put: (self at: tmp5 at: arg2) ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.878709-04:00' ],		#prior : OmReference [ '704' ],		#self : OmReference [ '705' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  contents numberOfRows isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.880537-04:00' ],		#prior : OmReference [ '705' ],		#self : OmReference [ '706' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  contents := Array2D rows: arg1 x columns: arg1 y',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.883906-04:00' ],		#prior : OmReference [ '706' ],		#self : OmReference [ '707' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 class == self class and: [ #metaObject count: 2.\r        nil.\r        arg1 numberOfRows = self numberOfRows and: [ #metaObject count: 3.\r              nil.\r              arg1 numberOfColumns = self numberOfColumns ] ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 5.\r        nil.\r        (self at: arg3 at: arg4) = arg2 ifFalse: [ #metaObject count: 6.\r              nil.\r              ^false ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.886198-04:00' ],		#prior : OmReference [ '707' ],		#self : OmReference [ '708' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg2 at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.889016-04:00' ],		#prior : OmReference [ '708' ],		#self : OmReference [ '709' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  contents numberOfColumns isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.891073-04:00' ],		#prior : OmReference [ '709' ],		#self : OmReference [ '710' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  #metaObject count: 1.\r  nil.\r  contents printOn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.893844-04:00' ],		#prior : OmReference [ '710' ],		#self : OmReference [ '711' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg1 at: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.900233-04:00' ],		#prior : OmReference [ '711' ],		#self : OmReference [ '712' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows + 1.\r  tmp2 := self numberOfColumns.\r  arg1 size = tmp2 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := arg2 - 1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp6 := tmp2.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 5.\r        nil.\r        tmp3 at: arg2 at: tmp7 put: (arg1 at: tmp7) ].\r  tmp4 := tmp1.\r  arg2 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 - 1 at: tmp7) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.902361-04:00' ],		#prior : OmReference [ '712' ],		#self : OmReference [ '713' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.905444-04:00' ],		#prior : OmReference [ '713' ],		#self : OmReference [ '714' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.909224-04:00' ],		#prior : OmReference [ '714' ],		#self : OmReference [ '715' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp1 := 0.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp1 := tmp1 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp9) asArray at: tmp7 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.911134-04:00' ],		#prior : OmReference [ '715' ],		#self : OmReference [ '716' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.913424-04:00' ],		#prior : OmReference [ '716' ],		#self : OmReference [ '717' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self new: arg1 rowCount @ arg1 columnCount.\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp1 at: arg3 at: arg4 put: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.916869-04:00' ],		#prior : OmReference [ '717' ],		#self : OmReference [ '718' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := 0.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp2 := tmp2 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp7) asArray at: tmp9 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.919669-04:00' ],		#prior : OmReference [ '718' ],		#self : OmReference [ '719' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: arg1 row: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 id = \'#\' ifTrue: [ #metaObject count: 2.\r        nil.\r        ^FTCellMorph new addMorph: (elements rowNames at: arg2) asMorph ].\r  tmp1 := elements columnNames indexOf: arg1 id.\r  ^FTCellMorph new addMorph: (elements at: arg2 at: tmp1) asMorph',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.922478-04:00' ],		#prior : OmReference [ '719' ],		#self : OmReference [ '720' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^elements numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.925337-04:00' ],		#prior : OmReference [ '720' ],		#self : OmReference [ '721' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp1 := self rowAt: tmp3.\r        arg1 value: tmp1.\r        self rowAt: tmp3 put: tmp1 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.927352-04:00' ],		#prior : OmReference [ '721' ],		#self : OmReference [ '722' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self outerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.929886-04:00' ],		#prior : OmReference [ '722' ],		#self : OmReference [ '723' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: arg1 into: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super inject: arg1 into: arg2.\r  tmp1 name: tmp1 defaultName.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.932551-04:00' ],		#prior : OmReference [ '723' ],		#self : OmReference [ '724' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.934614-04:00' ],		#prior : OmReference [ '724' ],		#self : OmReference [ '725' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnNames at: arg1.\r  ^self toColumn: tmp1 applyElementwise: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.938289-04:00' ],		#prior : OmReference [ '725' ],		#self : OmReference [ '726' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self columnAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.941272-04:00' ],		#prior : OmReference [ '726' ],		#self : OmReference [ '727' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self column: arg1) asArray.\r  tmp1 := tmp1 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg2 value: arg3 ].\r  self column: arg1 put: tmp1 asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.943318-04:00' ],		#prior : OmReference [ '727' ],		#self : OmReference [ '728' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rightJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.945423-04:00' ],		#prior : OmReference [ '728' ],		#self : OmReference [ '729' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        columnNames at: arg2 ].\r  self removeColumns: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.948725-04:00' ],		#prior : OmReference [ '729' ],		#self : OmReference [ '730' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self size.\r  1 to: tmp1 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp2 := nil.\r        tmp2 := self rowAt: tmp3.\r        arg1 value: tmp2 value: tmp3.\r        self rowAt: tmp3 put: tmp2 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.952065-04:00' ],		#prior : OmReference [ '730' ],		#self : OmReference [ '731' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := tmp1 select: arg1.\r  tmp3 := tmp2 isEmpty ifTrue: [ #metaObject count: 2.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp2 collect: #name ].\r  tmp4 := tmp2 isEmpty ifTrue: [ #metaObject count: 4.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 5.\r        nil.\r        self columnNames ].\r  tmp5 := tmp2 collect: #asArray.\r  tmp6 := self class withRows: tmp5 rowNames: tmp3 columnNames: tmp4.\r  ^tmp6',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.954671-04:00' ],		#prior : OmReference [ '731' ],		#self : OmReference [ '732' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.957865-04:00' ],		#prior : OmReference [ '732' ],		#self : OmReference [ '733' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.960119-04:00' ],		#prior : OmReference [ '733' ],		#self : OmReference [ '734' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.962892-04:00' ],		#prior : OmReference [ '734' ],		#self : OmReference [ '735' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.965133-04:00' ],		#prior : OmReference [ '735' ],		#self : OmReference [ '736' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: (Array new: self numberOfRows) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.968012-04:00' ],		#prior : OmReference [ '736' ],		#self : OmReference [ '737' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1 using: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp1 := tmp1 copy.\r  tmp1 sort: arg2.\r  tmp2 := tmp1 keys.\r  tmp3 := DataFrameInternal new: self dimensions.\r  tmp2 withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp3 rowAt: arg4 put: (self row: arg3) asArray ].\r  contents := tmp3.\r  self rowNames: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.970188-04:00' ],		#prior : OmReference [ '737' ],		#self : OmReference [ '738' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #average',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.972383-04:00' ],		#prior : OmReference [ '738' ],		#self : OmReference [ '739' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg2 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.975283-04:00' ],		#prior : OmReference [ '739' ],		#self : OmReference [ '740' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self column: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.981797-04:00' ],		#prior : OmReference [ '740' ],		#self : OmReference [ '741' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  self size isZero | arg1 size isZero ifFalse: [ #metaObject count: 2.\r        nil.\r        tmp1 := OrderedCollection new.\r        (self column: arg2) withIndexDo: [:arg4 :arg5 |  #metaObject count: 3.\r              nil.\r              ((arg1 column: arg3) includes: arg4) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    tmp1 add: arg5 ] ].\r        tmp1 do: [:arg6 |  | tmp4 tmp5 |\r              #metaObject count: 5.\r              nil.\r              tmp4 := arg1 findAllIndicesOf: (self at: arg6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp4 do: [:arg7 |  #metaObject count: 6.\r                    nil.\r                    tmp5 := (self rowAt: arg6) asArray , (arg1 rowAt: arg7) asArray.\r                    tmp2 addRow: tmp5 named: tmp2 size + 1 ] ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 7.\r        nil.\r        tmp2\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.984126-04:00' ],		#prior : OmReference [ '741' ],		#self : OmReference [ '742' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1.\r  self row: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.986176-04:00' ],		#prior : OmReference [ '742' ],		#self : OmReference [ '743' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumn: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.988519-04:00' ],		#prior : OmReference [ '743' ],		#self : OmReference [ '744' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #thirdQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.990114-04:00' ],		#prior : OmReference [ '744' ],		#self : OmReference [ '745' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: arg1\r  #metaObject count: 1.\r  nil.\r  self toColumns: self columnNames applyElementwise: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.992382-04:00' ],		#prior : OmReference [ '745' ],		#self : OmReference [ '746' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        self at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.994247-04:00' ],		#prior : OmReference [ '746' ],		#self : OmReference [ '747' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: (Array new: self numberOfColumns) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.997002-04:00' ],		#prior : OmReference [ '747' ],		#self : OmReference [ '748' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataFrame withRows: self asArrayOfColumns.\r  tmp1\r     rowNames: self columnNames;\r     columnNames: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:04.998749-04:00' ],		#prior : OmReference [ '748' ],		#self : OmReference [ '749' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 fastTable when: [ #metaObject count: 2.\r        nil.\r        false ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.001469-04:00' ],		#prior : OmReference [ '749' ],		#self : OmReference [ '750' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.005818-04:00' ],		#prior : OmReference [ '750' ],		#self : OmReference [ '751' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := columnNames deepCopy.\r  columnNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg2 at: arg4)) ifFalse: [ #metaObject count: 5.\r              nil.\r              columnNames add: arg3 ] ].\r  contents removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2.\r  self numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        rowNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.008599-04:00' ],		#prior : OmReference [ '751' ],		#self : OmReference [ '752' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  #metaObject count: 1.\r  nil.\r  ^columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.011485-04:00' ],		#prior : OmReference [ '752' ],		#self : OmReference [ '753' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumnAt: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.02035-04:00' ],		#prior : OmReference [ '753' ],		#self : OmReference [ '754' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := self size.\r  1 to: tmp4 do: [:tmp7 |  | tmp9 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (self at: tmp7 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := arg1 findAllIndicesOf: (self at: tmp7 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp9 := (self rowAt: tmp7) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp9 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp9 := (self rowAt: tmp7) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp9 named: tmp1 size + 1 ] ].\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  #metaObject count: 6.\r        nil.\r        tmp8 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 8.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 9.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 10.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.023733-04:00' ],		#prior : OmReference [ '754' ],		#self : OmReference [ '755' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self columnNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A column with that name already exists\' ].\r  contents addColumn: arg1 asArray atPosition: arg3.\r  columnNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.025351-04:00' ],		#prior : OmReference [ '755' ],		#self : OmReference [ '756' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyRowNamed: arg1 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.027282-04:00' ],		#prior : OmReference [ '756' ],		#self : OmReference [ '757' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.030026-04:00' ],		#prior : OmReference [ '757' ],		#self : OmReference [ '758' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 value: (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ tmp1 size.\r  tmp2 columnNames: tmp1 keys.\r  self do: [:arg2 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.032752-04:00' ],		#prior : OmReference [ '758' ],		#self : OmReference [ '759' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.034661-04:00' ],		#prior : OmReference [ '759' ],		#self : OmReference [ '760' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.036439-04:00' ],		#prior : OmReference [ '760' ],		#self : OmReference [ '761' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withRows: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.038281-04:00' ],		#prior : OmReference [ '761' ],		#self : OmReference [ '762' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: arg1\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.041923-04:00' ],		#prior : OmReference [ '762' ],		#self : OmReference [ '763' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  arg1 rowNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp2 includes: arg3) ifFalse: [ #metaObject count: 6.\r              nil.\r              tmp1 addRow: (Array new: self columnNames size) , (arg1 row: arg3) asArray named: arg3 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.044912-04:00' ],		#prior : OmReference [ '763' ],		#self : OmReference [ '764' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 < arg2 ifTrue: [ #metaObject count: 2.\r        nil.\r        (arg1 to: arg2) asArray ] ifFalse: [ #metaObject count: 3.\r        nil.\r        (arg2 to: arg1) asArray reverse ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.048132-04:00' ],		#prior : OmReference [ '764' ],		#self : OmReference [ '765' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents columnAt: arg1) asDataSeries.\r  tmp1\r     name: (self columnNames at: arg1);\r     keys: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.049978-04:00' ],		#prior : OmReference [ '765' ],		#self : OmReference [ '766' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 asArray named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.052054-04:00' ],		#prior : OmReference [ '766' ],		#self : OmReference [ '767' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.05375-04:00' ],		#prior : OmReference [ '767' ],		#self : OmReference [ '768' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self removeColumnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.055688-04:00' ],		#prior : OmReference [ '768' ],		#self : OmReference [ '769' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self columnNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.058024-04:00' ],		#prior : OmReference [ '769' ],		#self : OmReference [ '770' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #max',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.060366-04:00' ],		#prior : OmReference [ '770' ],		#self : OmReference [ '771' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.062261-04:00' ],		#prior : OmReference [ '771' ],		#self : OmReference [ '772' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeRow: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.067868-04:00' ],		#prior : OmReference [ '772' ],		#self : OmReference [ '773' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: arg1\r  < gtInspectorPresentationOrder: 0>\r  < gtInspectorTag: #basic>\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 morph.\r  tmp2\r     title: \'Fast Table\';\r     display: [ #metaObject count: 2.\r        nil.\r        self showWithGlamourIn: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.070438-04:00' ],		#prior : OmReference [ '773' ],		#self : OmReference [ '774' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRowNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg2.\r  self removeColumnsOfRowElementsSatisfing: arg1 onRow: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.073479-04:00' ],		#prior : OmReference [ '774' ],		#self : OmReference [ '775' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self rowNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A row with that name already exists\' ].\r  contents addRow: arg1 atPosition: arg3.\r  rowNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.076427-04:00' ],		#prior : OmReference [ '775' ],		#self : OmReference [ '776' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  ^arg1 contents = self contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.079124-04:00' ],		#prior : OmReference [ '776' ],		#self : OmReference [ '777' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3\r  #metaObject count: 1.\r  nil.\r  ^self group: arg1 by: arg2 aggregateUsing: arg3 as: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.081369-04:00' ],		#prior : OmReference [ '777' ],		#self : OmReference [ '778' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.083091-04:00' ],		#prior : OmReference [ '778' ],		#self : OmReference [ '779' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.086468-04:00' ],		#prior : OmReference [ '779' ],		#self : OmReference [ '780' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 transform: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 at: arg2.\r  self at: arg1 at: arg2 put: (arg3 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.088856-04:00' ],		#prior : OmReference [ '780' ],		#self : OmReference [ '781' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.092306-04:00' ],		#prior : OmReference [ '781' ],		#self : OmReference [ '782' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Column \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.094674-04:00' ],		#prior : OmReference [ '782' ],		#self : OmReference [ '783' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  self column: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.098321-04:00' ],		#prior : OmReference [ '783' ],		#self : OmReference [ '784' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : ': arg2;\r     columnNames: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3 as: arg4\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  arg2 = arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'Can not group a column by itself\' ].\r  tmp1 := self column: arg2.\r  tmp2 := self column: arg1.\r  ^tmp2 groupBy: tmp1 aggregateUsing: arg3 as: arg4',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.100473-04:00' ],		#prior : OmReference [ '784' ],		#self : OmReference [ '785' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #median',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.102491-04:00' ],		#prior : OmReference [ '785' ],		#self : OmReference [ '786' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.104363-04:00' ],		#prior : OmReference [ '786' ],		#self : OmReference [ '787' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.10632-04:00' ],		#prior : OmReference [ '787' ],		#self : OmReference [ '788' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyColumnNamed: arg1 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.108756-04:00' ],		#prior : OmReference [ '788' ],		#self : OmReference [ '789' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: arg1 atColumn: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames select: [:arg3 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.111233-04:00' ],		#prior : OmReference [ '789' ],		#self : OmReference [ '790' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self numberOfRows > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := self numberOfRows ].\r  ^self rowsAt: (1 to: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.117623-04:00' ],		#prior : OmReference [ '790' ],		#self : OmReference [ '791' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  | tmp8 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := self findAllIndicesOf: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3)) atColumn: arg2.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp8 := (self rowAt: arg4) asArray , (arg1 rowAt: tmp7) asArray.\r                    tmp1 addRow: tmp8 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 6.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 7.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 8.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.119681-04:00' ],		#prior : OmReference [ '791' ],		#self : OmReference [ '792' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowsAt: (arg1 to: arg2)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.121528-04:00' ],		#prior : OmReference [ '792' ],		#self : OmReference [ '793' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Row \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.123327-04:00' ],		#prior : OmReference [ '793' ],		#self : OmReference [ '794' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents rowAt: arg1) asDataSeries.\r  tmp1\r     name: (self rowNames at: arg1);\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.127577-04:00' ],		#prior : OmReference [ '794' ],		#self : OmReference [ '795' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.13031-04:00' ],		#prior : OmReference [ '795' ],		#self : OmReference [ '796' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp1 := self rowNames select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 rowNames includes: arg2 ].\r  tmp1 do: [:arg3 |  | tmp3 |\r        #metaObject count: 3.\r        nil.\r        tmp3 := (self row: arg3) asArray , (arg1 row: arg3) asArray.\r        tmp2 addRow: tmp3 named: arg3 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.132326-04:00' ],		#prior : OmReference [ '796' ],		#self : OmReference [ '797' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #interquartileRange',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.13455-04:00' ],		#prior : OmReference [ '797' ],		#self : OmReference [ '798' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.137499-04:00' ],		#prior : OmReference [ '798' ],		#self : OmReference [ '799' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self leftJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.139696-04:00' ],		#prior : OmReference [ '799' ],		#self : OmReference [ '800' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregate: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg2 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg3 value: self value: arg1 ].\r  ^DataFrame withColumns: tmp1 rowNames: tmp1 first keys columnNames: (tmp1 collect: #name)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.143504-04:00' ],		#prior : OmReference [ '800' ],		#self : OmReference [ '801' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 6.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 7.\r              nil.\r              ((self at: tmp2 at: tmp4) closeTo: (arg1 at: tmp2 at: tmp4)) ifFalse: [ #metaObject count: 8.\r                    nil.\r                    ^false ] ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.145511-04:00' ],		#prior : OmReference [ '801' ],		#self : OmReference [ '802' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #stdev',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.147186-04:00' ],		#prior : OmReference [ '802' ],		#self : OmReference [ '803' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.150841-04:00' ],		#prior : OmReference [ '803' ],		#self : OmReference [ '804' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self rowAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.153255-04:00' ],		#prior : OmReference [ '804' ],		#self : OmReference [ '805' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.155091-04:00' ],		#prior : OmReference [ '805' ],		#self : OmReference [ '806' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg2 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.157207-04:00' ],		#prior : OmReference [ '806' ],		#self : OmReference [ '807' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r  #metaObject count: 1.\r  nil.\r  ^rowNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.159534-04:00' ],		#prior : OmReference [ '807' ],		#self : OmReference [ '808' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeColumnAt: arg1.\r  columnNames := columnNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.162482-04:00' ],		#prior : OmReference [ '808' ],		#self : OmReference [ '809' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self rowNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents rowsAt: arg1) rowNames: tmp1 columnNames: self columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.165024-04:00' ],		#prior : OmReference [ '809' ],		#self : OmReference [ '810' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self column: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.167421-04:00' ],		#prior : OmReference [ '810' ],		#self : OmReference [ '811' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfColumnNamed: arg2 ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.169244-04:00' ],		#prior : OmReference [ '811' ],		#self : OmReference [ '812' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.170806-04:00' ],		#prior : OmReference [ '812' ],		#self : OmReference [ '813' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.172304-04:00' ],		#prior : OmReference [ '813' ],		#self : OmReference [ '814' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 asArray named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.174672-04:00' ],		#prior : OmReference [ '814' ],		#self : OmReference [ '815' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents columnAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.176715-04:00' ],		#prior : OmReference [ '815' ],		#self : OmReference [ '816' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self rowAt: arg1.\r  self rowAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.178341-04:00' ],		#prior : OmReference [ '816' ],		#self : OmReference [ '817' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.180149-04:00' ],		#prior : OmReference [ '817' ],		#self : OmReference [ '818' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.182833-04:00' ],		#prior : OmReference [ '818' ],		#self : OmReference [ '819' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: arg1 atColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := OrderedCollection new.\r  self rowNames withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp1 add: arg4 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.186941-04:00' ],		#prior : OmReference [ '819' ],		#self : OmReference [ '820' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self columnNames intersection: arg1 columnNames) asSet.\r  tmp2 := OrderedCollection new.\r  self columnNames do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (tmp1 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp2 add: (\'\' join: {(arg2 , \'_x\')}) ] ifFalse: [ #metaObject count: 4.\r              nil.\r              tmp2 add: arg2 ] ].\r  arg1 columnNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp1 includes: arg3) ifTrue: [ #metaObject count: 6.\r              nil.\r              tmp2 add: (\'\' join: {(arg3 , \'_y\')}) ] ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp2 add: arg3 ] ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.189389-04:00' ],		#prior : OmReference [ '820' ],		#self : OmReference [ '821' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of column names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All column names must be distinct\' ].\r  columnNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.191664-04:00' ],		#prior : OmReference [ '821' ],		#self : OmReference [ '822' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        rowNames at: arg2 ].\r  self removeRows: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.19448-04:00' ],		#prior : OmReference [ '822' ],		#self : OmReference [ '823' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self row: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.199605-04:00' ],		#prior : OmReference [ '823' ],		#self : OmReference [ '824' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := (1 to: tmp1 size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (tmp1 at: arg2) value: arg2 ].\r  tmp3 := tmp2 collect: [:arg3 |  #metaObject count: 3.\r        nil.\r        self rowNames at: arg3 ].\r  tmp4 := tmp2 collect: [:arg4 |  #metaObject count: 4.\r        nil.\r        (tmp1 at: arg4) asArray ].\r  tmp5 := self class withRows: tmp4 rowNames: tmp3 columnNames: self columnNames.\r  ^tmp5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.202728-04:00' ],		#prior : OmReference [ '824' ],		#self : OmReference [ '825' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.206463-04:00' ],		#prior : OmReference [ '825' ],		#self : OmReference [ '826' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := rowNames deepCopy.\r  rowNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg4 at: arg2)) ifFalse: [ #metaObject count: 5.\r              nil.\r              rowNames add: arg3 ] ].\r  contents removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2.\r  self numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        columnNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.21248-04:00' ],		#prior : OmReference [ '826' ],		#self : OmReference [ '827' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp3 := self size.\r  1 to: tmp3 do: [:tmp6 |  | tmp7 |\r        #metaObject count: 2.\r        nil.\r        tmp5 := nil.\r        (tmp2 includes: (self at: tmp6 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp5 := arg1 findAllIndicesOf: (self at: tmp6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp5 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp7 := (self rowAt: tmp6) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp7 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp7 := (self rowAt: tmp6) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp7 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 6.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.215189-04:00' ],		#prior : OmReference [ '827' ],		#self : OmReference [ '828' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ (arg1 value: tmp1 value: 1) size.\r  tmp2 columnNames: tmp1 keys.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy value: arg3) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.217742-04:00' ],		#prior : OmReference [ '828' ],		#self : OmReference [ '829' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self rowAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.220195-04:00' ],		#prior : OmReference [ '829' ],		#self : OmReference [ '830' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class name.\r  tmp3 := arg1.\r  tmp3\r     nextPutAll: (tmp1 first isVowel ifTrue: [ #metaObject count: 2.\r              nil.\r              \'an \' ] ifFalse: [ #metaObject count: 3.\r              nil.\r              \'a \' ]);\r     nextPutAll: tmp1;\r     space;\r     nextPutAll: self dimensions asString',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.222174-04:00' ],		#prior : OmReference [ '830' ],		#self : OmReference [ '831' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.224369-04:00' ],		#prior : OmReference [ '831' ],		#self : OmReference [ '832' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #min',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.227114-04:00' ],		#prior : OmReference [ '832' ],		#self : OmReference [ '833' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := FTTableMorph new.\r  tmp1\r     beResizable;\r     intercellSpacing: 1;\r     dataSource: (DataFrameFTData elements: self);\r     onAnnouncement: FTSelectionChanged do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (self rowAt: arg2 newSelectedIndexes first) inspect ].\r  tmp2 := #(\'#\') , self columnNames.\r  tmp1 columns: (tmp2 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              (FTColumn id: arg3) width: 100 ]).\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.229087-04:00' ],		#prior : OmReference [ '833' ],		#self : OmReference [ '834' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 <= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.232431-04:00' ],		#prior : OmReference [ '834' ],		#self : OmReference [ '835' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #mode',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.234597-04:00' ],		#prior : OmReference [ '835' ],		#self : OmReference [ '836' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self columnNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.23609-04:00' ],		#prior : OmReference [ '836' ],		#self : OmReference [ '837' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withColumns: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.237937-04:00' ],		#prior : OmReference [ '837' ],		#self : OmReference [ '838' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self columnNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents columnsAt: arg1) rowNames: self rowNames columnNames: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.240461-04:00' ],		#prior : OmReference [ '838' ],		#self : OmReference [ '839' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeRowAt: arg1.\r  rowNames := rowNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.242187-04:00' ],		#prior : OmReference [ '839' ],		#self : OmReference [ '840' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRowNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.244035-04:00' ],		#prior : OmReference [ '840' ],		#self : OmReference [ '841' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self rowNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.246248-04:00' ],		#prior : OmReference [ '841' ],		#self : OmReference [ '842' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self row: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.248129-04:00' ],		#prior : OmReference [ '842' ],		#self : OmReference [ '843' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumnNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.250413-04:00' ],		#prior : OmReference [ '843' ],		#self : OmReference [ '844' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #variance',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.251981-04:00' ],		#prior : OmReference [ '844' ],		#self : OmReference [ '845' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self removeRowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.254084-04:00' ],		#prior : OmReference [ '845' ],		#self : OmReference [ '846' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents rowAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.256175-04:00' ],		#prior : OmReference [ '846' ],		#self : OmReference [ '847' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.259705-04:00' ],		#prior : OmReference [ '847' ],		#self : OmReference [ '848' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self columnAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.263515-04:00' ],		#prior : OmReference [ '848' ],		#self : OmReference [ '849' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  arg1 rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (Array new: self columnNames size) , (arg1 row: arg2) asArray ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.265969-04:00' ],		#prior : OmReference [ '849' ],		#self : OmReference [ '850' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #range',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.270104-04:00' ],		#prior : OmReference [ '850' ],		#self : OmReference [ '851' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.272277-04:00' ],		#prior : OmReference [ '851' ],		#self : OmReference [ '852' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeColumn: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.274431-04:00' ],		#prior : OmReference [ '852' ],		#self : OmReference [ '853' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows @ self numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.276435-04:00' ],		#prior : OmReference [ '853' ],		#self : OmReference [ '854' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: arg1 with: arg2\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp2 := self column: arg2.\r  ^tmp1 crossTabulateWith: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.278188-04:00' ],		#prior : OmReference [ '854' ],		#self : OmReference [ '855' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self innerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.280409-04:00' ],		#prior : OmReference [ '855' ],		#self : OmReference [ '856' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp2 > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := tmp2 ].\r  ^self rowsAt: (tmp2 - tmp1 + 1 to: tmp2)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.282469-04:00' ],		#prior : OmReference [ '856' ],		#self : OmReference [ '857' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnAt: arg1.\r  self columnAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.284372-04:00' ],		#prior : OmReference [ '857' ],		#self : OmReference [ '858' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 >= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.286688-04:00' ],		#prior : OmReference [ '858' ],		#self : OmReference [ '859' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumnNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg2.\r  self removeRowsOfColumnElementsSatisfing: arg1 onColumn: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.289433-04:00' ],		#prior : OmReference [ '859' ],		#self : OmReference [ '860' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of row names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All row names must be distinct\' ].\r  rowNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.292448-04:00' ],		#prior : OmReference [ '860' ],		#self : OmReference [ '861' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r  #metaObject count: 1.\r  nil.\r  self\r     rowNames: (1 to: self numberOfRows);\r     columnNames: (1 to: self numberOfColumns)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.295088-04:00' ],		#prior : OmReference [ '861' ],		#self : OmReference [ '862' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataSeries withValues: (self columnNames collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              tmp3 := self column: arg2.\r              tmp3 perform: arg1 ]).\r  tmp1\r     name: arg1;\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.29745-04:00' ],		#prior : OmReference [ '862' ],		#self : OmReference [ '863' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents asArrayOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.299303-04:00' ],		#prior : OmReference [ '863' ],		#self : OmReference [ '864' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfRowNamed: arg2 ].\r  ^self rowsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.300797-04:00' ],		#prior : OmReference [ '864' ],		#self : OmReference [ '865' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.302238-04:00' ],		#prior : OmReference [ '865' ],		#self : OmReference [ '866' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeColumns: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.304732-04:00' ],		#prior : OmReference [ '866' ],		#self : OmReference [ '867' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.306806-04:00' ],		#prior : OmReference [ '867' ],		#self : OmReference [ '868' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 columnNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withColumns: arg1.\r  tmp1 columnNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.310049-04:00' ],		#prior : OmReference [ '868' ],		#self : OmReference [ '869' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1 columnNames: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := arg2 size.\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp3\r     rowNames: arg1;\r     columnNames: arg2.\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.312523-04:00' ],		#prior : OmReference [ '869' ],		#self : OmReference [ '870' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 columnNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           columnNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.313999-04:00' ],		#prior : OmReference [ '870' ],		#self : OmReference [ '871' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeRows: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.315586-04:00' ],		#prior : OmReference [ '871' ],		#self : OmReference [ '872' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: 0 @ tmp1.\r  tmp2 columnNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.318485-04:00' ],		#prior : OmReference [ '872' ],		#self : OmReference [ '873' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.32163-04:00' ],		#prior : OmReference [ '873' ],		#self : OmReference [ '874' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.323518-04:00' ],		#prior : OmReference [ '874' ],		#self : OmReference [ '875' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withRows: arg1.\r  tmp1 rowNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.325102-04:00' ],		#prior : OmReference [ '875' ],		#self : OmReference [ '876' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: tmp1 @ 0.\r  tmp2 rowNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.327297-04:00' ],		#prior : OmReference [ '876' ],		#self : OmReference [ '877' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r  #metaObject count: 1.\r  nil.\r  ^super new initialize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.329224-04:00' ],		#prior : OmReference [ '877' ],		#self : OmReference [ '878' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^super new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.331687-04:00' ],		#prior : OmReference [ '878' ],		#self : OmReference [ '879' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^self new initializeContents: arg1 rowNames: arg2 columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.483896-04:00' ],		#prior : OmReference [ '879' ],		#self : OmReference [ '880' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2\r  #metaObject count: 1.\r  nil.\r  ^self groupBy: arg1 aggregateUsing: arg2 as: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.48823-04:00' ],		#prior : OmReference [ '880' ],		#self : OmReference [ '881' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  #metaObject count: 1.\r  nil.\r  ^(self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.492208-04:00' ],		#prior : OmReference [ '881' ],		#self : OmReference [ '882' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := false',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.498751-04:00' ],		#prior : OmReference [ '882' ],		#self : OmReference [ '883' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keys withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.50267-04:00' ],		#prior : OmReference [ '883' ],		#self : OmReference [ '884' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super select: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.505755-04:00' ],		#prior : OmReference [ '884' ],		#self : OmReference [ '885' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) median.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.508793-04:00' ],		#prior : OmReference [ '885' ],		#self : OmReference [ '886' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  self at: arg1 transform: arg2 ifAbsent: NotFoundError',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.511824-04:00' ],		#prior : OmReference [ '886' ],		#self : OmReference [ '887' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  #metaObject count: 1.\r  nil.\r  ^0.0001',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.517327-04:00' ],		#prior : OmReference [ '887' ],		#self : OmReference [ '888' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := DataFrame withRows: (self uniqueValues collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              arg1 uniqueValues collect: [:arg3 |  #metaObject count: 4.\r                    nil.\r                    (1 to: self size) inject: 0 into: [:arg4 :arg5 |  #metaObject count: 5.\r                          nil.\r                          ((self atIndex: arg5) = arg2 and: (arg1 atIndex: arg5) = arg3) ifTrue: [ #metaObject count: 6.\r                                nil.\r                                arg4 + 1 ] ifFalse: [ #metaObject count: 7.\r                                nil.\r                                arg4 ] ] ] ]).\r  tmp1\r     rowNames: self uniqueValues;\r     columnNames: arg1 uniqueValues.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.519925-04:00' ],		#prior : OmReference [ '888' ],		#self : OmReference [ '889' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 8',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.522661-04:00' ],		#prior : OmReference [ '889' ],		#self : OmReference [ '890' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.525011-04:00' ],		#prior : OmReference [ '890' ],		#self : OmReference [ '891' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeAt: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.529119-04:00' ],		#prior : OmReference [ '891' ],		#self : OmReference [ '892' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: arg1 andSend: arg2\r  #metaObject count: 1.\r  nil.\r  (arg1 isSequenceable and: [ #metaObject count: 2.\r        nil.\r        self isSequenceable ]) ifFalse: [ #metaObject count: 3.\r        nil.\r        self error: \'Only sequenceable collections may be combined arithmetically\' ].\r  ^arg1 withSeries: self collect: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        arg3 perform: arg2 with: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.532846-04:00' ],		#prior : OmReference [ '892' ],		#self : OmReference [ '893' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  self sortAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.535008-04:00' ],		#prior : OmReference [ '893' ],		#self : OmReference [ '894' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  tmp3 := tmp1 asDataSeries.\r  tmp3 name: self name.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.537231-04:00' ],		#prior : OmReference [ '894' ],		#self : OmReference [ '895' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg2 key) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.540924-04:00' ],		#prior : OmReference [ '895' ],		#self : OmReference [ '896' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := forcedIsNumerical.\r  ^tmp2 ifNil: [ #metaObject count: 2.\r        nil.\r        self uniqueValues allSatisfy: [:arg1 |  #metaObject count: 3.\r              nil.\r              arg1 isNumber ] ] ifNotNil: [ #metaObject count: 4.\r        nil.\r        tmp2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.54361-04:00' ],		#prior : OmReference [ '896' ],		#self : OmReference [ '897' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.545952-04:00' ],		#prior : OmReference [ '897' ],		#self : OmReference [ '898' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.548339-04:00' ],		#prior : OmReference [ '898' ],		#self : OmReference [ '899' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.550344-04:00' ],		#prior : OmReference [ '899' ],		#self : OmReference [ '900' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeyDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.552471-04:00' ],		#prior : OmReference [ '900' ],		#self : OmReference [ '901' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  #metaObject count: 1.\r  nil.\r  ^self includes: nil',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.554535-04:00' ],		#prior : OmReference [ '901' ],		#self : OmReference [ '902' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 6',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.556666-04:00' ],		#prior : OmReference [ '902' ],		#self : OmReference [ '903' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super collect: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.560672-04:00' ],		#prior : OmReference [ '903' ],		#self : OmReference [ '904' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2 as: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg1 uniqueValues.\r  tmp2 := tmp1 collect: [:arg4 |  #metaObject count: 3.\r        nil.\r        (1 to: self size) select: [:arg5 |  #metaObject count: 4.\r              nil.\r              (arg1 atIndex: arg5) = arg4 ] thenCollect: [:arg6 |  #metaObject count: 5.\r              nil.\r              self atIndex: arg6 ] ].\r  ^DataSeries withKeys: tmp1 values: (tmp2 collect: arg2) name: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.567695-04:00' ],		#prior : OmReference [ '904' ],		#self : OmReference [ '905' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  #metaObject count: 1.\r  nil.\r  ^self isNumerical not',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.569776-04:00' ],		#prior : OmReference [ '905' ],		#self : OmReference [ '906' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifFalse: [ #metaObject count: 3.\r              nil.\r              arg1 value: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.573437-04:00' ],		#prior : OmReference [ '906' ],		#self : OmReference [ '907' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.575954-04:00' ],		#prior : OmReference [ '907' ],		#self : OmReference [ '908' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ].\r  ^DataSeries withKeys: tmp1 values: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self at: arg3 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.578091-04:00' ],		#prior : OmReference [ '908' ],		#self : OmReference [ '909' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 4',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.58182-04:00' ],		#prior : OmReference [ '909' ],		#self : OmReference [ '910' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.584359-04:00' ],		#prior : OmReference [ '910' ],		#self : OmReference [ '911' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self sorted.\r  arg1 = 0 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^tmp1 first ].\r  tmp2 := (tmp1 size * (arg1 / 100)) ceiling.\r  ^tmp1 atIndex: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.588429-04:00' ],		#prior : OmReference [ '911' ],		#self : OmReference [ '912' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1 precision: arg2\r  #metaObject count: 1.\r  nil.\r  self == arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^true ].\r  (self species == arg1 species and: [ #metaObject count: 3.\r        nil.\r        self size = arg1 size ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 name = self name ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 6.\r        nil.\r        ^false ].\r  ^(1 to: self values size) detect: [:arg3 |  #metaObject count: 7.\r        nil.\r        ((self atIndex: arg3) closeTo: (arg1 atIndex: arg3) precision: arg2) not ] ifFound: [ #metaObject count: 8.\r        nil.\r        false ] ifNone: [ #metaObject count: 9.\r        nil.\r        true ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.590706-04:00' ],		#prior : OmReference [ '912' ],		#self : OmReference [ '913' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1) put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.592819-04:00' ],		#prior : OmReference [ '913' ],		#self : OmReference [ '914' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  #metaObject count: 1.\r  nil.\r  ^\'(no name)\'',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.595197-04:00' ],		#prior : OmReference [ '914' ],		#self : OmReference [ '915' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self at: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.597771-04:00' ],		#prior : OmReference [ '915' ],		#self : OmReference [ '916' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  super = arg1 ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  ^arg1 name = self name and: [ #metaObject count: 3.\r        nil.\r        arg1 keys = self keys ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.599338-04:00' ],		#prior : OmReference [ '916' ],		#self : OmReference [ '917' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: arg1\r  #metaObject count: 1.\r  nil.\r  ^self quantile: 25 * arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.601346-04:00' ],		#prior : OmReference [ '917' ],		#self : OmReference [ '918' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  #metaObject count: 1.\r  nil.\r  self replaceNilsWith: 0',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.603414-04:00' ],		#prior : OmReference [ '918' ],		#self : OmReference [ '919' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: arg1\r  #metaObject count: 1.\r  nil.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              self atIndex: arg3 put: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.605948-04:00' ],		#prior : OmReference [ '919' ],		#self : OmReference [ '920' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.60893-04:00' ],		#prior : OmReference [ '920' ],		#self : OmReference [ '921' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.611034-04:00' ],		#prior : OmReference [ '921' ],		#self : OmReference [ '922' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.613713-04:00' ],		#prior : OmReference [ '922' ],		#self : OmReference [ '923' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.616663-04:00' ],		#prior : OmReference [ '923' ],		#self : OmReference [ '924' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        arg3 value.\r        ^self ].\r  self at: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.618848-04:00' ],		#prior : OmReference [ '924' ],		#self : OmReference [ '925' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  #metaObject count: 1.\r  nil.\r  Error signal: \'Keys of two series do not match\'',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.622222-04:00' ],		#prior : OmReference [ '925' ],		#self : OmReference [ '926' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  self initialize.\r  ^super initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.624181-04:00' ],		#prior : OmReference [ '926' ],		#self : OmReference [ '927' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: 1 to: arg1) values: (self values copyFrom: 1 to: arg1) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.62715-04:00' ],		#prior : OmReference [ '927' ],		#self : OmReference [ '928' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) average.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.633396-04:00' ],		#prior : OmReference [ '928' ],		#self : OmReference [ '929' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self thirdQuartile - self firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.636277-04:00' ],		#prior : OmReference [ '929' ],		#self : OmReference [ '930' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  #metaObject count: 1.\r  nil.\r  ^self closeTo: arg1 precision: self defaultPrecision',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.640616-04:00' ],		#prior : OmReference [ '930' ],		#self : OmReference [ '931' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  ^self sortedAssociations: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.643197-04:00' ],		#prior : OmReference [ '931' ],		#self : OmReference [ '932' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 asArray deepCopy.\r  dictionary := self dictionaryClass newFromKeys: tmp1 andValues: self values.\r  orderedKeys := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.646024-04:00' ],		#prior : OmReference [ '932' ],		#self : OmReference [ '933' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: arg1\r  #metaObject count: 1.\r  nil.\r  name := arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.648785-04:00' ],		#prior : OmReference [ '933' ],		#self : OmReference [ '934' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) mode.\r  self replaceNilsWith: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.651463-04:00' ],		#prior : OmReference [ '934' ],		#self : OmReference [ '935' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asSet asArray.\r  ^[ #metaObject count: 2.\r  nil.\r  tmp1 sort ] on: Error do: [ #metaObject count: 3.\r        nil.\r        tmp1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.654381-04:00' ],		#prior : OmReference [ '935' ],		#self : OmReference [ '936' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 4',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.656575-04:00' ],		#prior : OmReference [ '936' ],		#self : OmReference [ '937' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.658382-04:00' ],		#prior : OmReference [ '937' ],		#self : OmReference [ '938' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.661115-04:00' ],		#prior : OmReference [ '938' ],		#self : OmReference [ '939' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  #metaObject count: 1.\r  nil.\r  ^DataFrame withColumns: {self values} rowNames: self keys columnNames: {self name}',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.663079-04:00' ],		#prior : OmReference [ '939' ],		#self : OmReference [ '940' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.665909-04:00' ],		#prior : OmReference [ '940' ],		#self : OmReference [ '941' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 / self size.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.66878-04:00' ],		#prior : OmReference [ '941' ],		#self : OmReference [ '942' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keys withIndexDo: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg4)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.670772-04:00' ],		#prior : OmReference [ '942' ],		#self : OmReference [ '943' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 log: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.674398-04:00' ],		#prior : OmReference [ '943' ],		#self : OmReference [ '944' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.676273-04:00' ],		#prior : OmReference [ '944' ],		#self : OmReference [ '945' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>=',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.678904-04:00' ],		#prior : OmReference [ '945' ],		#self : OmReference [ '946' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg2) value: arg2 ].\r  ^DataSeries withKeys: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self keys at: arg3 ]) values: (tmp1 collect: [:arg4 |  #metaObject count: 4.\r              nil.\r              self atIndex: arg4 ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.680628-04:00' ],		#prior : OmReference [ '946' ],		#self : OmReference [ '947' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keysDo: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.682857-04:00' ],		#prior : OmReference [ '947' ],		#self : OmReference [ '948' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.684531-04:00' ],		#prior : OmReference [ '948' ],		#self : OmReference [ '949' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<=',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.68718-04:00' ],		#prior : OmReference [ '949' ],		#self : OmReference [ '950' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self atIndex: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.68915-04:00' ],		#prior : OmReference [ '950' ],		#self : OmReference [ '951' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  #metaObject count: 1.\r  nil.\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.693453-04:00' ],		#prior : OmReference [ '951' ],		#self : OmReference [ '952' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  #metaObject count: 1.\r  nil.\r  ^self reject: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNil ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.69578-04:00' ],		#prior : OmReference [ '952' ],		#self : OmReference [ '953' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.698092-04:00' ],		#prior : OmReference [ '953' ],		#self : OmReference [ '954' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations withIndexCollect: [:arg2 :arg3 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg3) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.699906-04:00' ],		#prior : OmReference [ '954' ],		#self : OmReference [ '955' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  self\r     removeAll;\r     addAll: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.701878-04:00' ],		#prior : OmReference [ '955' ],		#self : OmReference [ '956' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super reject: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.703619-04:00' ],		#prior : OmReference [ '956' ],		#self : OmReference [ '957' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.706772-04:00' ],		#prior : OmReference [ '957' ],		#self : OmReference [ '958' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.709333-04:00' ],		#prior : OmReference [ '958' ],		#self : OmReference [ '959' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 max.\r  ^tmp1 keyAtValue: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.712461-04:00' ],		#prior : OmReference [ '959' ],		#self : OmReference [ '960' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species new.\r  tmp1\r     name: self name;\r     at: \'Min\' put: self min;\r     at: \'1st Qu.\' put: self firstQuartile;\r     at: \'Median\' put: self median;\r     at: \'Average\' put: self average;\r     at: \'3rd Qu.\' put: self thirdQuartile;\r     at: \'Max\' put: self max.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.715545-04:00' ],		#prior : OmReference [ '960' ],		#self : OmReference [ '961' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys at: arg1.\r  self at: tmp1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.717673-04:00' ],		#prior : OmReference [ '961' ],		#self : OmReference [ '962' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 9',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.719933-04:00' ],		#prior : OmReference [ '962' ],		#self : OmReference [ '963' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 0',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.722303-04:00' ],		#prior : OmReference [ '963' ],		#self : OmReference [ '964' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.724678-04:00' ],		#prior : OmReference [ '964' ],		#self : OmReference [ '965' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: self size',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.727234-04:00' ],		#prior : OmReference [ '965' ],		#self : OmReference [ '966' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  name := self defaultName',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.729182-04:00' ],		#prior : OmReference [ '966' ],		#self : OmReference [ '967' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: self size - arg1 + 1 to: self size) values: (self values copyFrom: self size - arg1 + 1 to: self size) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.730785-04:00' ],		#prior : OmReference [ '967' ],		#self : OmReference [ '968' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeKey: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.732929-04:00' ],		#prior : OmReference [ '968' ],		#self : OmReference [ '969' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.734867-04:00' ],		#prior : OmReference [ '969' ],		#self : OmReference [ '970' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 7',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.737824-04:00' ],		#prior : OmReference [ '970' ],		#self : OmReference [ '971' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 3.\r        nil.\r        self errorKeysMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keysDo: [:arg3 |  #metaObject count: 4.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg3)) ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.74012-04:00' ],		#prior : OmReference [ '971' ],		#self : OmReference [ '972' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  #metaObject count: 1.\r  nil.\r  ^name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.741807-04:00' ],		#prior : OmReference [ '972' ],		#self : OmReference [ '973' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeySelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.743846-04:00' ],		#prior : OmReference [ '973' ],		#self : OmReference [ '974' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2\r  #metaObject count: 1.\r  nil.\r  ^self newFromKeys: arg1 andValues: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.746426-04:00' ],		#prior : OmReference [ '974' ],		#self : OmReference [ '975' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2 name: arg3\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self withKeys: arg1 values: arg2.\r  tmp2 name: arg3.\r  ^tmp2 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.747953-04:00' ],		#prior : OmReference [ '975' ],		#self : OmReference [ '976' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  ^self withKeys: tmp1 values: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.750076-04:00' ],		#prior : OmReference [ '976' ],		#self : OmReference [ '977' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1 name: arg2\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  tmp3 := self withKeys: tmp1 values: arg1.\r  tmp3 name: arg2.\r  ^tmp3 yourself',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.758472-04:00' ],		#prior : OmReference [ '977' ],		#self : OmReference [ '978' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 ifEmpty: [ #metaObject count: 2.\r        nil.\r        ^self new ].\r  arg1 species == self ifTrue: [ #metaObject count: 3.\r        nil.\r        ^super newFrom: arg1 associations ].\r  ^super newFrom: ((arg1 anyOne respondsTo: #key) ifTrue: [ #metaObject count: 4.\r              nil.\r              arg1 ] ifFalse: [ #metaObject count: 5.\r              nil.\r              arg1 withIndexCollect: [:arg2 :arg3 |  #metaObject count: 6.\r                    nil.\r                    arg3 -> arg2 ] ])',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.762941-04:00' ],		#prior : OmReference [ '978' ],		#self : OmReference [ '979' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows - 1 columns: self numberOfColumns.\r  tmp2 := self numberOfColumns.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: tmp3 put: (contents at: tmp5 at: tmp3) ].\r        tmp4 := self numberOfRows.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp5 - 1 at: tmp3 put: (contents at: tmp5 at: tmp3) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.764715-04:00' ],		#prior : OmReference [ '979' ],		#self : OmReference [ '980' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.766999-04:00' ],		#prior : OmReference [ '980' ],		#self : OmReference [ '981' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := Array2D new',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.772317-04:00' ],		#prior : OmReference [ '981' ],		#self : OmReference [ '982' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self rowAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size.\r  tmp1 numberOfColumns = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfRows.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfColumns.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp5 at: tmp7 - tmp3 put: (contents at: tmp5 at: tmp7) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.774769-04:00' ],		#prior : OmReference [ '982' ],		#self : OmReference [ '983' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfRows) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg3 at: arg1 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.779379-04:00' ],		#prior : OmReference [ '983' ],		#self : OmReference [ '984' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  tmp2 := self numberOfColumns + 1.\r  arg1 size = tmp1 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := arg2 - 1.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 5.\r        nil.\r        tmp3 at: tmp5 at: arg2 put: (arg1 at: tmp5) ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        arg2 + 1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7 - 1) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.781122-04:00' ],		#prior : OmReference [ '984' ],		#self : OmReference [ '985' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents collect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.782658-04:00' ],		#prior : OmReference [ '985' ],		#self : OmReference [ '986' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents withIndicesCollect: arg1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.786396-04:00' ],		#prior : OmReference [ '986' ],		#self : OmReference [ '987' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg2 at: arg1 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.788462-04:00' ],		#prior : OmReference [ '987' ],		#self : OmReference [ '988' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.790221-04:00' ],		#prior : OmReference [ '988' ],		#self : OmReference [ '989' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.792478-04:00' ],		#prior : OmReference [ '989' ],		#self : OmReference [ '990' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfColumns) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg3 put: (arg2 at: arg3) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.795468-04:00' ],		#prior : OmReference [ '990' ],		#self : OmReference [ '991' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp3 := self numberOfColumns.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  arg1 doWithIndex: [:arg2 :arg3 |  | tmp4 |\r        #metaObject count: 2.\r        nil.\r        tmp4 := tmp3.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: arg3 at: tmp5 put: (self at: arg2 at: tmp5) ].\r        1 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.797286-04:00' ],		#prior : OmReference [ '991' ],		#self : OmReference [ '992' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents do: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.800001-04:00' ],		#prior : OmReference [ '992' ],		#self : OmReference [ '993' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 2.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 3.\r              nil.\r              (arg1 includes: (contents at: tmp2 at: tmp4)) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    contents at: tmp2 at: tmp4 put: nil ] ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.804439-04:00' ],		#prior : OmReference [ '993' ],		#self : OmReference [ '994' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self columnAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size columns: self numberOfColumns.\r  tmp1 numberOfRows = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfColumns.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfRows.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp7 - tmp3 at: tmp5 put: (contents at: tmp7 at: tmp5) ] ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.805878-04:00' ],		#prior : OmReference [ '994' ],		#self : OmReference [ '995' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents withIndicesDo: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.809259-04:00' ],		#prior : OmReference [ '995' ],		#self : OmReference [ '996' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - 1.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp3 at: tmp5 put: (contents at: tmp3 at: tmp5) ].\r        tmp4 := self numberOfColumns.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp3 at: tmp5 - 1 put: (contents at: tmp3 at: tmp5) ] ].\r  contents := tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.812706-04:00' ],		#prior : OmReference [ '996' ],		#self : OmReference [ '997' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 tmp2 tmp3 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp3 := arg1 size.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        arg1 doWithIndex: [:arg2 :arg3 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: arg3 put: (self at: tmp5 at: arg2) ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.814938-04:00' ],		#prior : OmReference [ '997' ],		#self : OmReference [ '998' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  contents numberOfRows isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.816989-04:00' ],		#prior : OmReference [ '998' ],		#self : OmReference [ '999' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  contents := Array2D rows: arg1 x columns: arg1 y',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.821752-04:00' ],		#prior : OmReference [ '999' ],		#self : OmReference [ '1000' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 class == self class and: [ #metaObject count: 2.\r        nil.\r        arg1 numberOfRows = self numberOfRows and: [ #metaObject count: 3.\r              nil.\r              arg1 numberOfColumns = self numberOfColumns ] ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 5.\r        nil.\r        (self at: arg3 at: arg4) = arg2 ifFalse: [ #metaObject count: 6.\r              nil.\r              ^false ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.823937-04:00' ],		#prior : OmReference [ '1000' ],		#self : OmReference [ '1001' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg2 at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.82647-04:00' ],		#prior : OmReference [ '1001' ],		#self : OmReference [ '1002' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  contents numberOfColumns isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.828232-04:00' ],		#prior : OmReference [ '1002' ],		#self : OmReference [ '1003' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  #metaObject count: 1.\r  nil.\r  contents printOn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.83079-04:00' ],		#prior : OmReference [ '1003' ],		#self : OmReference [ '1004' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg1 at: arg2 ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.835386-04:00' ],		#prior : OmReference [ '1004' ],		#self : OmReference [ '1005' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows + 1.\r  tmp2 := self numberOfColumns.\r  arg1 size = tmp2 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := arg2 - 1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp6 := tmp2.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 5.\r        nil.\r        tmp3 at: arg2 at: tmp7 put: (arg1 at: tmp7) ].\r  tmp4 := tmp1.\r  arg2 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 - 1 at: tmp7) ] ].\r  contents := tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.837273-04:00' ],		#prior : OmReference [ '1005' ],		#self : OmReference [ '1006' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.840672-04:00' ],		#prior : OmReference [ '1006' ],		#self : OmReference [ '1007' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.8445-04:00' ],		#prior : OmReference [ '1007' ],		#self : OmReference [ '1008' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp1 := 0.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp1 := tmp1 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp9) asArray at: tmp7 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.846292-04:00' ],		#prior : OmReference [ '1008' ],		#self : OmReference [ '1009' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.849371-04:00' ],		#prior : OmReference [ '1009' ],		#self : OmReference [ '1010' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self new: arg1 rowCount @ arg1 columnCount.\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp1 at: arg3 at: arg4 put: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.852572-04:00' ],		#prior : OmReference [ '1010' ],		#self : OmReference [ '1011' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := 0.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp2 := tmp2 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp7) asArray at: tmp9 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.855193-04:00' ],		#prior : OmReference [ '1011' ],		#self : OmReference [ '1012' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: arg1 row: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 id = \'#\' ifTrue: [ #metaObject count: 2.\r        nil.\r        ^FTCellMorph new addMorph: (elements rowNames at: arg2) asMorph ].\r  tmp1 := elements columnNames indexOf: arg1 id.\r  ^FTCellMorph new addMorph: (elements at: arg2 at: tmp1) asMorph',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.85708-04:00' ],		#prior : OmReference [ '1012' ],		#self : OmReference [ '1013' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^elements numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.860744-04:00' ],		#prior : OmReference [ '1013' ],		#self : OmReference [ '1014' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp1 := self rowAt: tmp3.\r        arg1 value: tmp1.\r        self rowAt: tmp3 put: tmp1 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.86304-04:00' ],		#prior : OmReference [ '1014' ],		#self : OmReference [ '1015' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self outerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.865963-04:00' ],		#prior : OmReference [ '1015' ],		#self : OmReference [ '1016' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: arg1 into: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super inject: arg1 into: arg2.\r  tmp1 name: tmp1 defaultName.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.868227-04:00' ],		#prior : OmReference [ '1016' ],		#self : OmReference [ '1017' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.870214-04:00' ],		#prior : OmReference [ '1017' ],		#self : OmReference [ '1018' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnNames at: arg1.\r  ^self toColumn: tmp1 applyElementwise: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.872661-04:00' ],		#prior : OmReference [ '1018' ],		#self : OmReference [ '1019' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self columnAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.875114-04:00' ],		#prior : OmReference [ '1019' ],		#self : OmReference [ '1020' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self column: arg1) asArray.\r  tmp1 := tmp1 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg2 value: arg3 ].\r  self column: arg1 put: tmp1 asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.877664-04:00' ],		#prior : OmReference [ '1020' ],		#self : OmReference [ '1021' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rightJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.879917-04:00' ],		#prior : OmReference [ '1021' ],		#self : OmReference [ '1022' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        columnNames at: arg2 ].\r  self removeColumns: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.882599-04:00' ],		#prior : OmReference [ '1022' ],		#self : OmReference [ '1023' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self size.\r  1 to: tmp1 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp2 := nil.\r        tmp2 := self rowAt: tmp3.\r        arg1 value: tmp2 value: tmp3.\r        self rowAt: tmp3 put: tmp2 asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.915265-04:00' ],		#prior : OmReference [ '1023' ],		#self : OmReference [ '1024' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := tmp1 select: arg1.\r  tmp3 := tmp2 isEmpty ifTrue: [ #metaObject count: 2.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp2 collect: #name ].\r  tmp4 := tmp2 isEmpty ifTrue: [ #metaObject count: 4.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 5.\r        nil.\r        self columnNames ].\r  tmp5 := tmp2 collect: #asArray.\r  tmp6 := self class withRows: tmp5 rowNames: tmp3 columnNames: tmp4.\r  ^tmp6',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.921246-04:00' ],		#prior : OmReference [ '1024' ],		#self : OmReference [ '1025' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.926472-04:00' ],		#prior : OmReference [ '1025' ],		#self : OmReference [ '1026' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.929212-04:00' ],		#prior : OmReference [ '1026' ],		#self : OmReference [ '1027' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1 transform: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.931652-04:00' ],		#prior : OmReference [ '1027' ],		#self : OmReference [ '1028' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.933923-04:00' ],		#prior : OmReference [ '1028' ],		#self : OmReference [ '1029' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: (Array new: self numberOfRows) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.936778-04:00' ],		#prior : OmReference [ '1029' ],		#self : OmReference [ '1030' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1 using: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp1 := tmp1 copy.\r  tmp1 sort: arg2.\r  tmp2 := tmp1 keys.\r  tmp3 := DataFrameInternal new: self dimensions.\r  tmp2 withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp3 rowAt: arg4 put: (self row: arg3) asArray ].\r  contents := tmp3.\r  self rowNames: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.939159-04:00' ],		#prior : OmReference [ '1030' ],		#self : OmReference [ '1031' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #average',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.941361-04:00' ],		#prior : OmReference [ '1031' ],		#self : OmReference [ '1032' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg2 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.944342-04:00' ],		#prior : OmReference [ '1032' ],		#self : OmReference [ '1033' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self column: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.953969-04:00' ],		#prior : OmReference [ '1033' ],		#self : OmReference [ '1034' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  self size isZero | arg1 size isZero ifFalse: [ #metaObject count: 2.\r        nil.\r        tmp1 := OrderedCollection new.\r        (self column: arg2) withIndexDo: [:arg4 :arg5 |  #metaObject count: 3.\r              nil.\r              ((arg1 column: arg3) includes: arg4) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    tmp1 add: arg5 ] ].\r        tmp1 do: [:arg6 |  | tmp4 tmp5 |\r              #metaObject count: 5.\r              nil.\r              tmp4 := arg1 findAllIndicesOf: (self at: arg6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp4 do: [:arg7 |  #metaObject count: 6.\r                    nil.\r                    tmp5 := (self rowAt: arg6) asArray , (arg1 rowAt: arg7) asArray.\r                    tmp2 addRow: tmp5 named: tmp2 size + 1 ] ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 7.\r        nil.\r        tmp2\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.975401-04:00' ],		#prior : OmReference [ '1034' ],		#self : OmReference [ '1035' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1.\r  self row: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.978078-04:00' ],		#prior : OmReference [ '1035' ],		#self : OmReference [ '1036' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumn: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.980622-04:00' ],		#prior : OmReference [ '1036' ],		#self : OmReference [ '1037' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #thirdQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.982558-04:00' ],		#prior : OmReference [ '1037' ],		#self : OmReference [ '1038' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: arg1\r  #metaObject count: 1.\r  nil.\r  self toColumns: self columnNames applyElementwise: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.985245-04:00' ],		#prior : OmReference [ '1038' ],		#self : OmReference [ '1039' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        self at: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.987393-04:00' ],		#prior : OmReference [ '1039' ],		#self : OmReference [ '1040' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: (Array new: self numberOfColumns) named: arg1 atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.990823-04:00' ],		#prior : OmReference [ '1040' ],		#self : OmReference [ '1041' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataFrame withRows: self asArrayOfColumns.\r  tmp1\r     rowNames: self columnNames;\r     columnNames: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.992706-04:00' ],		#prior : OmReference [ '1041' ],		#self : OmReference [ '1042' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 fastTable when: [ #metaObject count: 2.\r        nil.\r        false ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:05.995685-04:00' ],		#prior : OmReference [ '1042' ],		#self : OmReference [ '1043' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  contents at: arg1 at: arg2 put: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.000691-04:00' ],		#prior : OmReference [ '1043' ],		#self : OmReference [ '1044' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := columnNames deepCopy.\r  columnNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg2 at: arg4)) ifFalse: [ #metaObject count: 5.\r              nil.\r              columnNames add: arg3 ] ].\r  contents removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2.\r  self numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        rowNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.003054-04:00' ],		#prior : OmReference [ '1044' ],		#self : OmReference [ '1045' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  #metaObject count: 1.\r  nil.\r  ^columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.005446-04:00' ],		#prior : OmReference [ '1045' ],		#self : OmReference [ '1046' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumnAt: arg3 applyElementwise: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.016418-04:00' ],		#prior : OmReference [ '1046' ],		#self : OmReference [ '1047' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := self size.\r  1 to: tmp4 do: [:tmp7 |  | tmp9 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (self at: tmp7 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := arg1 findAllIndicesOf: (self at: tmp7 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp9 := (self rowAt: tmp7) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp9 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp9 := (self rowAt: tmp7) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp9 named: tmp1 size + 1 ] ].\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  #metaObject count: 6.\r        nil.\r        tmp8 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 8.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 9.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 10.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.023458-04:00' ],		#prior : OmReference [ '1047' ],		#self : OmReference [ '1048' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self columnNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A column with that name already exists\' ].\r  contents addColumn: arg1 asArray atPosition: arg3.\r  columnNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.025398-04:00' ],		#prior : OmReference [ '1048' ],		#self : OmReference [ '1049' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyRowNamed: arg1 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.027693-04:00' ],		#prior : OmReference [ '1049' ],		#self : OmReference [ '1050' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.030352-04:00' ],		#prior : OmReference [ '1050' ],		#self : OmReference [ '1051' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 value: (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ tmp1 size.\r  tmp2 columnNames: tmp1 keys.\r  self do: [:arg2 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.034238-04:00' ],		#prior : OmReference [ '1051' ],		#self : OmReference [ '1052' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.036363-04:00' ],		#prior : OmReference [ '1052' ],		#self : OmReference [ '1053' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.038919-04:00' ],		#prior : OmReference [ '1053' ],		#self : OmReference [ '1054' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withRows: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.043119-04:00' ],		#prior : OmReference [ '1054' ],		#self : OmReference [ '1055' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: arg1\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.047146-04:00' ],		#prior : OmReference [ '1055' ],		#self : OmReference [ '1056' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  arg1 rowNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp2 includes: arg3) ifFalse: [ #metaObject count: 6.\r              nil.\r              tmp1 addRow: (Array new: self columnNames size) , (arg1 row: arg3) asArray named: arg3 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.049666-04:00' ],		#prior : OmReference [ '1056' ],		#self : OmReference [ '1057' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 < arg2 ifTrue: [ #metaObject count: 2.\r        nil.\r        (arg1 to: arg2) asArray ] ifFalse: [ #metaObject count: 3.\r        nil.\r        (arg2 to: arg1) asArray reverse ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.05161-04:00' ],		#prior : OmReference [ '1057' ],		#self : OmReference [ '1058' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents columnAt: arg1) asDataSeries.\r  tmp1\r     name: (self columnNames at: arg1);\r     keys: self rowNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.053509-04:00' ],		#prior : OmReference [ '1058' ],		#self : OmReference [ '1059' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 asArray named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.055333-04:00' ],		#prior : OmReference [ '1059' ],		#self : OmReference [ '1060' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.056772-04:00' ],		#prior : OmReference [ '1060' ],		#self : OmReference [ '1061' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self removeColumnAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.058587-04:00' ],		#prior : OmReference [ '1061' ],		#self : OmReference [ '1062' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self columnNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.060927-04:00' ],		#prior : OmReference [ '1062' ],		#self : OmReference [ '1063' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #max',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.063195-04:00' ],		#prior : OmReference [ '1063' ],		#self : OmReference [ '1064' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.064772-04:00' ],		#prior : OmReference [ '1064' ],		#self : OmReference [ '1065' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeRow: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.067169-04:00' ],		#prior : OmReference [ '1065' ],		#self : OmReference [ '1066' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: arg1\r  < gtInspectorPresentationOrder: 0>\r  < gtInspectorTag: #basic>\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 morph.\r  tmp2\r     title: \'Fast Table\';\r     display: [ #metaObject count: 2.\r        nil.\r        self showWithGlamourIn: arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.069143-04:00' ],		#prior : OmReference [ '1066' ],		#self : OmReference [ '1067' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRowNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg2.\r  self removeColumnsOfRowElementsSatisfing: arg1 onRow: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.072028-04:00' ],		#prior : OmReference [ '1067' ],		#self : OmReference [ '1068' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self rowNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A row with that name already exists\' ].\r  contents addRow: arg1 atPosition: arg3.\r  rowNames add: arg2 afterIndex: arg3 - 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.074923-04:00' ],		#prior : OmReference [ '1068' ],		#self : OmReference [ '1069' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  ^arg1 contents = self contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.078622-04:00' ],		#prior : OmReference [ '1069' ],		#self : OmReference [ '1070' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3\r  #metaObject count: 1.\r  nil.\r  ^self group: arg1 by: arg2 aggregateUsing: arg3 as: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.080966-04:00' ],		#prior : OmReference [ '1070' ],		#self : OmReference [ '1071' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.082715-04:00' ],		#prior : OmReference [ '1071' ],		#self : OmReference [ '1072' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.08723-04:00' ],		#prior : OmReference [ '1072' ],		#self : OmReference [ '1073' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 transform: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 at: arg2.\r  self at: arg1 at: arg2 put: (arg3 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.090214-04:00' ],		#prior : OmReference [ '1073' ],		#self : OmReference [ '1074' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.092286-04:00' ],		#prior : OmReference [ '1074' ],		#self : OmReference [ '1075' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Column \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.094364-04:00' ],		#prior : OmReference [ '1075' ],		#self : OmReference [ '1076' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  self column: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.097885-04:00' ],		#prior : OmReference [ '1076' ],		#self : OmReference [ '1077' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : ': arg2;\r     columnNames: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3 as: arg4\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  arg2 = arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'Can not group a column by itself\' ].\r  tmp1 := self column: arg2.\r  tmp2 := self column: arg1.\r  ^tmp2 groupBy: tmp1 aggregateUsing: arg3 as: arg4',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.099914-04:00' ],		#prior : OmReference [ '1077' ],		#self : OmReference [ '1078' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #median',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.101502-04:00' ],		#prior : OmReference [ '1078' ],		#self : OmReference [ '1079' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumn: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.103439-04:00' ],		#prior : OmReference [ '1079' ],		#self : OmReference [ '1080' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.104957-04:00' ],		#prior : OmReference [ '1080' ],		#self : OmReference [ '1081' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyColumnNamed: arg1 atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.107621-04:00' ],		#prior : OmReference [ '1081' ],		#self : OmReference [ '1082' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: arg1 atColumn: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames select: [:arg3 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.110066-04:00' ],		#prior : OmReference [ '1082' ],		#self : OmReference [ '1083' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self numberOfRows > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := self numberOfRows ].\r  ^self rowsAt: (1 to: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.118081-04:00' ],		#prior : OmReference [ '1083' ],		#self : OmReference [ '1084' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  | tmp8 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := self findAllIndicesOf: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3)) atColumn: arg2.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp8 := (self rowAt: arg4) asArray , (arg1 rowAt: tmp7) asArray.\r                    tmp1 addRow: tmp8 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 6.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 7.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 8.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.120088-04:00' ],		#prior : OmReference [ '1084' ],		#self : OmReference [ '1085' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowsAt: (arg1 to: arg2)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.121923-04:00' ],		#prior : OmReference [ '1085' ],		#self : OmReference [ '1086' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Row \' , arg1 , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.123643-04:00' ],		#prior : OmReference [ '1086' ],		#self : OmReference [ '1087' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents rowAt: arg1) asDataSeries.\r  tmp1\r     name: (self rowNames at: arg1);\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.126332-04:00' ],		#prior : OmReference [ '1087' ],		#self : OmReference [ '1088' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self columnAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.128868-04:00' ],		#prior : OmReference [ '1088' ],		#self : OmReference [ '1089' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp1 := self rowNames select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 rowNames includes: arg2 ].\r  tmp1 do: [:arg3 |  | tmp3 |\r        #metaObject count: 3.\r        nil.\r        tmp3 := (self row: arg3) asArray , (arg1 row: arg3) asArray.\r        tmp2 addRow: tmp3 named: arg3 ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.130847-04:00' ],		#prior : OmReference [ '1089' ],		#self : OmReference [ '1090' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #interquartileRange',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.132585-04:00' ],		#prior : OmReference [ '1090' ],		#self : OmReference [ '1091' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.135514-04:00' ],		#prior : OmReference [ '1091' ],		#self : OmReference [ '1092' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self leftJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.137739-04:00' ],		#prior : OmReference [ '1092' ],		#self : OmReference [ '1093' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregate: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg2 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg3 value: self value: arg1 ].\r  ^DataFrame withColumns: tmp1 rowNames: tmp1 first keys columnNames: (tmp1 collect: #name)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.141594-04:00' ],		#prior : OmReference [ '1093' ],		#self : OmReference [ '1094' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 6.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 7.\r              nil.\r              ((self at: tmp2 at: tmp4) closeTo: (arg1 at: tmp2 at: tmp4)) ifFalse: [ #metaObject count: 8.\r                    nil.\r                    ^false ] ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.143586-04:00' ],		#prior : OmReference [ '1094' ],		#self : OmReference [ '1095' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #stdev',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.144968-04:00' ],		#prior : OmReference [ '1095' ],		#self : OmReference [ '1096' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.149578-04:00' ],		#prior : OmReference [ '1096' ],		#self : OmReference [ '1097' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self rowAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.153208-04:00' ],		#prior : OmReference [ '1097' ],		#self : OmReference [ '1098' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.156161-04:00' ],		#prior : OmReference [ '1098' ],		#self : OmReference [ '1099' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg2 atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.158554-04:00' ],		#prior : OmReference [ '1099' ],		#self : OmReference [ '1100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r  #metaObject count: 1.\r  nil.\r  ^rowNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.160803-04:00' ],		#prior : OmReference [ '1100' ],		#self : OmReference [ '1101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeColumnAt: arg1.\r  columnNames := columnNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.162854-04:00' ],		#prior : OmReference [ '1101' ],		#self : OmReference [ '1102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self rowNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents rowsAt: arg1) rowNames: tmp1 columnNames: self columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.165244-04:00' ],		#prior : OmReference [ '1102' ],		#self : OmReference [ '1103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self column: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.166982-04:00' ],		#prior : OmReference [ '1103' ],		#self : OmReference [ '1104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfColumnNamed: arg2 ].\r  ^self columnsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.16876-04:00' ],		#prior : OmReference [ '1104' ],		#self : OmReference [ '1105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.170431-04:00' ],		#prior : OmReference [ '1105' ],		#self : OmReference [ '1106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.172051-04:00' ],		#prior : OmReference [ '1106' ],		#self : OmReference [ '1107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 asArray named: arg1 name',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.174192-04:00' ],		#prior : OmReference [ '1107' ],		#self : OmReference [ '1108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents columnAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.176163-04:00' ],		#prior : OmReference [ '1108' ],		#self : OmReference [ '1109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self rowAt: arg1.\r  self rowAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.177835-04:00' ],		#prior : OmReference [ '1109' ],		#self : OmReference [ '1110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.179714-04:00' ],		#prior : OmReference [ '1110' ],		#self : OmReference [ '1111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.182141-04:00' ],		#prior : OmReference [ '1111' ],		#self : OmReference [ '1112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: arg1 atColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := OrderedCollection new.\r  self rowNames withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp1 add: arg4 ] ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.186734-04:00' ],		#prior : OmReference [ '1112' ],		#self : OmReference [ '1113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self columnNames intersection: arg1 columnNames) asSet.\r  tmp2 := OrderedCollection new.\r  self columnNames do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (tmp1 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp2 add: (\'\' join: {(arg2 , \'_x\')}) ] ifFalse: [ #metaObject count: 4.\r              nil.\r              tmp2 add: arg2 ] ].\r  arg1 columnNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp1 includes: arg3) ifTrue: [ #metaObject count: 6.\r              nil.\r              tmp2 add: (\'\' join: {(arg3 , \'_y\')}) ] ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp2 add: arg3 ] ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.188828-04:00' ],		#prior : OmReference [ '1113' ],		#self : OmReference [ '1114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of column names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All column names must be distinct\' ].\r  columnNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.190563-04:00' ],		#prior : OmReference [ '1114' ],		#self : OmReference [ '1115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        rowNames at: arg2 ].\r  self removeRows: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.193389-04:00' ],		#prior : OmReference [ '1115' ],		#self : OmReference [ '1116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self row: arg1 put: (arg2 value: tmp1)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.196085-04:00' ],		#prior : OmReference [ '1116' ],		#self : OmReference [ '1117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := (1 to: tmp1 size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (tmp1 at: arg2) value: arg2 ].\r  tmp3 := tmp2 collect: [:arg3 |  #metaObject count: 3.\r        nil.\r        self rowNames at: arg3 ].\r  tmp4 := tmp2 collect: [:arg4 |  #metaObject count: 4.\r        nil.\r        (tmp1 at: arg4) asArray ].\r  tmp5 := self class withRows: tmp4 rowNames: tmp3 columnNames: self columnNames.\r  ^tmp5',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.198364-04:00' ],		#prior : OmReference [ '1117' ],		#self : OmReference [ '1118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.202564-04:00' ],		#prior : OmReference [ '1118' ],		#self : OmReference [ '1119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := rowNames deepCopy.\r  rowNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg4 at: arg2)) ifFalse: [ #metaObject count: 5.\r              nil.\r              rowNames add: arg3 ] ].\r  contents removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2.\r  self numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        columnNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.208061-04:00' ],		#prior : OmReference [ '1119' ],		#self : OmReference [ '1120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp3 := self size.\r  1 to: tmp3 do: [:tmp6 |  | tmp7 |\r        #metaObject count: 2.\r        nil.\r        tmp5 := nil.\r        (tmp2 includes: (self at: tmp6 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp5 := arg1 findAllIndicesOf: (self at: tmp6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp5 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp7 := (self rowAt: tmp6) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp7 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp7 := (self rowAt: tmp6) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp7 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 6.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.210294-04:00' ],		#prior : OmReference [ '1120' ],		#self : OmReference [ '1121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ (arg1 value: tmp1 value: 1) size.\r  tmp2 columnNames: tmp1 keys.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy value: arg3) ].\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.212525-04:00' ],		#prior : OmReference [ '1121' ],		#self : OmReference [ '1122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self rowAt: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.217727-04:00' ],		#prior : OmReference [ '1122' ],		#self : OmReference [ '1123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class name.\r  tmp3 := arg1.\r  tmp3\r     nextPutAll: (tmp1 first isVowel ifTrue: [ #metaObject count: 2.\r              nil.\r              \'an \' ] ifFalse: [ #metaObject count: 3.\r              nil.\r              \'a \' ]);\r     nextPutAll: tmp1;\r     space;\r     nextPutAll: self dimensions asString',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.219925-04:00' ],		#prior : OmReference [ '1123' ],		#self : OmReference [ '1124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.222682-04:00' ],		#prior : OmReference [ '1124' ],		#self : OmReference [ '1125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #min',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.225678-04:00' ],		#prior : OmReference [ '1125' ],		#self : OmReference [ '1126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := FTTableMorph new.\r  tmp1\r     beResizable;\r     intercellSpacing: 1;\r     dataSource: (DataFrameFTData elements: self);\r     onAnnouncement: FTSelectionChanged do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (self rowAt: arg2 newSelectedIndexes first) inspect ].\r  tmp2 := #(\'#\') , self columnNames.\r  tmp1 columns: (tmp2 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              (FTColumn id: arg3) width: 100 ]).\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.227469-04:00' ],		#prior : OmReference [ '1126' ],		#self : OmReference [ '1127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 <= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.229539-04:00' ],		#prior : OmReference [ '1127' ],		#self : OmReference [ '1128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #mode',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.231355-04:00' ],		#prior : OmReference [ '1128' ],		#self : OmReference [ '1129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self columnNames indexOf: arg1 ifAbsent: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.233291-04:00' ],		#prior : OmReference [ '1129' ],		#self : OmReference [ '1130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withColumns: arg1.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.235531-04:00' ],		#prior : OmReference [ '1130' ],		#self : OmReference [ '1131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self columnNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents columnsAt: arg1) rowNames: self rowNames columnNames: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.237768-04:00' ],		#prior : OmReference [ '1131' ],		#self : OmReference [ '1132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeRowAt: arg1.\r  rowNames := rowNames copyWithoutIndex: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.239737-04:00' ],		#prior : OmReference [ '1132' ],		#self : OmReference [ '1133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRowNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.241756-04:00' ],		#prior : OmReference [ '1133' ],		#self : OmReference [ '1134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self rowNames at: tmp1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.244154-04:00' ],		#prior : OmReference [ '1134' ],		#self : OmReference [ '1135' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self row: arg3 put: arg4 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.245985-04:00' ],		#prior : OmReference [ '1135' ],		#self : OmReference [ '1136' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumnNamed: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.24806-04:00' ],		#prior : OmReference [ '1136' ],		#self : OmReference [ '1137' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #variance',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.249645-04:00' ],		#prior : OmReference [ '1137' ],		#self : OmReference [ '1138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self removeRowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.252954-04:00' ],		#prior : OmReference [ '1138' ],		#self : OmReference [ '1139' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents rowAt: arg1 put: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.254918-04:00' ],		#prior : OmReference [ '1139' ],		#self : OmReference [ '1140' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg1 name atPosition: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.258592-04:00' ],		#prior : OmReference [ '1140' ],		#self : OmReference [ '1141' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self columnAt: arg4 put: (arg3 at: arg5) ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.261453-04:00' ],		#prior : OmReference [ '1141' ],		#self : OmReference [ '1142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  arg1 rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (Array new: self columnNames size) , (arg1 row: arg2) asArray ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.263446-04:00' ],		#prior : OmReference [ '1142' ],		#self : OmReference [ '1143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #range',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.265905-04:00' ],		#prior : OmReference [ '1143' ],		#self : OmReference [ '1144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.267601-04:00' ],		#prior : OmReference [ '1144' ],		#self : OmReference [ '1145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeColumn: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.269598-04:00' ],		#prior : OmReference [ '1145' ],		#self : OmReference [ '1146' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows @ self numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.271505-04:00' ],		#prior : OmReference [ '1146' ],		#self : OmReference [ '1147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: arg1 with: arg2\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp2 := self column: arg2.\r  ^tmp1 crossTabulateWith: tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.273246-04:00' ],		#prior : OmReference [ '1147' ],		#self : OmReference [ '1148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self innerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.275188-04:00' ],		#prior : OmReference [ '1148' ],		#self : OmReference [ '1149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp2 > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := tmp2 ].\r  ^self rowsAt: (tmp2 - tmp1 + 1 to: tmp2)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.278745-04:00' ],		#prior : OmReference [ '1149' ],		#self : OmReference [ '1150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnAt: arg1.\r  self columnAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.280485-04:00' ],		#prior : OmReference [ '1150' ],		#self : OmReference [ '1151' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 >= arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.282482-04:00' ],		#prior : OmReference [ '1151' ],		#self : OmReference [ '1152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumnNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg2.\r  self removeRowsOfColumnElementsSatisfing: arg1 onColumn: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.284516-04:00' ],		#prior : OmReference [ '1152' ],		#self : OmReference [ '1153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of row names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All row names must be distinct\' ].\r  rowNames := arg1 asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.288003-04:00' ],		#prior : OmReference [ '1153' ],		#self : OmReference [ '1154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r  #metaObject count: 1.\r  nil.\r  self\r     rowNames: (1 to: self numberOfRows);\r     columnNames: (1 to: self numberOfColumns)',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.29101-04:00' ],		#prior : OmReference [ '1154' ],		#self : OmReference [ '1155' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataSeries withValues: (self columnNames collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              tmp3 := self column: arg2.\r              tmp3 perform: arg1 ]).\r  tmp1\r     name: arg1;\r     keys: self columnNames.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.29316-04:00' ],		#prior : OmReference [ '1155' ],		#self : OmReference [ '1156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents asArrayOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.295013-04:00' ],		#prior : OmReference [ '1156' ],		#self : OmReference [ '1157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfRowNamed: arg2 ].\r  ^self rowsAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.296607-04:00' ],		#prior : OmReference [ '1157' ],		#self : OmReference [ '1158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.298374-04:00' ],		#prior : OmReference [ '1158' ],		#self : OmReference [ '1159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeColumns: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.300805-04:00' ],		#prior : OmReference [ '1159' ],		#self : OmReference [ '1160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.303037-04:00' ],		#prior : OmReference [ '1160' ],		#self : OmReference [ '1161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 columnNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withColumns: arg1.\r  tmp1 columnNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.305461-04:00' ],		#prior : OmReference [ '1161' ],		#self : OmReference [ '1162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1 columnNames: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := arg2 size.\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp3\r     rowNames: arg1;\r     columnNames: arg2.\r  ^tmp3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.308029-04:00' ],		#prior : OmReference [ '1162' ],		#self : OmReference [ '1163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 columnNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           columnNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.309585-04:00' ],		#prior : OmReference [ '1163' ],		#self : OmReference [ '1164' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeRows: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.311261-04:00' ],		#prior : OmReference [ '1164' ],		#self : OmReference [ '1165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: 0 @ tmp1.\r  tmp2 columnNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.314271-04:00' ],		#prior : OmReference [ '1165' ],		#self : OmReference [ '1166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.3172-04:00' ],		#prior : OmReference [ '1166' ],		#self : OmReference [ '1167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg3 ]',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.319025-04:00' ],		#prior : OmReference [ '1167' ],		#self : OmReference [ '1168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withRows: arg1.\r  tmp1 rowNames: arg2.\r  ^tmp1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.320744-04:00' ],		#prior : OmReference [ '1168' ],		#self : OmReference [ '1169' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: tmp1 @ 0.\r  tmp2 rowNames: arg1.\r  ^tmp2',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.323012-04:00' ],		#prior : OmReference [ '1169' ],		#self : OmReference [ '1170' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r  #metaObject count: 1.\r  nil.\r  ^super new initialize',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.326706-04:00' ],		#prior : OmReference [ '1170' ],		#self : OmReference [ '1171' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^super new initialize: arg1',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:06.329589-04:00' ],		#prior : OmReference [ '1171' ],		#self : OmReference [ '1172' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^self new initializeContents: arg1 rowNames: arg2 columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:28',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.652357-04:00' ],		#prior : OmReference [ '1172' ],		#self : OmReference [ '1173' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrame\r\tinstanceVariableNames: \'contents rowNames columnNames\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrame,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #contents,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #rowNames,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #columnNames,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrame class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrame class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrame				},				#parent : @7,				#content : 'I am a tabular data structure designed for data analysis.\r\rI store data in a table and provide an API for querying and modifying that data. I know row and column names associated with the table of data, which allows you to treat rows as observations and columns as features and reference them by their names. I also know the type of data stored in each column. In general, I am similar to spreadsheets such as Excel or to data frames in other languages, for example pandas (Python) or R.\r\rThe efficient data structure that I use to store the data is defined by DataFrameInternal. However, you can think of me as a collection of rows. Every time you interact with one of my rows or columns it will be an instance of the DataSeries class. I use DataTypeInductor to induce types of my columns every time they are modified. DataPrettyPrinter allows you to print me as a beautiful string table, DataFrameFTData defines a data source based on myself that is used in FastTable to display me in the inspector. I provide aggregation and grouping fuctionality which is implemented using a helper class DataFrameGrouped.\r\rPublic API and Key Messages\r\r\tCreating empty data frame (class side):\r\t\t- new (empty data frame)\r\t\t- new: point (empty data frame with given dimensions)\r\t\t- withColumnNames: arrayOfColumnNames (empty data frame with column names)\r\t\t- withRowNames: arrayOfRowNames (empty data frame with row names)\r\t\t- withRowNames: arrayOfRowNames columnNames: arrayOfColumnNames (empty data frame with row and column names)\r\t\t\r\tCreating data frame from an array of columns (class side):\r\t\t- withColumns: arrayOfArrays\r\t\t- withColumns: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\t\t\r\tCreating data frame from an array of rows (class side):\r\t\t- withRows: arrayOfArrays\r\t\t- withRows: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\r\tConverting:\r\t\t- asArrayOfColumns\r\t\t- asArrayOfRows\r\r\tDimensions\r\t\t- numberOfColumns\r\t\t- numberOfRows\r\t\t- dimensions (a Point numberOfRows @ numberOfColumns)\r\t\t\r\tColumn and row names:\r\t\t- columnNames \r\t\t- columnNames: arrayOfNewNames\r\t\t- rowNames\r\t\t- rowNames: arrayOfNewNames\r\t\t\r\tColumn types\r\t\t- columnTypes (classes of values stored in each column)\r\r\tGetting columns:\r\t\t- column: columnName \r\t\t- columnAt: index\r\t\t- columns: arrayOfColumnNames\r\t\t- columnsAt: arrayOfIndices\r\t\t- columnsFrom: firstIndex to: lastIndex\r\t\t\r\tGetting rows:\r\t\t- row: rowName\r\t\t- rowAt: index\r\t\t- rows: arrayOfRowNames\r\t\t- rowsAt: arrayOfIndices\r\t\t- rowsFrom: firstIndex to: lastIndex\r\t\t- at: index (same as rowAt:)\r\t\t\r\tGetting a cell value:\r\t\t- at: rowIndex at: columnIndex\r\t\t\r\tSetting columns\r\t\t- column: columnName put: arrayOrDataSeries\r\t\t- columnAt: index put: arrayOrDataSeries\r\t\t\r\tSetting rows\r\t\t- row: rowName put: arrayOrDataSeries\r\t\t- rowAt: index put: arrayOrDataSeries\r\r\tSetting a cell value:\r\t\t- at: rowIndex at: columnIndex put: value\r\t\t\r\tHead and tail:\r\t\t- head (first 5 rows)\r\t\t- head: numberOfRows\r\t\t- tail (last 5 rows)\r\t\t- tail: numberOfRows\r\t\t\r\tAdding columns:\r\t\t- addColumn: dataSeries\r\t\t- addColumn: dataSeries atPosition: index\r\t\t- addColumn: array named: columnName\r\t\t- addColumn: array named: columnName atPosition: index\r\t\t- addEmptyColumnNamed: columnName\r\t\t- addEmptyColumnNamed: columnName atPosition: index\r\t\t\r\tAdding rows:\r\t\t- addRow: dataSeries\r\t\t- addRow: dataSeries atPosition: index\r\t\t- addRow: array named: rowName\r\t\t- addRow: array named: rowName atPosition: index\r\t\t- addEmptyRowNamed: rowName\r\t\t- addEmptyRowNamed: rowName atPosition: index\r\t\t- add: dataSeries (same as addRow:)\r\t\t\r\tRemoving columns:\r\t\t- removeColumn: columnName\r\t\t- removeColumnAt: index\r\t\t\r\tRemoving rows: \r\t\t- removeRow: rowName\r\t\t- removeRowAt: index\r\t\t- removeFirstRow\r\t\t- removeLastRow\r\t\t\r\tEnumerating (over rows):\r\t\t- collect: block\r\t\t- do: block \r\t\t- select: block\r\t\t- withKeyDo: block\r\t\t\r\tAggregating and grouping:\r\t\t- groupBy: columnName (returns an instance of DataFrameGrouped)\r\t\t- groupBy: columnName aggregate: selector (groups data and aggregates it with a given function)\r\t\t- group: columnNameOrArrayOfColumnNames by: columnName (groups part of data frame)\r\t\t\r\tApplying:\r\t\t- applyElementwise: block (to all columns)\r\t\t- toColumn: columnName applyElementwise: block\r\t\t- toColumnAt: index applyElementwise: block\r\t\t- toColumns: arrayOfColumnNames applyElementwise: block\r\t\t- toColumnsAt: arrayOfIndices applyElementwise: block\r\t\t\r\tSorting:\r\t\t- sortBy: columnName\r\t\t- sortDescendingBy: columnName\r\t\t- sortBy: columnName using: block\r\t\t\r\tStatistical functions (applied to quantitative columns):\r\t\t- min\r\t\t- max\r\t\t- range (max minus min)\r\t\t- average\r\t\t- mean\r\t\t- mode\r\t\t- median (second quartile)\r\t\t- first quartile\r\t\t- third quartile\r\t\t- interquartileRange (trird quartile minus first quartile)\r\t\t- stdev (standard deviation)\r\t\t- variance\r \rInternal Representation and Key Implementation Points.\r\r\tDataFrameInternal defines how data is stored inside me.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a tabular data structure designed for data analysis.\r\rI store data in a table and provide an API for querying and modifying that data. I know row and column names associated with the table of data, which allows you to treat rows as observations and columns as features and reference them by their names. I also know the type of data stored in each column. In general, I am similar to spreadsheets such as Excel or to data frames in other languages, for example pandas (Python) or R.\r\rThe efficient data structure that I use to store the data is defined by DataFrameInternal. However, you can think of me as a collection of rows. Every time you interact with one of my rows or columns it will be an instance of the DataSeries class. I use DataTypeInductor to induce types of my columns every time they are modified. DataPrettyPrinter allows you to print me as a beautiful string table, DataFrameFTData defines a data source based on myself that is used in FastTable to display me in the inspector. I provide aggregation and grouping fuctionality which is implemented using a helper class DataFrameGrouped.\r\rPublic API and Key Messages\r\r\tCreating empty data frame (class side):\r\t\t- new (empty data frame)\r\t\t- new: point (empty data frame with given dimensions)\r\t\t- withColumnNames: arrayOfColumnNames (empty data frame with column names)\r\t\t- withRowNames: arrayOfRowNames (empty data frame with row names)\r\t\t- withRowNames: arrayOfRowNames columnNames: arrayOfColumnNames (empty data frame with row and column names)\r\t\t\r\tCreating data frame from an array of columns (class side):\r\t\t- withColumns: arrayOfArrays\r\t\t- withColumns: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\t\t\r\tCreating data frame from an array of rows (class side):\r\t\t- withRows: arrayOfArrays\r\t\t- withRows: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\r\tConverting:\r\t\t- asArrayOfColumns\r\t\t- asArrayOfRows\r\r\tDimensions\r\t\t- numberOfColumns\r\t\t- numberOfRows\r\t\t- dimensions (a Point numberOfRows @ numberOfColumns)\r\t\t\r\tColumn and row names:\r\t\t- columnNames \r\t\t- columnNames: arrayOfNewNames\r\t\t- rowNames\r\t\t- rowNames: arrayOfNewNames\r\t\t\r\tColumn types\r\t\t- columnTypes (classes of values stored in each column)\r\r\tGetting columns:\r\t\t- column: columnName \r\t\t- columnAt: index\r\t\t- columns: arrayOfColumnNames\r\t\t- columnsAt: arrayOfIndices\r\t\t- columnsFrom: firstIndex to: lastIndex\r\t\t\r\tGetting rows:\r\t\t- row: rowName\r\t\t- rowAt: index\r\t\t- rows: arrayOfRowNames\r\t\t- rowsAt: arrayOfIndices\r\t\t- rowsFrom: firstIndex to: lastIndex\r\t\t- at: index (same as rowAt:)\r\t\t\r\tGetting a cell value:\r\t\t- at: rowIndex at: columnIndex\r\t\t\r\tSetting columns\r\t\t- column: columnName put: arrayOrDataSeries\r\t\t- columnAt: index put: arrayOrDataSeries\r\t\t\r\tSetting rows\r\t\t- row: rowName put: arrayOrDataSeries\r\t\t- rowAt: index put: arrayOrDataSeries\r\r\tSetting a cell value:\r\t\t- at: rowIndex at: columnIndex put: value\r\t\t\r\tHead and tail:\r\t\t- head (first 5 rows)\r\t\t- head: numberOfRows\r\t\t- tail (last 5 rows)\r\t\t- tail: numberOfRows\r\t\t\r\tAdding columns:\r\t\t- addColumn: dataSeries\r\t\t- addColumn: dataSeries atPosition: index\r\t\t- addColumn: array named: columnName\r\t\t- addColumn: array named: columnName atPosition: index\r\t\t- addEmptyColumnNamed: columnName\r\t\t- addEmptyColumnNamed: columnName atPosition: index\r\t\t\r\tAdding rows:\r\t\t- addRow: dataSeries\r\t\t- addRow: dataSeries atPosition: index\r\t\t- addRow: array named: rowName\r\t\t- addRow: array named: rowName atPosition: index\r\t\t- addEmptyRowNamed: rowName\r\t\t- addEmptyRowNamed: rowName atPosition: index\r\t\t- add: dataSeries (same as addRow:)\r\t\t\r\tRemoving columns:\r\t\t- removeColumn: columnName\r\t\t- removeColumnAt: index\r\t\t\r\tRemoving rows: \r\t\t- removeRow: rowName\r\t\t- removeRowAt: index\r\t\t- removeFirstRow\r\t\t- removeLastRow\r\t\t\r\tEnumerating (over rows):\r\t\t- collect: block\r\t\t- do: block \r\t\t- select: block\r\t\t- withKeyDo: block\r\t\t\r\tAggregating and grouping:\r\t\t- groupBy: columnName (returns an instance of DataFrameGrouped)\r\t\t- groupBy: columnName aggregate: selector (groups data and aggregates it with a given function)\r\t\t- group: columnNameOrArrayOfColumnNames by: columnName (groups part of data frame)\r\t\t\r\tApplying:\r\t\t- applyElementwise: block (to all columns)\r\t\t- toColumn: columnName applyElementwise: block\r\t\t- toColumnAt: index applyElementwise: block\r\t\t- toColumns: arrayOfColumnNames applyElementwise: block\r\t\t- toColumnsAt: arrayOfIndices applyElementwise: block\r\t\t\r\tSorting:\r\t\t- sortBy: columnName\r\t\t- sortDescendingBy: columnName\r\t\t- sortBy: columnName using: block\r\t\t\r\tStatistical functions (applied to quantitative columns):\r\t\t- min\r\t\t- max\r\t\t- range (max minus min)\r\t\t- average\r\t\t- mean\r\t\t- mode\r\t\t- median (second quartile)\r\t\t- first quartile\r\t\t- third quartile\r\t\t- interquartileRange (trird quartile minus first quartile)\r\t\t- stdev (standard deviation)\r\t\t- variance\r \rInternal Representation and Key Implementation Points.\r\r\tDataFrameInternal defines how data is stored inside me.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.65406-04:00' ],		#prior : OmReference [ '1173' ],		#self : OmReference [ '1174' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrame\r\tinstanceVariableNames: \'contents rowNames columnNames\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrame,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #contents,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #rowNames,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #columnNames,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrame class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrame class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrame				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I am a tabular data structure designed for data analysis.\r\rI store data in a table and provide an API for querying and modifying that data. I know row and column names associated with the table of data, which allows you to treat rows as observations and columns as features and reference them by their names. I also know the type of data stored in each column. In general, I am similar to spreadsheets such as Excel or to data frames in other languages, for example pandas (Python) or R.\r\rThe efficient data structure that I use to store the data is defined by DataFrameInternal. However, you can think of me as a collection of rows. Every time you interact with one of my rows or columns it will be an instance of the DataSeries class. I use DataTypeInductor to induce types of my columns every time they are modified. DataPrettyPrinter allows you to print me as a beautiful string table, DataFrameFTData defines a data source based on myself that is used in FastTable to display me in the inspector. I provide aggregation and grouping fuctionality which is implemented using a helper class DataFrameGrouped.\r\rPublic API and Key Messages\r\r\tCreating empty data frame (class side):\r\t\t- new (empty data frame)\r\t\t- new: point (empty data frame with given dimensions)\r\t\t- withColumnNames: arrayOfColumnNames (empty data frame with column names)\r\t\t- withRowNames: arrayOfRowNames (empty data frame with row names)\r\t\t- withRowNames: arrayOfRowNames columnNames: arrayOfColumnNames (empty data frame with row and column names)\r\t\t\r\tCreating data frame from an array of columns (class side):\r\t\t- withColumns: arrayOfArrays\r\t\t- withColumns: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\t\t\r\tCreating data frame from an array of rows (class side):\r\t\t- withRows: arrayOfArrays\r\t\t- withRows: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\r\tConverting:\r\t\t- asArrayOfColumns\r\t\t- asArrayOfRows\r\r\tDimensions\r\t\t- numberOfColumns\r\t\t- numberOfRows\r\t\t- dimensions (a Point numberOfRows @ numberOfColumns)\r\t\t\r\tColumn and row names:\r\t\t- columnNames \r\t\t- columnNames: arrayOfNewNames\r\t\t- rowNames\r\t\t- rowNames: arrayOfNewNames\r\t\t\r\tColumn types\r\t\t- columnTypes (classes of values stored in each column)\r\r\tGetting columns:\r\t\t- column: columnName \r\t\t- columnAt: index\r\t\t- columns: arrayOfColumnNames\r\t\t- columnsAt: arrayOfIndices\r\t\t- columnsFrom: firstIndex to: lastIndex\r\t\t\r\tGetting rows:\r\t\t- row: rowName\r\t\t- rowAt: index\r\t\t- rows: arrayOfRowNames\r\t\t- rowsAt: arrayOfIndices\r\t\t- rowsFrom: firstIndex to: lastIndex\r\t\t- at: index (same as rowAt:)\r\t\t\r\tGetting a cell value:\r\t\t- at: rowIndex at: columnIndex\r\t\t\r\tSetting columns\r\t\t- column: columnName put: arrayOrDataSeries\r\t\t- columnAt: index put: arrayOrDataSeries\r\t\t\r\tSetting rows\r\t\t- row: rowName put: arrayOrDataSeries\r\t\t- rowAt: index put: arrayOrDataSeries\r\r\tSetting a cell value:\r\t\t- at: rowIndex at: columnIndex put: value\r\t\t\r\tHead and tail:\r\t\t- head (first 5 rows)\r\t\t- head: numberOfRows\r\t\t- tail (last 5 rows)\r\t\t- tail: numberOfRows\r\t\t\r\tAdding columns:\r\t\t- addColumn: dataSeries\r\t\t- addColumn: dataSeries atPosition: index\r\t\t- addColumn: array named: columnName\r\t\t- addColumn: array named: columnName atPosition: index\r\t\t- addEmptyColumnNamed: columnName\r\t\t- addEmptyColumnNamed: columnName atPosition: index\r\t\t\r\tAdding rows:\r\t\t- addRow: dataSeries\r\t\t- addRow: dataSeries atPosition: index\r\t\t- addRow: array named: rowName\r\t\t- addRow: array named: rowName atPosition: index\r\t\t- addEmptyRowNamed: rowName\r\t\t- addEmptyRowNamed: rowName atPosition: index\r\t\t- add: dataSeries (same as addRow:)\r\t\t\r\tRemoving columns:\r\t\t- removeColumn: columnName\r\t\t- removeColumnAt: index\r\t\t\r\tRemoving rows: \r\t\t- removeRow: rowName\r\t\t- removeRowAt: index\r\t\t- removeFirstRow\r\t\t- removeLastRow\r\t\t\r\tEnumerating (over rows):\r\t\t- collect: block\r\t\t- do: block \r\t\t- select: block\r\t\t- withKeyDo: block\r\t\t\r\tAggregating and grouping:\r\t\t- groupBy: columnName (returns an instance of DataFrameGrouped)\r\t\t- groupBy: columnName aggregate: selector (groups data and aggregates it with a given function)\r\t\t- group: columnNameOrArrayOfColumnNames by: columnName (groups part of data frame)\r\t\t\r\tApplying:\r\t\t- applyElementwise: block (to all columns)\r\t\t- toColumn: columnName applyElementwise: block\r\t\t- toColumnAt: index applyElementwise: block\r\t\t- toColumns: arrayOfColumnNames applyElementwise: block\r\t\t- toColumnsAt: arrayOfIndices applyElementwise: block\r\t\t\r\tSorting:\r\t\t- sortBy: columnName\r\t\t- sortDescendingBy: columnName\r\t\t- sortBy: columnName using: block\r\t\t\r\tStatistical functions (applied to quantitative columns):\r\t\t- min\r\t\t- max\r\t\t- range (max minus min)\r\t\t- average\r\t\t- mean\r\t\t- mode\r\t\t- median (second quartile)\r\t\t- first quartile\r\t\t- third quartile\r\t\t- interquartileRange (trird quartile minus first quartile)\r\t\t- stdev (standard deviation)\r\t\t- variance\r \rInternal Representation and Key Implementation Points.\r\r\tDataFrameInternal defines how data is stored inside me.',		#newComment : '',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.655238-04:00' ],		#prior : OmReference [ '1174' ],		#self : OmReference [ '1175' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrameInternal\r\tinstanceVariableNames: \'contents\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrameInternal,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrameInternal					},					#name : #contents,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrameInternal class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrameInternal class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrameInternal				},				#parent : @7,				#content : 'I am  the internal representation of a DataFrame. I store the data very efficiently and allow you to access it very quickly. ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am  the internal representation of a DataFrame. I store the data very efficiently and allow you to access it very quickly. ',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.656185-04:00' ],		#prior : OmReference [ '1175' ],		#self : OmReference [ '1176' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrameInternal\r\tinstanceVariableNames: \'contents\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrameInternal,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrameInternal					},					#name : #contents,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrameInternal class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrameInternal class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrameInternal				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I am  the internal representation of a DataFrame. I store the data very efficiently and allow you to access it very quickly. ',		#newComment : '',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.707142-04:00' ],		#prior : OmReference [ '1176' ],		#self : OmReference [ '1177' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrame\r\tinstanceVariableNames: \'contents rowNames columnNames\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrame,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #contents,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #rowNames,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #columnNames,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrame class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrame class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrame				},				#parent : @7,				#content : 'I am a tabular data structure designed for data analysis.\r\rI store data in a table and provide an API for querying and modifying that data. I know row and column names associated with the table of data, which allows you to treat rows as observations and columns as features and reference them by their names. I also know the type of data stored in each column. In general, I am similar to spreadsheets such as Excel or to data frames in other languages, for example pandas (Python) or R.\r\rThe efficient data structure that I use to store the data is defined by DataFrameInternal. However, you can think of me as a collection of rows. Every time you interact with one of my rows or columns it will be an instance of the DataSeries class. I use DataTypeInductor to induce types of my columns every time they are modified. DataPrettyPrinter allows you to print me as a beautiful string table, DataFrameFTData defines a data source based on myself that is used in FastTable to display me in the inspector. I provide aggregation and grouping fuctionality which is implemented using a helper class DataFrameGrouped.\r\rPublic API and Key Messages\r\r\tCreating empty data frame (class side):\r\t\t- new (empty data frame)\r\t\t- new: point (empty data frame with given dimensions)\r\t\t- withColumnNames: arrayOfColumnNames (empty data frame with column names)\r\t\t- withRowNames: arrayOfRowNames (empty data frame with row names)\r\t\t- withRowNames: arrayOfRowNames columnNames: arrayOfColumnNames (empty data frame with row and column names)\r\t\t\r\tCreating data frame from an array of columns (class side):\r\t\t- withColumns: arrayOfArrays\r\t\t- withColumns: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\t\t\r\tCreating data frame from an array of rows (class side):\r\t\t- withRows: arrayOfArrays\r\t\t- withRows: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\r\tConverting:\r\t\t- asArrayOfColumns\r\t\t- asArrayOfRows\r\r\tDimensions\r\t\t- numberOfColumns\r\t\t- numberOfRows\r\t\t- dimensions (a Point numberOfRows @ numberOfColumns)\r\t\t\r\tColumn and row names:\r\t\t- columnNames \r\t\t- columnNames: arrayOfNewNames\r\t\t- rowNames\r\t\t- rowNames: arrayOfNewNames\r\t\t\r\tColumn types\r\t\t- columnTypes (classes of values stored in each column)\r\r\tGetting columns:\r\t\t- column: columnName \r\t\t- columnAt: index\r\t\t- columns: arrayOfColumnNames\r\t\t- columnsAt: arrayOfIndices\r\t\t- columnsFrom: firstIndex to: lastIndex\r\t\t\r\tGetting rows:\r\t\t- row: rowName\r\t\t- rowAt: index\r\t\t- rows: arrayOfRowNames\r\t\t- rowsAt: arrayOfIndices\r\t\t- rowsFrom: firstIndex to: lastIndex\r\t\t- at: index (same as rowAt:)\r\t\t\r\tGetting a cell value:\r\t\t- at: rowIndex at: columnIndex\r\t\t\r\tSetting columns\r\t\t- column: columnName put: arrayOrDataSeries\r\t\t- columnAt: index put: arrayOrDataSeries\r\t\t\r\tSetting rows\r\t\t- row: rowName put: arrayOrDataSeries\r\t\t- rowAt: index put: arrayOrDataSeries\r\r\tSetting a cell value:\r\t\t- at: rowIndex at: columnIndex put: value\r\t\t\r\tHead and tail:\r\t\t- head (first 5 rows)\r\t\t- head: numberOfRows\r\t\t- tail (last 5 rows)\r\t\t- tail: numberOfRows\r\t\t\r\tAdding columns:\r\t\t- addColumn: dataSeries\r\t\t- addColumn: dataSeries atPosition: index\r\t\t- addColumn: array named: columnName\r\t\t- addColumn: array named: columnName atPosition: index\r\t\t- addEmptyColumnNamed: columnName\r\t\t- addEmptyColumnNamed: columnName atPosition: index\r\t\t\r\tAdding rows:\r\t\t- addRow: dataSeries\r\t\t- addRow: dataSeries atPosition: index\r\t\t- addRow: array named: rowName\r\t\t- addRow: array named: rowName atPosition: index\r\t\t- addEmptyRowNamed: rowName\r\t\t- addEmptyRowNamed: rowName atPosition: index\r\t\t- add: dataSeries (same as addRow:)\r\t\t\r\tRemoving columns:\r\t\t- removeColumn: columnName\r\t\t- removeColumnAt: index\r\t\t\r\tRemoving rows: \r\t\t- removeRow: rowName\r\t\t- removeRowAt: index\r\t\t- removeFirstRow\r\t\t- removeLastRow\r\t\t\r\tEnumerating (over rows):\r\t\t- collect: block\r\t\t- do: block \r\t\t- select: block\r\t\t- withKeyDo: block\r\t\t\r\tAggregating and grouping:\r\t\t- groupBy: columnName (returns an instance of DataFrameGrouped)\r\t\t- groupBy: columnName aggregate: selector (groups data and aggregates it with a given function)\r\t\t- group: columnNameOrArrayOfColumnNames by: columnName (groups part of data frame)\r\t\t\r\tApplying:\r\t\t- applyElementwise: block (to all columns)\r\t\t- toColumn: columnName applyElementwise: block\r\t\t- toColumnAt: index applyElementwise: block\r\t\t- toColumns: arrayOfColumnNames applyElementwise: block\r\t\t- toColumnsAt: arrayOfIndices applyElementwise: block\r\t\t\r\tSorting:\r\t\t- sortBy: columnName\r\t\t- sortDescendingBy: columnName\r\t\t- sortBy: columnName using: block\r\t\t\r\tStatistical functions (applied to quantitative columns):\r\t\t- min\r\t\t- max\r\t\t- range (max minus min)\r\t\t- average\r\t\t- mean\r\t\t- mode\r\t\t- median (second quartile)\r\t\t- first quartile\r\t\t- third quartile\r\t\t- interquartileRange (trird quartile minus first quartile)\r\t\t- stdev (standard deviation)\r\t\t- variance\r \rInternal Representation and Key Implementation Points.\r\r\tDataFrameInternal defines how data is stored inside me.',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am a tabular data structure designed for data analysis.\r\rI store data in a table and provide an API for querying and modifying that data. I know row and column names associated with the table of data, which allows you to treat rows as observations and columns as features and reference them by their names. I also know the type of data stored in each column. In general, I am similar to spreadsheets such as Excel or to data frames in other languages, for example pandas (Python) or R.\r\rThe efficient data structure that I use to store the data is defined by DataFrameInternal. However, you can think of me as a collection of rows. Every time you interact with one of my rows or columns it will be an instance of the DataSeries class. I use DataTypeInductor to induce types of my columns every time they are modified. DataPrettyPrinter allows you to print me as a beautiful string table, DataFrameFTData defines a data source based on myself that is used in FastTable to display me in the inspector. I provide aggregation and grouping fuctionality which is implemented using a helper class DataFrameGrouped.\r\rPublic API and Key Messages\r\r\tCreating empty data frame (class side):\r\t\t- new (empty data frame)\r\t\t- new: point (empty data frame with given dimensions)\r\t\t- withColumnNames: arrayOfColumnNames (empty data frame with column names)\r\t\t- withRowNames: arrayOfRowNames (empty data frame with row names)\r\t\t- withRowNames: arrayOfRowNames columnNames: arrayOfColumnNames (empty data frame with row and column names)\r\t\t\r\tCreating data frame from an array of columns (class side):\r\t\t- withColumns: arrayOfArrays\r\t\t- withColumns: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\t\t\r\tCreating data frame from an array of rows (class side):\r\t\t- withRows: arrayOfArrays\r\t\t- withRows: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\r\tConverting:\r\t\t- asArrayOfColumns\r\t\t- asArrayOfRows\r\r\tDimensions\r\t\t- numberOfColumns\r\t\t- numberOfRows\r\t\t- dimensions (a Point numberOfRows @ numberOfColumns)\r\t\t\r\tColumn and row names:\r\t\t- columnNames \r\t\t- columnNames: arrayOfNewNames\r\t\t- rowNames\r\t\t- rowNames: arrayOfNewNames\r\t\t\r\tColumn types\r\t\t- columnTypes (classes of values stored in each column)\r\r\tGetting columns:\r\t\t- column: columnName \r\t\t- columnAt: index\r\t\t- columns: arrayOfColumnNames\r\t\t- columnsAt: arrayOfIndices\r\t\t- columnsFrom: firstIndex to: lastIndex\r\t\t\r\tGetting rows:\r\t\t- row: rowName\r\t\t- rowAt: index\r\t\t- rows: arrayOfRowNames\r\t\t- rowsAt: arrayOfIndices\r\t\t- rowsFrom: firstIndex to: lastIndex\r\t\t- at: index (same as rowAt:)\r\t\t\r\tGetting a cell value:\r\t\t- at: rowIndex at: columnIndex\r\t\t\r\tSetting columns\r\t\t- column: columnName put: arrayOrDataSeries\r\t\t- columnAt: index put: arrayOrDataSeries\r\t\t\r\tSetting rows\r\t\t- row: rowName put: arrayOrDataSeries\r\t\t- rowAt: index put: arrayOrDataSeries\r\r\tSetting a cell value:\r\t\t- at: rowIndex at: columnIndex put: value\r\t\t\r\tHead and tail:\r\t\t- head (first 5 rows)\r\t\t- head: numberOfRows\r\t\t- tail (last 5 rows)\r\t\t- tail: numberOfRows\r\t\t\r\tAdding columns:\r\t\t- addColumn: dataSeries\r\t\t- addColumn: dataSeries atPosition: index\r\t\t- addColumn: array named: columnName\r\t\t- addColumn: array named: columnName atPosition: index\r\t\t- addEmptyColumnNamed: columnName\r\t\t- addEmptyColumnNamed: columnName atPosition: index\r\t\t\r\tAdding rows:\r\t\t- addRow: dataSeries\r\t\t- addRow: dataSeries atPosition: index\r\t\t- addRow: array named: rowName\r\t\t- addRow: array named: rowName atPosition: index\r\t\t- addEmptyRowNamed: rowName\r\t\t- addEmptyRowNamed: rowName atPosition: index\r\t\t- add: dataSeries (same as addRow:)\r\t\t\r\tRemoving columns:\r\t\t- removeColumn: columnName\r\t\t- removeColumnAt: index\r\t\t\r\tRemoving rows: \r\t\t- removeRow: rowName\r\t\t- removeRowAt: index\r\t\t- removeFirstRow\r\t\t- removeLastRow\r\t\t\r\tEnumerating (over rows):\r\t\t- collect: block\r\t\t- do: block \r\t\t- select: block\r\t\t- withKeyDo: block\r\t\t\r\tAggregating and grouping:\r\t\t- groupBy: columnName (returns an instance of DataFrameGrouped)\r\t\t- groupBy: columnName aggregate: selector (groups data and aggregates it with a given function)\r\t\t- group: columnNameOrArrayOfColumnNames by: columnName (groups part of data frame)\r\t\t\r\tApplying:\r\t\t- applyElementwise: block (to all columns)\r\t\t- toColumn: columnName applyElementwise: block\r\t\t- toColumnAt: index applyElementwise: block\r\t\t- toColumns: arrayOfColumnNames applyElementwise: block\r\t\t- toColumnsAt: arrayOfIndices applyElementwise: block\r\t\t\r\tSorting:\r\t\t- sortBy: columnName\r\t\t- sortDescendingBy: columnName\r\t\t- sortBy: columnName using: block\r\t\t\r\tStatistical functions (applied to quantitative columns):\r\t\t- min\r\t\t- max\r\t\t- range (max minus min)\r\t\t- average\r\t\t- mean\r\t\t- mode\r\t\t- median (second quartile)\r\t\t- first quartile\r\t\t- third quartile\r\t\t- interquartileRange (trird quartile minus first quartile)\r\t\t- stdev (standard deviation)\r\t\t- variance\r \rInternal Representation and Key Implementation Points.\r\r\tDataFrameInternal defines how data is stored inside me.',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.780144-04:00' ],		#prior : OmReference [ '1177' ],		#self : OmReference [ '1178' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrame\r\tinstanceVariableNames: \'contents rowNames columnNames\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrame,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #contents,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #rowNames,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrame					},					#name : #columnNames,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrame class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrame class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrame				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I am a tabular data structure designed for data analysis.\r\rI store data in a table and provide an API for querying and modifying that data. I know row and column names associated with the table of data, which allows you to treat rows as observations and columns as features and reference them by their names. I also know the type of data stored in each column. In general, I am similar to spreadsheets such as Excel or to data frames in other languages, for example pandas (Python) or R.\r\rThe efficient data structure that I use to store the data is defined by DataFrameInternal. However, you can think of me as a collection of rows. Every time you interact with one of my rows or columns it will be an instance of the DataSeries class. I use DataTypeInductor to induce types of my columns every time they are modified. DataPrettyPrinter allows you to print me as a beautiful string table, DataFrameFTData defines a data source based on myself that is used in FastTable to display me in the inspector. I provide aggregation and grouping fuctionality which is implemented using a helper class DataFrameGrouped.\r\rPublic API and Key Messages\r\r\tCreating empty data frame (class side):\r\t\t- new (empty data frame)\r\t\t- new: point (empty data frame with given dimensions)\r\t\t- withColumnNames: arrayOfColumnNames (empty data frame with column names)\r\t\t- withRowNames: arrayOfRowNames (empty data frame with row names)\r\t\t- withRowNames: arrayOfRowNames columnNames: arrayOfColumnNames (empty data frame with row and column names)\r\t\t\r\tCreating data frame from an array of columns (class side):\r\t\t- withColumns: arrayOfArrays\r\t\t- withColumns: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withColumns: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\t\t\r\tCreating data frame from an array of rows (class side):\r\t\t- withRows: arrayOfArrays\r\t\t- withRows: arrayOfArrays columnNames: arrayOfColumnNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames\r\t\t- withRows: arrayOfArrays rowNames: arrayOfRowNames columnNames: arrayOfColumnNames\r\r\tConverting:\r\t\t- asArrayOfColumns\r\t\t- asArrayOfRows\r\r\tDimensions\r\t\t- numberOfColumns\r\t\t- numberOfRows\r\t\t- dimensions (a Point numberOfRows @ numberOfColumns)\r\t\t\r\tColumn and row names:\r\t\t- columnNames \r\t\t- columnNames: arrayOfNewNames\r\t\t- rowNames\r\t\t- rowNames: arrayOfNewNames\r\t\t\r\tColumn types\r\t\t- columnTypes (classes of values stored in each column)\r\r\tGetting columns:\r\t\t- column: columnName \r\t\t- columnAt: index\r\t\t- columns: arrayOfColumnNames\r\t\t- columnsAt: arrayOfIndices\r\t\t- columnsFrom: firstIndex to: lastIndex\r\t\t\r\tGetting rows:\r\t\t- row: rowName\r\t\t- rowAt: index\r\t\t- rows: arrayOfRowNames\r\t\t- rowsAt: arrayOfIndices\r\t\t- rowsFrom: firstIndex to: lastIndex\r\t\t- at: index (same as rowAt:)\r\t\t\r\tGetting a cell value:\r\t\t- at: rowIndex at: columnIndex\r\t\t\r\tSetting columns\r\t\t- column: columnName put: arrayOrDataSeries\r\t\t- columnAt: index put: arrayOrDataSeries\r\t\t\r\tSetting rows\r\t\t- row: rowName put: arrayOrDataSeries\r\t\t- rowAt: index put: arrayOrDataSeries\r\r\tSetting a cell value:\r\t\t- at: rowIndex at: columnIndex put: value\r\t\t\r\tHead and tail:\r\t\t- head (first 5 rows)\r\t\t- head: numberOfRows\r\t\t- tail (last 5 rows)\r\t\t- tail: numberOfRows\r\t\t\r\tAdding columns:\r\t\t- addColumn: dataSeries\r\t\t- addColumn: dataSeries atPosition: index\r\t\t- addColumn: array named: columnName\r\t\t- addColumn: array named: columnName atPosition: index\r\t\t- addEmptyColumnNamed: columnName\r\t\t- addEmptyColumnNamed: columnName atPosition: index\r\t\t\r\tAdding rows:\r\t\t- addRow: dataSeries\r\t\t- addRow: dataSeries atPosition: index\r\t\t- addRow: array named: rowName\r\t\t- addRow: array named: rowName atPosition: index\r\t\t- addEmptyRowNamed: rowName\r\t\t- addEmptyRowNamed: rowName atPosition: index\r\t\t- add: dataSeries (same as addRow:)\r\t\t\r\tRemoving columns:\r\t\t- removeColumn: columnName\r\t\t- removeColumnAt: index\r\t\t\r\tRemoving rows: \r\t\t- removeRow: rowName\r\t\t- removeRowAt: index\r\t\t- removeFirstRow\r\t\t- removeLastRow\r\t\t\r\tEnumerating (over rows):\r\t\t- collect: block\r\t\t- do: block \r\t\t- select: block\r\t\t- withKeyDo: block\r\t\t\r\tAggregating and grouping:\r\t\t- groupBy: columnName (returns an instance of DataFrameGrouped)\r\t\t- groupBy: columnName aggregate: selector (groups data and aggregates it with a given function)\r\t\t- group: columnNameOrArrayOfColumnNames by: columnName (groups part of data frame)\r\t\t\r\tApplying:\r\t\t- applyElementwise: block (to all columns)\r\t\t- toColumn: columnName applyElementwise: block\r\t\t- toColumnAt: index applyElementwise: block\r\t\t- toColumns: arrayOfColumnNames applyElementwise: block\r\t\t- toColumnsAt: arrayOfIndices applyElementwise: block\r\t\t\r\tSorting:\r\t\t- sortBy: columnName\r\t\t- sortDescendingBy: columnName\r\t\t- sortBy: columnName using: block\r\t\t\r\tStatistical functions (applied to quantitative columns):\r\t\t- min\r\t\t- max\r\t\t- range (max minus min)\r\t\t- average\r\t\t- mean\r\t\t- mode\r\t\t- median (second quartile)\r\t\t- first quartile\r\t\t- third quartile\r\t\t- interquartileRange (trird quartile minus first quartile)\r\t\t- stdev (standard deviation)\r\t\t- variance\r \rInternal Representation and Key Implementation Points.\r\r\tDataFrameInternal defines how data is stored inside me.',		#newComment : '',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.781784-04:00' ],		#prior : OmReference [ '1178' ],		#self : OmReference [ '1179' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrameInternal\r\tinstanceVariableNames: \'contents\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrameInternal,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrameInternal					},					#name : #contents,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrameInternal class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrameInternal class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrameInternal				},				#parent : @7,				#content : 'I am  the internal representation of a DataFrame. I store the data very efficiently and allow you to access it very quickly. ',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I am  the internal representation of a DataFrame. I store the data very efficiently and allow you to access it very quickly. ',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.801662-04:00' ],		#prior : OmReference [ '1179' ],		#self : OmReference [ '1180' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'Collection',				#definitionSource : 'Collection subclass: #DataFrameInternal\r\tinstanceVariableNames: \'contents\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'DataFrame-Core\''			},			#name : #DataFrameInternal,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #DataFrameInternal					},					#name : #contents,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DataFrameInternal class\r\tinstanceVariableNames: \'\''				},				#name : #'DataFrameInternal class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #DataFrameInternal				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #DataFrame-Core,			#package : #DataFrame,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I am  the internal representation of a DataFrame. I store the data very efficiently and allow you to access it very quickly. ',		#newComment : '',		#oldStamp : '',		#newStamp : ''	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.84274-04:00' ],		#prior : OmReference [ '1180' ],		#self : OmReference [ '1181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 ifEmpty: [ #metaObject count: 2.\r        nil.\r        ^self new ].\r  arg1 species == self ifTrue: [ #metaObject count: 3.\r        nil.\r        ^super newFrom: arg1 associations ].\r  ^super newFrom: ((arg1 anyOne respondsTo: #key) ifTrue: [ #metaObject count: 4.\r              nil.\r              arg1 ] ifFalse: [ #metaObject count: 5.\r              nil.\r              arg1 withIndexCollect: [:arg2 :arg3 |  #metaObject count: 6.\r                    nil.\r                    arg3 -> arg2 ] ])',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: aCollection\r\taCollection ifEmpty: [ ^ self new ].\r\r\t(aCollection species == self)\r\t\tifTrue: [ ^ super newFrom: aCollection associations ].\r\t\t\r\t"If it\'s a collection of associations use the superclass implementation"\r\t^ super newFrom: ((aCollection anyOne respondsTo: #key)\r\t\tifTrue: [ aCollection ]\r\t\tifFalse: [ aCollection withIndexCollect: [ :each :i | i -> each ] ]).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.843598-04:00' ],		#prior : OmReference [ '1181' ],		#self : OmReference [ '1182' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2\r  #metaObject count: 1.\r  nil.\r  ^self newFromKeys: arg1 andValues: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: keys values: values\r\t^ self newFromKeys: keys andValues: values ',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.844246-04:00' ],		#prior : OmReference [ '1182' ],		#self : OmReference [ '1183' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: arg1 values: arg2 name: arg3\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self withKeys: arg1 values: arg2.\r  tmp2 name: arg3.\r  ^tmp2 yourself',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: keys values: values name: aName\r\t^ (self withKeys: keys values: values) name: aName; yourself',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.844769-04:00' ],		#prior : OmReference [ '1183' ],		#self : OmReference [ '1184' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  ^self withKeys: tmp1 values: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: values\r\t| keys |\r\tkeys := (1 to: values size) asArray. \r\t^ self withKeys: keys values: values ',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.845403-04:00' ],		#prior : OmReference [ '1184' ],		#self : OmReference [ '1185' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: arg1 name: arg2\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: arg1 size) asArray.\r  tmp3 := self withKeys: tmp1 values: arg1.\r  tmp3 name: arg2.\r  ^tmp3 yourself',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: values name: aName\r\t| keys |\r\tkeys := (1 to: values size) asArray. \r\t^ (self withKeys: keys values: values) name: aName; yourself',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.845951-04:00' ],		#prior : OmReference [ '1185' ],		#self : OmReference [ '1186' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg\r\t"Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r\r\t^ arg adaptToCollection: self andSend: #<\r\t',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.84643-04:00' ],		#prior : OmReference [ '1186' ],		#self : OmReference [ '1187' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #<=',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg\r\t"Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r\r\t^ arg adaptToCollection: self andSend: #<=',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.846925-04:00' ],		#prior : OmReference [ '1187' ],		#self : OmReference [ '1188' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  super = arg1 ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  ^arg1 name = self name and: [ #metaObject count: 3.\r        nil.\r        arg1 keys = self keys ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r\t(super = anObject)\r\t\tifFalse: [ ^ false ].\r\t\t\r\t^ anObject name = self name\r\t\t"order of keys"\r\t\tand: [ anObject keys = self keys ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.84739-04:00' ],		#prior : OmReference [ '1188' ],		#self : OmReference [ '1189' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg\r\t"Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r\r\t^ arg adaptToCollection: self andSend: #>\r\t',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.847976-04:00' ],		#prior : OmReference [ '1189' ],		#self : OmReference [ '1190' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg1\r  #metaObject count: 1.\r  nil.\r  ^arg1 adaptToCollection: self andSend: #>=',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg\r\t"Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r\r\t^ arg adaptToCollection: self andSend: #>=\r\t',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.848543-04:00' ],		#prior : OmReference [ '1190' ],		#self : OmReference [ '1191' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: arg1 andSend: arg2\r  #metaObject count: 1.\r  nil.\r  (arg1 isSequenceable and: [ #metaObject count: 2.\r        nil.\r        self isSequenceable ]) ifFalse: [ #metaObject count: 3.\r        nil.\r        self error: \'Only sequenceable collections may be combined arithmetically\' ].\r  ^arg1 withSeries: self collect: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        arg3 perform: arg2 with: arg4 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: rcvr andSend: selector\r\t"If I am involved in arithmetic with another Collection, return a Collection of\r\tthe results of each element combined with the scalar in that expression."\r\r\t(rcvr isSequenceable and: [ self isSequenceable ]) ifFalse:\r\t\t[self error: \'Only sequenceable collections may be combined arithmetically\'].\r\t^ rcvr withSeries: self collect:\r\t\t[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.849031-04:00' ],		#prior : OmReference [ '1191' ],		#self : OmReference [ '1192' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  #metaObject count: 1.\r  nil.\r  ^DataFrame withColumns: {self values} rowNames: self keys columnNames: {self name}',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r\t^ DataFrame\r\t\twithColumns: {  self values }\r\t\trowNames: self keys\r\t\tcolumnNames: { self name }.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.849589-04:00' ],		#prior : OmReference [ '1192' ],		#self : OmReference [ '1193' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  self at: arg1 transform: arg2 ifAbsent: NotFoundError',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: aKey transform: aBlock\r\t"Evaluate aBlock on the value at aKey and replace that value with the result. Signal an exception if aKey was not found"\r\tself at: aKey transform: aBlock ifAbsent: NotFoundError.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.850083-04:00' ],		#prior : OmReference [ '1193' ],		#self : OmReference [ '1194' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        arg3 value.\r        ^self ].\r  self at: arg1 put: (arg2 value: tmp1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: aKey transform: aBlock ifAbsent: exceptionBlock\r\t"Evaluate aBlock on the value at aKey and replace that value with the result. Evaluate exceptionBlock if aKey was not found"\r\t| oldValue |\r\toldValue := self at: aKey ifAbsent: [\r\t\texceptionBlock value.\r\t\t^ self ].\r\t\r\tself at: aKey put: (aBlock value: oldValue).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.850541-04:00' ],		#prior : OmReference [ '1194' ],		#self : OmReference [ '1195' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber\r\t^ self at: (self keys at: aNumber)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.852389-04:00' ],		#prior : OmReference [ '1195' ],		#self : OmReference [ '1196' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: arg1) put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber put: aValue\r\t^ self at: (self keys at: aNumber) put: aValue',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.852993-04:00' ],		#prior : OmReference [ '1196' ],		#self : OmReference [ '1197' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys at: arg1.\r  self at: tmp1 transform: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber transform: aBlock\r\t"Evaluate aBlock on the value at aNumber and replace that value with the result"\r\t| key |\r\tkey := self keys at: aNumber.\r\tself at: key transform: aBlock',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.853426-04:00' ],		#prior : OmReference [ '1197' ],		#self : OmReference [ '1198' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  #metaObject count: 1.\r  nil.\r  ^self closeTo: arg1 precision: self defaultPrecision',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: anObject\r\t^ self closeTo: anObject precision: self defaultPrecision.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.85394-04:00' ],		#prior : OmReference [ '1198' ],		#self : OmReference [ '1199' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1 precision: arg2\r  #metaObject count: 1.\r  nil.\r  self == arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^true ].\r  (self species == arg1 species and: [ #metaObject count: 3.\r        nil.\r        self size = arg1 size ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 name = self name ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 6.\r        nil.\r        ^false ].\r  ^(1 to: self values size) detect: [:arg3 |  #metaObject count: 7.\r        nil.\r        ((self atIndex: arg3) closeTo: (arg1 atIndex: arg3) precision: arg2) not ] ifFound: [ #metaObject count: 8.\r        nil.\r        false ] ifNone: [ #metaObject count: 9.\r        nil.\r        true ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: anObject precision: aPrecision\r\tself == anObject\r\t\tifTrue: [^ true].\r\r\t(self species == anObject species\r\t\tand: [self size = anObject size])\r\t\tifFalse: [^ false].\r\t\t\r\t(anObject name = self name)\r\t\tifFalse: [ ^ false ].\r\t\t\r\t(anObject keys = self keys)\r\t\tifFalse: [ ^ false ].\r\r\t^ (1 to: self values size)\r\t\tdetect: [ :i | ((self atIndex: i) closeTo: (anObject atIndex: i) precision: aPrecision) not ]\r\t\tifFound: [ false ]\r\t\tifNone: [ true ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.854366-04:00' ],		#prior : OmReference [ '1199' ],		#self : OmReference [ '1200' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super collect: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r\t| result |\r\tresult :=  super collect: aBlock.\r\tresult name: self name.\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.854798-04:00' ],		#prior : OmReference [ '1200' ],		#self : OmReference [ '1201' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifFalse: [ #metaObject count: 3.\r              nil.\r              arg1 value: arg2 ] ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: aBlock\r\t"Applies aBlock to every non-nil element"\r\t^ self collect: [ :each |\r\t\teach isNil ifTrue: [ nil ] ifFalse: [ aBlock value: each ]\r\t\t]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.855318-04:00' ],		#prior : OmReference [ '1201' ],		#self : OmReference [ '1202' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := DataFrame withRows: (self uniqueValues collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              arg1 uniqueValues collect: [:arg3 |  #metaObject count: 4.\r                    nil.\r                    (1 to: self size) inject: 0 into: [:arg4 :arg5 |  #metaObject count: 5.\r                          nil.\r                          ((self atIndex: arg5) = arg2 and: (arg1 atIndex: arg5) = arg3) ifTrue: [ #metaObject count: 6.\r                                nil.\r                                arg4 + 1 ] ifFalse: [ #metaObject count: 7.\r                                nil.\r                                arg4 ] ] ] ]).\r  tmp1\r     rowNames: self uniqueValues;\r     columnNames: arg1 uniqueValues.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: aSeries\r\t| df |\r\t\r\t(self size = aSeries size)\r\t\tifFalse: [ SizeMismatch signal ].\r\t\r\tdf := DataFrame withRows: \r\t\t(self uniqueValues collect: [ :each1 |\r\t\t\taSeries uniqueValues collect: [ :each2 |\r\t\t\t\t(1 to: self size) inject: 0 into: [ :accum :i |\r\t\t\t\t\t(((self atIndex: i) = each1) and: ((aSeries atIndex: i) = each2))\r\t\t\t\t\t\tifTrue: [ accum + 1 ]\r\t\t\t\t\t\tifFalse: [ accum ] ] ] ]).\r\t\t\r\tdf rowNames: self uniqueValues.\r\tdf columnNames: aSeries uniqueValues.\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.855744-04:00' ],		#prior : OmReference [ '1202' ],		#self : OmReference [ '1203' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r\t^ 5',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.856431-04:00' ],		#prior : OmReference [ '1203' ],		#self : OmReference [ '1204' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  #metaObject count: 1.\r  nil.\r  ^\'(no name)\'',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r\t^ \'(no name)\'',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.856881-04:00' ],		#prior : OmReference [ '1204' ],		#self : OmReference [ '1205' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  #metaObject count: 1.\r  nil.\r  ^0.0001',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r\t^ 0.0001',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.857319-04:00' ],		#prior : OmReference [ '1205' ],		#self : OmReference [ '1206' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 8',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r\t"Answer the eighth element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 8',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.857741-04:00' ],		#prior : OmReference [ '1206' ],		#self : OmReference [ '1207' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  #metaObject count: 1.\r  nil.\r  Error signal: \'Keys of two series do not match\'',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r\tError signal: \'Keys of two series do not match\'',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.858178-04:00' ],		#prior : OmReference [ '1207' ],		#self : OmReference [ '1208' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 5',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r\t"Answer the fifth element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 5',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.858595-04:00' ],		#prior : OmReference [ '1208' ],		#self : OmReference [ '1209' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first \r\t"Answer the first element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 1',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.859004-04:00' ],		#prior : OmReference [ '1209' ],		#self : OmReference [ '1210' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r\t^ self quartile: 1',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.859421-04:00' ],		#prior : OmReference [ '1210' ],		#self : OmReference [ '1211' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 4',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r\t"Answer the fourth element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 4',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.859827-04:00' ],		#prior : OmReference [ '1211' ],		#self : OmReference [ '1212' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 4',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r\t^ self quartile: 4',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.860255-04:00' ],		#prior : OmReference [ '1212' ],		#self : OmReference [ '1213' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2\r  #metaObject count: 1.\r  nil.\r  ^self groupBy: arg1 aggregateUsing: arg2 as: self name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: otherSeries aggregateUsing: aBlock\r\t"Group my values by the unique values of otherSeries, aggregate them using aBlock. Use my name by default"\r\t^ self groupBy: otherSeries aggregateUsing: aBlock as: self name',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.860771-04:00' ],		#prior : OmReference [ '1213' ],		#self : OmReference [ '1214' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregateUsing: arg2 as: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  self size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg1 uniqueValues.\r  tmp2 := tmp1 collect: [:arg4 |  #metaObject count: 3.\r        nil.\r        (1 to: self size) select: [:arg5 |  #metaObject count: 4.\r              nil.\r              (arg1 atIndex: arg5) = arg4 ] thenCollect: [:arg6 |  #metaObject count: 5.\r              nil.\r              self atIndex: arg6 ] ].\r  ^DataSeries withKeys: tmp1 values: (tmp2 collect: arg2) name: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: otherSeries aggregateUsing: aBlock as: aNewName\r\t"Group my values by the unique values of otherSeries, aggregate them using aBlock, and answer a new DataSeries with unique values of otherSeries (group keys) as keys, aggregated values of myself as values, and aNewName as name"\r\t| groupKeys groups |\r\t\r\tself size = otherSeries size\r\t\tifFalse: [ SizeMismatch signal ].\r\t\t\r\tgroupKeys := otherSeries uniqueValues.\r\t\r\tgroups := groupKeys collect: [ :each |\r\t\t(1 to: self size)\r\t\t\tselect: [ :i | (otherSeries atIndex: i) = each ]\r\t\t\tthenCollect: [ :i | self atIndex: i ] ].\r\t\r\t^ DataSeries\r\t\twithKeys: groupKeys\r\t\tvalues: (groups collect: aBlock)\r\t\tname: aNewName',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.861179-04:00' ],		#prior : OmReference [ '1214' ],		#self : OmReference [ '1215' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  #metaObject count: 1.\r  nil.\r  ^self includes: nil',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r\t"return true if data series has at least one nil value"\r\t^ self includes: nil. ',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.861589-04:00' ],		#prior : OmReference [ '1215' ],		#self : OmReference [ '1216' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head \r\t^ self head: self defaultHeadTailSize.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.862018-04:00' ],		#prior : OmReference [ '1216' ],		#self : OmReference [ '1217' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: 1 to: arg1) values: (self values copyFrom: 1 to: arg1) name: self name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: aNumber\r\t^ self species\r\t\twithKeys: (self keys copyFrom: 1 to: aNumber)\r\t\tvalues: (self values copyFrom: 1 to: aNumber)\r\t\tname: self name.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.862447-04:00' ],		#prior : OmReference [ '1217' ],		#self : OmReference [ '1218' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  name := self defaultName',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize \r\tsuper initialize.\r\tname := self defaultName.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.862877-04:00' ],		#prior : OmReference [ '1218' ],		#self : OmReference [ '1219' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  self initialize.\r  ^super initialize: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aCapacity\r\t"Make sure that initialize is called and the default name is set"\r\tself initialize.\r\t^ super initialize: aCapacity.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.86329-04:00' ],		#prior : OmReference [ '1219' ],		#self : OmReference [ '1220' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self thirdQuartile - self firstQuartile',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r\t^ self thirdQuartile - self firstQuartile ',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.863752-04:00' ],		#prior : OmReference [ '1220' ],		#self : OmReference [ '1221' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  #metaObject count: 1.\r  nil.\r  ^self isNumerical not',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r\t^ self isNumerical not',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.864366-04:00' ],		#prior : OmReference [ '1221' ],		#self : OmReference [ '1222' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := forcedIsNumerical.\r  ^tmp2 ifNil: [ #metaObject count: 2.\r        nil.\r        self uniqueValues allSatisfy: [:arg1 |  #metaObject count: 3.\r              nil.\r              arg1 isNumber ] ] ifNotNil: [ #metaObject count: 4.\r        nil.\r        tmp2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r\t^ forcedIsNumerical ifNil: [self uniqueValues allSatisfy: [:each|each isNumber]]\r\t\t',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.864881-04:00' ],		#prior : OmReference [ '1222' ],		#self : OmReference [ '1223' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  #metaObject count: 1.\r  nil.\r  ^true',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r\t^ true',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.865323-04:00' ],		#prior : OmReference [ '1223' ],		#self : OmReference [ '1224' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 asArray deepCopy.\r  dictionary := self dictionaryClass newFromKeys: tmp1 andValues: self values.\r  orderedKeys := tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: anArrayOfKeys\r\t| keys |\r\tkeys := anArrayOfKeys asArray deepCopy.\r\tdictionary := self dictionaryClass newFromKeys: keys andValues: self values.\r\torderedKeys := keys.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.86574-04:00' ],		#prior : OmReference [ '1224' ],		#self : OmReference [ '1225' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: self size',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r\t"Answer the last element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: self size',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.866164-04:00' ],		#prior : OmReference [ '1225' ],		#self : OmReference [ '1226' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: arg1\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 log: arg1 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: base\r\t^ self collect: [ :each | each log: base ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.866575-04:00' ],		#prior : OmReference [ '1226' ],		#self : OmReference [ '1227' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := false',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r\tforcedIsNumerical := false\r\t\t',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.866994-04:00' ],		#prior : OmReference [ '1227' ],		#self : OmReference [ '1228' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := true',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r\tforcedIsNumerical := true\r\t\t',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.867428-04:00' ],		#prior : OmReference [ '1228' ],		#self : OmReference [ '1229' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 max.\r  ^tmp1 keyAtValue: tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r\t| valueCounts maxCount |\r\tvalueCounts := self valueCounts.\r\tmaxCount := valueCounts max.\r\t^ valueCounts keyAtValue: maxCount.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.86783-04:00' ],		#prior : OmReference [ '1229' ],		#self : OmReference [ '1230' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  #metaObject count: 1.\r  nil.\r  ^name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r\t^ name',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.868237-04:00' ],		#prior : OmReference [ '1230' ],		#self : OmReference [ '1231' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: arg1\r  #metaObject count: 1.\r  nil.\r  name := arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: anObject\r\tname := anObject',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.86865-04:00' ],		#prior : OmReference [ '1231' ],		#self : OmReference [ '1232' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 9',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r\t"Answer the ninth element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 9',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.869104-04:00' ],		#prior : OmReference [ '1232' ],		#self : OmReference [ '1233' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self sorted.\r  arg1 = 0 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^tmp1 first ].\r  tmp2 := (tmp1 size * (arg1 / 100)) ceiling.\r  ^tmp1 atIndex: tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: aNumber\r\t| sortedSeries index |\r\tsortedSeries := self sorted.\r\t\r\taNumber = 0\r\t\tifTrue: [ ^ sortedSeries first ].\r\t\r\tindex := (sortedSeries size * (aNumber / 100)) ceiling.\r\t^ sortedSeries atIndex: index.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.869815-04:00' ],		#prior : OmReference [ '1233' ],		#self : OmReference [ '1234' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: arg1\r  #metaObject count: 1.\r  nil.\r  ^self quantile: 25 * arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: aNumber\r\t^ self quantile: (25 * aNumber)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.870272-04:00' ],		#prior : OmReference [ '1234' ],		#self : OmReference [ '1235' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super reject: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: aBlock\r\t| result |\r\tresult := super reject: aBlock.\r\tresult name: self name.\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.870687-04:00' ],		#prior : OmReference [ '1235' ],		#self : OmReference [ '1236' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeKey: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: aKey\r\t^ self removeKey: aKey',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.871103-04:00' ],		#prior : OmReference [ '1236' ],		#self : OmReference [ '1237' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: arg1\r  #metaObject count: 1.\r  nil.\r  ^self removeAt: (self keys at: arg1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: aNumber\r\t^ self removeAt: (self keys at: aNumber)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.871524-04:00' ],		#prior : OmReference [ '1237' ],		#self : OmReference [ '1238' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  #metaObject count: 1.\r  nil.\r  ^self reject: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNil ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r\t^ self reject: [ :ele | ele isNil ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.872025-04:00' ],		#prior : OmReference [ '1238' ],		#self : OmReference [ '1239' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: arg1\r  #metaObject count: 1.\r  nil.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              self atIndex: arg3 put: arg1 ] ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: anObject\r\t"Replaces nils inplace with anObject"\r\t\r\tself withIndexDo: [ :ele :index |\r\t\tele isNil\r\t\t\tifTrue: [ self atIndex: index put: anObject ] ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.872656-04:00' ],		#prior : OmReference [ '1239' ],		#self : OmReference [ '1240' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) average.\r  self replaceNilsWith: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r\t"Replaces nils inplace with average"\r\t\r\t| mean |\r\tmean := (self select: [ :ele | ele isNotNil ]) average.\r\tself replaceNilsWith: mean.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.873129-04:00' ],		#prior : OmReference [ '1240' ],		#self : OmReference [ '1241' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) median.\r  self replaceNilsWith: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r\t"Replaces nils inplace with median"\r\t\r\t| median |\r\tmedian := (self select: [ :ele | ele isNotNil ]) median.\r\tself replaceNilsWith: median.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.873571-04:00' ],		#prior : OmReference [ '1241' ],		#self : OmReference [ '1242' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self select: [:arg1 |  #metaObject count: 2.\r        nil.\r        arg1 isNotNil ]) mode.\r  self replaceNilsWith: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r\t"Replaces nils inplace with mode"\r\t\r\t| mode |\r\tmode := (self select: [ :ele | ele isNotNil ]) mode.\r\tself replaceNilsWith: mode.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.875242-04:00' ],		#prior : OmReference [ '1242' ],		#self : OmReference [ '1243' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  #metaObject count: 1.\r  nil.\r  self replaceNilsWith: 0',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r\t"Replaces nils inplace with zero"\r\t\r\tself replaceNilsWith: 0.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.875731-04:00' ],		#prior : OmReference [ '1243' ],		#self : OmReference [ '1244' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r\t"Answer the second element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 2',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.876153-04:00' ],		#prior : OmReference [ '1244' ],		#self : OmReference [ '1245' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r\t^ self quartile: 2',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.876589-04:00' ],		#prior : OmReference [ '1245' ],		#self : OmReference [ '1246' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super select: arg1.\r  tmp1 name: self name.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: aBlock\r\t| result |\r\tresult := super select: aBlock.\r\tresult name: self name.\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.877014-04:00' ],		#prior : OmReference [ '1246' ],		#self : OmReference [ '1247' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 7',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r\t"Answer the seventh element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 7',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.877441-04:00' ],		#prior : OmReference [ '1247' ],		#self : OmReference [ '1248' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 6',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r\t"Answer the sixth element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 6',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.877858-04:00' ],		#prior : OmReference [ '1248' ],		#self : OmReference [ '1249' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r\tself sort: [ :a :b | a <= b ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.878299-04:00' ],		#prior : OmReference [ '1249' ],		#self : OmReference [ '1250' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  self sortAssociations: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: aBlock\r\t| associationBlock |\r\tassociationBlock := [ :a :b | aBlock value: a value value: b value ].\r\tself sortAssociations: associationBlock',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.878742-04:00' ],		#prior : OmReference [ '1250' ],		#self : OmReference [ '1251' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  self\r     removeAll;\r     addAll: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: aBlock\r\t| sortedAssociations |\r\tsortedAssociations := self associations sort: aBlock.\r\tself removeAll.\r\tself addAll: sortedAssociations.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.879156-04:00' ],		#prior : OmReference [ '1251' ],		#self : OmReference [ '1252' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  #metaObject count: 1.\r  nil.\r  self sort: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r\tself sort: [ :a :b | a > b ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.879574-04:00' ],		#prior : OmReference [ '1252' ],		#self : OmReference [ '1253' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 <= arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r\t^ self sorted: [ :a :b | a <= b ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.880046-04:00' ],		#prior : OmReference [ '1253' ],		#self : OmReference [ '1254' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := [:arg2 :arg3 |  #metaObject count: 2.\r  nil.\r  arg1 value: arg2 value value: arg3 value ].\r  ^self sortedAssociations: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: aBlock\r\t| associationBlock |\r\tassociationBlock := [ :a :b | aBlock value: a value value: b value ].\r\t^ self sortedAssociations: associationBlock',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.880551-04:00' ],		#prior : OmReference [ '1254' ],		#self : OmReference [ '1255' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self associations sort: arg1.\r  tmp3 := tmp1 asDataSeries.\r  tmp3 name: self name.\r  ^tmp3 yourself',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: aBlock\r\t| sortedAssociations |\r\tsortedAssociations := self associations sort: aBlock.\r\t^ sortedAssociations asDataSeries name: self name; yourself',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.881135-04:00' ],		#prior : OmReference [ '1255' ],		#self : OmReference [ '1256' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:arg1 :arg2 |  #metaObject count: 2.\r        nil.\r        arg1 > arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r\t^ self sorted: [ :a :b | a > b ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.88163-04:00' ],		#prior : OmReference [ '1256' ],		#self : OmReference [ '1257' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species new.\r  tmp1\r     name: self name;\r     at: \'Min\' put: self min;\r     at: \'1st Qu.\' put: self firstQuartile;\r     at: \'Median\' put: self median;\r     at: \'Average\' put: self average;\r     at: \'3rd Qu.\' put: self thirdQuartile;\r     at: \'Max\' put: self max.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r\t| summary |\r\tsummary := self species new.\r\tsummary name: self name.\r\t\r\tsummary\r\t\tat: \'Min\' put: self min;\r\t\tat: \'1st Qu.\' put: self firstQuartile;\r\t\tat: \'Median\' put: self median;\r\t\tat: \'Average\' put: self average;\r\t\tat: \'3rd Qu.\' put: self thirdQuartile;\r\t\tat: \'Max\' put: self max.\r\t\t\r\t^ summary',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.88205-04:00' ],		#prior : OmReference [ '1257' ],		#self : OmReference [ '1258' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r\t^ self tail: self defaultHeadTailSize.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.882493-04:00' ],		#prior : OmReference [ '1258' ],		#self : OmReference [ '1259' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: arg1\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: self size - arg1 + 1 to: self size) values: (self values copyFrom: self size - arg1 + 1 to: self size) name: self name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: aNumber\r\t^ self species\r\t\twithKeys: (self keys copyFrom: self size - aNumber + 1 to: self size)\r\t\tvalues: (self values copyFrom: self size - aNumber + 1 to: self size)\r\t\tname: self name.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.882914-04:00' ],		#prior : OmReference [ '1259' ],		#self : OmReference [ '1260' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r\t"Answer the third element of the receiver.\r\tRaise an error if there are not enough elements."\r\t^ self atIndex: 3',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.883343-04:00' ],		#prior : OmReference [ '1260' ],		#self : OmReference [ '1261' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r\t^ self quartile: 3',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.883779-04:00' ],		#prior : OmReference [ '1261' ],		#self : OmReference [ '1262' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asSet asArray.\r  ^[ #metaObject count: 2.\r  nil.\r  tmp1 sort ] on: Error do: [ #metaObject count: 3.\r        nil.\r        tmp1 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r\t| v |\r\tv := self asSet asArray.\r\t\r\t"Sort if possible"\r\t^ [ v sort ] on: Error do: [ v ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.884195-04:00' ],		#prior : OmReference [ '1262' ],		#self : OmReference [ '1263' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  #metaObject count: 1.\r  nil.\r  ^(self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r\t^ (self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.884619-04:00' ],		#prior : OmReference [ '1263' ],		#self : OmReference [ '1264' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self valueCounts.\r  tmp2 := tmp1 / self size.\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r\t| count freq |\r\tcount := self valueCounts.\r\tfreq := count / self size.\r\t^ freq',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.885094-04:00' ],		#prior : OmReference [ '1264' ],		#self : OmReference [ '1265' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keys withIndexDo: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg4)) ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: aCollection collect: twoArgBlock \r\t"Collect and return the result of evaluating twoArgBlock with corresponding elements from this series and aCollection."\r\t| result |\r\taCollection size = self size ifFalse: [self errorSizeMismatch].\r\t\r\tresult := self species new: self size.\r\tresult name: self name.\r\t\r\tself keys withIndexDo: [ :key :i |\r\t\tresult at: key put:\r\t\t(twoArgBlock\r\t\t\tvalue: (self at: key)\r\t\t\tvalue: (aCollection at: i))].\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.885544-04:00' ],		#prior : OmReference [ '1265' ],		#self : OmReference [ '1266' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations withIndexCollect: [:arg2 :arg3 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg3) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: aBlock\r\t| result |\r\tresult := self species newFrom:\r\t\t(self associations withIndexCollect: [:each :i |\r\t\t\teach key -> (aBlock value: each value value: i)]).\r\tresult name: self name.\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.88597-04:00' ],		#prior : OmReference [ '1266' ],		#self : OmReference [ '1267' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: aBlock\r\t\r\t^ self withIndexDetect: aBlock ifNone: [ NotFound signal ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.886409-04:00' ],		#prior : OmReference [ '1267' ],		#self : OmReference [ '1268' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self atIndex: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: aBlock ifNone: exceptionBlock\r\t\r\t| selectedIndex |\r\t\r\tselectedIndex := (1 to: self size)\r\t\tdetect: [ :i | aBlock value: (self atIndex: i) value: i ]\r\t\tifNone: [ ^ exceptionBlock value ].\r\t\t\r\t^ self atIndex: selectedIndex.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.886826-04:00' ],		#prior : OmReference [ '1268' ],		#self : OmReference [ '1269' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keys withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg3 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: aBlock\r\tself keys withIndexDo: [ :each :i | aBlock value: (self at: each) value: i ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.887247-04:00' ],		#prior : OmReference [ '1269' ],		#self : OmReference [ '1270' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: aBlock\r\t^ self withIndexSelect: [ :each :i | (aBlock value: each value: i) not ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.887721-04:00' ],		#prior : OmReference [ '1270' ],		#self : OmReference [ '1271' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (1 to: self size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self atIndex: arg2) value: arg2 ].\r  ^DataSeries withKeys: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self keys at: arg3 ]) values: (tmp1 collect: [:arg4 |  #metaObject count: 4.\r              nil.\r              self atIndex: arg4 ]) name: self name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: aBlock\r\t| selectedIndices |\r\t\r\tselectedIndices := (1 to: self size) select: [ :i |\r\t\taBlock value: (self atIndex: i) value: i ].\r\t\r\t^ DataSeries\r\t\twithKeys: (selectedIndices collect: [ :i | self keys at: i ])\r\t\tvalues: (selectedIndices collect: [ :i | self atIndex: i ])\r\t\tname: self name.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.888174-04:00' ],		#prior : OmReference [ '1271' ],		#self : OmReference [ '1272' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self species newFrom: (self associations collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              arg2 key -> (arg1 value: arg2 value value: arg2 key) ]).\r  tmp1 name: self name.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: aBlock\r\t| result |\r\tresult := self species newFrom:\r\t\t(self associations collect: [:each |\r\t\t\teach key -> (aBlock value: each value value: each key)]).\r\tresult name: self name.\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.888661-04:00' ],		#prior : OmReference [ '1272' ],		#self : OmReference [ '1273' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeyDetect: arg1 ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: aBlock\r\t\r\t^ self withKeyDetect: aBlock ifNone: [ NotFound signal ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.889266-04:00' ],		#prior : OmReference [ '1273' ],		#self : OmReference [ '1274' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: arg1 ifNone: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys detect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg3) value: arg3 ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^arg2 value ].\r  ^self at: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: aBlock ifNone: exceptionBlock\r\t\r\t| selectedKey |\r\t\r\tselectedKey := self keys\r\t\tdetect: [ :key | aBlock value: (self at: key) value: key ]\r\t\tifNone: [ ^ exceptionBlock value ].\r\t\t\r\t^ self at: selectedKey.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.889714-04:00' ],		#prior : OmReference [ '1274' ],		#self : OmReference [ '1275' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: arg1\r  #metaObject count: 1.\r  nil.\r  self keysDo: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: aBlock\r\tself keysDo: [ :each | aBlock value: (self at: each) value: each ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.89046-04:00' ],		#prior : OmReference [ '1275' ],		#self : OmReference [ '1276' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withKeySelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: aBlock\r\t^ self withKeySelect: [ :each :key | (aBlock value: each value: key) not ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.890937-04:00' ],		#prior : OmReference [ '1276' ],		#self : OmReference [ '1277' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self keys select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (self at: arg2) value: arg2 ].\r  ^DataSeries withKeys: tmp1 values: (tmp1 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              self at: arg3 ]) name: self name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: aBlock\r\t| selectedKeys |\r\t\r\tselectedKeys := self keys select: [ :key |\r\t\taBlock value: (self at: key) value: key ].\r\t\r\t^ DataSeries\r\t\twithKeys: selectedKeys\r\t\tvalues: (selectedKeys collect: [ :key | self at: key ])\r\t\tname: self name.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.891496-04:00' ],		#prior : OmReference [ '1277' ],		#self : OmReference [ '1278' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: arg1 collect: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  arg1 keys = self keys ifFalse: [ #metaObject count: 3.\r        nil.\r        self errorKeysMismatch ].\r  tmp1 := self species new: self size.\r  tmp1 name: self name.\r  self keysDo: [:arg3 |  #metaObject count: 4.\r        nil.\r        tmp1 at: arg3 put: (arg2 value: (self at: arg3) value: (arg1 at: arg3)) ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: otherDataSeries collect: twoArgBlock \r\t"Collect and return the result of evaluating twoArgBlock with corresponding elements from this series and otherDataSeries."\r\t| result |\r\totherDataSeries size = self size ifFalse: [self errorSizeMismatch].\r\totherDataSeries keys = self keys ifFalse: [ self errorKeysMismatch ].\r\t\r\tresult := self species new: self size.\r\tresult name: self name.\r\t\r\tself keysDo: [ :key |\r\t\tresult at: key put:\r\t\t(twoArgBlock\r\t\t\tvalue: (self at: key)\r\t\t\tvalue: (otherDataSeries at: key))].\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.891919-04:00' ],		#prior : OmReference [ '1278' ],		#self : OmReference [ '1279' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 0',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r\t^ self quartile: 0',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.896466-04:00' ],		#prior : OmReference [ '1279' ],		#self : OmReference [ '1280' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #String			},			#name : #'using:',			#protocol : #'*DataFrame',			#sourceCode : 'using: arg1\r  ^[:arg2 :arg3 |  arg2 group: self by: arg3 aggregateUsing: arg1 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #String			},			#name : #'using:',			#protocol : #'*DataFrame',			#sourceCode : 'using: aBlock\r\t"Answer a block which takes two arguments: a data frame and a column name. This block groups a column of data frame which has name equal to myself by the values of another column, aggregates them using aBlock, and returns a new data series"\r\t^ [ :dataFrame :groupColumnName |\r\t\tdataFrame\r\t\t\tgroup: self\r\t\t\tby: groupColumnName\r\t\t\taggregateUsing: aBlock ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.899223-04:00' ],		#prior : OmReference [ '1280' ],		#self : OmReference [ '1281' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #String			},			#name : #'using:as:',			#protocol : #'*DataFrame',			#sourceCode : 'using: arg1 as: arg2\r  ^[:arg3 :arg4 |  arg3 group: self by: arg4 aggregateUsing: arg1 as: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #String			},			#name : #'using:as:',			#protocol : #'*DataFrame',			#sourceCode : 'using: aBlock as: aNewName\r\t"Answer a block which takes two arguments: a data frame and a column name. This block groups a column of data frame which has name equal to myself by the values of another column, aggregates them using aBlock, and returns a new data series with aNewName"\r\t^ [ :dataFrame :groupColumnName |\r\t\tdataFrame\r\t\t\tgroup: self\r\t\t\tby: groupColumnName\r\t\t\taggregateUsing: aBlock\r\t\t\tas: aNewName ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.899828-04:00' ],		#prior : OmReference [ '1281' ],		#self : OmReference [ '1282' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: arg1 row: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg1 id = \'#\' ifTrue: [ #metaObject count: 2.\r        nil.\r        ^FTCellMorph new addMorph: (elements rowNames at: arg2) asMorph ].\r  tmp1 := elements columnNames indexOf: arg1 id.\r  ^FTCellMorph new addMorph: (elements at: arg2 at: tmp1) asMorph',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: column row: rowNumber\r\t\r\t| columnNumber |\r\t\r\tcolumn id = \'#\'\r\t\tifTrue: [ ^ FTCellMorph new addMorph: (elements rowNames at: rowNumber) asMorph ].\r\t\t\r\tcolumnNumber := elements columnNames indexOf: column id.\r\t\r\t^ FTCellMorph new\r\t\taddMorph: (elements at: rowNumber at: columnNumber) asMorph.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.900251-04:00' ],		#prior : OmReference [ '1282' ],		#self : OmReference [ '1283' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^elements numberOfRows',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r\r\t^ elements numberOfRows',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.903744-04:00' ],		#prior : OmReference [ '1283' ],		#self : OmReference [ '1284' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #'**',			#protocol : #'*DataFrame-Core-Base',			#sourceCode : '** arg1\r  ^self raisedTo: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #'**',			#protocol : #'*DataFrame-Core-Base',			#sourceCode : '** arg\r\r\t^ self raisedTo: arg',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.906011-04:00' ],		#prior : OmReference [ '1284' ],		#self : OmReference [ '1285' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #asDataSeries,			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'asDataSeries\r  ^self as: DataSeries',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #asDataSeries,			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'asDataSeries\r\r\t^ self as: DataSeries\r\r',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.90829-04:00' ],		#prior : OmReference [ '1285' ],		#self : OmReference [ '1286' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #'closeTo:',			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'closeTo: arg1\r  ^self - arg1 inject: true into: [:arg2 :arg3 |  arg2 and: (arg3 closeTo: 0) ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #'closeTo:',			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'closeTo: aCollection\r\r\t^ (self - aCollection) inject: true into: [ :accum :each |\r\t\taccum and: (each closeTo: 0) ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.910136-04:00' ],		#prior : OmReference [ '1286' ],		#self : OmReference [ '1287' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #variance,			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'variance\r  ^self stdev squared',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #variance,			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'variance\r\r\t^ self stdev squared.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.912689-04:00' ],		#prior : OmReference [ '1287' ],		#self : OmReference [ '1288' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #'withSeries:collect:',			#protocol : #'*DataFrame',			#sourceCode : 'withSeries: arg1 collect: arg2\r  | tmp1 |\r  arg1 size = self size ifFalse: [ self errorSizeMismatch ].\r  tmp1 := arg1 species new: self size.\r  tmp1 name: arg1 name.\r  arg1 keys withIndexDo: [:arg3 :arg4 |  tmp1 at: arg3 put: (arg2 value: (self at: arg4) value: (arg1 at: arg3)) ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Collection			},			#name : #'withSeries:collect:',			#protocol : #'*DataFrame',			#sourceCode : 'withSeries: aDataSeries collect: twoArgBlock \r\t"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and aDataSeries."\r\t| result |\r\taDataSeries size = self size ifFalse: [self errorSizeMismatch].\r\t\r\tresult := aDataSeries species new: self size.\r\tresult name: aDataSeries name.\r\t\r\taDataSeries keys withIndexDo: [ :key :i |\r\t\tresult at: key put:\r\t\t(twoArgBlock\r\t\t\tvalue: (self at: i)\r\t\t\tvalue: (aDataSeries at: key))].\r\t^ result',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.913522-04:00' ],		#prior : OmReference [ '1288' ],		#self : OmReference [ '1289' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r  #metaObject count: 1.\r  nil.\r  ^super new initialize',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t\r\t^ super new initialize.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.913972-04:00' ],		#prior : OmReference [ '1289' ],		#self : OmReference [ '1290' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^super new initialize: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aPoint\r\t\r\t^ super new initialize: aPoint.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.914389-04:00' ],		#prior : OmReference [ '1290' ],		#self : OmReference [ '1291' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: 0 @ tmp1.\r  tmp2 columnNames: arg1.\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: anArrayOfColumnNames\r\t"Create an empty data frame with given column names"\r\t| numberOfColumns df |\r\t\r\tnumberOfColumns := anArrayOfColumnNames size.\r\tdf := self new: 0 @ numberOfColumns.\r\t\r\tdf columnNames: anArrayOfColumnNames.\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.914794-04:00' ],		#prior : OmReference [ '1291' ],		#self : OmReference [ '1292' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeColumns: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays\r\r\t^ self new initializeColumns: anArrayOfArrays.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.915199-04:00' ],		#prior : OmReference [ '1292' ],		#self : OmReference [ '1293' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 columnNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withColumns: arg1.\r  tmp1 columnNames: arg2.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays columnNames: anArrayOfColumnNames\r\r\t| df |\r\tdf := self withColumns: anArrayOfArrays.\r\tdf columnNames: anArrayOfColumnNames.\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.915611-04:00' ],		#prior : OmReference [ '1293' ],		#self : OmReference [ '1294' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays rowNames: anArrayOfRowNames\r\t^ anArrayOfArrays\r\t\tifNotEmpty: [ (self withColumns: anArrayOfArrays)\r\t\t\t\trowNames: anArrayOfRowNames;\r\t\t\t\tyourself ]\r\t\tifEmpty: [ self withRowNames: anArrayOfRowNames ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.91603-04:00' ],		#prior : OmReference [ '1294' ],		#self : OmReference [ '1295' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withColumns: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays rowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r\t^ anArrayOfArrays\r\t\tifNotEmpty: [ (self withColumns: anArrayOfArrays)\r\t\t\t\trowNames: anArrayOfRowNames;\r\t\t\t\tcolumnNames: anArrayOfColumnNames;\r\t\t\t\tyourself ]\r\t\tifEmpty: [ self withRowNames: anArrayOfRowNames ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.916426-04:00' ],		#prior : OmReference [ '1295' ],		#self : OmReference [ '1296' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^self new initializeContents: arg1 rowNames: arg2 columnNames: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: aDataFrameIndernal rowNames: rows columnNames: columns\r\r\t^ self new\r\t\tinitializeContents: aDataFrameIndernal\r\t\trowNames: rows\r\t\tcolumnNames: columns.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.916818-04:00' ],		#prior : OmReference [ '1296' ],		#self : OmReference [ '1297' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := self new: tmp1 @ 0.\r  tmp2 rowNames: arg1.\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: anArrayOfRowNames\r\t"Create an empty data frame with given row names"\r\t| numberOfRows df |\r\t\r\tnumberOfRows := anArrayOfRowNames size.\r\tdf := self new: numberOfRows @ 0.\r\t\r\tdf rowNames: anArrayOfRowNames.\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.91726-04:00' ],		#prior : OmReference [ '1297' ],		#self : OmReference [ '1298' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: arg1 columnNames: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := arg2 size.\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp3\r     rowNames: arg1;\r     columnNames: arg2.\r  ^tmp3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r\t"Create an empty data frame with given row and column names"\r\t| numberOfRows numberOfColumns df |\r\t\r\tnumberOfRows := anArrayOfRowNames size.\r\tnumberOfColumns := anArrayOfColumnNames size.\r\t\r\tdf := self new: numberOfRows @ numberOfColumns.\r\t\r\tdf rowNames: anArrayOfRowNames.\r\tdf columnNames: anArrayOfColumnNames.\r\t\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.917637-04:00' ],		#prior : OmReference [ '1298' ],		#self : OmReference [ '1299' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initializeRows: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays\r\r\t^ self new initializeRows: anArrayOfArrays.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.918047-04:00' ],		#prior : OmReference [ '1299' ],		#self : OmReference [ '1300' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 columnNames: arg2\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           columnNames: arg2;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays columnNames: anArrayOfColumnNames\r\t^ anArrayOfArrays\r\t\tifNotEmpty: [ (self withRows: anArrayOfArrays)\r\t\t\t\tcolumnNames: anArrayOfColumnNames;\r\t\t\t\tyourself ]\r\t\tifEmpty: [ self withColumnNames: anArrayOfColumnNames ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.918434-04:00' ],		#prior : OmReference [ '1300' ],		#self : OmReference [ '1301' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self withRows: arg1.\r  tmp1 rowNames: arg2.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays rowNames: anArrayOfRowNames\r\r\t| df |\r\tdf := self withRows: anArrayOfArrays.\r\tdf rowNames: anArrayOfRowNames.\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.918852-04:00' ],		#prior : OmReference [ '1301' ],		#self : OmReference [ '1302' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  ^arg1 ifNotEmpty: [ | tmp2 |\r        #metaObject count: 2.\r        nil.\r        tmp2 := self withRows: arg1.\r        tmp2\r           rowNames: arg2;\r           columnNames: arg3;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: arg3 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays rowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r\t^ anArrayOfArrays\r\t\tifNotEmpty: [ (self withRows: anArrayOfArrays)\r\t\t\t\trowNames: anArrayOfRowNames;\r\t\t\t\tcolumnNames: anArrayOfColumnNames;\r\t\t\t\tyourself ]\r\t\tifEmpty: [ self withColumnNames: anArrayOfColumnNames ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.919378-04:00' ],		#prior : OmReference [ '1302' ],		#self : OmReference [ '1303' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  ^arg1 contents = self contents',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= aDataFrame\r\r\t"Most objects will fail here"\r\taDataFrame species = self species\r\t\tifFalse: [ ^ false ].\r\t\r\t"This is the fastest way for two data frames with different dimensions"\r\taDataFrame dimensions = self dimensions\r\t\tifFalse: [ ^ false ].\r\t\r\t"If the names are different we don\'t need to iterate through values"\t\r\t(aDataFrame rowNames = self rowNames\r\t\tand: [ aDataFrame columnNames = self columnNames ])\r\t\tifFalse: [ ^ false ].\r\t\t\r\t^ aDataFrame contents = self contents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.919806-04:00' ],		#prior : OmReference [ '1303' ],		#self : OmReference [ '1304' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aDataSeries\r\t"Add DataSeries as a new row at the end"\r\tself addRow: aDataSeries.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.920229-04:00' ],		#prior : OmReference [ '1304' ],		#self : OmReference [ '1305' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg1 name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: aDataSeries\r\t"Add DataSeries as a new column at the end"\r\tself addColumn: aDataSeries named: aDataSeries name.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.920927-04:00' ],		#prior : OmReference [ '1305' ],		#self : OmReference [ '1306' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 asArray named: arg1 name atPosition: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: aDataSeries atPosition: aNumber\r\t"Add DataSeries as a new column at the given position"\r\tself addColumn: aDataSeries asArray named: aDataSeries name atPosition: aNumber.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.921632-04:00' ],		#prior : OmReference [ '1306' ],		#self : OmReference [ '1307' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: arg1 named: arg2 atPosition: self numberOfColumns + 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray named: aString\r\t"Add a new column at the end"\r\tself addColumn: anArray named: aString atPosition: self numberOfColumns + 1.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.922143-04:00' ],		#prior : OmReference [ '1307' ],		#self : OmReference [ '1308' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self columnNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A column with that name already exists\' ].\r  contents addColumn: arg1 asArray atPosition: arg3.\r  columnNames add: arg2 afterIndex: arg3 - 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray named: aString atPosition: aNumber\r\t"Add a new column at the given position"\r\t(self columnNames includes: aString)\r\t\tifTrue: [ Error signal: \'A column with that name already exists\' ].\r\t\r\tcontents addColumn: anArray asArray atPosition: aNumber.\r\tcolumnNames add: aString afterIndex: aNumber - 1.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.922585-04:00' ],		#prior : OmReference [ '1308' ],		#self : OmReference [ '1309' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyColumnNamed: arg1 atPosition: self numberOfColumns + 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: aString\r\t"Add an empty column at the end"\r\tself addEmptyColumnNamed: aString atPosition: self numberOfColumns + 1',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.92305-04:00' ],		#prior : OmReference [ '1309' ],		#self : OmReference [ '1310' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addColumn: (Array new: self numberOfRows) named: arg1 atPosition: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: aString atPosition: aNumber\r\t"Add an empty column at the given position"\r\tself addColumn: (Array new: self numberOfRows) named: aString atPosition: aNumber',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.923486-04:00' ],		#prior : OmReference [ '1310' ],		#self : OmReference [ '1311' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self addEmptyRowNamed: arg1 atPosition: self numberOfRows + 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: aString\r\t"Add an empty row at the end"\r\tself addEmptyRowNamed: aString atPosition: self numberOfRows + 1',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.923942-04:00' ],		#prior : OmReference [ '1311' ],		#self : OmReference [ '1312' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: (Array new: self numberOfColumns) named: arg1 atPosition: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: aString atPosition: aNumber\r\t"Add an empty row at the given position"\r\tself addRow: (Array new: self numberOfColumns) named: aString atPosition: aNumber',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.924365-04:00' ],		#prior : OmReference [ '1312' ],		#self : OmReference [ '1313' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: arg1\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 asArray named: arg1 name',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: aDataSeries\r\t"Add DataSeries as a new row at the end"\r\tself addRow: aDataSeries asArray named: aDataSeries name.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.924793-04:00' ],		#prior : OmReference [ '1313' ],		#self : OmReference [ '1314' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg1 name atPosition: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: aDataSeries atPosition: aNumber\r\t"Add DataSeries as a new row at the given position"\r\tself addRow: aDataSeries named: aDataSeries name atPosition: aNumber.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.925334-04:00' ],		#prior : OmReference [ '1314' ],		#self : OmReference [ '1315' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2\r  #metaObject count: 1.\r  nil.\r  self addRow: arg1 named: arg2 atPosition: self numberOfRows + 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: anArray named: aString\r\t"Add a new row at the end"\r\tself addRow: anArray named: aString atPosition: self numberOfRows + 1.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.926013-04:00' ],		#prior : OmReference [ '1315' ],		#self : OmReference [ '1316' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 named: arg2 atPosition: arg3\r  #metaObject count: 1.\r  nil.\r  (self rowNames includes: arg2) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A row with that name already exists\' ].\r  contents addRow: arg1 atPosition: arg3.\r  rowNames add: arg2 afterIndex: arg3 - 1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: anArray named: aString atPosition: aNumber\r\t"Add a new row at the given position"\r\t(self rowNames includes: aString)\r\t\tifTrue: [ Error signal: \'A row with that name already exists\' ].\r\t\r\tcontents addRow: anArray atPosition: aNumber.\r\trowNames add: aString afterIndex: aNumber - 1.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.926508-04:00' ],		#prior : OmReference [ '1316' ],		#self : OmReference [ '1317' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: arg1\r  #metaObject count: 1.\r  nil.\r  self toColumns: self columnNames applyElementwise: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: aBlock\r\t"Applies a given block to all columns of a data frame"\r\t\t\r\tself toColumns: self columnNames applyElementwise: aBlock.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.928489-04:00' ],		#prior : OmReference [ '1317' ],		#self : OmReference [ '1318' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataSeries withValues: (self columnNames collect: [:arg2 |  #metaObject count: 2.\r              nil.\r              tmp3 := self column: arg2.\r              tmp3 perform: arg1 ]).\r  tmp1\r     name: arg1;\r     keys: self columnNames.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: aSymbol\r"Sends the unary selector, aSymbol, to all columns of DataFrame and collects the result into a DataSeries object. Used by statistical functions of DataFrame"\r\r\t| series column |\r\t\r\tseries := DataSeries withValues:\r\t\t(self columnNames collect: [ :colName |\r\t\t\tcolumn := self column: colName.\r\t\t\tcolumn perform: aSymbol ]).\r\t\r\tseries name: aSymbol.\r\tseries keys: self columnNames.\r\t\r\t^ series',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.929189-04:00' ],		#prior : OmReference [ '1318' ],		#self : OmReference [ '1319' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents asArrayOfColumns',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r\t"Converts DataFrame to the array of columns"\r\r\t^ contents asArrayOfColumns. ',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.929874-04:00' ],		#prior : OmReference [ '1319' ],		#self : OmReference [ '1320' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        self at: arg1 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r\t"Converts DataFrame to the array of rows"\r\t\r\t^ (1 to: self numberOfRows) collect: [ :i |\r\t\tself at: i ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.93039-04:00' ],		#prior : OmReference [ '1320' ],		#self : OmReference [ '1321' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: arg1\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: aNumber\r\r\t^ self rowAt: aNumber',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.931172-04:00' ],		#prior : OmReference [ '1321' ],		#self : OmReference [ '1322' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber\r\r\t^ contents at: rowNumber at: columnNumber',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.931657-04:00' ],		#prior : OmReference [ '1322' ],		#self : OmReference [ '1323' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  contents at: arg1 at: arg2 put: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber put: value\r\r\tcontents at: rowNumber at: columnNumber put: value.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.932167-04:00' ],		#prior : OmReference [ '1323' ],		#self : OmReference [ '1324' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 transform: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self at: arg1 at: arg2.\r  self at: arg1 at: arg2 put: (arg3 value: tmp1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex transform: aBlock\r\t"Evaluate aBlock on the value at the intersection of rowIndex and columnIndex and replace that value with the result"\r\t| value |\r\tvalue := self at: rowIndex at: columnIndex.\r\tself at: rowIndex at: columnIndex put: (aBlock value: value)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.932649-04:00' ],		#prior : OmReference [ '1324' ],		#self : OmReference [ '1325' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: arg1 transform: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: arg1 transform: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: aNumber transform: aBlock\r\t"Evaluate aBlock on the row at aNumber and replace that row with the result"\r\t^ self rowAt: aNumber transform: aBlock',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.933268-04:00' ],		#prior : OmReference [ '1325' ],		#self : OmReference [ '1326' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #average',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r\r\t^ self applyToAllColumns: #average',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.933842-04:00' ],		#prior : OmReference [ '1326' ],		#self : OmReference [ '1327' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  arg1 species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  arg1 dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (arg1 rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        arg1 columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 6.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 7.\r              nil.\r              ((self at: tmp2 at: tmp4) closeTo: (arg1 at: tmp2 at: tmp4)) ifFalse: [ #metaObject count: 8.\r                    nil.\r                    ^false ] ] ].\r  ^true',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: aDataFrame\r\r\taDataFrame species = self species\r\t\tifFalse: [ ^ false ].\r\t\r\taDataFrame dimensions = self dimensions\r\t\tifFalse: [ ^ false ].\r\t\t\r\t(aDataFrame rowNames = self rowNames\r\t\tand: [ aDataFrame columnNames = self columnNames ])\r\t\tifFalse: [ ^ false ].\r\t\t\r\t1 to: self numberOfRows do: [ :i |\r\t\t1 to: self numberOfColumns do: [ :j |\r\t\t\t((self at: i at: j) closeTo: (aDataFrame at: i at: j))\r\t\t\t\tifFalse: [ ^ false ] ] ].\r\t\r\t^ true',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.934353-04:00' ],		#prior : OmReference [ '1327' ],		#self : OmReference [ '1328' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 value: (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ tmp1 size.\r  tmp2 columnNames: tmp1 keys.\r  self do: [:arg2 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy) ].\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock \r\t"Overrides the Collection>>collect to create DataFrame with the same number of columns as values in the first row"\r\t| firstRow newDataFrame |\r\t\r\tfirstRow := aBlock value: (self rowAt: 1) copy.\r\tnewDataFrame := self class new: 0@firstRow size.\r\tnewDataFrame columnNames: firstRow keys.\r\t\r\tself do: [:each | newDataFrame add: (aBlock value: each copy)].\r\t^ newDataFrame',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.934844-04:00' ],		#prior : OmReference [ '1328' ],		#self : OmReference [ '1329' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: columnName\r\t"Answer the column with columnName as a DataSeries or signal an exception if a column with that name was not found"\r\t| index |\r\tindex := self indexOfColumnNamed: columnName.\r\t^ self columnAt: index',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.935308-04:00' ],		#prior : OmReference [ '1329' ],		#self : OmReference [ '1330' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self columnAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName ifAbsent: exceptionBlock\r\t"Answer the column with columnName as a DataSeries or evaluate exception block if a column with that name was not found"\r\t| index |\r\tindex := self\r\t\tindexOfColumnNamed: columnName\r\t\tifAbsent: [ ^ exceptionBlock value ].\r\t\t\r\t^ self columnAt: index',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.935761-04:00' ],		#prior : OmReference [ '1330' ],		#self : OmReference [ '1331' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  ^self columnAt: tmp1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: columnName put: anArray\r\t"Replace the current values of column with columnName with anArray or signal an exception if a column with that name was not found"\r\t| index |\r\tindex := self indexOfColumnNamed: columnName.\r\t^ self columnAt: index put: anArray.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.93622-04:00' ],		#prior : OmReference [ '1331' ],		#self : OmReference [ '1332' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self columnAt: tmp1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName put: anArray ifAbsent: exceptionBlock\r\t"Replace the current values of column with columnName with anArray or evaluate exception block if a column with that name was not found"\r\t| index |\r\tindex := self\r\t\tindexOfColumnNamed: columnName\r\t\tifAbsent: [ ^ exceptionBlock value ].\r\t\t\r\t^ self columnAt: index put: anArray',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.936665-04:00' ],		#prior : OmReference [ '1332' ],		#self : OmReference [ '1333' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  self column: arg1 put: (arg2 value: tmp1) asArray',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: columnName transform: aBlock\r\t"Evaluate aBlock on the column with columnName and replace column with the result. Signal an exception if columnName was not found"\r\t| column |\r\tcolumn := self column: columnName.\r\tself column: columnName put: (aBlock value: column) asArray',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.937217-04:00' ],		#prior : OmReference [ '1333' ],		#self : OmReference [ '1334' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self column: arg1 put: (arg2 value: tmp1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName transform: aBlock ifAbsent: exceptionBlock\r\t"Evaluate aBlock on the column with columnName and replace column with the result. Evaluate exceptionBlock if columnName was not found"\r\t| column |\r\tcolumn := self column: columnName ifAbsent: [ ^ exceptionBlock value ].\r\tself column: columnName put: (aBlock value: column)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.937837-04:00' ],		#prior : OmReference [ '1334' ],		#self : OmReference [ '1335' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents columnAt: arg1) asDataSeries.\r  tmp1\r     name: (self columnNames at: arg1);\r     keys: self rowNames.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber\r\r\t| series |\r\tseries := (contents columnAt: aNumber) asDataSeries.\r\tseries name: (self columnNames at: aNumber).\r\tseries keys: self rowNames.\r\t^ series',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.938307-04:00' ],		#prior : OmReference [ '1335' ],		#self : OmReference [ '1336' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents columnAt: arg1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber put: anArray\r\t\r\tanArray size = self numberOfRows\r\t\tifFalse: [ SizeMismatch signal ].\t\r\t\r\tcontents columnAt: aNumber put: anArray.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.93875-04:00' ],		#prior : OmReference [ '1336' ],		#self : OmReference [ '1337' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnAt: arg1.\r  self columnAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber transform: aBlock\r\t"Evaluate aBlock on the column at aNumber and replace that column with the result"\r\t| column |\r\tcolumn := self columnAt: aNumber.\r\tself columnAt: aNumber put: (aBlock value: column) asArray',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.939172-04:00' ],		#prior : OmReference [ '1337' ],		#self : OmReference [ '1338' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  #metaObject count: 1.\r  nil.\r  ^columnNames',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r\r\t^ columnNames',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.939671-04:00' ],		#prior : OmReference [ '1338' ],		#self : OmReference [ '1339' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of column names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All column names must be distinct\' ].\r  columnNames := arg1 asOrderedCollection',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: anArray\r\tanArray size = self numberOfColumns \r\t\tifFalse: [ SizeMismatch signal: \'Wrong number of column names\' ].\r\t\t\r\tanArray asSet size = anArray size\r\t\tifFalse: [ Error signal: \'All column names must be distinct\' ].\r\t\t\r\tcolumnNames := anArray asOrderedCollection',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.940125-04:00' ],		#prior : OmReference [ '1339' ],		#self : OmReference [ '1340' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfColumnNamed: arg2 ].\r  ^self columnsAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: anArrayOfNames\r\t\r\t| anArrayOfNumbers |\r\t\r\tanArrayOfNumbers := anArrayOfNames\r\t\tcollect: [ :name |\r\t\t\tself indexOfColumnNamed: name ].\r\t\t\t\r\t^ self columnsAt: anArrayOfNumbers.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.94058-04:00' ],		#prior : OmReference [ '1340' ],		#self : OmReference [ '1341' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self column: arg3 put: arg4 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: anArrayOfColumnNames put: anArrayOfArrays\r\t\r\tanArrayOfArrays size = anArrayOfColumnNames size\r\t\tifFalse: [ SizeMismatch signal ].\t\r\t\r\tanArrayOfColumnNames with: anArrayOfArrays do: [ :name :array |\r\t\tself column: name put: array ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.941032-04:00' ],		#prior : OmReference [ '1341' ],		#self : OmReference [ '1342' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self columnNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents columnsAt: arg1) rowNames: self rowNames columnNames: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers\r\r\t| newColumnNames |\r\t\r\tnewColumnNames := (anArrayOfNumbers collect: [ :i |\r\t\tself columnNames at: i ]).\r\r\t^ DataFrame\r\t\twithDataFrameInternal: (self contents columnsAt: anArrayOfNumbers)\r\t\trowNames: self rowNames\r\t\tcolumnNames: newColumnNames.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.941489-04:00' ],		#prior : OmReference [ '1342' ],		#self : OmReference [ '1343' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self columnAt: arg3 put: arg4 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers put: anArrayOfArrays\r\t\r\tanArrayOfArrays size = anArrayOfNumbers size\r\t\tifFalse: [ SizeMismatch signal ].\t\r\t\r\tanArrayOfNumbers with: anArrayOfArrays do: [ :index :array |\r\t\tself columnAt: index put: array ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.941946-04:00' ],		#prior : OmReference [ '1343' ],		#self : OmReference [ '1344' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 < arg2 ifTrue: [ #metaObject count: 2.\r        nil.\r        (arg1 to: arg2) asArray ] ifFalse: [ #metaObject count: 3.\r        nil.\r        (arg2 to: arg1) asArray reverse ].\r  ^self columnsAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: begin to: end\r\r\t| array |\r\t\r\tarray := begin < end\r\t\tifTrue: [ (begin to: end) asArray ]\r\t\tifFalse: [ (end to: begin) asArray reverse ].\r\t\r\t^ self columnsAt: array.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.942432-04:00' ],		#prior : OmReference [ '1344' ],		#self : OmReference [ '1345' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self columnAt: arg4 put: (arg3 at: arg5) ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: firstNumber to: secondNumber put: anArrayOfArrays\r\r\t| interval |\r\t\r\tanArrayOfArrays size = ((firstNumber - secondNumber) abs + 1)\r\t\tifFalse: [ SizeMismatch signal ].\t\r\t\t\t\r\tinterval := secondNumber >= firstNumber\r\t\tifTrue: [ (firstNumber to: secondNumber) ]\r\t\tifFalse: [ (secondNumber to: firstNumber) reversed ].\r\t\r\tinterval withIndexDo: [ :columnIndex :i |\r\t\tself columnAt: columnIndex put: (anArrayOfArrays at: i) ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.942866-04:00' ],		#prior : OmReference [ '1345' ],		#self : OmReference [ '1346' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r\r\t^ contents',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.943308-04:00' ],		#prior : OmReference [ '1346' ],		#self : OmReference [ '1347' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: arg1 with: arg2\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp2 := self column: arg2.\r  ^tmp1 crossTabulateWith: tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: colName1 with: colName2\r\r\t| col1 col2 |\r\t\r\tcol1 := self column: colName1.\r\tcol2 := self column: colName2.\r\t\r\t^ col1 crossTabulateWith: col2.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.94373-04:00' ],		#prior : OmReference [ '1347' ],		#self : OmReference [ '1348' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r\r\t^ 5',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.944161-04:00' ],		#prior : OmReference [ '1348' ],		#self : OmReference [ '1349' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows @ self numberOfColumns',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r\r\t^ (self numberOfRows) @ (self numberOfColumns)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.944625-04:00' ],		#prior : OmReference [ '1349' ],		#self : OmReference [ '1350' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp1 := self rowAt: tmp3.\r        arg1 value: tmp1.\r        self rowAt: tmp3 put: tmp1 asArray ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: aBlock\r"We enumerate through the data enrties - through rows of a data frame"\r\t| row |\r\t\r\t1 to: self numberOfRows do: [ :i |\r\t\trow := self rowAt: i.\r\t\taBlock value: row. \r\t\t"A hack to allow modification of rows inside do block"\r\t\tself rowAt: i put: row asArray ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.945118-04:00' ],		#prior : OmReference [ '1350' ],		#self : OmReference [ '1351' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: arg1 atColumn: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames select: [:arg3 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: anObject atColumn: columnName\r\t"Returns rowNames of rows having anObject at columnName"\r\r\t^ self rowNames select: [ :row | ((self column: columnName) at: row) = anObject ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.945757-04:00' ],		#prior : OmReference [ '1351' ],		#self : OmReference [ '1352' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: arg1 atColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := OrderedCollection new.\r  self rowNames withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        ((self column: arg2) at: arg3) = arg1 ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp1 add: arg4 ] ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: anObject atColumn: columnName\r\t"Returns indices of rows having anObject at columnName"\r\t| output |\r\toutput := OrderedCollection new.\r\tself rowNames withIndexDo: [ :row :index | ((self column: columnName) at: row) = anObject ifTrue: [ output add: index ]].\r\t^ output',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.946231-04:00' ],		#prior : OmReference [ '1352' ],		#self : OmReference [ '1353' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #firstQuartile',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r\r\t^ self applyToAllColumns: #firstQuartile',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.946785-04:00' ],		#prior : OmReference [ '1353' ],		#self : OmReference [ '1354' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self columnNames intersection: arg1 columnNames) asSet.\r  tmp2 := OrderedCollection new.\r  self columnNames do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (tmp1 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp2 add: (\'\' join: {(arg2 , \'_x\')}) ] ifFalse: [ #metaObject count: 4.\r              nil.\r              tmp2 add: arg2 ] ].\r  arg1 columnNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp1 includes: arg3) ifTrue: [ #metaObject count: 6.\r              nil.\r              tmp2 add: (\'\' join: {(arg3 , \'_y\')}) ] ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp2 add: arg3 ] ].\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: aDataFrame\r\t"comment stating purpose of message"\r\r\t| columnIntersection outputColumns |\r\tcolumnIntersection := (self columnNames intersection: (aDataFrame columnNames)) asSet.\r\toutputColumns := OrderedCollection new.\r\tself columnNames do: [ :column |\r\t\t(columnIntersection includes: column)\r\t\t\tifTrue: [ outputColumns add: (\'\' join: {column, \'_x\'}) ]\r\t\t\tifFalse: [ outputColumns add: column ]\r\t\t\t].\r\taDataFrame columnNames do: [ :column |\r\t\t(columnIntersection includes: column)\r\t\t\tifTrue: [ outputColumns add: (\'\' join: {column, \'_y\'}) ]\r\t\t\tifFalse: [ outputColumns add: column ]\r\t\t\t].\r\t\r\t^ outputColumns',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.947234-04:00' ],		#prior : OmReference [ '1354' ],		#self : OmReference [ '1355' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3\r  #metaObject count: 1.\r  nil.\r  ^self group: arg1 by: arg2 aggregateUsing: arg3 as: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock\r\t^ self group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock as: anAggregateColumnName.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.947708-04:00' ],		#prior : OmReference [ '1355' ],		#self : OmReference [ '1356' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: arg1 by: arg2 aggregateUsing: arg3 as: arg4\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  arg2 = arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'Can not group a column by itself\' ].\r  tmp1 := self column: arg2.\r  tmp2 := self column: arg1.\r  ^tmp2 groupBy: tmp1 aggregateUsing: arg3 as: arg4',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock as: aNewColumnName\r\r\t| groupColumn aggregateColumn |\r\t\r\taGroupColumnName = anAggregateColumnName\r\t\tifTrue: [ Error signal: \'Can not group a column by itself\' ].\r\t\t\r\tgroupColumn := self column: aGroupColumnName.\r\taggregateColumn := self column: anAggregateColumnName.\r\t\r\t^ aggregateColumn groupBy: groupColumn aggregateUsing: aBlock as: aNewColumnName',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.948176-04:00' ],		#prior : OmReference [ '1356' ],		#self : OmReference [ '1357' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: arg1 aggregate: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg2 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg3 value: self value: arg1 ].\r  ^DataFrame withColumns: tmp1 rowNames: tmp1 first keys columnNames: (tmp1 collect: #name)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: columnName aggregate: anArrayOfUsingAsStatements\r\r\t| aggregatedColumns |\r\t\r\taggregatedColumns := anArrayOfUsingAsStatements collect: [ :aBlock |\r\t\taBlock value: self value: columnName ].\r\t\r\t^ DataFrame\r\t\twithColumns: aggregatedColumns\r\t\trowNames: aggregatedColumns first keys\r\t\tcolumnNames: (aggregatedColumns collect: #name)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.948713-04:00' ],		#prior : OmReference [ '1357' ],		#self : OmReference [ '1358' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: arg1\r  < gtInspectorPresentationOrder: 0>\r  < gtInspectorTag: #basic>\r  | tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 morph.\r  tmp2\r     title: \'Fast Table\';\r     display: [ #metaObject count: 2.\r        nil.\r        self showWithGlamourIn: arg1 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: composite\r\t<gtInspectorPresentationOrder: 0>\r\t<gtInspectorTag: #basic>\r\t\r\tcomposite morph\r\t\ttitle: \'Fast Table\';\r\t\tdisplay: [ self showWithGlamourIn: composite ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.949169-04:00' ],		#prior : OmReference [ '1358' ],		#self : OmReference [ '1359' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 fastTable when: [ #metaObject count: 2.\r        nil.\r        false ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: composite\r"Hide Items from inspector"\r\r\tcomposite fastTable\r\t\twhen: [ false ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.949604-04:00' ],		#prior : OmReference [ '1359' ],		#self : OmReference [ '1360' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head \r\r\t^ self head: self defaultHeadTailSize.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.950061-04:00' ],		#prior : OmReference [ '1360' ],		#self : OmReference [ '1361' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  self numberOfRows > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := self numberOfRows ].\r  ^self rowsAt: (1 to: tmp1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: aNumber\r\r\t| n |\r\t\r\tself numberOfRows  > aNumber\r\t\tifTrue: [ n := aNumber ]\r\t\tifFalse: [ n := self numberOfRows ].\r\t\t\r\t^ self rowsAt: (1 to: n).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.950527-04:00' ],		#prior : OmReference [ '1361' ],		#self : OmReference [ '1362' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfColumnNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Column \' , arg1 , \' was not found\' ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: columnName\r\t"Answer the index of a column with a given name or signal an exception if the column with that name was not found"\r\t^ self\r\t\tindexOfColumnNamed: columnName\r\t\tifAbsent: [ LibrarySymbolNotFoundError signal: (\'Column \', columnName, \' was not found\') ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.951279-04:00' ],		#prior : OmReference [ '1362' ],		#self : OmReference [ '1363' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self columnNames indexOf: arg1 ifAbsent: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: columnName ifAbsent: exceptionBlock\r\t"Answer the index of a column with a given name or evaluate the exceptionBlock if the column with that name was not found"\r\t^ self columnNames\r\t\tindexOf: columnName\r\t\tifAbsent: exceptionBlock.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.953196-04:00' ],		#prior : OmReference [ '1363' ],		#self : OmReference [ '1364' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  ^self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Row \' , arg1 , \' was not found\' ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: rowName\r\t"Answer the index of a row with a given name or signal an exception if the row with that name was not found"\r\t^ self\r\t\tindexOfRowNamed: rowName\r\t\tifAbsent: [ LibrarySymbolNotFoundError signal: (\'Row \', rowName, \' was not found\') ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.953964-04:00' ],		#prior : OmReference [ '1364' ],		#self : OmReference [ '1365' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: arg1 ifAbsent: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowNames indexOf: arg1 ifAbsent: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: rowName ifAbsent: exceptionBlock\r\t"Answer the index of a row with a given name or evaluate the exceptionBlock if the row with that name was not found"\r\t^ self rowNames\r\t\tindexOf: rowName\r\t\tifAbsent: exceptionBlock.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.954478-04:00' ],		#prior : OmReference [ '1365' ],		#self : OmReference [ '1366' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new.\r  self setDefaultRowColumnNames',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\r\tsuper initialize.\r\t\r\tcontents := DataFrameInternal new.\r\tself setDefaultRowColumnNames.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.954925-04:00' ],		#prior : OmReference [ '1366' ],		#self : OmReference [ '1367' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new: arg1.\r  self setDefaultRowColumnNames',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aPoint\r\r\tsuper initialize.\r\t\r\tcontents := DataFrameInternal new: aPoint.\r\tself setDefaultRowColumnNames.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.955375-04:00' ],		#prior : OmReference [ '1367' ],		#self : OmReference [ '1368' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withColumns: arg1.\r  self setDefaultRowColumnNames',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: anArrayOfArrays\r\r\tcontents := DataFrameInternal withColumns: anArrayOfArrays.\r\tself setDefaultRowColumnNames.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.955822-04:00' ],		#prior : OmReference [ '1368' ],		#self : OmReference [ '1369' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeContents:rowNames:columnNames:',			#protocol : #initialization,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeContents:rowNames:columnNames:',			#protocol : #initialization,			#sourceCode : 'initializeContents: aDataFrameInternal rowNames: rows columnNames: columns\r\r\tsuper initialize.\r\t\r\tcontents := aDataFrameInternal.\r\tself rowNames: rows.\r\tself columnNames: columns.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.956261-04:00' ],		#prior : OmReference [ '1369' ],		#self : OmReference [ '1370' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: arg1\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withRows: arg1.\r  self setDefaultRowColumnNames',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: anArrayOfArrays\r\r\tcontents := DataFrameInternal withRows: anArrayOfArrays.\r\tself setDefaultRowColumnNames.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.956698-04:00' ],		#prior : OmReference [ '1370' ],		#self : OmReference [ '1371' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: arg1 into: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := super inject: arg1 into: arg2.\r  tmp1 name: tmp1 defaultName.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: thisValue into: binaryBlock \r\t| series |\r\tseries := super inject: thisValue into: binaryBlock.\r\tseries name: series defaultName.\r\t^ series',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.957198-04:00' ],		#prior : OmReference [ '1371' ],		#self : OmReference [ '1372' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp1 := self rowNames select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 rowNames includes: arg2 ].\r  tmp1 do: [:arg3 |  | tmp3 |\r        #metaObject count: 3.\r        nil.\r        tmp3 := (self row: arg3) asArray , (arg1 row: arg3) asArray.\r        tmp2 addRow: tmp3 named: arg3 ].\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame\r\t"Performs inner join on aDataFrame with rowNames as keys"\r\r\t| outputRows outputDf |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\t\r\t"Using select instead of intersection to preserve order"\r\toutputRows := self rowNames select: [ :row | aDataFrame rowNames includes: row ].\r\toutputRows do: [ :rowName |\r\t\t| rowToAdd |\r\t\trowToAdd := (self row: rowName) asArray, (aDataFrame row: rowName) asArray.\r\t\toutputDf addRow: rowToAdd named: rowName.\r\t\t].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.957637-04:00' ],		#prior : OmReference [ '1372' ],		#self : OmReference [ '1373' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self innerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame on: aColumnName\r\t"Inner join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r\t^ self innerJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.958265-04:00' ],		#prior : OmReference [ '1373' ],		#self : OmReference [ '1374' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  self size isZero | arg1 size isZero ifFalse: [ #metaObject count: 2.\r        nil.\r        tmp1 := OrderedCollection new.\r        (self column: arg2) withIndexDo: [:arg4 :arg5 |  #metaObject count: 3.\r              nil.\r              ((arg1 column: arg3) includes: arg4) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    tmp1 add: arg5 ] ].\r        tmp1 do: [:arg6 |  | tmp4 tmp5 |\r              #metaObject count: 5.\r              nil.\r              tmp4 := arg1 findAllIndicesOf: (self at: arg6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp4 do: [:arg7 |  #metaObject count: 6.\r                    nil.\r                    tmp5 := (self rowAt: arg6) asArray , (arg1 rowAt: arg7) asArray.\r                    tmp2 addRow: tmp5 named: tmp2 size + 1 ] ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 7.\r        nil.\r        tmp2\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r\t"Performs inner join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r\r\t| outputRows outputDf |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\t\r\t"Skip join if any of the dataframe is zero"\r\t((self size isZero) | (aDataFrame size isZero)) ifFalse: [\r\t\t"Using select instead of intersection to preserve order"\r\t\toutputRows := OrderedCollection new.\r\t\t(self column: leftColumn) withIndexDo: [ :ele :index |\r\t\t\t((aDataFrame column: rightColumn) includes: ele) ifTrue: [ outputRows add: index ] ].\r\t\toutputRows do: [ :rowIndex |\r\t\t\t| rowsWithSameKey rowToAdd |\r\t\t\trowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r\t\t\trowsWithSameKey do: [ :rightRow |\r\t\t\t\trowToAdd := (self rowAt: rowIndex) asArray, (aDataFrame rowAt: rightRow) asArray.\r\t\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t"Since Key is common, remove duplicate key column if it is of same name"\r\t(leftColumn = rightColumn) ifTrue: [\r\t\toutputDf removeColumn: (rightColumn, \'_y\').\r\t\toutputDf renameColumn: (leftColumn, \'_x\') to: leftColumn.\r\t\t].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.958699-04:00' ],		#prior : OmReference [ '1374' ],		#self : OmReference [ '1375' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #interquartileRange',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r\r\t^ self applyToAllColumns: #interquartileRange',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.959217-04:00' ],		#prior : OmReference [ '1375' ],		#self : OmReference [ '1376' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame\r\t"Performs left join on aDataFrame with rowNames as keys"\r\r\t| outputDf commonRows |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\tcommonRows := self rowNames intersection: aDataFrame rowNames.\r\tself rowNames do: [ :rowName | \r\t\t| rowToAdd |\r\t\trowToAdd := (commonRows includes: rowName)\r\t\t\tifTrue: [ (self row: rowName) asArray , (aDataFrame row: rowName) asArray ]\r\t\t\tifFalse: [ (self row: rowName) asArray , (Array new: aDataFrame columnNames size) ].\r\t\toutputDf addRow: rowToAdd named: rowName ].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.959656-04:00' ],		#prior : OmReference [ '1376' ],		#self : OmReference [ '1377' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self leftJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame on: aColumnName\r\t"Left join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r\t^ self leftJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.96031-04:00' ],		#prior : OmReference [ '1377' ],		#self : OmReference [ '1378' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp3 := self size.\r  1 to: tmp3 do: [:tmp6 |  | tmp7 |\r        #metaObject count: 2.\r        nil.\r        tmp5 := nil.\r        (tmp2 includes: (self at: tmp6 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp5 := arg1 findAllIndicesOf: (self at: tmp6 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp5 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp7 := (self rowAt: tmp6) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp7 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp7 := (self rowAt: tmp6) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp7 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 6.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r\t"Performs left join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r\r\t| outputDf commonRows |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\t\r\tcommonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r\t\r\t1 to: self size do: [ :rowIndex |\r\t\t| rowsWithSameKey rowToAdd |\r\t\t(commonRows includes: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)))\r\t\tifTrue: [\r\t\t\t"Row present in both df - append rows and add to outputDf"\r\t\t\trowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r\t\t\trowsWithSameKey do: [ :rightRow |\r\t\t\t\trowToAdd := (self rowAt: rowIndex) asArray, (aDataFrame rowAt: rightRow) asArray.\r\t\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1).\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse: [\r\t\t\t"Row present in left-only - append nils and add to outputDf"\r\t\t\trowToAdd := (self rowAt: rowIndex) asArray, (Array new: aDataFrame columnNames size).\r\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1)\r\t\t\t].\r\t\t].\r\t\r\t"Since Key is common, remove duplicate key column if it is of same name"\r\t(leftColumn = rightColumn) ifTrue: [\r\t\toutputDf removeColumn: (rightColumn, \'_y\').\r\t\toutputDf renameColumn: (leftColumn, \'_x\') to: leftColumn.\r\t\t].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.96073-04:00' ],		#prior : OmReference [ '1378' ],		#self : OmReference [ '1379' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #max',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r\r\t^ self applyToAllColumns: #max',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.961154-04:00' ],		#prior : OmReference [ '1379' ],		#self : OmReference [ '1380' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #median',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r\r\t^ self applyToAllColumns: #median',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.961623-04:00' ],		#prior : OmReference [ '1380' ],		#self : OmReference [ '1381' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #min',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r\r\t^ self applyToAllColumns: #min',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.962256-04:00' ],		#prior : OmReference [ '1381' ],		#self : OmReference [ '1382' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #mode',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r\r\t^ self applyToAllColumns: #mode',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.962715-04:00' ],		#prior : OmReference [ '1382' ],		#self : OmReference [ '1383' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfColumns',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r\r\t^ contents numberOfColumns',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.963143-04:00' ],		#prior : OmReference [ '1383' ],		#self : OmReference [ '1384' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfRows',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r\r\t^ contents numberOfRows',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.963705-04:00' ],		#prior : OmReference [ '1384' ],		#self : OmReference [ '1385' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  self rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: arg2) asArray , (Array new: arg1 columnNames size) ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  arg1 rowNames do: [:arg3 |  #metaObject count: 5.\r        nil.\r        (tmp2 includes: arg3) ifFalse: [ #metaObject count: 6.\r              nil.\r              tmp1 addRow: (Array new: self columnNames size) , (arg1 row: arg3) asArray named: arg3 ] ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame\r\t"Performs outer join on aDataFrame with rowNames as keys"\r\r\t| outputDf commonRows |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\tcommonRows := self rowNames intersection: aDataFrame rowNames.\r\tself rowNames do: [ :rowName | \r\t\t| rowToAdd |\r\t\trowToAdd := (commonRows includes: rowName)\r\t\t\tifTrue: [ (self row: rowName) asArray , (aDataFrame row: rowName) asArray ]\r\t\t\tifFalse: [ (self row: rowName) asArray , (Array new: aDataFrame columnNames size) ].\r\t\toutputDf addRow: rowToAdd named: rowName ].\r\t\r\taDataFrame rowNames do: [ :rowName | \r\t\t(commonRows includes: rowName)\r\t\t\tifFalse: [ outputDf\r\t\t\t\taddRow: (Array new: self columnNames size) , (aDataFrame row: rowName) asArray\r\t\t\t\tnamed: rowName ] ].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.964155-04:00' ],		#prior : OmReference [ '1385' ],		#self : OmReference [ '1386' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self outerJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame on: aColumnName\r\t"Outer join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r\t^ self outerJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.964927-04:00' ],		#prior : OmReference [ '1386' ],		#self : OmReference [ '1387' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := self size.\r  1 to: tmp4 do: [:tmp7 |  | tmp9 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (self at: tmp7 at: (self indexOfColumnNamed: arg2))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := arg1 findAllIndicesOf: (self at: tmp7 at: (self indexOfColumnNamed: arg2)) atColumn: arg3.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp9 := (self rowAt: tmp7) asArray , (arg1 rowAt: arg4) asArray.\r                    tmp1 addRow: tmp9 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp9 := (self rowAt: tmp7) asArray , (Array new: arg1 columnNames size).\r              tmp1 addRow: tmp9 named: tmp1 size + 1 ] ].\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  #metaObject count: 6.\r        nil.\r        tmp8 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifFalse: [ #metaObject count: 7.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 8.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 9.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 10.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r\t"Performs outer join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r\r\t| outputDf commonRows leftNils |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\t\r\tcommonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r\r\t1 to: self size do: [ :rowIndex |\r\t\t| rowsWithSameKey rowToAdd |\r\t\t(commonRows includes: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)))\r\t\tifTrue: [\r\t\t\t"Row present in both df - append rows and add to outputDf"\r\t\t\trowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r\t\t\trowsWithSameKey do: [ :rightRow |\r\t\t\t\trowToAdd := (self rowAt: rowIndex) asArray, (aDataFrame rowAt: rightRow) asArray.\r\t\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1).\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse: [\r\t\t\t"Row present in left-only - append nils and add to outputDf"\r\t\t\trowToAdd := (self rowAt: rowIndex) asArray, (Array new: aDataFrame columnNames size).\r\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1)\r\t\t\t].\r\t\t].\r\t\r\t1 to: aDataFrame size do: [ :rowIndex |\r\t\t| rowToAdd |\r\t\t(commonRows includes: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn)))\r\t\tifFalse: [\r\t\t\t"Row present in right-only - construct row and append"\r\t\t\tleftNils := self columnNames collect: [ :col |\r\t\t\t\tcol = rightColumn\r\t\t\t\t\tifTrue: [ (aDataFrame rowAt: rowIndex) at: rightColumn ]\r\t\t\t\t\tifFalse: [ nil ] ].\r\t\t\trowToAdd := leftNils, (aDataFrame rowAt: rowIndex) asArray.\r\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1).\r\t\t\t].\r\t\t].\r\t\r\t"Since Key is common, remove duplicate key column if it is of same name"\r\t(leftColumn = rightColumn) ifTrue: [\r\t\toutputDf removeColumn: (rightColumn, \'_y\').\r\t\toutputDf renameColumn: (leftColumn, \'_x\') to: leftColumn.\r\t\t].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.965394-04:00' ],		#prior : OmReference [ '1387' ],		#self : OmReference [ '1388' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class name.\r  tmp3 := arg1.\r  tmp3\r     nextPutAll: (tmp1 first isVowel ifTrue: [ #metaObject count: 2.\r              nil.\r              \'an \' ] ifFalse: [ #metaObject count: 3.\r              nil.\r              \'a \' ]);\r     nextPutAll: tmp1;\r     space;\r     nextPutAll: self dimensions asString',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\r\t| title |\r\ttitle := self class name.\r\taStream\r\t\tnextPutAll: (title first isVowel ifTrue: [\'an \'] ifFalse: [\'a \']);\r\t\tnextPutAll: title;\r\t\tspace;\r\t\tnextPutAll: self dimensions asString.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.965822-04:00' ],		#prior : OmReference [ '1388' ],		#self : OmReference [ '1389' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #range',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r\r\t^ self applyToAllColumns: #range',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.966258-04:00' ],		#prior : OmReference [ '1389' ],		#self : OmReference [ '1390' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self removeColumnAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: columnName\r\r\t| index |\r\tindex := self indexOfColumnNamed: columnName.\r\tself removeColumnAt: index.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.966733-04:00' ],		#prior : OmReference [ '1390' ],		#self : OmReference [ '1391' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeColumnAt: arg1.\r  columnNames := columnNames copyWithoutIndex: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: columnNumber\r\t(columnNumber < 1 or: [ columnNumber > self numberOfColumns ])\r\t\tifTrue: [ SubscriptOutOfBounds signalFor: columnNumber ].\r\r\tcontents removeColumnAt: columnNumber.\r\tcolumnNames := columnNames copyWithoutIndex: columnNumber.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.967172-04:00' ],		#prior : OmReference [ '1391' ],		#self : OmReference [ '1392' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeColumn: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: aCollectionOfColumnNames\r\taCollectionOfColumnNames do: [ :each |\r\t\tself removeColumn: each ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.967614-04:00' ],		#prior : OmReference [ '1392' ],		#self : OmReference [ '1393' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        columnNames at: arg2 ].\r  self removeColumns: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: aCollectionOfColumnIndices\r\t| columnNamesToRemove |\r\tcolumnNamesToRemove := aCollectionOfColumnIndices collect: [ :i |\r\t\tcolumnNames at: i ].\r\tself removeColumns: columnNamesToRemove',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.96813-04:00' ],		#prior : OmReference [ '1393' ],		#self : OmReference [ '1394' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := columnNames deepCopy.\r  columnNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg2 at: arg4)) ifFalse: [ #metaObject count: 5.\r              nil.\r              columnNames add: arg3 ] ].\r  contents removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2.\r  self numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        rowNames removeAll ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber\r\r\t| columnNamesCopy |\r\t(rowNumber < 1 or: [ rowNumber > self numberOfRows ])\r\t\tifTrue: [ SubscriptOutOfBounds signalFor: rowNumber ].\r\t\t\r\tcolumnNamesCopy := columnNames deepCopy.\r\tcolumnNames removeAll.\r\tcolumnNamesCopy withIndexDo: [ :columnName :j |\r\t\t(aBlock value: (contents at: rowNumber at: j))\r\t\t\tifFalse: [ columnNames add: columnName ]].\r\tcontents removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber.\r\t\r\tself numberOfColumns = 0 ifTrue: [ rowNames removeAll ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.96859-04:00' ],		#prior : OmReference [ '1394' ],		#self : OmReference [ '1395' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRowNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg2.\r  self removeColumnsOfRowElementsSatisfing: arg1 onRow: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRowNamed: rowName\r\r\t| index |\r\tindex := self indexOfRowNamed: rowName.\r\tself removeColumnsOfRowElementsSatisfing: aBlock onRow: index.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.969029-04:00' ],		#prior : OmReference [ '1395' ],		#self : OmReference [ '1396' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRow: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: rowNumber\r\tself removeColumnsOfRowElementsSatisfing: [ :ele | ele isNil ] onRow: rowNumber.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.969522-04:00' ],		#prior : OmReference [ '1396' ],		#self : OmReference [ '1397' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onRowNamed: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: rowName\r\tself removeColumnsOfRowElementsSatisfing: [ :ele | ele isNil ] onRowNamed: rowName.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.970113-04:00' ],		#prior : OmReference [ '1397' ],		#self : OmReference [ '1398' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self removeRowAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: rowName\r\r\t| index |\r\tindex := self indexOfRowNamed: rowName.\r\tself removeRowAt: index.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.970728-04:00' ],		#prior : OmReference [ '1398' ],		#self : OmReference [ '1399' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg1 > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg1 ].\r  contents removeRowAt: arg1.\r  rowNames := rowNames copyWithoutIndex: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: rowNumber\r\t(rowNumber < 1 or: [ rowNumber > self numberOfRows ])\r\t\tifTrue: [ SubscriptOutOfBounds signalFor: rowNumber ].\r\t\t\r\tcontents removeRowAt: rowNumber.\r\trowNames := rowNames copyWithoutIndex: rowNumber.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.971437-04:00' ],		#prior : OmReference [ '1399' ],		#self : OmReference [ '1400' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg2 |  #metaObject count: 2.\r        nil.\r        self removeRow: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: aCollectionOfRowNames\r\taCollectionOfRowNames do: [ :each |\r\t\tself removeRow: each ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.971902-04:00' ],		#prior : OmReference [ '1400' ],		#self : OmReference [ '1401' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        rowNames at: arg2 ].\r  self removeRows: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: aCollectionOfRowIndices\r\t| rowNamesToRemove |\r\trowNamesToRemove := aCollectionOfRowIndices collect: [ :i |\r\t\trowNames at: i ].\r\tself removeRows: rowNamesToRemove',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.972454-04:00' ],		#prior : OmReference [ '1401' ],		#self : OmReference [ '1402' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  (arg2 < 1 or: [ #metaObject count: 2.\r        nil.\r        arg2 > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: arg2 ].\r  tmp1 := rowNames deepCopy.\r  rowNames removeAll.\r  tmp1 withIndexDo: [:arg3 :arg4 |  #metaObject count: 4.\r        nil.\r        (arg1 value: (contents at: arg4 at: arg2)) ifFalse: [ #metaObject count: 5.\r              nil.\r              rowNames add: arg3 ] ].\r  contents removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2.\r  self numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        columnNames removeAll ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber\r\t\r\t| rowNamesCopy |\r\t(columnNumber < 1 or: [ columnNumber > self numberOfColumns ])\r\t\tifTrue: [ SubscriptOutOfBounds signalFor: columnNumber ].\r\r\trowNamesCopy := rowNames deepCopy.\r\trowNames removeAll.\r\trowNamesCopy withIndexDo: [ :rowName :i |\r\t\t(aBlock value: (contents at: i at: columnNumber))\r\t\t\tifFalse: [ rowNames add: rowName ] ].\r\tcontents removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber.\r\t\r\tself numberOfRows = 0 ifTrue: [ columnNames removeAll ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.972902-04:00' ],		#prior : OmReference [ '1402' ],		#self : OmReference [ '1403' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumnNamed: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg2.\r  self removeRowsOfColumnElementsSatisfing: arg1 onColumn: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumnNamed: columnName\r\r\t| index |\r\tindex := self indexOfColumnNamed: columnName.\r\tself removeRowsOfColumnElementsSatisfing: aBlock onColumn: index.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.973446-04:00' ],		#prior : OmReference [ '1403' ],		#self : OmReference [ '1404' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumn: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: columnNumber\r\tself removeRowsOfColumnElementsSatisfing: [ :ele | ele isNil ] onColumn: columnNumber.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.973924-04:00' ],		#prior : OmReference [ '1404' ],		#self : OmReference [ '1405' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: arg1\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg2 isNil ] onColumnNamed: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: columnName\r\tself removeRowsOfColumnElementsSatisfing: [ :ele | ele isNil ] onColumnNamed: columnName.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.974375-04:00' ],		#prior : OmReference [ '1405' ],		#self : OmReference [ '1406' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfColumnNamed: arg1.\r  self columnNames at: tmp1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: oldName to: newName\r\t"Find a column with oldName and rename it to newName"\r\t| index |\r\tindex := self indexOfColumnNamed: oldName.\r\tself columnNames at: index put: newName.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.974832-04:00' ],		#prior : OmReference [ '1406' ],		#self : OmReference [ '1407' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: arg1 to: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  self rowNames at: tmp1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: oldName to: newName\r\t"Find a row with oldName and rename it to newName"\r\t| index |\r\tindex := self indexOfRowNamed: oldName.\r\tself rowNames at: index put: newName.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.975356-04:00' ],		#prior : OmReference [ '1407' ],		#self : OmReference [ '1408' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := self rowNames intersection: arg1 rowNames.\r  arg1 rowNames do: [:arg2 |  | tmp3 |\r        #metaObject count: 2.\r        nil.\r        tmp3 := (tmp2 includes: arg2) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: arg2) asArray , (arg1 row: arg2) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (Array new: self columnNames size) , (arg1 row: arg2) asArray ].\r        tmp1 addRow: tmp3 named: arg2 ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame\r\t"Performs right join on aDataFrame with rowNames as keys"\r\r\t| outputDf commonRows |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\tcommonRows := self rowNames intersection: aDataFrame rowNames.\r\t\r\taDataFrame rowNames do: [ :rowName | \r\t\t| rowToAdd |\r\t\trowToAdd := (commonRows includes: rowName)\r\t\t\tifTrue: [ (self row: rowName) asArray , (aDataFrame row: rowName) asArray ]\r\t\t\tifFalse: [ (Array new: self columnNames size) , (aDataFrame row: rowName) asArray ].\r\t\toutputDf addRow: rowToAdd named: rowName ].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.977156-04:00' ],		#prior : OmReference [ '1408' ],		#self : OmReference [ '1409' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 on: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rightJoin: arg1 onLeft: arg2 onRight: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame on: aColumnName\r\t"Right join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r\t^ self rightJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.97798-04:00' ],		#prior : OmReference [ '1409' ],		#self : OmReference [ '1410' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: arg1 onLeft: arg2 onRight: arg3\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self class withColumnNames: (self getJointColumnsWith: arg1).\r  tmp2 := (self column: arg2) asArray intersection: (arg1 column: arg3) asArray.\r  tmp4 := arg1 size.\r  1 to: tmp4 do: [:tmp7 |  | tmp8 |\r        #metaObject count: 2.\r        nil.\r        tmp6 := nil.\r        (tmp2 includes: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3))) ifTrue: [ #metaObject count: 3.\r              nil.\r              tmp6 := self findAllIndicesOf: (arg1 at: tmp7 at: (arg1 indexOfColumnNamed: arg3)) atColumn: arg2.\r              tmp6 do: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    tmp8 := (self rowAt: arg4) asArray , (arg1 rowAt: tmp7) asArray.\r                    tmp1 addRow: tmp8 named: tmp1 size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              tmp3 := self columnNames collect: [:arg5 |  #metaObject count: 6.\r                    nil.\r                    arg5 = arg3 ifTrue: [ #metaObject count: 7.\r                          nil.\r                          (arg1 rowAt: tmp7) at: arg3 ] ].\r              tmp8 := tmp3 , (arg1 rowAt: tmp7) asArray.\r              tmp1 addRow: tmp8 named: tmp1 size + 1 ] ].\r  arg2 = arg3 ifTrue: [ #metaObject count: 8.\r        nil.\r        tmp1\r           removeColumn: arg3 , \'_y\';\r           renameColumn: arg2 , \'_x\' to: arg2 ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r\t"Performs right join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r\r\t| outputDf commonRows leftNils |\r\t\r\toutputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r\t\r\tcommonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r\t\r\t1 to: aDataFrame size do: [ :rowIndex |\r\t\t| rowToAdd rowsWithSameKey |\r\t\t(commonRows includes: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn)))\r\t\tifTrue: [ \r\t\t\t"Row present in both df - append rows and add to outputDf"\r\t\t\trowsWithSameKey := self findAllIndicesOf: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn)) atColumn: leftColumn.\r\t\t\trowsWithSameKey do: [ :leftRow |\r\t\t\t\trowToAdd := (self rowAt: leftRow) asArray, (aDataFrame rowAt: rowIndex) asArray.\r\t\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1).\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse: [\r\t\t\t"Row present in right-only - construct row and append"\r\t\t\tleftNils := self columnNames collect: [ :col |\r\t\t\t\tcol = rightColumn\r\t\t\t\t\tifTrue: [ (aDataFrame rowAt: rowIndex) at: rightColumn ]\r\t\t\t\t\tifFalse: [ nil ] ].\r\t\t\trowToAdd := leftNils, (aDataFrame rowAt: rowIndex) asArray.\r\t\t\toutputDf addRow: rowToAdd named: (outputDf size + 1).\r\t\t\t].\r\t\t].\r\t\r\t"Since Key is common, remove duplicate key column if it is of same name"\r\t(leftColumn = rightColumn) ifTrue: [\r\t\toutputDf removeColumn: (rightColumn, \'_y\').\r\t\toutputDf renameColumn: (leftColumn, \'_x\') to: leftColumn.\r\t\t].\r\t\r\t^ outputDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.978599-04:00' ],		#prior : OmReference [ '1410' ],		#self : OmReference [ '1411' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: rowName\r\t"Answer the row with rowName as a DataSeries or signal an exception if a row with that name was not found"\r\t| index |\r\tindex := self indexOfRowNamed: rowName.\r\t^ self rowAt: index',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.979079-04:00' ],		#prior : OmReference [ '1411' ],		#self : OmReference [ '1412' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 ifAbsent: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg2 value ].\r  ^self rowAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName ifAbsent: exceptionBlock\r\t"Answer the row with rowName as a DataSeries or evaluate exception block if a row with that name was not found"\r\t| index |\r\tindex := self\r\t\tindexOfRowNamed: rowName\r\t\tifAbsent: [ ^ exceptionBlock value ].\r\t\t\r\t^ self rowAt: index',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.979521-04:00' ],		#prior : OmReference [ '1412' ],		#self : OmReference [ '1413' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1.\r  ^self rowAt: tmp1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: rowName put: anArray\r\t"Replace the current values of row with rowName with anArray or signal an exception if a row with that name was not found"\r\t| index |\r\tindex := self indexOfRowNamed: rowName.\r\t^ self rowAt: index put: anArray.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.979992-04:00' ],		#prior : OmReference [ '1413' ],		#self : OmReference [ '1414' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 put: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self indexOfRowNamed: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  ^self rowAt: tmp1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName put: anArray ifAbsent: exceptionBlock\r\t"Replace the current values of row with rowName with anArray or evaluate exception block if a row with that name was not found"\r\t| index |\r\tindex := self\r\t\tindexOfRowNamed: rowName\r\t\tifAbsent: [ ^ exceptionBlock value ].\r\t\t\r\t^ self rowAt: index put: anArray',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.980434-04:00' ],		#prior : OmReference [ '1414' ],		#self : OmReference [ '1415' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1.\r  self row: arg1 put: (arg2 value: tmp1) asArray',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: rowName transform: aBlock\r\t"Evaluate aBlock on the row with rowName and replace row with the result. Signal an exception if rowName was not found"\r\t| row |\r\trow := self row: rowName.\r\tself row: rowName put: (aBlock value: row) asArray',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.980885-04:00' ],		#prior : OmReference [ '1415' ],		#self : OmReference [ '1416' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: arg1 transform: arg2 ifAbsent: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self row: arg1 ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^arg3 value ].\r  self row: arg1 put: (arg2 value: tmp1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName transform: aBlock ifAbsent: exceptionBlock\r\t"Evaluate aBlock on the row with rowName and replace row with the result. Evaluate exceptionBlock if rowName was not found"\r\t| row |\r\trow := self row: rowName ifAbsent: [ ^ exceptionBlock value ].\r\tself row: rowName put: (aBlock value: row)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.981312-04:00' ],		#prior : OmReference [ '1416' ],		#self : OmReference [ '1417' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (contents rowAt: arg1) asDataSeries.\r  tmp1\r     name: (self rowNames at: arg1);\r     keys: self columnNames.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber\r\r\t| series |\r\tseries := (contents rowAt: aNumber) asDataSeries.\r\tseries name: (self rowNames at: aNumber).\r\tseries keys: self columnNames.\r\t^ series',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.981744-04:00' ],		#prior : OmReference [ '1417' ],		#self : OmReference [ '1418' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents rowAt: arg1 put: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber put: anArray\r\r\tanArray size = self numberOfColumns\r\t\tifFalse: [ SizeMismatch signal ].\r\t\t\r\tcontents rowAt: aNumber put: anArray.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.982193-04:00' ],		#prior : OmReference [ '1418' ],		#self : OmReference [ '1419' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 transform: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self rowAt: arg1.\r  self rowAt: arg1 put: (arg2 value: tmp1) asArray',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber transform: aBlock\r\t"Evaluate aBlock on the row at aNumber and replace that row with the result"\r\t| row |\r\trow := self rowAt: aNumber.\r\tself rowAt: aNumber put: (aBlock value: row) asArray',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.982603-04:00' ],		#prior : OmReference [ '1419' ],		#self : OmReference [ '1420' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r  #metaObject count: 1.\r  nil.\r  ^rowNames',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r\r\t^ rowNames',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.983063-04:00' ],		#prior : OmReference [ '1420' ],		#self : OmReference [ '1421' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: arg1\r  #metaObject count: 1.\r  nil.\r  arg1 size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of row names\' ].\r  arg1 asSet size = arg1 size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All row names must be distinct\' ].\r  rowNames := arg1 asOrderedCollection',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: anArray\r\tanArray size = self numberOfRows \r\t\tifFalse: [ SizeMismatch signal: \'Wrong number of row names\' ].\r\t\t\r\tanArray asSet size = anArray size\r\t\tifFalse: [ Error signal: \'All row names must be distinct\' ].\r\t\t\r\trowNames := anArray asOrderedCollection',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.983492-04:00' ],		#prior : OmReference [ '1421' ],		#self : OmReference [ '1422' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self indexOfRowNamed: arg2 ].\r  ^self rowsAt: tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: anArrayOfNames\r\t\r\t| anArrayOfNumbers |\r\t\r\tanArrayOfNumbers := anArrayOfNames\r\t\tcollect: [ :name |\r\t\t\tself indexOfRowNamed: name ].\r\t\t\t\r\t^ self rowsAt: anArrayOfNumbers.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.983934-04:00' ],		#prior : OmReference [ '1422' ],		#self : OmReference [ '1423' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self row: arg3 put: arg4 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: anArrayOfRowNames put: anArrayOfArrays\r\t\r\tanArrayOfArrays size = anArrayOfRowNames size\r\t\tifFalse: [ SizeMismatch signal ].\t\r\t\r\tanArrayOfRowNames with: anArrayOfArrays do: [ :name :array |\r\t\tself row: name put: array ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.984383-04:00' ],		#prior : OmReference [ '1423' ],		#self : OmReference [ '1424' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self rowNames at: arg2 ].\r  ^DataFrame withDataFrameInternal: (self contents rowsAt: arg1) rowNames: tmp1 columnNames: self columnNames',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers\r\r\t| newRowNames |\r\t\r\tnewRowNames := (anArrayOfNumbers collect: [ :i |\r\t\tself rowNames at: i ]).\r\r\t^ DataFrame\r\t\twithDataFrameInternal: (self contents rowsAt: anArrayOfNumbers)\r\t\trowNames: newRowNames\r\t\tcolumnNames: self columnNames.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.984842-04:00' ],		#prior : OmReference [ '1424' ],		#self : OmReference [ '1425' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  arg2 size = arg1 size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  arg1 with: arg2 do: [:arg3 :arg4 |  #metaObject count: 3.\r        nil.\r        self rowAt: arg3 put: arg4 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers put: anArrayOfArrays\r\t\r\tanArrayOfArrays size = anArrayOfNumbers size\r\t\tifFalse: [ SizeMismatch signal ].\t\r\t\r\tanArrayOfNumbers with: anArrayOfArrays do: [ :index :array |\r\t\tself rowAt: index put: array ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.985257-04:00' ],		#prior : OmReference [ '1425' ],		#self : OmReference [ '1426' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2\r  #metaObject count: 1.\r  nil.\r  ^self rowsAt: (arg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: begin to: end\r\r\t^ self rowsAt: (begin to: end).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.98573-04:00' ],		#prior : OmReference [ '1426' ],		#self : OmReference [ '1427' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: arg1 to: arg2 put: arg3\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  arg3 size = ((arg1 - arg2) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp1 := arg2 >= arg1 ifTrue: [ #metaObject count: 3.\r        nil.\r        arg1 to: arg2 ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (arg2 to: arg1) reversed ].\r  tmp1 withIndexDo: [:arg4 :arg5 |  #metaObject count: 5.\r        nil.\r        self rowAt: arg4 put: (arg3 at: arg5) ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: firstNumber to: secondNumber put: anArrayOfArrays\r\r\t| interval |\r\t\r\tanArrayOfArrays size = ((firstNumber - secondNumber) abs + 1)\r\t\tifFalse: [ SizeMismatch signal ].\t\r\t\t\t\r\tinterval := secondNumber >= firstNumber\r\t\tifTrue: [ (firstNumber to: secondNumber) ]\r\t\tifFalse: [ (secondNumber to: firstNumber) reversed ].\r\t\r\tinterval withIndexDo: [ :rowIndex :i |\r\t\tself rowAt: rowIndex put: (anArrayOfArrays at: i) ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.986463-04:00' ],		#prior : OmReference [ '1427' ],		#self : OmReference [ '1428' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := tmp1 select: arg1.\r  tmp3 := tmp2 isEmpty ifTrue: [ #metaObject count: 2.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp2 collect: #name ].\r  tmp4 := tmp2 isEmpty ifTrue: [ #metaObject count: 4.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 5.\r        nil.\r        self columnNames ].\r  tmp5 := tmp2 collect: #asArray.\r  tmp6 := self class withRows: tmp5 rowNames: tmp3 columnNames: tmp4.\r  ^tmp6',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: aBlock \r\t"Evaluate aBlock with each of the receiver\'s elements as the argument. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to true. Answer the new collection."\r\r\t| rows selectedRows selectedRowNames selectedColumnNames selectedRowsAsArrays df |\r\t\r\trows := self asArrayOfRows.\r\tselectedRows := rows select: aBlock.\r\tselectedRowNames := (selectedRows isEmpty)\r\t\tifTrue: [ #() ] ifFalse: [ selectedRows collect: #name ].\r\tselectedColumnNames := (selectedRows isEmpty)\r\t\tifTrue: [ #() ] ifFalse: [ self columnNames ].\r\tselectedRowsAsArrays := selectedRows collect: #asArray.\r\t\r\tdf := self class\r\t\twithRows: selectedRowsAsArrays\r\t\trowNames: selectedRowNames\r\t\tcolumnNames: selectedColumnNames.\r\t\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.98697-04:00' ],		#prior : OmReference [ '1428' ],		#self : OmReference [ '1429' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r  #metaObject count: 1.\r  nil.\r  self\r     rowNames: (1 to: self numberOfRows);\r     columnNames: (1 to: self numberOfColumns)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r\r\tself rowNames: (1 to: self numberOfRows).\r\tself columnNames: (1 to: self numberOfColumns).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.987486-04:00' ],		#prior : OmReference [ '1429' ],		#self : OmReference [ '1430' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := FTTableMorph new.\r  tmp1\r     beResizable;\r     intercellSpacing: 1;\r     dataSource: (DataFrameFTData elements: self);\r     onAnnouncement: FTSelectionChanged do: [:arg2 |  #metaObject count: 2.\r        nil.\r        (self rowAt: arg2 newSelectedIndexes first) inspect ].\r  tmp2 := #(\'#\') , self columnNames.\r  tmp1 columns: (tmp2 collect: [:arg3 |  #metaObject count: 3.\r              nil.\r              (FTColumn id: arg3) width: 100 ]).\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: composite\r\t| table headerNames |\r\ttable := FTTableMorph new.\r\t"extent: 650@500"\r\ttable\r\t\tbeResizable;\r\t\tintercellSpacing: 1;\r\t\tdataSource: (DataFrameFTData elements: self);\r\t\tonAnnouncement: FTSelectionChanged\r\t\t\tdo: [ :ann | (self rowAt: ann newSelectedIndexes first) inspect ].\r\r\t"\t\tonAnnouncement: FTSelectionChanged \r\t\t\tdo: [ :ann | (self rowsAt: ann newSelectedRowIndexes) gtInspectorItemsIn: composite ];"\r\theaderNames := #(\'#\') , self columnNames.\r\ttable\r\t\tcolumns: (headerNames collect: [ :name | (FTColumn id: name) width: 100 ]).\r\t^ table',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.987906-04:00' ],		#prior : OmReference [ '1430' ],		#self : OmReference [ '1431' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r\t^ self numberOfRows',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.988328-04:00' ],		#prior : OmReference [ '1431' ],		#self : OmReference [ '1432' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 <= arg3 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: columnName\r\tself sortBy: columnName using: [ :a :b | a <= b ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.9888-04:00' ],		#prior : OmReference [ '1432' ],		#self : OmReference [ '1433' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: arg1 using: arg2\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self column: arg1.\r  tmp1 := tmp1 copy.\r  tmp1 sort: arg2.\r  tmp2 := tmp1 keys.\r  tmp3 := DataFrameInternal new: self dimensions.\r  tmp2 withIndexDo: [:arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp3 rowAt: arg4 put: (self row: arg3) asArray ].\r  contents := tmp3.\r  self rowNames: tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: columnName using: aBlock\r\r\t| column sortedKeys newContents |\r\tcolumn := self column: columnName.\r\tcolumn := column copy.\r\tcolumn sort: aBlock.\r\tsortedKeys := column keys.\r\t\r\tnewContents := DataFrameInternal new: self dimensions.\r\t\r\tsortedKeys withIndexDo: [ :key :i |\r\t\tnewContents rowAt: i put: (self row: key) asArray ].\r\t\t\r\tcontents := newContents.\r\tself rowNames: sortedKeys.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.989241-04:00' ],		#prior : OmReference [ '1433' ],		#self : OmReference [ '1434' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: arg1\r  #metaObject count: 1.\r  nil.\r  self sortBy: arg1 using: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        arg2 >= arg3 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: columnName\r\tself sortBy: columnName using: [ :a :b | a >= b ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.989654-04:00' ],		#prior : OmReference [ '1434' ],		#self : OmReference [ '1435' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #stdev',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r\r\t^ self applyToAllColumns: #stdev',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.990069-04:00' ],		#prior : OmReference [ '1435' ],		#self : OmReference [ '1436' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r\r\t^ self tail: self defaultHeadTailSize.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.990508-04:00' ],		#prior : OmReference [ '1436' ],		#self : OmReference [ '1437' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp2 > arg1 ifTrue: [ #metaObject count: 2.\r        nil.\r        tmp1 := arg1 ] ifFalse: [ #metaObject count: 3.\r        nil.\r        tmp1 := tmp2 ].\r  ^self rowsAt: (tmp2 - tmp1 + 1 to: tmp2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: aNumber\r\r\t| n rows |\r\t\r\trows := self numberOfRows.\r\t\r\trows > aNumber\r\t\tifTrue: [ n := aNumber ]\r\t\tifFalse: [ n := rows ].\r\t\t\t\r\t^ self rowsAt: ((rows - n + 1) to: rows).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.990921-04:00' ],		#prior : OmReference [ '1437' ],		#self : OmReference [ '1438' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #thirdQuartile',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r\r\t^ self applyToAllColumns: #thirdQuartile',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.991604-04:00' ],		#prior : OmReference [ '1438' ],		#self : OmReference [ '1439' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self column: arg1) asArray.\r  tmp1 := tmp1 collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        arg2 value: arg3 ].\r  self column: arg1 put: tmp1 asArray',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: columnName applyElementwise: aBlock\r\t| column |\r\tcolumn := (self column: columnName) asArray.\r\tcolumn := column collect: [ :each | aBlock value: each ].\r\tself column: columnName put: column asArray.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.99206-04:00' ],		#prior : OmReference [ '1439' ],		#self : OmReference [ '1440' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: arg1 applyElementwise: arg2\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self columnNames at: arg1.\r  ^self toColumn: tmp1 applyElementwise: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: columnNumber applyElementwise: aBlock\r\t| columnName |\r\tcolumnName := self columnNames at: columnNumber.\r\t^ self toColumn: columnName applyElementwise: aBlock.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.9925-04:00' ],		#prior : OmReference [ '1440' ],		#self : OmReference [ '1441' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumn: arg3 applyElementwise: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arrayOfColumnNames applyElementwise: aBlock\r\t\t\r\tarrayOfColumnNames do: [ :each |\r\t\tself toColumn: each applyElementwise: aBlock ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.992934-04:00' ],		#prior : OmReference [ '1441' ],		#self : OmReference [ '1442' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arg1 applyElementwise: arg2\r  #metaObject count: 1.\r  nil.\r  arg1 do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self toColumnAt: arg3 applyElementwise: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arrayOfColumnNumbers applyElementwise: aBlock\r\t\t\r\tarrayOfColumnNumbers do: [ :each |\r\t\tself toColumnAt: each applyElementwise: aBlock ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.993375-04:00' ],		#prior : OmReference [ '1442' ],		#self : OmReference [ '1443' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := DataFrame withRows: self asArrayOfColumns.\r  tmp1\r     rowNames: self columnNames;\r     columnNames: self rowNames.\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r\t"Returs a transposed DataFrame. Columns become rows and rows become columns."\r\r\t| transposedDf |\r\ttransposedDf := DataFrame withRows: (self asArrayOfColumns).\r\ttransposedDf rowNames: self columnNames.\r\ttransposedDf columnNames: self rowNames.\r\t^ transposedDf',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.993803-04:00' ],		#prior : OmReference [ '1443' ],		#self : OmReference [ '1444' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #variance',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r\r\t^ self applyToAllColumns: #variance',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.994461-04:00' ],		#prior : OmReference [ '1444' ],		#self : OmReference [ '1445' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := (self rowAt: 1) copy.\r  tmp2 := self class new: 0 @ (arg1 value: tmp1 value: 1) size.\r  tmp2 columnNames: tmp1 keys.\r  self withIndexDo: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        tmp2 add: (arg1 value: arg2 copy value: arg3) ].\r  ^tmp2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: elementAndIndexBlock\r\t"Overrides withIndexCollect: to create DataFrame with the same number of columns as values in the first row"\r\t| firstRow newDataFrame |\r\t\r\tfirstRow := (self rowAt: 1) copy.\r\tnewDataFrame := self class new: 0@(elementAndIndexBlock value: firstRow value: 1) size.\r\tnewDataFrame columnNames: firstRow keys.\r\t\r\tself withIndexDo: [ :each :index | newDataFrame add: (elementAndIndexBlock value: each copy value: index)].\r\t^ newDataFrame',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.994946-04:00' ],		#prior : OmReference [ '1445' ],		#self : OmReference [ '1446' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: arg1\r  | tmp1 tmp2 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self size.\r  1 to: tmp1 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp2 := nil.\r        tmp2 := self rowAt: tmp3.\r        arg1 value: tmp2 value: tmp3.\r        self rowAt: tmp3 put: tmp2 asArray ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: elementAndIndexBlock\r\r\t1 to: self size do: [ :i |\r\t\t| row |\r\t\trow := (self rowAt: i).\r\t\telementAndIndexBlock value: row value: i.\r\t\t\t\r\t\t"A hack to allow modification of rows inside do block"\r\t\tself rowAt: i put: row asArray ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.995406-04:00' ],		#prior : OmReference [ '1446' ],		#self : OmReference [ '1447' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: arg1\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:arg2 :arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg2 value: arg3) not ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: elementAndIndexBlock \r\t"Evaluate aBlock with each of the receiver\'s elements and index as the arguments. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to false. Answer the new collection."\r\t^ self withIndexSelect: [ :row :index | (elementAndIndexBlock value: row value: index) not ]',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.995921-04:00' ],		#prior : OmReference [ '1447' ],		#self : OmReference [ '1448' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp5 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self asArrayOfRows.\r  tmp2 := (1 to: tmp1 size) select: [:arg2 |  #metaObject count: 2.\r        nil.\r        arg1 value: (tmp1 at: arg2) value: arg2 ].\r  tmp3 := tmp2 collect: [:arg3 |  #metaObject count: 3.\r        nil.\r        self rowNames at: arg3 ].\r  tmp4 := tmp2 collect: [:arg4 |  #metaObject count: 4.\r        nil.\r        (tmp1 at: arg4) asArray ].\r  tmp5 := self class withRows: tmp4 rowNames: tmp3 columnNames: self columnNames.\r  ^tmp5',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: elementAndIndexBlock \r\t"Evaluate aBlock with each of the receiver\'s elements and index as the arguments. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to true. Answer the new collection."\r\r\t| rows selectedRowIndices selectedRowNames selectedRowsAsArrays df |\r\t\r\trows := self asArrayOfRows.\r\tselectedRowIndices := (1 to: rows size) select: [ :i |\r\t\telementAndIndexBlock value: (rows at: i) value: i ].\r\tselectedRowNames := selectedRowIndices collect: [ :i | self rowNames at: i ].\r\tselectedRowsAsArrays := selectedRowIndices collect: [ :i | (rows at: i) asArray ].\r\t\r\tdf := self class\r\t\twithRows: selectedRowsAsArrays\r\t\trowNames: selectedRowNames\r\t\tcolumnNames: self columnNames.\r\t\r\t^ df',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.99637-04:00' ],		#prior : OmReference [ '1448' ],		#self : OmReference [ '1449' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: arg1\r  | tmp1 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self new: arg1 rowCount @ arg1 columnCount.\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 2.\r        nil.\r        tmp1 at: arg3 at: arg4 put: arg2 ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: anArray2D\r\r\t| dfInternal |\r\t\r\t"We can\'t use Array2D>>extent, because it gives us col@row instead of row@col"\r\tdfInternal := self new:\r\t\t(anArray2D rowCount @ anArray2D columnCount).\r\t\r\tanArray2D withIndicesDo: [ :each :i :j |\r\t\tdfInternal at: i at: j put: each ].\r\t\r\t^ dfInternal',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.996745-04:00' ],		#prior : OmReference [ '1449' ],		#self : OmReference [ '1450' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: arg1\r  #metaObject count: 1.\r  nil.\r  ^self new initialize: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aPoint\r\r\t^ self new initialize: aPoint',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.997199-04:00' ],		#prior : OmReference [ '1450' ],		#self : OmReference [ '1451' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp1 := 0.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp1 := tmp1 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp9) asArray at: tmp7 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays\r\t\r\t| numberOfRows numberOfColumns dfInternal |\r\t\r\tnumberOfColumns := anArrayOfArrays size.\r\tnumberOfRows := 0.\r\t1 to: numberOfColumns do: [ :index |\r\t\tnumberOfRows := numberOfRows max: (anArrayOfArrays at: index) size\r\t\t].\r\tdfInternal := self new: (numberOfRows @ numberOfColumns ).\r\t\r\t1 to: numberOfRows do: [ :i |\r\t\t1 to: numberOfColumns do: [ :j |\r\t\t\tdfInternal at: i at: j\r\t\t\t\tput: ((anArrayOfArrays at: j) asArray at: i ifAbsent: nil) ] ].\r\t\t\r\t^ dfInternal',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.997647-04:00' ],		#prior : OmReference [ '1451' ],		#self : OmReference [ '1452' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: arg1\r  | tmp1 tmp2 tmp3 tmp4 tmp6 tmp8 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := arg1 size.\r  tmp2 := 0.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        tmp2 := tmp2 max: (arg1 at: tmp5) size ].\r  tmp3 := self new: tmp1 @ tmp2.\r  tmp6 := tmp1.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 3.\r        nil.\r        tmp8 := tmp2.\r        1 to: tmp8 do: [:tmp9 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp7 at: tmp9 put: ((arg1 at: tmp7) asArray at: tmp9 ifAbsent: nil) ] ].\r  ^tmp3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays\r\r\t| numberOfRows numberOfColumns dfInternal |\r\t\r\tnumberOfRows := anArrayOfArrays size.\r\tnumberOfColumns := 0.\r\t1 to: numberOfRows do: [ :index |\r\t\tnumberOfColumns := numberOfColumns max: (anArrayOfArrays at: index) size\r\t\t].\r\tdfInternal := self new: numberOfRows @ numberOfColumns.\r\t\r\t1 to: numberOfRows do: [ :i | \r\t\t1 to: numberOfColumns do: [ :j | \r\t\t\tdfInternal at: i at: j\r\t\t\t\tput: ((anArrayOfArrays at: i) asArray at: j ifAbsent: nil) ] ].\r\t\r\t^ dfInternal',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.998127-04:00' ],		#prior : OmReference [ '1452' ],		#self : OmReference [ '1453' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= arg1\r  #metaObject count: 1.\r  nil.\r  (arg1 class == self class and: [ #metaObject count: 2.\r        nil.\r        arg1 numberOfRows = self numberOfRows and: [ #metaObject count: 3.\r              nil.\r              arg1 numberOfColumns = self numberOfColumns ] ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  arg1 withIndicesDo: [:arg2 :arg3 :arg4 |  #metaObject count: 5.\r        nil.\r        (self at: arg3 at: arg4) = arg2 ifFalse: [ #metaObject count: 6.\r              nil.\r              ^false ] ].\r  ^true',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= other\r\r\t((other class == self class)\r\t\tand: [ other numberOfRows = self numberOfRows \r\t\tand: [ other numberOfColumns = self numberOfColumns]])\r\t\tifFalse: [ ^ false ].\r\t\t\r\tother withIndicesDo: [ :each :i :j |\r\t\t(self at: i at: j) = each\r\t\t\tifFalse: [ ^ false ] ].\r\t\t\r\t^ true.\r\r\t\r\t',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:46.999948-04:00' ],		#prior : OmReference [ '1453' ],		#self : OmReference [ '1454' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  tmp2 := self numberOfColumns + 1.\r  arg1 size = tmp1 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := arg2 - 1.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 5.\r        nil.\r        tmp3 at: tmp5 at: arg2 put: (arg1 at: tmp5) ].\r  tmp4 := tmp1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        arg2 + 1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7 - 1) ] ].\r  contents := tmp3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray atPosition: aNumber\r\r\t| rows cols newContents |\r\t\r\trows := self numberOfRows.\r\tcols := self numberOfColumns + 1.\r\t\r\tanArray size = rows\r\t\tifFalse: [ SizeMismatch signal ].\r\t\r\tnewContents := Array2D\r\t\trows: rows\r\t\tcolumns: cols.\r\t\r\t1 to: rows do: [ :i |\r\t\t1 to: aNumber - 1 do: [ :j |\r\t\t\tnewContents at: i at: j put:\r\t\t\t\t(self at: i at: j) ] ].\r\t\r\t1 to: rows do: [ :i |\r\t\tnewContents at: i at: aNumber\r\t\t\tput: (anArray at: i) ].\r\t\t\r\t1 to: rows do: [ :i |\r\t\taNumber + 1 to: cols do: [ :j |\r\t\t\tnewContents at: i at: j put:\r\t\t\t\t(self at: i at: j - 1) ] ].\r\t\r\tcontents := newContents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.000585-04:00' ],		#prior : OmReference [ '1454' ],		#self : OmReference [ '1455' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: arg1 atPosition: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows + 1.\r  tmp2 := self numberOfColumns.\r  arg1 size = tmp2 ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  tmp3 := Array2D rows: tmp1 columns: tmp2.\r  tmp4 := arg2 - 1.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 4.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 at: tmp7) ] ].\r  tmp6 := tmp2.\r  1 to: tmp6 do: [:tmp7 |  #metaObject count: 5.\r        nil.\r        tmp3 at: arg2 at: tmp7 put: (arg1 at: tmp7) ].\r  tmp4 := tmp1.\r  arg2 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp6 := tmp2.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              tmp3 at: tmp5 at: tmp7 put: (self at: tmp5 - 1 at: tmp7) ] ].\r  contents := tmp3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: anArray atPosition: aNumber\r\r\t| rows cols newContents |\r\t\r\trows := self numberOfRows + 1.\r\tcols := self numberOfColumns.\r\t\r\tanArray size = cols\r\t\tifFalse: [ SizeMismatch signal ].\r\t\r\tnewContents := Array2D\r\t\trows: rows\r\t\tcolumns: cols.\r\t\r\t1 to: aNumber - 1 do: [ :i |\r\t\t1 to: cols do: [ :j |\r\t\t\tnewContents at: i at: j put:\r\t\t\t\t(self at: i at: j) ] ].\r\t\r\t1 to: cols do: [ :j |\r\t\tnewContents at: aNumber at: j\r\t\t\tput: (anArray at: j) ].\r\t\t\r\taNumber + 1 to: rows do: [ :i |\r\t\t1 to: cols do: [ :j |\r\t\t\tnewContents at: i at: j put:\r\t\t\t\t(self at: i - 1 at: j) ] ].\r\t\r\tcontents := newContents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.000978-04:00' ],		#prior : OmReference [ '1455' ],		#self : OmReference [ '1456' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r\t^ contents',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.001387-04:00' ],		#prior : OmReference [ '1456' ],		#self : OmReference [ '1457' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg2 at: arg1 ] ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r\t"Converts DataFrameInternal to the array of columns"\r\r\t^ (1 to: self numberOfColumns) collect: [ :j |\r\t\t(1 to: self numberOfRows) collect: [ :i |\r\t\t\tself at: i at: j ] ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.00179-04:00' ],		#prior : OmReference [ '1457' ],		#self : OmReference [ '1458' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg1 |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 3.\r              nil.\r              self at: arg1 at: arg2 ] ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r\t"Converts DataFrameInternal to the array of rows"\r\r\t^ (1 to: self numberOfRows) collect: [ :i |\r\t\t(1 to: self numberOfColumns) collect: [ :j |\r\t\t\tself at: i at: j ] ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.002179-04:00' ],		#prior : OmReference [ '1458' ],		#self : OmReference [ '1459' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex\r\r\t^ contents at: rowIndex at: columnIndex.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.002753-04:00' ],		#prior : OmReference [ '1459' ],		#self : OmReference [ '1460' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: arg1 at: arg2 put: arg3\r  #metaObject count: 1.\r  nil.\r  ^contents at: arg1 at: arg2 put: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex put: value\r\r\t^ contents at: rowIndex at: columnIndex put: value.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.003205-04:00' ],		#prior : OmReference [ '1460' ],		#self : OmReference [ '1461' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents collect: arg1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r\r\t^ self class fromArray2D:\r\t\t(contents collect: aBlock).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.003608-04:00' ],		#prior : OmReference [ '1461' ],		#self : OmReference [ '1462' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg2 at: arg1 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber\r\r\t^ (1 to: self numberOfRows) collect: [ :i |\r\t\tself at: i at: aNumber ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.004018-04:00' ],		#prior : OmReference [ '1462' ],		#self : OmReference [ '1463' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfRows) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg3 at: arg1 put: (arg2 at: arg3) ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber put: anArray\r"Sets all the values of a given column equal to the values in array. It is assumed that array is of the same size as every column (number of rows). This should be tested in DataFrame"\r\r\t(1 to: self numberOfRows) do: [ :i |\r\t\tself at: i at: aNumber put: (anArray at: i) ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.004457-04:00' ],		#prior : OmReference [ '1463' ],		#self : OmReference [ '1464' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: arg1\r  | tmp1 tmp2 tmp3 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := self numberOfRows.\r  tmp3 := arg1 size.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  tmp4 := tmp2.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 2.\r        nil.\r        arg1 doWithIndex: [:arg2 :arg3 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: arg3 put: (self at: tmp5 at: arg2) ] ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers\r\r\t| dfInternal numberOfRows numberOfColumns |\r\t\r\tnumberOfRows := self numberOfRows.\r\tnumberOfColumns := anArrayOfNumbers size.\r\tdfInternal := DataFrameInternal new: (numberOfRows @ numberOfColumns).\r\t\r\t1 to: numberOfRows do: [ :i |\r\t\tanArrayOfNumbers doWithIndex: [ :j :k |\r\t\t\tdfInternal at: i at: k put: (self at: i at: j) ] ].\r\t\r\t^ dfInternal.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.004832-04:00' ],		#prior : OmReference [ '1464' ],		#self : OmReference [ '1465' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: contents',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r\r\t^ self class fromArray2D: contents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.005224-04:00' ],		#prior : OmReference [ '1465' ],		#self : OmReference [ '1466' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents do: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: aBlock\r\r\t^ contents do: aBlock.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.005602-04:00' ],		#prior : OmReference [ '1466' ],		#self : OmReference [ '1467' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := Array2D new',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t\r\tsuper initialize.\r\tcontents := Array2D new.\r\t^ self.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.005982-04:00' ],		#prior : OmReference [ '1467' ],		#self : OmReference [ '1468' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: arg1\r  #metaObject count: 1.\r  nil.\r  contents := Array2D rows: arg1 x columns: arg1 y',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aPoint\r\t\r\tcontents := Array2D\r\t\trows: aPoint x\r\t\tcolumns: aPoint y.\r\t\t\r\t^ self.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.006372-04:00' ],		#prior : OmReference [ '1468' ],		#self : OmReference [ '1469' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  contents numberOfColumns isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfColumns',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r\r\tcontents numberOfColumns isNil\r\t\tifTrue: [ ^ 0 ].\r\t\t\r\t^ contents numberOfColumns.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.006754-04:00' ],		#prior : OmReference [ '1469' ],		#self : OmReference [ '1470' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  contents numberOfRows isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfRows',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r\r\tcontents numberOfRows isNil\r\t\tifTrue: [ ^ 0 ].\r\t\t\r\t^ contents numberOfRows.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.007134-04:00' ],		#prior : OmReference [ '1470' ],		#self : OmReference [ '1471' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: arg1\r  #metaObject count: 1.\r  nil.\r  contents printOn: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\r\tcontents printOn: aStream.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.007597-04:00' ],		#prior : OmReference [ '1471' ],		#self : OmReference [ '1472' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - 1.\r  tmp2 := self numberOfRows.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp3 at: tmp5 put: (contents at: tmp3 at: tmp5) ].\r        tmp4 := self numberOfColumns.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp3 at: tmp5 - 1 put: (contents at: tmp3 at: tmp5) ] ].\r  contents := tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: columnNumber\r\r\t| newContents |\r\tnewContents := Array2D\r\t\trows: (self numberOfRows)\r\t\tcolumns: (self numberOfColumns - 1).\r\t\t\r\t1 to: self numberOfRows do: [ :i |\r\t\t1 to: columnNumber - 1 do: [ :j |\r\t\t\tnewContents at: i at: j put:\r\t\t\t\t(contents at: i at: j) ].\r\t\t\t\r\t\tcolumnNumber + 1 to: self numberOfColumns do: [ :j |\r\t\t\tnewContents at: i at: j - 1 put:\r\t\t\t\t(contents at: i at: j) ] ].\r\t\t\r\tcontents := newContents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.008135-04:00' ],		#prior : OmReference [ '1472' ],		#self : OmReference [ '1473' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: arg1 onRow: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self rowAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows columns: self numberOfColumns - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size.\r  tmp1 numberOfColumns = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfRows.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfColumns.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp5 at: tmp7 - tmp3 put: (contents at: tmp5 at: tmp7) ] ] ].\r  contents := tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber\r\t"Executes aBlock for all elements in specified rowNumber and deletes the column\r\t which satisfied condition given in aBlock."\r\r\t| newContents columnsToDrop k |\r\t"columnsToDrop has 1 at i if i-th column needs to be dropped, else 0"\r\tcolumnsToDrop := (self rowAt: rowNumber) collect: [ :ele |\r\t\t(aBlock value: ele) ifTrue: [ true ] ifFalse: [ false ] ].\r\t\r\tnewContents := Array2D\r\t\trows: (self numberOfRows)\r\t\tcolumns: (self numberOfColumns - (columnsToDrop select: [ :ele | ele ]) size).\r\t\r\t(newContents numberOfColumns = 0) ifTrue: [ \r\t\tcontents := Array2D rows: 0 columns: 0.\r\t\t^ self.\r\t\t].\r\t\t\r\t1 to: self numberOfRows do: [ :i |\r\t\tk := 0.\r\t\t1 to: self numberOfColumns do: [ :j |\r\t\t\t(columnsToDrop at: j)\r\t\t\t\tifTrue: [ k := k + 1 ]\r\t\t\t\tifFalse: [\r\t\t\t\tnewContents at: i at: j - k put:\r\t\t\t\t\t(contents at: i at: j) ]]].\r\t\t\r\tcontents := newContents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.00874-04:00' ],		#prior : OmReference [ '1473' ],		#self : OmReference [ '1474' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: arg1\r  | tmp1 tmp2 tmp4 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := Array2D rows: self numberOfRows - 1 columns: self numberOfColumns.\r  tmp2 := self numberOfColumns.\r  1 to: tmp2 do: [:tmp3 |  #metaObject count: 2.\r        nil.\r        tmp4 := arg1 - 1.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: tmp5 at: tmp3 put: (contents at: tmp5 at: tmp3) ].\r        tmp4 := self numberOfRows.\r        arg1 + 1 to: tmp4 do: [:tmp5 |  #metaObject count: 4.\r              nil.\r              tmp1 at: tmp5 - 1 at: tmp3 put: (contents at: tmp5 at: tmp3) ] ].\r  contents := tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: rowNumber\r\r\t| newContents |\r\tnewContents := Array2D\r\t\trows: (self numberOfRows - 1)\r\t\tcolumns: (self numberOfColumns).\r\t\t\r\t1 to: self numberOfColumns do: [ :j |\r\t\t1 to: rowNumber - 1 do: [ :i |\r\t\t\tnewContents at: i at: j put:\r\t\t\t\t(contents at: i at: j) ].\r\t\t\t\r\t\trowNumber + 1 to: self numberOfRows do: [ :i |\r\t\t\tnewContents at: i - 1 at: j put:\r\t\t\t\t(contents at: i at: j) ] ].\r\t\t\r\tcontents := newContents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.009467-04:00' ],		#prior : OmReference [ '1474' ],		#self : OmReference [ '1475' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: arg1 onColumn: arg2\r  | tmp1 tmp2 tmp3 tmp4 tmp6 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := (self columnAt: arg2) collect: [:arg3 |  #metaObject count: 2.\r        nil.\r        (arg1 value: arg3) and: [ #metaObject count: 3.\r              nil.\r              true ] ].\r  tmp1 := Array2D rows: self numberOfRows - (tmp2 select: [:arg4 |  #metaObject count: 4.\r                    nil.\r                    arg4 ]) size columns: self numberOfColumns.\r  tmp1 numberOfRows = 0 ifTrue: [ #metaObject count: 5.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  tmp4 := self numberOfColumns.\r  1 to: tmp4 do: [:tmp5 |  #metaObject count: 6.\r        nil.\r        tmp3 := 0.\r        tmp6 := self numberOfRows.\r        1 to: tmp6 do: [:tmp7 |  #metaObject count: 7.\r              nil.\r              (tmp2 at: tmp7) ifTrue: [ #metaObject count: 8.\r                    nil.\r                    tmp3 := tmp3 + 1 ] ifFalse: [ #metaObject count: 9.\r                    nil.\r                    tmp1 at: tmp7 - tmp3 at: tmp5 put: (contents at: tmp7 at: tmp5) ] ] ].\r  contents := tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber\r\t"Removes all rows having a nil value at the column columnNumber"\r\r\t| newContents rowsToDrop k |\r\t"rowsToDrop has 1 at i if i-th row needs to be dropped, else 0"\r\trowsToDrop := (self columnAt: columnNumber) collect: [ :ele |\r\t\t(aBlock value: ele) ifTrue: [ true ] ifFalse: [ false ] ].\r\tnewContents := Array2D\r\t\trows: (self numberOfRows - (rowsToDrop select: [ :ele | ele ]) size)\r\t\tcolumns: (self numberOfColumns).\r\t\t\r\t(newContents numberOfRows = 0) ifTrue: [ \r\t\tcontents := Array2D rows: 0 columns: 0.\r\t\t^ self.\r\t\t].\r\t\r\t1 to: self numberOfColumns do: [ :j |\r\t\tk := 0.\r\t\t1 to: self numberOfRows do: [ :i |\r\t\t\t(rowsToDrop at: i)\r\t\t\t\tifTrue: [ k := k + 1 ]\r\t\t\t\tifFalse: [\r\t\t\t\tnewContents at: i - k at: j put:\r\t\t\t\t\t(contents at: i at: j) ]]].\r\t\t\r\tcontents := newContents.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.010037-04:00' ],		#prior : OmReference [ '1475' ],		#self : OmReference [ '1476' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: arg1\r  | tmp1 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp1 := self numberOfRows.\r  1 to: tmp1 do: [:tmp2 |  #metaObject count: 2.\r        nil.\r        tmp3 := self numberOfColumns.\r        1 to: tmp3 do: [:tmp4 |  #metaObject count: 3.\r              nil.\r              (arg1 includes: (contents at: tmp2 at: tmp4)) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    contents at: tmp2 at: tmp4 put: nil ] ] ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: aSet\r\t"Replaces dataframeinternal values with nil if they are a part of aSet"\r\r\t1 to: self numberOfRows do: [ :i |\r\t\t1 to: self numberOfColumns do: [ :j |\r\t\t\t(aSet includes: (contents at: i at: j))\r\t\t\t\tifTrue: [ contents at: i at: j put: nil ].\r\t\t\t ] ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.010531-04:00' ],		#prior : OmReference [ '1476' ],		#self : OmReference [ '1477' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:arg2 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg2 ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber\r\r\t^ (1 to: self numberOfColumns) collect: [ :j |\r\t\tself at: aNumber at: j ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.011169-04:00' ],		#prior : OmReference [ '1477' ],		#self : OmReference [ '1478' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: arg1 put: arg2\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfColumns) do: [:arg3 |  #metaObject count: 2.\r        nil.\r        self at: arg1 at: arg3 put: (arg2 at: arg3) ]',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber put: anArray\r"Sets all the values of a given row equal to the values in array. It is assumed that array is of the same size as every row (number of columns). This should be tested in DataFrame"\r\r\t(1 to: self numberOfColumns) do: [ :j |\r\t\tself at: aNumber at: j put: (anArray at: j) ].',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.011926-04:00' ],		#prior : OmReference [ '1478' ],		#self : OmReference [ '1479' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: arg1\r  | tmp1 tmp2 tmp3 |\r  #metaObject count: 1.\r  nil.\r  tmp2 := arg1 size.\r  tmp3 := self numberOfColumns.\r  tmp1 := DataFrameInternal new: tmp2 @ tmp3.\r  arg1 doWithIndex: [:arg2 :arg3 |  | tmp4 |\r        #metaObject count: 2.\r        nil.\r        tmp4 := tmp3.\r        1 to: tmp4 do: [:tmp5 |  #metaObject count: 3.\r              nil.\r              tmp1 at: arg3 at: tmp5 put: (self at: arg2 at: tmp5) ].\r        1 ].\r  ^tmp1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers\r\r\t| dfInternal numberOfRows numberOfColumns |\r\t\r\tnumberOfRows := anArrayOfNumbers size.\r\tnumberOfColumns := self numberOfColumns.\r\tdfInternal := DataFrameInternal new: (numberOfRows @ numberOfColumns).\r\t\r\tanArrayOfNumbers doWithIndex: [ :i :k |\r\t\t1 to: numberOfColumns do: [ :j |\r\t\t\tdfInternal at: k at: j put: (self at: i at: j) ] ].\r\t\r\t^ dfInternal.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.012381-04:00' ],		#prior : OmReference [ '1479' ],		#self : OmReference [ '1480' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: arg1\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents withIndicesCollect: arg1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: aBlock\r\r\t^ self class fromArray2D:\r\t\t(contents withIndicesCollect: aBlock).',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.012807-04:00' ],		#prior : OmReference [ '1480' ],		#self : OmReference [ '1481' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: arg1\r  #metaObject count: 1.\r  nil.\r  ^contents withIndicesDo: arg1',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: aBlock\r\r\t^ contents withIndicesDo: aBlock.',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:28:47.014841-04:00' ],		#prior : OmReference [ '1481' ],		#self : OmReference [ '1482' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Behavior			},			#name : #'inheritsFromOrEqualTo:',			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'inheritsFromOrEqualTo: arg1\r  ^self == arg1 or: (self inheritsFrom: arg1)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Behavior			},			#name : #'inheritsFromOrEqualTo:',			#protocol : #'*DataFrame-Core-Base',			#sourceCode : 'inheritsFromOrEqualTo: aClass \r\t"Answer whether the argument, aClass, is equal to the receiver or belongs to its superclass chain."\r\r\t^ (self == aClass) or: (self inheritsFrom: aClass)',			#stamp : '',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.632918-04:00' ],		#prior : OmReference [ '1482' ],		#self : OmReference [ '1483' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: otherSeries aggregateUsing: aBlock\r  "Group my values by the unique values of otherSeries, aggregate them using aBlock. Use my name by default"\r  #metaObject count: 1.\r  nil.\r  ^self groupBy: otherSeries aggregateUsing: aBlock as: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.636273-04:00' ],		#prior : OmReference [ '1483' ],		#self : OmReference [ '1484' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  #metaObject count: 1.\r  nil.\r  ^(self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.63935-04:00' ],		#prior : OmReference [ '1484' ],		#self : OmReference [ '1485' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := false',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.643903-04:00' ],		#prior : OmReference [ '1485' ],		#self : OmReference [ '1486' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: aBlock\r  #metaObject count: 1.\r  nil.\r  self keys withIndexDo: [:each :i |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: each) value: i ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.646317-04:00' ],		#prior : OmReference [ '1486' ],		#self : OmReference [ '1487' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := super select: aBlock.\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.649002-04:00' ],		#prior : OmReference [ '1487' ],		#self : OmReference [ '1488' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  "Replaces nils inplace with median"\r  | median |\r  #metaObject count: 1.\r  nil.\r  median := (self select: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNotNil ]) median.\r  self replaceNilsWith: median',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.651153-04:00' ],		#prior : OmReference [ '1488' ],		#self : OmReference [ '1489' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: aKey transform: aBlock\r  "Evaluate aBlock on the value at aKey and replace that value with the result. Signal an exception if aKey was not found"\r  #metaObject count: 1.\r  nil.\r  self at: aKey transform: aBlock ifAbsent: NotFoundError',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.653352-04:00' ],		#prior : OmReference [ '1489' ],		#self : OmReference [ '1490' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  #metaObject count: 1.\r  nil.\r  ^0.0001',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.657118-04:00' ],		#prior : OmReference [ '1490' ],		#self : OmReference [ '1491' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: aSeries\r  | df |\r  #metaObject count: 1.\r  nil.\r  self size = aSeries size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  df := DataFrame withRows: (self uniqueValues collect: [:each1 |  #metaObject count: 3.\r              nil.\r              aSeries uniqueValues collect: [:each2 |  #metaObject count: 4.\r                    nil.\r                    (1 to: self size) inject: 0 into: [:accum :i |  #metaObject count: 5.\r                          nil.\r                          ((self atIndex: i) = each1 and: (aSeries atIndex: i) = each2) ifTrue: [ #metaObject count: 6.\r                                nil.\r                                accum + 1 ] ifFalse: [ #metaObject count: 7.\r                                nil.\r                                accum ] ] ] ]).\r  df rowNames: self uniqueValues.\r  df columnNames: aSeries uniqueValues.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.659382-04:00' ],		#prior : OmReference [ '1491' ],		#self : OmReference [ '1492' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  "Answer the eighth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 8',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.66318-04:00' ],		#prior : OmReference [ '1492' ],		#self : OmReference [ '1493' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.664912-04:00' ],		#prior : OmReference [ '1493' ],		#self : OmReference [ '1494' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self removeAt: (self keys at: aNumber)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.667512-04:00' ],		#prior : OmReference [ '1494' ],		#self : OmReference [ '1495' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: rcvr andSend: selector\r  "If I am involved in arithmetic with another Collection, return a Collection of\r\tthe results of each element combined with the scalar in that expression."\r  #metaObject count: 1.\r  nil.\r  (rcvr isSequenceable and: [ #metaObject count: 2.\r        nil.\r        self isSequenceable ]) ifFalse: [ #metaObject count: 3.\r        nil.\r        self error: \'Only sequenceable collections may be combined arithmetically\' ].\r  ^rcvr withSeries: self collect: [:rcvrElement :myElement |  #metaObject count: 4.\r        nil.\r        rcvrElement perform: selector with: myElement ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.669355-04:00' ],		#prior : OmReference [ '1495' ],		#self : OmReference [ '1496' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: aBlock\r  | associationBlock |\r  #metaObject count: 1.\r  nil.\r  associationBlock := [:a :b |  #metaObject count: 2.\r  nil.\r  aBlock value: a value value: b value ].\r  self sortAssociations: associationBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.671112-04:00' ],		#prior : OmReference [ '1496' ],		#self : OmReference [ '1497' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: aBlock\r  | sortedAssociations |\r  #metaObject count: 1.\r  nil.\r  sortedAssociations := self associations sort: aBlock.\r  ^sortedAssociations asDataSeries\r     name: self name;\r     yourself',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.67295-04:00' ],		#prior : OmReference [ '1497' ],		#self : OmReference [ '1498' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := self species newFrom: (self associations collect: [:each |  #metaObject count: 2.\r              nil.\r              each key -> (aBlock value: each value value: each key) ]).\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.67532-04:00' ],		#prior : OmReference [ '1498' ],		#self : OmReference [ '1499' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  #metaObject count: 1.\r  nil.\r  ^forcedIsNumerical ifNil: [ #metaObject count: 2.\r        nil.\r        self uniqueValues allSatisfy: [:each |  #metaObject count: 3.\r              nil.\r              each isNumber ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.677053-04:00' ],		#prior : OmReference [ '1499' ],		#self : OmReference [ '1500' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #>',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.678982-04:00' ],		#prior : OmReference [ '1500' ],		#self : OmReference [ '1501' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 3',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.68095-04:00' ],		#prior : OmReference [ '1501' ],		#self : OmReference [ '1502' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.682668-04:00' ],		#prior : OmReference [ '1502' ],		#self : OmReference [ '1503' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withKeyDetect: aBlock ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.684588-04:00' ],		#prior : OmReference [ '1503' ],		#self : OmReference [ '1504' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  "return true if data series has at least one nil value"\r  #metaObject count: 1.\r  nil.\r  ^self includes: nil',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.686483-04:00' ],		#prior : OmReference [ '1504' ],		#self : OmReference [ '1505' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  "Answer the sixth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 6',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.689476-04:00' ],		#prior : OmReference [ '1505' ],		#self : OmReference [ '1506' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := super collect: aBlock.\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.693219-04:00' ],		#prior : OmReference [ '1506' ],		#self : OmReference [ '1507' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: otherSeries aggregateUsing: aBlock as: aNewName\r  "Group my values by the unique values of otherSeries, aggregate them using aBlock, and answer a new DataSeries with unique values of otherSeries (group keys) as keys, aggregated values of myself as values, and aNewName as name"\r  | groupKeys groups |\r  #metaObject count: 1.\r  nil.\r  self size = otherSeries size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  groupKeys := otherSeries uniqueValues.\r  groups := groupKeys collect: [:each |  #metaObject count: 3.\r        nil.\r        (1 to: self size) select: [:i |  #metaObject count: 4.\r              nil.\r              (otherSeries atIndex: i) = each ] thenCollect: [:i |  #metaObject count: 5.\r              nil.\r              self atIndex: i ] ].\r  ^DataSeries withKeys: groupKeys values: (groups collect: aBlock) name: aNewName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.695113-04:00' ],		#prior : OmReference [ '1507' ],		#self : OmReference [ '1508' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  #metaObject count: 1.\r  nil.\r  ^self isNumerical not',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.696864-04:00' ],		#prior : OmReference [ '1508' ],		#self : OmReference [ '1509' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: aBlock\r  "Applies aBlock to every non-nil element"\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:each |  #metaObject count: 2.\r        nil.\r        each isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              nil ] ifFalse: [ #metaObject count: 4.\r              nil.\r              aBlock value: each ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.69901-04:00' ],		#prior : OmReference [ '1509' ],		#self : OmReference [ '1510' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  "Answer the second element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 2',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.700996-04:00' ],		#prior : OmReference [ '1510' ],		#self : OmReference [ '1511' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: aBlock\r  | selectedKeys |\r  #metaObject count: 1.\r  nil.\r  selectedKeys := self keys select: [:key |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: key) value: key ].\r  ^DataSeries withKeys: selectedKeys values: (selectedKeys collect: [:key |  #metaObject count: 3.\r              nil.\r              self at: key ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.703509-04:00' ],		#prior : OmReference [ '1511' ],		#self : OmReference [ '1512' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 4',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.706974-04:00' ],		#prior : OmReference [ '1512' ],		#self : OmReference [ '1513' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  #metaObject count: 1.\r  nil.\r  self sort: [:a :b |  #metaObject count: 2.\r        nil.\r        a <= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.709946-04:00' ],		#prior : OmReference [ '1513' ],		#self : OmReference [ '1514' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: aNumber\r  | sortedSeries index |\r  #metaObject count: 1.\r  nil.\r  sortedSeries := self sorted.\r  aNumber = 0 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^sortedSeries first ].\r  index := (sortedSeries size * (aNumber / 100)) ceiling.\r  ^sortedSeries atIndex: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.714164-04:00' ],		#prior : OmReference [ '1514' ],		#self : OmReference [ '1515' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: anObject precision: aPrecision\r  #metaObject count: 1.\r  nil.\r  self == anObject ifTrue: [ #metaObject count: 2.\r        nil.\r        ^true ].\r  (self species == anObject species and: [ #metaObject count: 3.\r        nil.\r        self size = anObject size ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  anObject name = self name ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  anObject keys = self keys ifFalse: [ #metaObject count: 6.\r        nil.\r        ^false ].\r  ^(1 to: self values size) detect: [:i |  #metaObject count: 7.\r        nil.\r        ((self atIndex: i) closeTo: (anObject atIndex: i) precision: aPrecision) not ] ifFound: [ #metaObject count: 8.\r        nil.\r        false ] ifNone: [ #metaObject count: 9.\r        nil.\r        true ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.716031-04:00' ],		#prior : OmReference [ '1515' ],		#self : OmReference [ '1516' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber put: aValue\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: aNumber) put: aValue',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.718284-04:00' ],		#prior : OmReference [ '1516' ],		#self : OmReference [ '1517' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  #metaObject count: 1.\r  nil.\r  ^\'(no name)\'',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.720559-04:00' ],		#prior : OmReference [ '1517' ],		#self : OmReference [ '1518' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: aBlock ifNone: exceptionBlock\r  | selectedKey |\r  #metaObject count: 1.\r  nil.\r  selectedKey := self keys detect: [:key |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: key) value: key ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^exceptionBlock value ].\r  ^self at: selectedKey',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.722674-04:00' ],		#prior : OmReference [ '1518' ],		#self : OmReference [ '1519' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r  #metaObject count: 1.\r  nil.\r  super = anObject ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  ^anObject name = self name and: [ #metaObject count: 3.\r        nil.\r        anObject keys = self keys ]\r  "order of keys"',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.724294-04:00' ],		#prior : OmReference [ '1519' ],		#self : OmReference [ '1520' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self quantile: 25 * aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.726966-04:00' ],		#prior : OmReference [ '1520' ],		#self : OmReference [ '1521' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  "Replaces nils inplace with zero"\r  #metaObject count: 1.\r  nil.\r  self replaceNilsWith: 0',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.729318-04:00' ],		#prior : OmReference [ '1521' ],		#self : OmReference [ '1522' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: anObject\r  "Replaces nils inplace with anObject"\r  #metaObject count: 1.\r  nil.\r  self withIndexDo: [:ele :index |  #metaObject count: 2.\r        nil.\r        ele isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              self atIndex: index put: anObject ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.73271-04:00' ],		#prior : OmReference [ '1522' ],		#self : OmReference [ '1523' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 2',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.735132-04:00' ],		#prior : OmReference [ '1523' ],		#self : OmReference [ '1524' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  "Answer the first element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.736793-04:00' ],		#prior : OmReference [ '1524' ],		#self : OmReference [ '1525' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:each :i |  #metaObject count: 2.\r        nil.\r        (aBlock value: each value: i) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.73867-04:00' ],		#prior : OmReference [ '1525' ],		#self : OmReference [ '1526' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.741229-04:00' ],		#prior : OmReference [ '1526' ],		#self : OmReference [ '1527' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: aKey transform: aBlock ifAbsent: exceptionBlock\r  "Evaluate aBlock on the value at aKey and replace that value with the result. Evaluate exceptionBlock if aKey was not found"\r  | oldValue |\r  #metaObject count: 1.\r  nil.\r  oldValue := self at: aKey ifAbsent: [ #metaObject count: 2.\r        nil.\r        exceptionBlock value.\r        ^self ].\r  self at: aKey put: (aBlock value: oldValue)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.743116-04:00' ],		#prior : OmReference [ '1527' ],		#self : OmReference [ '1528' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  #metaObject count: 1.\r  nil.\r  Error signal: \'Keys of two series do not match\'',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.744909-04:00' ],		#prior : OmReference [ '1528' ],		#self : OmReference [ '1529' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aCapacity\r  "Make sure that initialize is called and the default name is set"\r  #metaObject count: 1.\r  nil.\r  self initialize.\r  ^super initialize: aCapacity',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.746502-04:00' ],		#prior : OmReference [ '1529' ],		#self : OmReference [ '1530' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: 1 to: aNumber) values: (self values copyFrom: 1 to: aNumber) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.748845-04:00' ],		#prior : OmReference [ '1530' ],		#self : OmReference [ '1531' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  "Replaces nils inplace with average"\r  | mean |\r  #metaObject count: 1.\r  nil.\r  mean := (self select: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNotNil ]) average.\r  self replaceNilsWith: mean',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.750748-04:00' ],		#prior : OmReference [ '1531' ],		#self : OmReference [ '1532' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self thirdQuartile - self firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.752019-04:00' ],		#prior : OmReference [ '1532' ],		#self : OmReference [ '1533' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: anObject\r  #metaObject count: 1.\r  nil.\r  ^self closeTo: anObject precision: self defaultPrecision',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.753595-04:00' ],		#prior : OmReference [ '1533' ],		#self : OmReference [ '1534' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: aBlock\r  | associationBlock |\r  #metaObject count: 1.\r  nil.\r  associationBlock := [:a :b |  #metaObject count: 2.\r  nil.\r  aBlock value: a value value: b value ].\r  ^self sortedAssociations: associationBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.755404-04:00' ],		#prior : OmReference [ '1534' ],		#self : OmReference [ '1535' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: anArrayOfKeys\r  | keys |\r  #metaObject count: 1.\r  nil.\r  keys := anArrayOfKeys asArray deepCopy.\r  dictionary := self dictionaryClass newFromKeys: keys andValues: self values.\r  orderedKeys := keys',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.756936-04:00' ],		#prior : OmReference [ '1535' ],		#self : OmReference [ '1536' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: anObject\r  #metaObject count: 1.\r  nil.\r  name := anObject',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.759096-04:00' ],		#prior : OmReference [ '1536' ],		#self : OmReference [ '1537' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  "Replaces nils inplace with mode"\r  | mode |\r  #metaObject count: 1.\r  nil.\r  mode := (self select: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNotNil ]) mode.\r  self replaceNilsWith: mode',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.761582-04:00' ],		#prior : OmReference [ '1537' ],		#self : OmReference [ '1538' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  | v |\r  #metaObject count: 1.\r  nil.\r  v := self asSet asArray.\r  \r  "Sort if possible"^[ #metaObject count: 2.\r  nil.\r  v sort ] on: Error do: [ #metaObject count: 3.\r        nil.\r        v ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.763721-04:00' ],		#prior : OmReference [ '1538' ],		#self : OmReference [ '1539' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  "Answer the fourth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 4',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.767449-04:00' ],		#prior : OmReference [ '1539' ],		#self : OmReference [ '1540' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.769289-04:00' ],		#prior : OmReference [ '1540' ],		#self : OmReference [ '1541' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withIndexDetect: aBlock ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.77174-04:00' ],		#prior : OmReference [ '1541' ],		#self : OmReference [ '1542' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  #metaObject count: 1.\r  nil.\r  ^DataFrame withColumns: {self values} rowNames: self keys columnNames: {self name}',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.773604-04:00' ],		#prior : OmReference [ '1542' ],		#self : OmReference [ '1543' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #<',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.775892-04:00' ],		#prior : OmReference [ '1543' ],		#self : OmReference [ '1544' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  | count freq |\r  #metaObject count: 1.\r  nil.\r  count := self valueCounts.\r  freq := count / self size.\r  ^freq',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.780207-04:00' ],		#prior : OmReference [ '1544' ],		#self : OmReference [ '1545' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: aCollection collect: twoArgBlock\r  "Collect and return the result of evaluating twoArgBlock with corresponding elements from this series and aCollection."\r  | result |\r  #metaObject count: 1.\r  nil.\r  aCollection size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  result := self species new: self size.\r  result name: self name.\r  self keys withIndexDo: [:key :i |  #metaObject count: 3.\r        nil.\r        result at: key put: (twoArgBlock value: (self at: key) value: (aCollection at: i)) ].\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.782073-04:00' ],		#prior : OmReference [ '1545' ],		#self : OmReference [ '1546' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: base\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:each |  #metaObject count: 2.\r        nil.\r        each log: base ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.784343-04:00' ],		#prior : OmReference [ '1546' ],		#self : OmReference [ '1547' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:a :b |  #metaObject count: 2.\r        nil.\r        a > b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.786177-04:00' ],		#prior : OmReference [ '1547' ],		#self : OmReference [ '1548' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #>=',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.788525-04:00' ],		#prior : OmReference [ '1548' ],		#self : OmReference [ '1549' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: aBlock\r  | selectedIndices |\r  #metaObject count: 1.\r  nil.\r  selectedIndices := (1 to: self size) select: [:i |  #metaObject count: 2.\r        nil.\r        aBlock value: (self atIndex: i) value: i ].\r  ^DataSeries withKeys: (selectedIndices collect: [:i |  #metaObject count: 3.\r              nil.\r              self keys at: i ]) values: (selectedIndices collect: [:i |  #metaObject count: 4.\r              nil.\r              self atIndex: i ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.790268-04:00' ],		#prior : OmReference [ '1549' ],		#self : OmReference [ '1550' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: aBlock\r  #metaObject count: 1.\r  nil.\r  self keysDo: [:each |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: each) value: each ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.792226-04:00' ],		#prior : OmReference [ '1550' ],		#self : OmReference [ '1551' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  "Answer the third element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 3',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.793901-04:00' ],		#prior : OmReference [ '1551' ],		#self : OmReference [ '1552' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #<=',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.796134-04:00' ],		#prior : OmReference [ '1552' ],		#self : OmReference [ '1553' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: aBlock ifNone: exceptionBlock\r  | selectedIndex |\r  #metaObject count: 1.\r  nil.\r  selectedIndex := (1 to: self size) detect: [:i |  #metaObject count: 2.\r        nil.\r        aBlock value: (self atIndex: i) value: i ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^exceptionBlock value ].\r  ^self atIndex: selectedIndex',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.797991-04:00' ],		#prior : OmReference [ '1553' ],		#self : OmReference [ '1554' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  #metaObject count: 1.\r  nil.\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.800033-04:00' ],		#prior : OmReference [ '1554' ],		#self : OmReference [ '1555' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  #metaObject count: 1.\r  nil.\r  ^self reject: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.801927-04:00' ],		#prior : OmReference [ '1555' ],		#self : OmReference [ '1556' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.803909-04:00' ],		#prior : OmReference [ '1556' ],		#self : OmReference [ '1557' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := self species newFrom: (self associations withIndexCollect: [:each :i |  #metaObject count: 2.\r              nil.\r              each key -> (aBlock value: each value value: i) ]).\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.805448-04:00' ],		#prior : OmReference [ '1557' ],		#self : OmReference [ '1558' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: aBlock\r  | sortedAssociations |\r  #metaObject count: 1.\r  nil.\r  sortedAssociations := self associations sort: aBlock.\r  self removeAll.\r  self addAll: sortedAssociations',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.80713-04:00' ],		#prior : OmReference [ '1558' ],		#self : OmReference [ '1559' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := super reject: aBlock.\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.808734-04:00' ],		#prior : OmReference [ '1559' ],		#self : OmReference [ '1560' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: aNumber)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.810767-04:00' ],		#prior : OmReference [ '1560' ],		#self : OmReference [ '1561' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  "Answer the fifth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 5',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.812867-04:00' ],		#prior : OmReference [ '1561' ],		#self : OmReference [ '1562' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  | valueCounts maxCount |\r  #metaObject count: 1.\r  nil.\r  valueCounts := self valueCounts.\r  maxCount := valueCounts max.\r  ^valueCounts keyAtValue: maxCount',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.815264-04:00' ],		#prior : OmReference [ '1562' ],		#self : OmReference [ '1563' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  | summary |\r  #metaObject count: 1.\r  nil.\r  summary := self species new.\r  summary name: self name.\r  summary\r     at: \'Min\' put: self min;\r     at: \'1st Qu.\' put: self firstQuartile;\r     at: \'Median\' put: self median;\r     at: \'Average\' put: self average;\r     at: \'3rd Qu.\' put: self thirdQuartile;\r     at: \'Max\' put: self max.\r  ^summary',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.818222-04:00' ],		#prior : OmReference [ '1563' ],		#self : OmReference [ '1564' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber transform: aBlock\r  "Evaluate aBlock on the value at aNumber and replace that value with the result"\r  | key |\r  #metaObject count: 1.\r  nil.\r  key := self keys at: aNumber.\r  self at: key transform: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.820278-04:00' ],		#prior : OmReference [ '1564' ],		#self : OmReference [ '1565' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  "Answer the ninth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 9',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.82212-04:00' ],		#prior : OmReference [ '1565' ],		#self : OmReference [ '1566' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 0',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.824129-04:00' ],		#prior : OmReference [ '1566' ],		#self : OmReference [ '1567' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  #metaObject count: 1.\r  nil.\r  self sort: [:a :b |  #metaObject count: 2.\r        nil.\r        a > b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.82636-04:00' ],		#prior : OmReference [ '1567' ],		#self : OmReference [ '1568' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  "Answer the last element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: self size',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.828531-04:00' ],		#prior : OmReference [ '1568' ],		#self : OmReference [ '1569' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  name := self defaultName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.830269-04:00' ],		#prior : OmReference [ '1569' ],		#self : OmReference [ '1570' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: self size - aNumber + 1 to: self size) values: (self values copyFrom: self size - aNumber + 1 to: self size) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.833417-04:00' ],		#prior : OmReference [ '1570' ],		#self : OmReference [ '1571' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: aKey\r  #metaObject count: 1.\r  nil.\r  ^self removeKey: aKey',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.836054-04:00' ],		#prior : OmReference [ '1571' ],		#self : OmReference [ '1572' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:a :b |  #metaObject count: 2.\r        nil.\r        a <= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.838176-04:00' ],		#prior : OmReference [ '1572' ],		#self : OmReference [ '1573' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  "Answer the seventh element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 7',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.841076-04:00' ],		#prior : OmReference [ '1573' ],		#self : OmReference [ '1574' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: otherDataSeries collect: twoArgBlock\r  "Collect and return the result of evaluating twoArgBlock with corresponding elements from this series and otherDataSeries."\r  | result |\r  #metaObject count: 1.\r  nil.\r  otherDataSeries size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  otherDataSeries keys = self keys ifFalse: [ #metaObject count: 3.\r        nil.\r        self errorKeysMismatch ].\r  result := self species new: self size.\r  result name: self name.\r  self keysDo: [:key |  #metaObject count: 4.\r        nil.\r        result at: key put: (twoArgBlock value: (self at: key) value: (otherDataSeries at: key)) ].\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.843663-04:00' ],		#prior : OmReference [ '1574' ],		#self : OmReference [ '1575' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  #metaObject count: 1.\r  nil.\r  ^name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.84536-04:00' ],		#prior : OmReference [ '1575' ],		#self : OmReference [ '1576' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withKeySelect: [:each :key |  #metaObject count: 2.\r        nil.\r        (aBlock value: each value: key) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.848096-04:00' ],		#prior : OmReference [ '1576' ],		#self : OmReference [ '1577' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: keys values: values\r  #metaObject count: 1.\r  nil.\r  ^self newFromKeys: keys andValues: values',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.851149-04:00' ],		#prior : OmReference [ '1577' ],		#self : OmReference [ '1578' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: keys values: values name: aName\r  #metaObject count: 1.\r  nil.\r  ^(self withKeys: keys values: values)\r     name: aName;\r     yourself',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.852899-04:00' ],		#prior : OmReference [ '1578' ],		#self : OmReference [ '1579' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: values\r  | keys |\r  #metaObject count: 1.\r  nil.\r  keys := (1 to: values size) asArray.\r  ^self withKeys: keys values: values',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.854901-04:00' ],		#prior : OmReference [ '1579' ],		#self : OmReference [ '1580' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: values name: aName\r  | keys |\r  #metaObject count: 1.\r  nil.\r  keys := (1 to: values size) asArray.\r  ^(self withKeys: keys values: values)\r     name: aName;\r     yourself',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.85795-04:00' ],		#prior : OmReference [ '1580' ],		#self : OmReference [ '1581' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: aCollection\r  #metaObject count: 1.\r  nil.\r  aCollection ifEmpty: [ #metaObject count: 2.\r        nil.\r        ^self new ].\r  aCollection species == self ifTrue: [ #metaObject count: 3.\r        nil.\r        ^super newFrom: aCollection associations ].\r  \r  "If it\'s a collection of associations use the superclass implementation"^super newFrom: ((aCollection anyOne respondsTo: #key) ifTrue: [ #metaObject count: 4.\r              nil.\r              aCollection ] ifFalse: [ #metaObject count: 5.\r              nil.\r              aCollection withIndexCollect: [:each :i |  #metaObject count: 6.\r                    nil.\r                    i -> each ] ])',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.860826-04:00' ],		#prior : OmReference [ '1581' ],		#self : OmReference [ '1582' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: rowNumber\r  | newContents |\r  #metaObject count: 1.\r  nil.\r  newContents := Array2D rows: self numberOfRows - 1 columns: self numberOfColumns.\r  1 to: self numberOfColumns do: [:j |  #metaObject count: 2.\r        nil.\r        1 to: rowNumber - 1 do: [:i |  #metaObject count: 3.\r              nil.\r              newContents at: i at: j put: (contents at: i at: j) ].\r        rowNumber + 1 to: self numberOfRows do: [:i |  #metaObject count: 4.\r              nil.\r              newContents at: i - 1 at: j put: (contents at: i at: j) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.864186-04:00' ],		#prior : OmReference [ '1582' ],		#self : OmReference [ '1583' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:j |  #metaObject count: 2.\r        nil.\r        self at: aNumber at: j ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.867077-04:00' ],		#prior : OmReference [ '1583' ],		#self : OmReference [ '1584' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := Array2D new.\r  ^self',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.871892-04:00' ],		#prior : OmReference [ '1584' ],		#self : OmReference [ '1585' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber\r  "Executes aBlock for all elements in specified rowNumber and deletes the column\r\t which satisfied condition given in aBlock."\r  | newContents columnsToDrop k |\r  "columnsToDrop has 1 at i if i-th column needs to be dropped, else 0"\r  #metaObject count: 1.\r  nil.\r  columnsToDrop := (self rowAt: rowNumber) collect: [:ele |  #metaObject count: 2.\r        nil.\r        (aBlock value: ele) ifTrue: [ #metaObject count: 3.\r              nil.\r              true ] ifFalse: [ #metaObject count: 4.\r              nil.\r              false ] ].\r  newContents := Array2D rows: self numberOfRows columns: self numberOfColumns - (columnsToDrop select: [:ele |  #metaObject count: 5.\r                    nil.\r                    ele ]) size.\r  newContents numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  1 to: self numberOfRows do: [:i |  #metaObject count: 7.\r        nil.\r        k := 0.\r        1 to: self numberOfColumns do: [:j |  #metaObject count: 8.\r              nil.\r              (columnsToDrop at: j) ifTrue: [ #metaObject count: 9.\r                    nil.\r                    k := k + 1 ] ifFalse: [ #metaObject count: 10.\r                    nil.\r                    newContents at: i at: j - k put: (contents at: i at: j) ] ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.875321-04:00' ],		#prior : OmReference [ '1585' ],		#self : OmReference [ '1586' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber put: anArray\r  "Sets all the values of a given column equal to the values in array. It is assumed that array is of the same size as every column (number of rows). This should be tested in DataFrame"\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfRows) do: [:i |  #metaObject count: 2.\r        nil.\r        self at: i at: aNumber put: (anArray at: i) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.880304-04:00' ],		#prior : OmReference [ '1586' ],		#self : OmReference [ '1587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray atPosition: aNumber\r  | rows cols newContents |\r  #metaObject count: 1.\r  nil.\r  rows := self numberOfRows.\r  cols := self numberOfColumns + 1.\r  anArray size = rows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  newContents := Array2D rows: rows columns: cols.\r  1 to: rows do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: aNumber - 1 do: [:j |  #metaObject count: 4.\r              nil.\r              newContents at: i at: j put: (self at: i at: j) ] ].\r  1 to: rows do: [:i |  #metaObject count: 5.\r        nil.\r        newContents at: i at: aNumber put: (anArray at: i) ].\r  1 to: rows do: [:i |  #metaObject count: 6.\r        nil.\r        aNumber + 1 to: cols do: [:j |  #metaObject count: 7.\r              nil.\r              newContents at: i at: j put: (self at: i at: j - 1) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.882559-04:00' ],		#prior : OmReference [ '1587' ],		#self : OmReference [ '1588' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents collect: aBlock)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.884309-04:00' ],		#prior : OmReference [ '1588' ],		#self : OmReference [ '1589' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents withIndicesCollect: aBlock)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.88695-04:00' ],		#prior : OmReference [ '1589' ],		#self : OmReference [ '1590' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  "Converts DataFrameInternal to the array of columns"\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:j |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfRows) collect: [:i |  #metaObject count: 3.\r              nil.\r              self at: i at: j ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.889291-04:00' ],		#prior : OmReference [ '1590' ],		#self : OmReference [ '1591' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.892162-04:00' ],		#prior : OmReference [ '1591' ],		#self : OmReference [ '1592' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex\r  #metaObject count: 1.\r  nil.\r  ^contents at: rowIndex at: columnIndex',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.894485-04:00' ],		#prior : OmReference [ '1592' ],		#self : OmReference [ '1593' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber put: anArray\r  "Sets all the values of a given row equal to the values in array. It is assumed that array is of the same size as every row (number of columns). This should be tested in DataFrame"\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfColumns) do: [:j |  #metaObject count: 2.\r        nil.\r        self at: aNumber at: j put: (anArray at: j) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.897046-04:00' ],		#prior : OmReference [ '1593' ],		#self : OmReference [ '1594' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers\r  | dfInternal numberOfRows numberOfColumns |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfNumbers size.\r  numberOfColumns := self numberOfColumns.\r  dfInternal := DataFrameInternal new: numberOfRows @ numberOfColumns.\r  anArrayOfNumbers doWithIndex: [:i :k |  #metaObject count: 2.\r        nil.\r        1 to: numberOfColumns do: [:j |  #metaObject count: 3.\r              nil.\r              dfInternal at: k at: j put: (self at: i at: j) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.899302-04:00' ],		#prior : OmReference [ '1594' ],		#self : OmReference [ '1595' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: aBlock\r  #metaObject count: 1.\r  nil.\r  ^contents do: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.901723-04:00' ],		#prior : OmReference [ '1595' ],		#self : OmReference [ '1596' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: aSet\r  "Replaces dataframeinternal values with nil if they are a part of aSet"\r  #metaObject count: 1.\r  nil.\r  1 to: self numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        1 to: self numberOfColumns do: [:j |  #metaObject count: 3.\r              nil.\r              (aSet includes: (contents at: i at: j)) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    contents at: i at: j put: nil ] ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.907755-04:00' ],		#prior : OmReference [ '1596' ],		#self : OmReference [ '1597' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber\r  "Removes all rows having a nil value at the column columnNumber"\r  | newContents rowsToDrop k |\r  "rowsToDrop has 1 at i if i-th row needs to be dropped, else 0"\r  #metaObject count: 1.\r  nil.\r  rowsToDrop := (self columnAt: columnNumber) collect: [:ele |  #metaObject count: 2.\r        nil.\r        (aBlock value: ele) ifTrue: [ #metaObject count: 3.\r              nil.\r              true ] ifFalse: [ #metaObject count: 4.\r              nil.\r              false ] ].\r  newContents := Array2D rows: self numberOfRows - (rowsToDrop select: [:ele |  #metaObject count: 5.\r                    nil.\r                    ele ]) size columns: self numberOfColumns.\r  newContents numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  1 to: self numberOfColumns do: [:j |  #metaObject count: 7.\r        nil.\r        k := 0.\r        1 to: self numberOfRows do: [:i |  #metaObject count: 8.\r              nil.\r              (rowsToDrop at: i) ifTrue: [ #metaObject count: 9.\r                    nil.\r                    k := k + 1 ] ifFalse: [ #metaObject count: 10.\r                    nil.\r                    newContents at: i - k at: j put: (contents at: i at: j) ] ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.909405-04:00' ],		#prior : OmReference [ '1597' ],		#self : OmReference [ '1598' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: aBlock\r  #metaObject count: 1.\r  nil.\r  ^contents withIndicesDo: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.912345-04:00' ],		#prior : OmReference [ '1598' ],		#self : OmReference [ '1599' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: columnNumber\r  | newContents |\r  #metaObject count: 1.\r  nil.\r  newContents := Array2D rows: self numberOfRows columns: self numberOfColumns - 1.\r  1 to: self numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        1 to: columnNumber - 1 do: [:j |  #metaObject count: 3.\r              nil.\r              newContents at: i at: j put: (contents at: i at: j) ].\r        columnNumber + 1 to: self numberOfColumns do: [:j |  #metaObject count: 4.\r              nil.\r              newContents at: i at: j - 1 put: (contents at: i at: j) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.915283-04:00' ],		#prior : OmReference [ '1599' ],		#self : OmReference [ '1600' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers\r  | dfInternal numberOfRows numberOfColumns |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := self numberOfRows.\r  numberOfColumns := anArrayOfNumbers size.\r  dfInternal := DataFrameInternal new: numberOfRows @ numberOfColumns.\r  1 to: numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        anArrayOfNumbers doWithIndex: [:j :k |  #metaObject count: 3.\r              nil.\r              dfInternal at: i at: k put: (self at: i at: j) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.918094-04:00' ],		#prior : OmReference [ '1600' ],		#self : OmReference [ '1601' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  contents numberOfRows isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.920047-04:00' ],		#prior : OmReference [ '1601' ],		#self : OmReference [ '1602' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aPoint\r  #metaObject count: 1.\r  nil.\r  contents := Array2D rows: aPoint x columns: aPoint y.\r  ^self',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.923025-04:00' ],		#prior : OmReference [ '1602' ],		#self : OmReference [ '1603' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= other\r  #metaObject count: 1.\r  nil.\r  (other class == self class and: [ #metaObject count: 2.\r        nil.\r        other numberOfRows = self numberOfRows and: [ #metaObject count: 3.\r              nil.\r              other numberOfColumns = self numberOfColumns ] ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  other withIndicesDo: [:each :i :j |  #metaObject count: 5.\r        nil.\r        (self at: i at: j) = each ifFalse: [ #metaObject count: 6.\r              nil.\r              ^false ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.925118-04:00' ],		#prior : OmReference [ '1603' ],		#self : OmReference [ '1604' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:i |  #metaObject count: 2.\r        nil.\r        self at: i at: aNumber ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.927644-04:00' ],		#prior : OmReference [ '1604' ],		#self : OmReference [ '1605' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  contents numberOfColumns isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.929261-04:00' ],		#prior : OmReference [ '1605' ],		#self : OmReference [ '1606' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r  #metaObject count: 1.\r  nil.\r  contents printOn: aStream',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.932228-04:00' ],		#prior : OmReference [ '1606' ],		#self : OmReference [ '1607' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  "Converts DataFrameInternal to the array of rows"\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:i |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfColumns) collect: [:j |  #metaObject count: 3.\r              nil.\r              self at: i at: j ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.936134-04:00' ],		#prior : OmReference [ '1607' ],		#self : OmReference [ '1608' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: anArray atPosition: aNumber\r  | rows cols newContents |\r  #metaObject count: 1.\r  nil.\r  rows := self numberOfRows + 1.\r  cols := self numberOfColumns.\r  anArray size = cols ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  newContents := Array2D rows: rows columns: cols.\r  1 to: aNumber - 1 do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: cols do: [:j |  #metaObject count: 4.\r              nil.\r              newContents at: i at: j put: (self at: i at: j) ] ].\r  1 to: cols do: [:j |  #metaObject count: 5.\r        nil.\r        newContents at: aNumber at: j put: (anArray at: j) ].\r  aNumber + 1 to: rows do: [:i |  #metaObject count: 6.\r        nil.\r        1 to: cols do: [:j |  #metaObject count: 7.\r              nil.\r              newContents at: i at: j put: (self at: i - 1 at: j) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.938015-04:00' ],		#prior : OmReference [ '1608' ],		#self : OmReference [ '1609' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.942234-04:00' ],		#prior : OmReference [ '1609' ],		#self : OmReference [ '1610' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex put: value\r  #metaObject count: 1.\r  nil.\r  ^contents at: rowIndex at: columnIndex put: value',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.945094-04:00' ],		#prior : OmReference [ '1610' ],		#self : OmReference [ '1611' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays\r  | numberOfRows numberOfColumns dfInternal |\r  #metaObject count: 1.\r  nil.\r  numberOfColumns := anArrayOfArrays size.\r  numberOfRows := 0.\r  1 to: numberOfColumns do: [:index |  #metaObject count: 2.\r        nil.\r        numberOfRows := numberOfRows max: (anArrayOfArrays at: index) size ].\r  dfInternal := self new: numberOfRows @ numberOfColumns.\r  1 to: numberOfRows do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: numberOfColumns do: [:j |  #metaObject count: 4.\r              nil.\r              dfInternal at: i at: j put: ((anArrayOfArrays at: j) asArray at: i ifAbsent: nil) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.946855-04:00' ],		#prior : OmReference [ '1611' ],		#self : OmReference [ '1612' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aPoint\r  #metaObject count: 1.\r  nil.\r  ^self new initialize: aPoint',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.94901-04:00' ],		#prior : OmReference [ '1612' ],		#self : OmReference [ '1613' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: anArray2D\r  | dfInternal |\r  "We can\'t use Array2D>>extent, because it gives us col@row instead of row@col"\r  #metaObject count: 1.\r  nil.\r  dfInternal := self new: anArray2D rowCount @ anArray2D columnCount.\r  anArray2D withIndicesDo: [:each :i :j |  #metaObject count: 2.\r        nil.\r        dfInternal at: i at: j put: each ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.952137-04:00' ],		#prior : OmReference [ '1613' ],		#self : OmReference [ '1614' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays\r  | numberOfRows numberOfColumns dfInternal |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfArrays size.\r  numberOfColumns := 0.\r  1 to: numberOfRows do: [:index |  #metaObject count: 2.\r        nil.\r        numberOfColumns := numberOfColumns max: (anArrayOfArrays at: index) size ].\r  dfInternal := self new: numberOfRows @ numberOfColumns.\r  1 to: numberOfRows do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: numberOfColumns do: [:j |  #metaObject count: 4.\r              nil.\r              dfInternal at: i at: j put: ((anArrayOfArrays at: i) asArray at: j ifAbsent: nil) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.954459-04:00' ],		#prior : OmReference [ '1614' ],		#self : OmReference [ '1615' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: column row: rowNumber\r  | columnNumber |\r  #metaObject count: 1.\r  nil.\r  column id = \'#\' ifTrue: [ #metaObject count: 2.\r        nil.\r        ^FTCellMorph new addMorph: (elements rowNames at: rowNumber) asMorph ].\r  columnNumber := elements columnNames indexOf: column id.\r  ^FTCellMorph new addMorph: (elements at: rowNumber at: columnNumber) asMorph',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.956914-04:00' ],		#prior : OmReference [ '1615' ],		#self : OmReference [ '1616' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^elements numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.959233-04:00' ],		#prior : OmReference [ '1616' ],		#self : OmReference [ '1617' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: aBlock\r  "We enumerate through the data enrties - through rows of a data frame"\r  | row |\r  #metaObject count: 1.\r  nil.\r  1 to: self numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        row := self rowAt: i.\r        aBlock value: row.\r        \r        "A hack to allow modification of rows inside do block"self rowAt: i put: row asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.96106-04:00' ],		#prior : OmReference [ '1617' ],		#self : OmReference [ '1618' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame on: aColumnName\r  "Outer join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self outerJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.963465-04:00' ],		#prior : OmReference [ '1618' ],		#self : OmReference [ '1619' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: thisValue into: binaryBlock\r  | series |\r  #metaObject count: 1.\r  nil.\r  series := super inject: thisValue into: binaryBlock.\r  series name: series defaultName.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.966025-04:00' ],		#prior : OmReference [ '1619' ],		#self : OmReference [ '1620' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.96789-04:00' ],		#prior : OmReference [ '1620' ],		#self : OmReference [ '1621' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: columnNumber applyElementwise: aBlock\r  | columnName |\r  #metaObject count: 1.\r  nil.\r  columnName := self columnNames at: columnNumber.\r  ^self toColumn: columnName applyElementwise: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.970087-04:00' ],		#prior : OmReference [ '1621' ],		#self : OmReference [ '1622' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfNumbers size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfNumbers with: anArrayOfArrays do: [:index :array |  #metaObject count: 3.\r        nil.\r        self columnAt: index put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.972767-04:00' ],		#prior : OmReference [ '1622' ],		#self : OmReference [ '1623' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: columnName applyElementwise: aBlock\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := (self column: columnName) asArray.\r  column := column collect: [:each |  #metaObject count: 2.\r        nil.\r        aBlock value: each ].\r  self column: columnName put: column asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.974706-04:00' ],		#prior : OmReference [ '1623' ],		#self : OmReference [ '1624' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame on: aColumnName\r  "Right join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self rightJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.976411-04:00' ],		#prior : OmReference [ '1624' ],		#self : OmReference [ '1625' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: aCollectionOfColumnIndices\r  | columnNamesToRemove |\r  #metaObject count: 1.\r  nil.\r  columnNamesToRemove := aCollectionOfColumnIndices collect: [:i |  #metaObject count: 2.\r        nil.\r        columnNames at: i ].\r  self removeColumns: columnNamesToRemove',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.97848-04:00' ],		#prior : OmReference [ '1625' ],		#self : OmReference [ '1626' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: elementAndIndexBlock\r  #metaObject count: 1.\r  nil.\r  1 to: self size do: [:i |  | row |\r        #metaObject count: 2.\r        nil.\r        row := self rowAt: i.\r        elementAndIndexBlock value: row value: i.\r        \r        "A hack to allow modification of rows inside do block"self rowAt: i put: row asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.982734-04:00' ],		#prior : OmReference [ '1626' ],		#self : OmReference [ '1627' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: aBlock\r  "Evaluate aBlock with each of the receiver\'s elements as the argument. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to true. Answer the new collection."\r  | rows selectedRows selectedRowNames selectedColumnNames selectedRowsAsArrays df |\r  #metaObject count: 1.\r  nil.\r  rows := self asArrayOfRows.\r  selectedRows := rows select: aBlock.\r  selectedRowNames := selectedRows isEmpty ifTrue: [ #metaObject count: 2.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 3.\r        nil.\r        selectedRows collect: #name ].\r  selectedColumnNames := selectedRows isEmpty ifTrue: [ #metaObject count: 4.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 5.\r        nil.\r        self columnNames ].\r  selectedRowsAsArrays := selectedRows collect: #asArray.\r  df := self class withRows: selectedRowsAsArrays rowNames: selectedRowNames columnNames: selectedColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.984903-04:00' ],		#prior : OmReference [ '1627' ],		#self : OmReference [ '1628' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName ifAbsent: exceptionBlock\r  "Answer the column with columnName as a DataSeries or evaluate exception block if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self columnAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.987723-04:00' ],		#prior : OmReference [ '1628' ],		#self : OmReference [ '1629' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame\r  "Performs left join on aDataFrame with rowNames as keys"\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := self rowNames intersection: aDataFrame rowNames.\r  self rowNames do: [:rowName |  | rowToAdd |\r        #metaObject count: 2.\r        nil.\r        rowToAdd := (commonRows includes: rowName) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: rowName) asArray , (aDataFrame row: rowName) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: rowName) asArray , (Array new: aDataFrame columnNames size) ].\r        outputDf addRow: rowToAdd named: rowName ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.989823-04:00' ],		#prior : OmReference [ '1629' ],		#self : OmReference [ '1630' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: aNumber transform: aBlock\r  "Evaluate aBlock on the row at aNumber and replace that row with the result"\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: aNumber transform: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.992329-04:00' ],		#prior : OmReference [ '1630' ],		#self : OmReference [ '1631' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.994304-04:00' ],		#prior : OmReference [ '1631' ],		#self : OmReference [ '1632' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: aString atPosition: aNumber\r  "Add an empty column at the given position"\r  #metaObject count: 1.\r  nil.\r  self addColumn: (Array new: self numberOfRows) named: aString atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.997073-04:00' ],		#prior : OmReference [ '1632' ],		#self : OmReference [ '1633' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: columnName using: aBlock\r  | column sortedKeys newContents |\r  #metaObject count: 1.\r  nil.\r  column := self column: columnName.\r  column := column copy.\r  column sort: aBlock.\r  sortedKeys := column keys.\r  newContents := DataFrameInternal new: self dimensions.\r  sortedKeys withIndexDo: [:key :i |  #metaObject count: 2.\r        nil.\r        newContents rowAt: i put: (self row: key) asArray ].\r  contents := newContents.\r  self rowNames: sortedKeys',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:20.999287-04:00' ],		#prior : OmReference [ '1633' ],		#self : OmReference [ '1634' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #average',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.001067-04:00' ],		#prior : OmReference [ '1634' ],		#self : OmReference [ '1635' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray named: aString\r  "Add a new column at the end"\r  #metaObject count: 1.\r  nil.\r  self addColumn: anArray named: aString atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.003664-04:00' ],		#prior : OmReference [ '1635' ],		#self : OmReference [ '1636' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName transform: aBlock ifAbsent: exceptionBlock\r  "Evaluate aBlock on the column with columnName and replace column with the result. Evaluate exceptionBlock if columnName was not found"\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := self column: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  self column: columnName put: (aBlock value: column)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.00891-04:00' ],		#prior : OmReference [ '1636' ],		#self : OmReference [ '1637' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs inner join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputRows outputDf |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  \r  "Skip join if any of the dataframe is zero"self size isZero | aDataFrame size isZero ifFalse: [ #metaObject count: 2.\r        nil.\r        outputRows := OrderedCollection new.\r        (self column: leftColumn) withIndexDo: [:ele :index |  #metaObject count: 3.\r              nil.\r              ((aDataFrame column: rightColumn) includes: ele) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    outputRows add: index ] ].\r        outputRows do: [:rowIndex |  | rowsWithSameKey rowToAdd |\r              #metaObject count: 5.\r              nil.\r              rowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r              rowsWithSameKey do: [:rightRow |  #metaObject count: 6.\r                    nil.\r                    rowToAdd := (self rowAt: rowIndex) asArray , (aDataFrame rowAt: rightRow) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 7.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.010894-04:00' ],		#prior : OmReference [ '1637' ],		#self : OmReference [ '1638' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: rowName transform: aBlock\r  "Evaluate aBlock on the row with rowName and replace row with the result. Signal an exception if rowName was not found"\r  | row |\r  #metaObject count: 1.\r  nil.\r  row := self row: rowName.\r  self row: rowName put: (aBlock value: row) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.013287-04:00' ],		#prior : OmReference [ '1638' ],		#self : OmReference [ '1639' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arrayOfColumnNames applyElementwise: aBlock\r  #metaObject count: 1.\r  nil.\r  arrayOfColumnNames do: [:each |  #metaObject count: 2.\r        nil.\r        self toColumn: each applyElementwise: aBlock ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.01541-04:00' ],		#prior : OmReference [ '1639' ],		#self : OmReference [ '1640' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #thirdQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.016805-04:00' ],		#prior : OmReference [ '1640' ],		#self : OmReference [ '1641' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: aBlock\r  "Applies a given block to all columns of a data frame"\r  #metaObject count: 1.\r  nil.\r  self toColumns: self columnNames applyElementwise: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.018885-04:00' ],		#prior : OmReference [ '1641' ],		#self : OmReference [ '1642' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  "Converts DataFrame to the array of rows"\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:i |  #metaObject count: 2.\r        nil.\r        self at: i ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.020871-04:00' ],		#prior : OmReference [ '1642' ],		#self : OmReference [ '1643' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: aString atPosition: aNumber\r  "Add an empty row at the given position"\r  #metaObject count: 1.\r  nil.\r  self addRow: (Array new: self numberOfColumns) named: aString atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.024399-04:00' ],		#prior : OmReference [ '1643' ],		#self : OmReference [ '1644' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  "Returs a transposed DataFrame. Columns become rows and rows become columns."\r  | transposedDf |\r  #metaObject count: 1.\r  nil.\r  transposedDf := DataFrame withRows: self asArrayOfColumns.\r  transposedDf rowNames: self columnNames.\r  transposedDf columnNames: self rowNames.\r  ^transposedDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.025917-04:00' ],		#prior : OmReference [ '1644' ],		#self : OmReference [ '1645' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: composite\r  "Hide Items from inspector"\r  #metaObject count: 1.\r  nil.\r  composite fastTable when: [ #metaObject count: 2.\r        nil.\r        false ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.028795-04:00' ],		#prior : OmReference [ '1645' ],		#self : OmReference [ '1646' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber put: value\r  #metaObject count: 1.\r  nil.\r  contents at: rowNumber at: columnNumber put: value',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.031862-04:00' ],		#prior : OmReference [ '1646' ],		#self : OmReference [ '1647' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber\r  | columnNamesCopy |\r  #metaObject count: 1.\r  nil.\r  (rowNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        rowNumber > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: rowNumber ].\r  columnNamesCopy := columnNames deepCopy.\r  columnNames removeAll.\r  columnNamesCopy withIndexDo: [:columnName :j |  #metaObject count: 4.\r        nil.\r        (aBlock value: (contents at: rowNumber at: j)) ifFalse: [ #metaObject count: 5.\r              nil.\r              columnNames add: columnName ] ].\r  contents removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber.\r  self numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        rowNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.034371-04:00' ],		#prior : OmReference [ '1647' ],		#self : OmReference [ '1648' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  #metaObject count: 1.\r  nil.\r  ^columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.037284-04:00' ],		#prior : OmReference [ '1648' ],		#self : OmReference [ '1649' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arrayOfColumnNumbers applyElementwise: aBlock\r  #metaObject count: 1.\r  nil.\r  arrayOfColumnNumbers do: [:each |  #metaObject count: 2.\r        nil.\r        self toColumnAt: each applyElementwise: aBlock ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.043543-04:00' ],		#prior : OmReference [ '1649' ],		#self : OmReference [ '1650' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs outer join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputDf commonRows leftNils |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r  1 to: self size do: [:rowIndex |  | rowsWithSameKey rowToAdd |\r        #metaObject count: 2.\r        nil.\r        (commonRows includes: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn))) ifTrue: [ #metaObject count: 3.\r              nil.\r              rowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r              rowsWithSameKey do: [:rightRow |  #metaObject count: 4.\r                    nil.\r                    rowToAdd := (self rowAt: rowIndex) asArray , (aDataFrame rowAt: rightRow) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              rowToAdd := (self rowAt: rowIndex) asArray , (Array new: aDataFrame columnNames size).\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  1 to: aDataFrame size do: [:rowIndex |  | rowToAdd |\r        #metaObject count: 6.\r        nil.\r        (commonRows includes: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn))) ifFalse: [ #metaObject count: 7.\r              nil.\r              leftNils := self columnNames collect: [:col |  #metaObject count: 8.\r                    nil.\r                    col = rightColumn ifTrue: [ #metaObject count: 9.\r                          nil.\r                          (aDataFrame rowAt: rowIndex) at: rightColumn ] ifFalse: [ #metaObject count: 10.\r                          nil.\r                          nil ] ].\r              rowToAdd := leftNils , (aDataFrame rowAt: rowIndex) asArray.\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 11.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.046847-04:00' ],		#prior : OmReference [ '1650' ],		#self : OmReference [ '1651' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray named: aString atPosition: aNumber\r  "Add a new column at the given position"\r  #metaObject count: 1.\r  nil.\r  (self columnNames includes: aString) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A column with that name already exists\' ].\r  contents addColumn: anArray asArray atPosition: aNumber.\r  columnNames add: aString afterIndex: aNumber - 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.048531-04:00' ],		#prior : OmReference [ '1651' ],		#self : OmReference [ '1652' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: aString\r  "Add an empty row at the end"\r  #metaObject count: 1.\r  nil.\r  self addEmptyRowNamed: aString atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.050902-04:00' ],		#prior : OmReference [ '1652' ],		#self : OmReference [ '1653' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.053691-04:00' ],		#prior : OmReference [ '1653' ],		#self : OmReference [ '1654' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r  "Overrides the Collection>>collect to create DataFrame with the same number of columns as values in the first row"\r  | firstRow newDataFrame |\r  #metaObject count: 1.\r  nil.\r  firstRow := aBlock value: (self rowAt: 1) copy.\r  newDataFrame := self class new: 0 @ firstRow size.\r  newDataFrame columnNames: firstRow keys.\r  self do: [:each |  #metaObject count: 2.\r        nil.\r        newDataFrame add: (aBlock value: each copy) ].\r  ^newDataFrame',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.056985-04:00' ],		#prior : OmReference [ '1654' ],		#self : OmReference [ '1655' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName put: anArray ifAbsent: exceptionBlock\r  "Replace the current values of row with rowName with anArray or evaluate exception block if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self rowAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.058962-04:00' ],		#prior : OmReference [ '1655' ],		#self : OmReference [ '1656' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: columnName\r  "Answer the column with columnName as a DataSeries or signal an exception if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  ^self columnAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.060529-04:00' ],		#prior : OmReference [ '1656' ],		#self : OmReference [ '1657' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withRows: anArrayOfArrays.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.062558-04:00' ],		#prior : OmReference [ '1657' ],		#self : OmReference [ '1658' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.067162-04:00' ],		#prior : OmReference [ '1658' ],		#self : OmReference [ '1659' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame\r  "Performs outer join on aDataFrame with rowNames as keys"\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := self rowNames intersection: aDataFrame rowNames.\r  self rowNames do: [:rowName |  | rowToAdd |\r        #metaObject count: 2.\r        nil.\r        rowToAdd := (commonRows includes: rowName) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: rowName) asArray , (aDataFrame row: rowName) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: rowName) asArray , (Array new: aDataFrame columnNames size) ].\r        outputDf addRow: rowToAdd named: rowName ].\r  aDataFrame rowNames do: [:rowName |  #metaObject count: 5.\r        nil.\r        (commonRows includes: rowName) ifFalse: [ #metaObject count: 6.\r              nil.\r              outputDf addRow: (Array new: self columnNames size) , (aDataFrame row: rowName) asArray named: rowName ] ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.069536-04:00' ],		#prior : OmReference [ '1659' ],		#self : OmReference [ '1660' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: begin to: end\r  | array |\r  #metaObject count: 1.\r  nil.\r  array := begin < end ifTrue: [ #metaObject count: 2.\r        nil.\r        (begin to: end) asArray ] ifFalse: [ #metaObject count: 3.\r        nil.\r        (end to: begin) asArray reverse ].\r  ^self columnsAt: array',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.072006-04:00' ],		#prior : OmReference [ '1660' ],		#self : OmReference [ '1661' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber\r  | series |\r  #metaObject count: 1.\r  nil.\r  series := (contents columnAt: aNumber) asDataSeries.\r  series name: (self columnNames at: aNumber).\r  series keys: self rowNames.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.074675-04:00' ],		#prior : OmReference [ '1661' ],		#self : OmReference [ '1662' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: aDataSeries atPosition: aNumber\r  "Add DataSeries as a new column at the given position"\r  #metaObject count: 1.\r  nil.\r  self addColumn: aDataSeries asArray named: aDataSeries name atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.076996-04:00' ],		#prior : OmReference [ '1662' ],		#self : OmReference [ '1663' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: columnName put: anArray\r  "Replace the current values of column with columnName with anArray or signal an exception if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  ^self columnAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.078884-04:00' ],		#prior : OmReference [ '1663' ],		#self : OmReference [ '1664' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: columnName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  self removeColumnAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.080801-04:00' ],		#prior : OmReference [ '1664' ],		#self : OmReference [ '1665' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: oldName to: newName\r  "Find a column with oldName and rename it to newName"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: oldName.\r  self columnNames at: index put: newName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.08306-04:00' ],		#prior : OmReference [ '1665' ],		#self : OmReference [ '1666' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #max',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.085122-04:00' ],		#prior : OmReference [ '1666' ],		#self : OmReference [ '1667' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName ifAbsent: exceptionBlock\r  "Answer the row with rowName as a DataSeries or evaluate exception block if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self rowAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.087161-04:00' ],		#prior : OmReference [ '1667' ],		#self : OmReference [ '1668' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: aCollectionOfRowNames\r  #metaObject count: 1.\r  nil.\r  aCollectionOfRowNames do: [:each |  #metaObject count: 2.\r        nil.\r        self removeRow: each ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.089497-04:00' ],		#prior : OmReference [ '1668' ],		#self : OmReference [ '1669' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: composite\r  < gtInspectorPresentationOrder: 0>\r  < gtInspectorTag: #basic>\r  #metaObject count: 1.\r  nil.\r  composite morph\r     title: \'Fast Table\';\r     display: [ #metaObject count: 2.\r        nil.\r        self showWithGlamourIn: composite ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.091439-04:00' ],		#prior : OmReference [ '1669' ],		#self : OmReference [ '1670' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRowNamed: rowName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  self removeColumnsOfRowElementsSatisfing: aBlock onRow: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.094537-04:00' ],		#prior : OmReference [ '1670' ],		#self : OmReference [ '1671' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: anArray named: aString atPosition: aNumber\r  "Add a new row at the given position"\r  #metaObject count: 1.\r  nil.\r  (self rowNames includes: aString) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A row with that name already exists\' ].\r  contents addRow: anArray atPosition: aNumber.\r  rowNames add: aString afterIndex: aNumber - 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.09765-04:00' ],		#prior : OmReference [ '1671' ],		#self : OmReference [ '1672' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= aDataFrame\r  "Most objects will fail here"\r  #metaObject count: 1.\r  nil.\r  aDataFrame species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  \r  "This is the fastest way for two data frames with different dimensions"aDataFrame dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  \r  "If the names are different we don\'t need to iterate through values"(aDataFrame rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        aDataFrame columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  ^aDataFrame contents = self contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.100131-04:00' ],		#prior : OmReference [ '1672' ],		#self : OmReference [ '1673' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock as: anAggregateColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.10258-04:00' ],		#prior : OmReference [ '1673' ],		#self : OmReference [ '1674' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.104499-04:00' ],		#prior : OmReference [ '1674' ],		#self : OmReference [ '1675' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: elementAndIndexBlock\r  "Evaluate aBlock with each of the receiver\'s elements and index as the arguments. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to false. Answer the new collection."\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:row :index |  #metaObject count: 2.\r        nil.\r        (elementAndIndexBlock value: row value: index) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.107018-04:00' ],		#prior : OmReference [ '1675' ],		#self : OmReference [ '1676' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex transform: aBlock\r  "Evaluate aBlock on the value at the intersection of rowIndex and columnIndex and replace that value with the result"\r  | value |\r  #metaObject count: 1.\r  nil.\r  value := self at: rowIndex at: columnIndex.\r  self at: rowIndex at: columnIndex put: (aBlock value: value)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.110453-04:00' ],		#prior : OmReference [ '1676' ],		#self : OmReference [ '1677' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.112651-04:00' ],		#prior : OmReference [ '1677' ],		#self : OmReference [ '1678' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: columnName\r  "Answer the index of a column with a given name or signal an exception if the column with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self indexOfColumnNamed: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Column \' , columnName , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.114562-04:00' ],		#prior : OmReference [ '1678' ],		#self : OmReference [ '1679' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: columnName transform: aBlock\r  "Evaluate aBlock on the column with columnName and replace column with the result. Signal an exception if columnName was not found"\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := self column: columnName.\r  self column: columnName put: (aBlock value: column) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.118891-04:00' ],		#prior : OmReference [ '1679' ],		#self : OmReference [ '1680' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : ': arg2;\r     columnNames: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock as: aNewColumnName\r  | groupColumn aggregateColumn |\r  #metaObject count: 1.\r  nil.\r  aGroupColumnName = anAggregateColumnName ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'Can not group a column by itself\' ].\r  groupColumn := self column: aGroupColumnName.\r  aggregateColumn := self column: anAggregateColumnName.\r  ^aggregateColumn groupBy: groupColumn aggregateUsing: aBlock as: aNewColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.122239-04:00' ],		#prior : OmReference [ '1680' ],		#self : OmReference [ '1681' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #median',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.123835-04:00' ],		#prior : OmReference [ '1681' ],		#self : OmReference [ '1682' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: columnNumber\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onColumn: columnNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.125584-04:00' ],		#prior : OmReference [ '1682' ],		#self : OmReference [ '1683' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aPoint\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new: aPoint.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.127346-04:00' ],		#prior : OmReference [ '1683' ],		#self : OmReference [ '1684' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: aString\r  "Add an empty column at the end"\r  #metaObject count: 1.\r  nil.\r  self addEmptyColumnNamed: aString atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.129348-04:00' ],		#prior : OmReference [ '1684' ],		#self : OmReference [ '1685' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: anObject atColumn: columnName\r  "Returns rowNames of rows having anObject at columnName"\r  #metaObject count: 1.\r  nil.\r  ^self rowNames select: [:row |  #metaObject count: 2.\r        nil.\r        ((self column: columnName) at: row) = anObject ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.131053-04:00' ],		#prior : OmReference [ '1685' ],		#self : OmReference [ '1686' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: aNumber\r  | n |\r  #metaObject count: 1.\r  nil.\r  self numberOfRows > aNumber ifTrue: [ #metaObject count: 2.\r        nil.\r        n := aNumber ] ifFalse: [ #metaObject count: 3.\r        nil.\r        n := self numberOfRows ].\r  ^self rowsAt: (1 to: n)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.136833-04:00' ],		#prior : OmReference [ '1686' ],		#self : OmReference [ '1687' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs right join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputDf commonRows leftNils |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r  1 to: aDataFrame size do: [:rowIndex |  | rowToAdd rowsWithSameKey |\r        #metaObject count: 2.\r        nil.\r        (commonRows includes: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn))) ifTrue: [ #metaObject count: 3.\r              nil.\r              rowsWithSameKey := self findAllIndicesOf: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn)) atColumn: leftColumn.\r              rowsWithSameKey do: [:leftRow |  #metaObject count: 4.\r                    nil.\r                    rowToAdd := (self rowAt: leftRow) asArray , (aDataFrame rowAt: rowIndex) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              leftNils := self columnNames collect: [:col |  #metaObject count: 6.\r                    nil.\r                    col = rightColumn ifTrue: [ #metaObject count: 7.\r                          nil.\r                          (aDataFrame rowAt: rowIndex) at: rightColumn ] ifFalse: [ #metaObject count: 8.\r                          nil.\r                          nil ] ].\r              rowToAdd := leftNils , (aDataFrame rowAt: rowIndex) asArray.\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 9.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.138737-04:00' ],		#prior : OmReference [ '1687' ],		#self : OmReference [ '1688' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: begin to: end\r  #metaObject count: 1.\r  nil.\r  ^self rowsAt: (begin to: end)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.140485-04:00' ],		#prior : OmReference [ '1688' ],		#self : OmReference [ '1689' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: rowName\r  "Answer the index of a row with a given name or signal an exception if the row with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self indexOfRowNamed: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Row \' , rowName , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.142037-04:00' ],		#prior : OmReference [ '1689' ],		#self : OmReference [ '1690' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber\r  | series |\r  #metaObject count: 1.\r  nil.\r  series := (contents rowAt: aNumber) asDataSeries.\r  series name: (self rowNames at: aNumber).\r  series keys: self columnNames.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.145014-04:00' ],		#prior : OmReference [ '1690' ],		#self : OmReference [ '1691' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName put: anArray ifAbsent: exceptionBlock\r  "Replace the current values of column with columnName with anArray or evaluate exception block if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self columnAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.147239-04:00' ],		#prior : OmReference [ '1691' ],		#self : OmReference [ '1692' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame\r  "Performs inner join on aDataFrame with rowNames as keys"\r  | outputRows outputDf |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  \r  "Using select instead of intersection to preserve order"outputRows := self rowNames select: [:row |  #metaObject count: 2.\r        nil.\r        aDataFrame rowNames includes: row ].\r  outputRows do: [:rowName |  | rowToAdd |\r        #metaObject count: 3.\r        nil.\r        rowToAdd := (self row: rowName) asArray , (aDataFrame row: rowName) asArray.\r        outputDf addRow: rowToAdd named: rowName ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.150531-04:00' ],		#prior : OmReference [ '1692' ],		#self : OmReference [ '1693' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #interquartileRange',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.152764-04:00' ],		#prior : OmReference [ '1693' ],		#self : OmReference [ '1694' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber\r  #metaObject count: 1.\r  nil.\r  ^contents at: rowNumber at: columnNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.155173-04:00' ],		#prior : OmReference [ '1694' ],		#self : OmReference [ '1695' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeContents:rowNames:columnNames:',			#protocol : #initialization,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeContents:rowNames:columnNames:',			#protocol : #initialization,			#sourceCode : 'initializeContents: aDataFrameInternal rowNames: rows columnNames: columns\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := aDataFrameInternal.\r  self rowNames: rows.\r  self columnNames: columns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.156899-04:00' ],		#prior : OmReference [ '1695' ],		#self : OmReference [ '1696' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame on: aColumnName\r  "Left join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self leftJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.159734-04:00' ],		#prior : OmReference [ '1696' ],		#self : OmReference [ '1697' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: columnName aggregate: anArrayOfUsingAsStatements\r  | aggregatedColumns |\r  #metaObject count: 1.\r  nil.\r  aggregatedColumns := anArrayOfUsingAsStatements collect: [:aBlock |  #metaObject count: 2.\r        nil.\r        aBlock value: self value: columnName ].\r  ^DataFrame withColumns: aggregatedColumns rowNames: aggregatedColumns first keys columnNames: (aggregatedColumns collect: #name)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.162777-04:00' ],		#prior : OmReference [ '1697' ],		#self : OmReference [ '1698' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: aDataFrame\r  #metaObject count: 1.\r  nil.\r  aDataFrame species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  aDataFrame dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (aDataFrame rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        aDataFrame columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  1 to: self numberOfRows do: [:i |  #metaObject count: 6.\r        nil.\r        1 to: self numberOfColumns do: [:j |  #metaObject count: 7.\r              nil.\r              ((self at: i at: j) closeTo: (aDataFrame at: i at: j)) ifFalse: [ #metaObject count: 8.\r                    nil.\r                    ^false ] ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.16477-04:00' ],		#prior : OmReference [ '1698' ],		#self : OmReference [ '1699' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #stdev',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.166155-04:00' ],		#prior : OmReference [ '1699' ],		#self : OmReference [ '1700' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: aDataSeries\r  "Add DataSeries as a new column at the end"\r  #metaObject count: 1.\r  nil.\r  self addColumn: aDataSeries named: aDataSeries name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.16973-04:00' ],		#prior : OmReference [ '1700' ],		#self : OmReference [ '1701' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: firstNumber to: secondNumber put: anArrayOfArrays\r  | interval |\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = ((firstNumber - secondNumber) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  interval := secondNumber >= firstNumber ifTrue: [ #metaObject count: 3.\r        nil.\r        firstNumber to: secondNumber ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (secondNumber to: firstNumber) reversed ].\r  interval withIndexDo: [:rowIndex :i |  #metaObject count: 5.\r        nil.\r        self rowAt: rowIndex put: (anArrayOfArrays at: i) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.17198-04:00' ],		#prior : OmReference [ '1701' ],		#self : OmReference [ '1702' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.173718-04:00' ],		#prior : OmReference [ '1702' ],		#self : OmReference [ '1703' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: anArray named: aString\r  "Add a new row at the end"\r  #metaObject count: 1.\r  nil.\r  self addRow: anArray named: aString atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.176225-04:00' ],		#prior : OmReference [ '1703' ],		#self : OmReference [ '1704' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r  #metaObject count: 1.\r  nil.\r  ^rowNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.178179-04:00' ],		#prior : OmReference [ '1704' ],		#self : OmReference [ '1705' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: columnNumber\r  #metaObject count: 1.\r  nil.\r  (columnNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        columnNumber > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: columnNumber ].\r  contents removeColumnAt: columnNumber.\r  columnNames := columnNames copyWithoutIndex: columnNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.179983-04:00' ],		#prior : OmReference [ '1705' ],		#self : OmReference [ '1706' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers\r  | newRowNames |\r  #metaObject count: 1.\r  nil.\r  newRowNames := anArrayOfNumbers collect: [:i |  #metaObject count: 2.\r        nil.\r        self rowNames at: i ].\r  ^DataFrame withDataFrameInternal: (self contents rowsAt: anArrayOfNumbers) rowNames: newRowNames columnNames: self columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.182611-04:00' ],		#prior : OmReference [ '1706' ],		#self : OmReference [ '1707' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: anArrayOfColumnNames put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfColumnNames size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfColumnNames with: anArrayOfArrays do: [:name :array |  #metaObject count: 3.\r        nil.\r        self column: name put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.184652-04:00' ],		#prior : OmReference [ '1707' ],		#self : OmReference [ '1708' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: anArrayOfNames\r  | anArrayOfNumbers |\r  #metaObject count: 1.\r  nil.\r  anArrayOfNumbers := anArrayOfNames collect: [:name |  #metaObject count: 2.\r        nil.\r        self indexOfColumnNamed: name ].\r  ^self columnsAt: anArrayOfNumbers',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.186461-04:00' ],		#prior : OmReference [ '1708' ],		#self : OmReference [ '1709' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: rowName ifAbsent: exceptionBlock\r  "Answer the index of a row with a given name or evaluate the exceptionBlock if the row with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self rowNames indexOf: rowName ifAbsent: exceptionBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.188009-04:00' ],		#prior : OmReference [ '1709' ],		#self : OmReference [ '1710' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: rowNumber\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onRow: rowNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.190678-04:00' ],		#prior : OmReference [ '1710' ],		#self : OmReference [ '1711' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: aDataSeries\r  "Add DataSeries as a new row at the end"\r  #metaObject count: 1.\r  nil.\r  self addRow: aDataSeries asArray named: aDataSeries name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.193043-04:00' ],		#prior : OmReference [ '1711' ],		#self : OmReference [ '1712' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber put: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents columnAt: aNumber put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.194957-04:00' ],		#prior : OmReference [ '1712' ],		#self : OmReference [ '1713' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber transform: aBlock\r  "Evaluate aBlock on the row at aNumber and replace that row with the result"\r  | row |\r  #metaObject count: 1.\r  nil.\r  row := self rowAt: aNumber.\r  self rowAt: aNumber put: (aBlock value: row) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.196577-04:00' ],		#prior : OmReference [ '1713' ],		#self : OmReference [ '1714' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aDataSeries\r  "Add DataSeries as a new row at the end"\r  #metaObject count: 1.\r  nil.\r  self addRow: aDataSeries',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.198389-04:00' ],		#prior : OmReference [ '1714' ],		#self : OmReference [ '1715' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: rowName put: anArray\r  "Replace the current values of row with rowName with anArray or signal an exception if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  ^self rowAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.200978-04:00' ],		#prior : OmReference [ '1715' ],		#self : OmReference [ '1716' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: anObject atColumn: columnName\r  "Returns indices of rows having anObject at columnName"\r  | output |\r  #metaObject count: 1.\r  nil.\r  output := OrderedCollection new.\r  self rowNames withIndexDo: [:row :index |  #metaObject count: 2.\r        nil.\r        ((self column: columnName) at: row) = anObject ifTrue: [ #metaObject count: 3.\r              nil.\r              output add: index ] ].\r  ^output',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.204548-04:00' ],		#prior : OmReference [ '1716' ],		#self : OmReference [ '1717' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: aDataFrame\r  "comment stating purpose of message"\r  | columnIntersection outputColumns |\r  #metaObject count: 1.\r  nil.\r  columnIntersection := (self columnNames intersection: aDataFrame columnNames) asSet.\r  outputColumns := OrderedCollection new.\r  self columnNames do: [:column |  #metaObject count: 2.\r        nil.\r        (columnIntersection includes: column) ifTrue: [ #metaObject count: 3.\r              nil.\r              outputColumns add: (\'\' join: {(column , \'_x\')}) ] ifFalse: [ #metaObject count: 4.\r              nil.\r              outputColumns add: column ] ].\r  aDataFrame columnNames do: [:column |  #metaObject count: 5.\r        nil.\r        (columnIntersection includes: column) ifTrue: [ #metaObject count: 6.\r              nil.\r              outputColumns add: (\'\' join: {(column , \'_y\')}) ] ifFalse: [ #metaObject count: 7.\r              nil.\r              outputColumns add: column ] ].\r  ^outputColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.20748-04:00' ],		#prior : OmReference [ '1717' ],		#self : OmReference [ '1718' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of column names\' ].\r  anArray asSet size = anArray size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All column names must be distinct\' ].\r  columnNames := anArray asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.20969-04:00' ],		#prior : OmReference [ '1718' ],		#self : OmReference [ '1719' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: aCollectionOfRowIndices\r  | rowNamesToRemove |\r  #metaObject count: 1.\r  nil.\r  rowNamesToRemove := aCollectionOfRowIndices collect: [:i |  #metaObject count: 2.\r        nil.\r        rowNames at: i ].\r  self removeRows: rowNamesToRemove',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.212895-04:00' ],		#prior : OmReference [ '1719' ],		#self : OmReference [ '1720' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName transform: aBlock ifAbsent: exceptionBlock\r  "Evaluate aBlock on the row with rowName and replace row with the result. Evaluate exceptionBlock if rowName was not found"\r  | row |\r  #metaObject count: 1.\r  nil.\r  row := self row: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  self row: rowName put: (aBlock value: row)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.216133-04:00' ],		#prior : OmReference [ '1720' ],		#self : OmReference [ '1721' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: elementAndIndexBlock\r  "Evaluate aBlock with each of the receiver\'s elements and index as the arguments. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to true. Answer the new collection."\r  | rows selectedRowIndices selectedRowNames selectedRowsAsArrays df |\r  #metaObject count: 1.\r  nil.\r  rows := self asArrayOfRows.\r  selectedRowIndices := (1 to: rows size) select: [:i |  #metaObject count: 2.\r        nil.\r        elementAndIndexBlock value: (rows at: i) value: i ].\r  selectedRowNames := selectedRowIndices collect: [:i |  #metaObject count: 3.\r        nil.\r        self rowNames at: i ].\r  selectedRowsAsArrays := selectedRowIndices collect: [:i |  #metaObject count: 4.\r        nil.\r        (rows at: i) asArray ].\r  df := self class withRows: selectedRowsAsArrays rowNames: selectedRowNames columnNames: self columnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.218762-04:00' ],		#prior : OmReference [ '1721' ],		#self : OmReference [ '1722' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.222369-04:00' ],		#prior : OmReference [ '1722' ],		#self : OmReference [ '1723' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber\r  | rowNamesCopy |\r  #metaObject count: 1.\r  nil.\r  (columnNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        columnNumber > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: columnNumber ].\r  rowNamesCopy := rowNames deepCopy.\r  rowNames removeAll.\r  rowNamesCopy withIndexDo: [:rowName :i |  #metaObject count: 4.\r        nil.\r        (aBlock value: (contents at: i at: columnNumber)) ifFalse: [ #metaObject count: 5.\r              nil.\r              rowNames add: rowName ] ].\r  contents removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber.\r  self numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        columnNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.22932-04:00' ],		#prior : OmReference [ '1723' ],		#self : OmReference [ '1724' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs left join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r  1 to: self size do: [:rowIndex |  | rowsWithSameKey rowToAdd |\r        #metaObject count: 2.\r        nil.\r        (commonRows includes: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn))) ifTrue: [ #metaObject count: 3.\r              nil.\r              rowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r              rowsWithSameKey do: [:rightRow |  #metaObject count: 4.\r                    nil.\r                    rowToAdd := (self rowAt: rowIndex) asArray , (aDataFrame rowAt: rightRow) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              rowToAdd := (self rowAt: rowIndex) asArray , (Array new: aDataFrame columnNames size).\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 6.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.232077-04:00' ],		#prior : OmReference [ '1724' ],		#self : OmReference [ '1725' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: elementAndIndexBlock\r  "Overrides withIndexCollect: to create DataFrame with the same number of columns as values in the first row"\r  | firstRow newDataFrame |\r  #metaObject count: 1.\r  nil.\r  firstRow := (self rowAt: 1) copy.\r  newDataFrame := self class new: 0 @ (elementAndIndexBlock value: firstRow value: 1) size.\r  newDataFrame columnNames: firstRow keys.\r  self withIndexDo: [:each :index |  #metaObject count: 2.\r        nil.\r        newDataFrame add: (elementAndIndexBlock value: each copy value: index) ].\r  ^newDataFrame',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.234786-04:00' ],		#prior : OmReference [ '1725' ],		#self : OmReference [ '1726' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfNumbers size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfNumbers with: anArrayOfArrays do: [:index :array |  #metaObject count: 3.\r        nil.\r        self rowAt: index put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.238055-04:00' ],		#prior : OmReference [ '1726' ],		#self : OmReference [ '1727' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r  | title |\r  #metaObject count: 1.\r  nil.\r  title := self class name.\r  aStream\r     nextPutAll: (title first isVowel ifTrue: [ #metaObject count: 2.\r              nil.\r              \'an \' ] ifFalse: [ #metaObject count: 3.\r              nil.\r              \'a \' ]);\r     nextPutAll: title;\r     space;\r     nextPutAll: self dimensions asString',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.240626-04:00' ],		#prior : OmReference [ '1727' ],		#self : OmReference [ '1728' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.243313-04:00' ],		#prior : OmReference [ '1728' ],		#self : OmReference [ '1729' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #min',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.246581-04:00' ],		#prior : OmReference [ '1729' ],		#self : OmReference [ '1730' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: composite\r  | table headerNames |\r  #metaObject count: 1.\r  nil.\r  table := FTTableMorph new.\r  \r  "extent: 650@500"table\r     beResizable;\r     intercellSpacing: 1;\r     dataSource: (DataFrameFTData elements: self);\r     onAnnouncement: FTSelectionChanged do: [:ann |  #metaObject count: 2.\r        nil.\r        (self rowAt: ann newSelectedIndexes first) inspect ].\r  \r  "\t\tonAnnouncement: FTSelectionChanged \r\t\t\tdo: [ :ann | (self rowsAt: ann newSelectedRowIndexes) gtInspectorItemsIn: composite ];"headerNames := #(\'#\') , self columnNames.\r  table columns: (headerNames collect: [:name |  #metaObject count: 3.\r              nil.\r              (FTColumn id: name) width: 100 ]).\r  ^table',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.24905-04:00' ],		#prior : OmReference [ '1730' ],		#self : OmReference [ '1731' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: columnName\r  #metaObject count: 1.\r  nil.\r  self sortBy: columnName using: [:a :b |  #metaObject count: 2.\r        nil.\r        a <= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.251332-04:00' ],		#prior : OmReference [ '1731' ],		#self : OmReference [ '1732' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #mode',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.253529-04:00' ],		#prior : OmReference [ '1732' ],		#self : OmReference [ '1733' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: columnName ifAbsent: exceptionBlock\r  "Answer the index of a column with a given name or evaluate the exceptionBlock if the column with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self columnNames indexOf: columnName ifAbsent: exceptionBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.255042-04:00' ],		#prior : OmReference [ '1733' ],		#self : OmReference [ '1734' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withColumns: anArrayOfArrays.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.257158-04:00' ],		#prior : OmReference [ '1734' ],		#self : OmReference [ '1735' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers\r  | newColumnNames |\r  #metaObject count: 1.\r  nil.\r  newColumnNames := anArrayOfNumbers collect: [:i |  #metaObject count: 2.\r        nil.\r        self columnNames at: i ].\r  ^DataFrame withDataFrameInternal: (self contents columnsAt: anArrayOfNumbers) rowNames: self rowNames columnNames: newColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.259275-04:00' ],		#prior : OmReference [ '1735' ],		#self : OmReference [ '1736' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: rowNumber\r  #metaObject count: 1.\r  nil.\r  (rowNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        rowNumber > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: rowNumber ].\r  contents removeRowAt: rowNumber.\r  rowNames := rowNames copyWithoutIndex: rowNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.260961-04:00' ],		#prior : OmReference [ '1736' ],		#self : OmReference [ '1737' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: rowName\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onRowNamed: rowName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.263519-04:00' ],		#prior : OmReference [ '1737' ],		#self : OmReference [ '1738' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: oldName to: newName\r  "Find a row with oldName and rename it to newName"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: oldName.\r  self rowNames at: index put: newName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.266865-04:00' ],		#prior : OmReference [ '1738' ],		#self : OmReference [ '1739' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: anArrayOfRowNames put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfRowNames size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfRowNames with: anArrayOfArrays do: [:name :array |  #metaObject count: 3.\r        nil.\r        self row: name put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.268792-04:00' ],		#prior : OmReference [ '1739' ],		#self : OmReference [ '1740' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: columnName\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onColumnNamed: columnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.270914-04:00' ],		#prior : OmReference [ '1740' ],		#self : OmReference [ '1741' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #variance',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.274071-04:00' ],		#prior : OmReference [ '1741' ],		#self : OmReference [ '1742' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: rowName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  self removeRowAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.276277-04:00' ],		#prior : OmReference [ '1742' ],		#self : OmReference [ '1743' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber put: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents rowAt: aNumber put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.278141-04:00' ],		#prior : OmReference [ '1743' ],		#self : OmReference [ '1744' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: aDataSeries atPosition: aNumber\r  "Add DataSeries as a new row at the given position"\r  #metaObject count: 1.\r  nil.\r  self addRow: aDataSeries named: aDataSeries name atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.283057-04:00' ],		#prior : OmReference [ '1744' ],		#self : OmReference [ '1745' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: firstNumber to: secondNumber put: anArrayOfArrays\r  | interval |\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = ((firstNumber - secondNumber) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  interval := secondNumber >= firstNumber ifTrue: [ #metaObject count: 3.\r        nil.\r        firstNumber to: secondNumber ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (secondNumber to: firstNumber) reversed ].\r  interval withIndexDo: [:columnIndex :i |  #metaObject count: 5.\r        nil.\r        self columnAt: columnIndex put: (anArrayOfArrays at: i) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.285957-04:00' ],		#prior : OmReference [ '1745' ],		#self : OmReference [ '1746' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame\r  "Performs right join on aDataFrame with rowNames as keys"\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := self rowNames intersection: aDataFrame rowNames.\r  aDataFrame rowNames do: [:rowName |  | rowToAdd |\r        #metaObject count: 2.\r        nil.\r        rowToAdd := (commonRows includes: rowName) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: rowName) asArray , (aDataFrame row: rowName) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (Array new: self columnNames size) , (aDataFrame row: rowName) asArray ].\r        outputDf addRow: rowToAdd named: rowName ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.288052-04:00' ],		#prior : OmReference [ '1746' ],		#self : OmReference [ '1747' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #range',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.290837-04:00' ],		#prior : OmReference [ '1747' ],		#self : OmReference [ '1748' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.292634-04:00' ],		#prior : OmReference [ '1748' ],		#self : OmReference [ '1749' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: aCollectionOfColumnNames\r  #metaObject count: 1.\r  nil.\r  aCollectionOfColumnNames do: [:each |  #metaObject count: 2.\r        nil.\r        self removeColumn: each ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.294803-04:00' ],		#prior : OmReference [ '1749' ],		#self : OmReference [ '1750' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows @ self numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.297487-04:00' ],		#prior : OmReference [ '1750' ],		#self : OmReference [ '1751' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: colName1 with: colName2\r  | col1 col2 |\r  #metaObject count: 1.\r  nil.\r  col1 := self column: colName1.\r  col2 := self column: colName2.\r  ^col1 crossTabulateWith: col2',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.299921-04:00' ],		#prior : OmReference [ '1751' ],		#self : OmReference [ '1752' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame on: aColumnName\r  "Inner join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self innerJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.302711-04:00' ],		#prior : OmReference [ '1752' ],		#self : OmReference [ '1753' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: aNumber\r  | n rows |\r  #metaObject count: 1.\r  nil.\r  rows := self numberOfRows.\r  rows > aNumber ifTrue: [ #metaObject count: 2.\r        nil.\r        n := aNumber ] ifFalse: [ #metaObject count: 3.\r        nil.\r        n := rows ].\r  ^self rowsAt: (rows - n + 1 to: rows)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.305007-04:00' ],		#prior : OmReference [ '1753' ],		#self : OmReference [ '1754' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber transform: aBlock\r  "Evaluate aBlock on the column at aNumber and replace that column with the result"\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := self columnAt: aNumber.\r  self columnAt: aNumber put: (aBlock value: column) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.306837-04:00' ],		#prior : OmReference [ '1754' ],		#self : OmReference [ '1755' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: columnName\r  #metaObject count: 1.\r  nil.\r  self sortBy: columnName using: [:a :b |  #metaObject count: 2.\r        nil.\r        a >= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.308758-04:00' ],		#prior : OmReference [ '1755' ],		#self : OmReference [ '1756' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumnNamed: columnName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  self removeRowsOfColumnElementsSatisfing: aBlock onColumn: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.311259-04:00' ],		#prior : OmReference [ '1756' ],		#self : OmReference [ '1757' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of row names\' ].\r  anArray asSet size = anArray size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All row names must be distinct\' ].\r  rowNames := anArray asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.315135-04:00' ],		#prior : OmReference [ '1757' ],		#self : OmReference [ '1758' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r  #metaObject count: 1.\r  nil.\r  self rowNames: (1 to: self numberOfRows).\r  self columnNames: (1 to: self numberOfColumns)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.317578-04:00' ],		#prior : OmReference [ '1758' ],		#self : OmReference [ '1759' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: aSymbol\r  "Sends the unary selector, aSymbol, to all columns of DataFrame and collects the result into a DataSeries object. Used by statistical functions of DataFrame"\r  | series column |\r  #metaObject count: 1.\r  nil.\r  series := DataSeries withValues: (self columnNames collect: [:colName |  #metaObject count: 2.\r              nil.\r              column := self column: colName.\r              column perform: aSymbol ]).\r  series name: aSymbol.\r  series keys: self columnNames.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.32123-04:00' ],		#prior : OmReference [ '1759' ],		#self : OmReference [ '1760' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  "Converts DataFrame to the array of columns"\r  #metaObject count: 1.\r  nil.\r  ^contents asArrayOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.323251-04:00' ],		#prior : OmReference [ '1760' ],		#self : OmReference [ '1761' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: anArrayOfNames\r  | anArrayOfNumbers |\r  #metaObject count: 1.\r  nil.\r  anArrayOfNumbers := anArrayOfNames collect: [:name |  #metaObject count: 2.\r        nil.\r        self indexOfRowNamed: name ].\r  ^self rowsAt: anArrayOfNumbers',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.324796-04:00' ],		#prior : OmReference [ '1761' ],		#self : OmReference [ '1762' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: rowName\r  "Answer the row with rowName as a DataSeries or signal an exception if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  ^self rowAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.3262-04:00' ],		#prior : OmReference [ '1762' ],		#self : OmReference [ '1763' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  ^self new initializeColumns: anArrayOfArrays',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.328353-04:00' ],		#prior : OmReference [ '1763' ],		#self : OmReference [ '1764' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays rowNames: anArrayOfRowNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withColumns: anArrayOfArrays)\r           rowNames: anArrayOfRowNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: anArrayOfRowNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.331415-04:00' ],		#prior : OmReference [ '1764' ],		#self : OmReference [ '1765' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays columnNames: anArrayOfColumnNames\r  | df |\r  #metaObject count: 1.\r  nil.\r  df := self withColumns: anArrayOfArrays.\r  df columnNames: anArrayOfColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.333674-04:00' ],		#prior : OmReference [ '1765' ],		#self : OmReference [ '1766' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r  "Create an empty data frame with given row and column names"\r  | numberOfRows numberOfColumns df |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfRowNames size.\r  numberOfColumns := anArrayOfColumnNames size.\r  df := self new: numberOfRows @ numberOfColumns.\r  df rowNames: anArrayOfRowNames.\r  df columnNames: anArrayOfColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.336053-04:00' ],		#prior : OmReference [ '1766' ],		#self : OmReference [ '1767' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays columnNames: anArrayOfColumnNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withRows: anArrayOfArrays)\r           columnNames: anArrayOfColumnNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: anArrayOfColumnNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.337609-04:00' ],		#prior : OmReference [ '1767' ],		#self : OmReference [ '1768' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  ^self new initializeRows: anArrayOfArrays',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.339326-04:00' ],		#prior : OmReference [ '1768' ],		#self : OmReference [ '1769' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: anArrayOfColumnNames\r  "Create an empty data frame with given column names"\r  | numberOfColumns df |\r  #metaObject count: 1.\r  nil.\r  numberOfColumns := anArrayOfColumnNames size.\r  df := self new: 0 @ numberOfColumns.\r  df columnNames: anArrayOfColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.342288-04:00' ],		#prior : OmReference [ '1769' ],		#self : OmReference [ '1770' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays rowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withColumns: anArrayOfArrays)\r           rowNames: anArrayOfRowNames;\r           columnNames: anArrayOfColumnNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: anArrayOfRowNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.345456-04:00' ],		#prior : OmReference [ '1770' ],		#self : OmReference [ '1771' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays rowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withRows: anArrayOfArrays)\r           rowNames: anArrayOfRowNames;\r           columnNames: anArrayOfColumnNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: anArrayOfColumnNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.348077-04:00' ],		#prior : OmReference [ '1771' ],		#self : OmReference [ '1772' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays rowNames: anArrayOfRowNames\r  | df |\r  #metaObject count: 1.\r  nil.\r  df := self withRows: anArrayOfArrays.\r  df rowNames: anArrayOfRowNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.349723-04:00' ],		#prior : OmReference [ '1772' ],		#self : OmReference [ '1773' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: anArrayOfRowNames\r  "Create an empty data frame with given row names"\r  | numberOfRows df |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfRowNames size.\r  df := self new: numberOfRows @ 0.\r  df rowNames: anArrayOfRowNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.352075-04:00' ],		#prior : OmReference [ '1773' ],		#self : OmReference [ '1774' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r  #metaObject count: 1.\r  nil.\r  ^super new initialize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.353801-04:00' ],		#prior : OmReference [ '1774' ],		#self : OmReference [ '1775' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aPoint\r  #metaObject count: 1.\r  nil.\r  ^super new initialize: aPoint',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.356262-04:00' ],		#prior : OmReference [ '1775' ],		#self : OmReference [ '1776' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: aDataFrameIndernal rowNames: rows columnNames: columns\r  #metaObject count: 1.\r  nil.\r  ^self new initializeContents: aDataFrameIndernal rowNames: rows columnNames: columns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.505404-04:00' ],		#prior : OmReference [ '1776' ],		#self : OmReference [ '1777' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'groupBy: otherSeries aggregateUsing: aBlock\r  "Group my values by the unique values of otherSeries, aggregate them using aBlock. Use my name by default"\r  #metaObject count: 1.\r  nil.\r  ^self groupBy: otherSeries aggregateUsing: aBlock as: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.509441-04:00' ],		#prior : OmReference [ '1777' ],		#self : OmReference [ '1778' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueCounts,			#protocol : #statistics,			#sourceCode : 'valueCounts\r  #metaObject count: 1.\r  nil.\r  ^(self groupBy: self aggregateUsing: #size) sortDescending',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.512123-04:00' ],		#prior : OmReference [ '1778' ],		#self : OmReference [ '1779' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'makeCategorical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := false',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.516105-04:00' ],		#prior : OmReference [ '1779' ],		#self : OmReference [ '1780' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: aBlock\r  #metaObject count: 1.\r  nil.\r  self keys withIndexDo: [:each :i |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: each) value: i ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.518723-04:00' ],		#prior : OmReference [ '1780' ],		#self : OmReference [ '1781' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := super select: aBlock.\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.521656-04:00' ],		#prior : OmReference [ '1781' ],		#self : OmReference [ '1782' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMedian,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMedian\r  "Replaces nils inplace with median"\r  | median |\r  #metaObject count: 1.\r  nil.\r  median := (self select: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNotNil ]) median.\r  self replaceNilsWith: median',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.523911-04:00' ],		#prior : OmReference [ '1782' ],		#self : OmReference [ '1783' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: aKey transform: aBlock\r  "Evaluate aBlock on the value at aKey and replace that value with the result. Signal an exception if aKey was not found"\r  #metaObject count: 1.\r  nil.\r  self at: aKey transform: aBlock ifAbsent: NotFoundError',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.52644-04:00' ],		#prior : OmReference [ '1783' ],		#self : OmReference [ '1784' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultPrecision,			#protocol : #defaults,			#sourceCode : 'defaultPrecision\r  #metaObject count: 1.\r  nil.\r  ^0.0001',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.533367-04:00' ],		#prior : OmReference [ '1784' ],		#self : OmReference [ '1785' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'crossTabulateWith:',			#protocol : #statistics,			#sourceCode : 'crossTabulateWith: aSeries\r  | df |\r  #metaObject count: 1.\r  nil.\r  self size = aSeries size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  df := DataFrame withRows: (self uniqueValues collect: [:each1 |  #metaObject count: 3.\r              nil.\r              aSeries uniqueValues collect: [:each2 |  #metaObject count: 4.\r                    nil.\r                    (1 to: self size) inject: 0 into: [:accum :i |  #metaObject count: 5.\r                          nil.\r                          ((self atIndex: i) = each1 and: (aSeries atIndex: i) = each2) ifTrue: [ #metaObject count: 6.\r                                nil.\r                                accum + 1 ] ifFalse: [ #metaObject count: 7.\r                                nil.\r                                accum ] ] ] ]).\r  df rowNames: self uniqueValues.\r  df columnNames: aSeries uniqueValues.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.536691-04:00' ],		#prior : OmReference [ '1785' ],		#self : OmReference [ '1786' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #eighth,			#protocol : #accessing,			#sourceCode : 'eighth\r  "Answer the eighth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 8',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.539356-04:00' ],		#prior : OmReference [ '1786' ],		#self : OmReference [ '1787' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #head,			#protocol : #slicing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.543836-04:00' ],		#prior : OmReference [ '1787' ],		#self : OmReference [ '1788' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAtIndex:',			#protocol : #removing,			#sourceCode : 'removeAtIndex: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self removeAt: (self keys at: aNumber)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.550316-04:00' ],		#prior : OmReference [ '1788' ],		#self : OmReference [ '1789' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'adaptToCollection:andSend:',			#protocol : #adapting,			#sourceCode : 'adaptToCollection: rcvr andSend: selector\r  "If I am involved in arithmetic with another Collection, return a Collection of\r\tthe results of each element combined with the scalar in that expression."\r  #metaObject count: 1.\r  nil.\r  (rcvr isSequenceable and: [ #metaObject count: 2.\r        nil.\r        self isSequenceable ]) ifFalse: [ #metaObject count: 3.\r        nil.\r        self error: \'Only sequenceable collections may be combined arithmetically\' ].\r  ^rcvr withSeries: self collect: [:rcvrElement :myElement |  #metaObject count: 4.\r        nil.\r        rcvrElement perform: selector with: myElement ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.553256-04:00' ],		#prior : OmReference [ '1789' ],		#self : OmReference [ '1790' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: aBlock\r  | associationBlock |\r  #metaObject count: 1.\r  nil.\r  associationBlock := [:a :b |  #metaObject count: 2.\r  nil.\r  aBlock value: a value value: b value ].\r  self sortAssociations: associationBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.555481-04:00' ],		#prior : OmReference [ '1790' ],		#self : OmReference [ '1791' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortedAssociations:',			#protocol : #sorting,			#sourceCode : 'sortedAssociations: aBlock\r  | sortedAssociations |\r  #metaObject count: 1.\r  nil.\r  sortedAssociations := self associations sort: aBlock.\r  ^sortedAssociations asDataSeries\r     name: self name;\r     yourself',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.558172-04:00' ],		#prior : OmReference [ '1791' ],		#self : OmReference [ '1792' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyCollect:',			#protocol : #enumerating,			#sourceCode : 'withKeyCollect: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := self species newFrom: (self associations collect: [:each |  #metaObject count: 2.\r              nil.\r              each key -> (aBlock value: each value value: each key) ]).\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.561087-04:00' ],		#prior : OmReference [ '1792' ],		#self : OmReference [ '1793' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'isNumerical\r  #metaObject count: 1.\r  nil.\r  ^forcedIsNumerical ifNil: [ #metaObject count: 2.\r        nil.\r        self uniqueValues allSatisfy: [:each |  #metaObject count: 3.\r              nil.\r              each isNumber ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.563265-04:00' ],		#prior : OmReference [ '1793' ],		#self : OmReference [ '1794' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #>',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.565704-04:00' ],		#prior : OmReference [ '1794' ],		#self : OmReference [ '1795' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 3',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.568036-04:00' ],		#prior : OmReference [ '1795' ],		#self : OmReference [ '1796' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultHeadTailSize,			#protocol : #defaults,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.570103-04:00' ],		#prior : OmReference [ '1796' ],		#self : OmReference [ '1797' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withKeyDetect: aBlock ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.572305-04:00' ],		#prior : OmReference [ '1797' ],		#self : OmReference [ '1798' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #hasNil,			#protocol : #testing,			#sourceCode : 'hasNil\r  "return true if data series has at least one nil value"\r  #metaObject count: 1.\r  nil.\r  ^self includes: nil',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.575095-04:00' ],		#prior : OmReference [ '1798' ],		#self : OmReference [ '1799' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sixth,			#protocol : #accessing,			#sourceCode : 'sixth\r  "Answer the sixth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 6',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.577246-04:00' ],		#prior : OmReference [ '1799' ],		#self : OmReference [ '1800' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := super collect: aBlock.\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.581784-04:00' ],		#prior : OmReference [ '1800' ],		#self : OmReference [ '1801' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'groupBy:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'groupBy: otherSeries aggregateUsing: aBlock as: aNewName\r  "Group my values by the unique values of otherSeries, aggregate them using aBlock, and answer a new DataSeries with unique values of otherSeries (group keys) as keys, aggregated values of myself as values, and aNewName as name"\r  | groupKeys groups |\r  #metaObject count: 1.\r  nil.\r  self size = otherSeries size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  groupKeys := otherSeries uniqueValues.\r  groups := groupKeys collect: [:each |  #metaObject count: 3.\r        nil.\r        (1 to: self size) select: [:i |  #metaObject count: 4.\r              nil.\r              (otherSeries atIndex: i) = each ] thenCollect: [:i |  #metaObject count: 5.\r              nil.\r              self atIndex: i ] ].\r  ^DataSeries withKeys: groupKeys values: (groups collect: aBlock) name: aNewName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.584117-04:00' ],		#prior : OmReference [ '1801' ],		#self : OmReference [ '1802' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isCategorical,			#protocol : #categorical-numerical,			#sourceCode : 'isCategorical\r  #metaObject count: 1.\r  nil.\r  ^self isNumerical not',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.586268-04:00' ],		#prior : OmReference [ '1802' ],		#self : OmReference [ '1803' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'collectWithNotNils:',			#protocol : #enumerating,			#sourceCode : 'collectWithNotNils: aBlock\r  "Applies aBlock to every non-nil element"\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:each |  #metaObject count: 2.\r        nil.\r        each isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              nil ] ifFalse: [ #metaObject count: 4.\r              nil.\r              aBlock value: each ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.588699-04:00' ],		#prior : OmReference [ '1803' ],		#self : OmReference [ '1804' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #second,			#protocol : #accessing,			#sourceCode : 'second\r  "Answer the second element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 2',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.591462-04:00' ],		#prior : OmReference [ '1804' ],		#self : OmReference [ '1805' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeySelect:',			#protocol : #enumerating,			#sourceCode : 'withKeySelect: aBlock\r  | selectedKeys |\r  #metaObject count: 1.\r  nil.\r  selectedKeys := self keys select: [:key |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: key) value: key ].\r  ^DataSeries withKeys: selectedKeys values: (selectedKeys collect: [:key |  #metaObject count: 3.\r              nil.\r              self at: key ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.593593-04:00' ],		#prior : OmReference [ '1805' ],		#self : OmReference [ '1806' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourthQuartile,			#protocol : #statistics,			#sourceCode : 'fourthQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 4',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.596522-04:00' ],		#prior : OmReference [ '1806' ],		#self : OmReference [ '1807' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sort,			#protocol : #sorting,			#sourceCode : 'sort\r  #metaObject count: 1.\r  nil.\r  self sort: [:a :b |  #metaObject count: 2.\r        nil.\r        a <= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.599342-04:00' ],		#prior : OmReference [ '1807' ],		#self : OmReference [ '1808' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quantile:',			#protocol : #statistics,			#sourceCode : 'quantile: aNumber\r  | sortedSeries index |\r  #metaObject count: 1.\r  nil.\r  sortedSeries := self sorted.\r  aNumber = 0 ifTrue: [ #metaObject count: 2.\r        nil.\r        ^sortedSeries first ].\r  index := (sortedSeries size * (aNumber / 100)) ceiling.\r  ^sortedSeries atIndex: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.60471-04:00' ],		#prior : OmReference [ '1808' ],		#self : OmReference [ '1809' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:precision:',			#protocol : #comparing,			#sourceCode : 'closeTo: anObject precision: aPrecision\r  #metaObject count: 1.\r  nil.\r  self == anObject ifTrue: [ #metaObject count: 2.\r        nil.\r        ^true ].\r  (self species == anObject species and: [ #metaObject count: 3.\r        nil.\r        self size = anObject size ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  anObject name = self name ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  anObject keys = self keys ifFalse: [ #metaObject count: 6.\r        nil.\r        ^false ].\r  ^(1 to: self values size) detect: [:i |  #metaObject count: 7.\r        nil.\r        ((self atIndex: i) closeTo: (anObject atIndex: i) precision: aPrecision) not ] ifFound: [ #metaObject count: 8.\r        nil.\r        false ] ifNone: [ #metaObject count: 9.\r        nil.\r        true ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.60885-04:00' ],		#prior : OmReference [ '1809' ],		#self : OmReference [ '1810' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:put:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber put: aValue\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: aNumber) put: aValue',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.611534-04:00' ],		#prior : OmReference [ '1810' ],		#self : OmReference [ '1811' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #defaultName,			#protocol : #defaults,			#sourceCode : 'defaultName\r  #metaObject count: 1.\r  nil.\r  ^\'(no name)\'',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.615128-04:00' ],		#prior : OmReference [ '1811' ],		#self : OmReference [ '1812' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withKeyDetect: aBlock ifNone: exceptionBlock\r  | selectedKey |\r  #metaObject count: 1.\r  nil.\r  selectedKey := self keys detect: [:key |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: key) value: key ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^exceptionBlock value ].\r  ^self at: selectedKey',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.617603-04:00' ],		#prior : OmReference [ '1812' ],		#self : OmReference [ '1813' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anObject\r  #metaObject count: 1.\r  nil.\r  super = anObject ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  ^anObject name = self name and: [ #metaObject count: 3.\r        nil.\r        anObject keys = self keys ]\r  "order of keys"',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.619102-04:00' ],		#prior : OmReference [ '1813' ],		#self : OmReference [ '1814' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'quartile:',			#protocol : #statistics,			#sourceCode : 'quartile: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self quantile: 25 * aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.621366-04:00' ],		#prior : OmReference [ '1814' ],		#self : OmReference [ '1815' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithZero,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithZero\r  "Replaces nils inplace with zero"\r  #metaObject count: 1.\r  nil.\r  self replaceNilsWith: 0',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.623544-04:00' ],		#prior : OmReference [ '1815' ],		#self : OmReference [ '1816' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'replaceNilsWith:',			#protocol : #replacing,			#sourceCode : 'replaceNilsWith: anObject\r  "Replaces nils inplace with anObject"\r  #metaObject count: 1.\r  nil.\r  self withIndexDo: [:ele :index |  #metaObject count: 2.\r        nil.\r        ele isNil ifTrue: [ #metaObject count: 3.\r              nil.\r              self atIndex: index put: anObject ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.625669-04:00' ],		#prior : OmReference [ '1816' ],		#self : OmReference [ '1817' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #secondQuartile,			#protocol : #statistics,			#sourceCode : 'secondQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 2',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.628045-04:00' ],		#prior : OmReference [ '1817' ],		#self : OmReference [ '1818' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #first,			#protocol : #accessing,			#sourceCode : 'first\r  "Answer the first element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.630914-04:00' ],		#prior : OmReference [ '1818' ],		#self : OmReference [ '1819' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:each :i |  #metaObject count: 2.\r        nil.\r        (aBlock value: each value: i) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.633147-04:00' ],		#prior : OmReference [ '1819' ],		#self : OmReference [ '1820' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.635978-04:00' ],		#prior : OmReference [ '1820' ],		#self : OmReference [ '1821' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'at:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'at: aKey transform: aBlock ifAbsent: exceptionBlock\r  "Evaluate aBlock on the value at aKey and replace that value with the result. Evaluate exceptionBlock if aKey was not found"\r  | oldValue |\r  #metaObject count: 1.\r  nil.\r  oldValue := self at: aKey ifAbsent: [ #metaObject count: 2.\r        nil.\r        exceptionBlock value.\r        ^self ].\r  self at: aKey put: (aBlock value: oldValue)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.638048-04:00' ],		#prior : OmReference [ '1821' ],		#self : OmReference [ '1822' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #errorKeysMismatch,			#protocol : #errors,			#sourceCode : 'errorKeysMismatch\r  #metaObject count: 1.\r  nil.\r  Error signal: \'Keys of two series do not match\'',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.640246-04:00' ],		#prior : OmReference [ '1822' ],		#self : OmReference [ '1823' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aCapacity\r  "Make sure that initialize is called and the default name is set"\r  #metaObject count: 1.\r  nil.\r  self initialize.\r  ^super initialize: aCapacity',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.642075-04:00' ],		#prior : OmReference [ '1823' ],		#self : OmReference [ '1824' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'head:',			#protocol : #slicing,			#sourceCode : 'head: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: 1 to: aNumber) values: (self values copyFrom: 1 to: aNumber) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.644459-04:00' ],		#prior : OmReference [ '1824' ],		#self : OmReference [ '1825' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithAverage,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithAverage\r  "Replaces nils inplace with average"\r  | mean |\r  #metaObject count: 1.\r  nil.\r  mean := (self select: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNotNil ]) average.\r  self replaceNilsWith: mean',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.646704-04:00' ],		#prior : OmReference [ '1825' ],		#self : OmReference [ '1826' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self thirdQuartile - self firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.6487-04:00' ],		#prior : OmReference [ '1826' ],		#self : OmReference [ '1827' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: anObject\r  #metaObject count: 1.\r  nil.\r  ^self closeTo: anObject precision: self defaultPrecision',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.650519-04:00' ],		#prior : OmReference [ '1827' ],		#self : OmReference [ '1828' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sorted:',			#protocol : #sorting,			#sourceCode : 'sorted: aBlock\r  | associationBlock |\r  #metaObject count: 1.\r  nil.\r  associationBlock := [:a :b |  #metaObject count: 2.\r  nil.\r  aBlock value: a value value: b value ].\r  ^self sortedAssociations: associationBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.654364-04:00' ],		#prior : OmReference [ '1828' ],		#self : OmReference [ '1829' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'keys:',			#protocol : #accessing,			#sourceCode : 'keys: anArrayOfKeys\r  | keys |\r  #metaObject count: 1.\r  nil.\r  keys := anArrayOfKeys asArray deepCopy.\r  dictionary := self dictionaryClass newFromKeys: keys andValues: self values.\r  orderedKeys := keys',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.656415-04:00' ],		#prior : OmReference [ '1829' ],		#self : OmReference [ '1830' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'name:',			#protocol : #accessing,			#sourceCode : 'name: anObject\r  #metaObject count: 1.\r  nil.\r  name := anObject',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.658784-04:00' ],		#prior : OmReference [ '1830' ],		#self : OmReference [ '1831' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #replaceNilsWithMode,			#protocol : #replacing,			#sourceCode : 'replaceNilsWithMode\r  "Replaces nils inplace with mode"\r  | mode |\r  #metaObject count: 1.\r  nil.\r  mode := (self select: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNotNil ]) mode.\r  self replaceNilsWith: mode',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.661458-04:00' ],		#prior : OmReference [ '1831' ],		#self : OmReference [ '1832' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #uniqueValues,			#protocol : #accessing,			#sourceCode : 'uniqueValues\r  | v |\r  #metaObject count: 1.\r  nil.\r  v := self asSet asArray.\r  \r  "Sort if possible"^[ #metaObject count: 2.\r  nil.\r  v sort ] on: Error do: [ #metaObject count: 3.\r        nil.\r        v ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.664145-04:00' ],		#prior : OmReference [ '1832' ],		#self : OmReference [ '1833' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fourth,			#protocol : #accessing,			#sourceCode : 'fourth\r  "Answer the fourth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 4',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.666259-04:00' ],		#prior : OmReference [ '1833' ],		#self : OmReference [ '1834' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #makeNumerical,			#protocol : #categorical-numerical,			#sourceCode : 'makeNumerical\r  #metaObject count: 1.\r  nil.\r  forcedIsNumerical := true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.669723-04:00' ],		#prior : OmReference [ '1834' ],		#self : OmReference [ '1835' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withIndexDetect: aBlock ifNone: [ #metaObject count: 2.\r        nil.\r        NotFound signal ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.6727-04:00' ],		#prior : OmReference [ '1835' ],		#self : OmReference [ '1836' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #asDataFrame,			#protocol : #converting,			#sourceCode : 'asDataFrame\r  #metaObject count: 1.\r  nil.\r  ^DataFrame withColumns: {self values} rowNames: self keys columnNames: {self name}',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.674697-04:00' ],		#prior : OmReference [ '1836' ],		#self : OmReference [ '1837' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #<',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.67684-04:00' ],		#prior : OmReference [ '1837' ],		#self : OmReference [ '1838' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #valueFrequencies,			#protocol : #statistics,			#sourceCode : 'valueFrequencies\r  | count freq |\r  #metaObject count: 1.\r  nil.\r  count := self valueCounts.\r  freq := count / self size.\r  ^freq',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.679824-04:00' ],		#prior : OmReference [ '1838' ],		#self : OmReference [ '1839' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'with:collect:',			#protocol : #enumerating,			#sourceCode : 'with: aCollection collect: twoArgBlock\r  "Collect and return the result of evaluating twoArgBlock with corresponding elements from this series and aCollection."\r  | result |\r  #metaObject count: 1.\r  nil.\r  aCollection size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  result := self species new: self size.\r  result name: self name.\r  self keys withIndexDo: [:key :i |  #metaObject count: 3.\r        nil.\r        result at: key put: (twoArgBlock value: (self at: key) value: (aCollection at: i)) ].\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.682302-04:00' ],		#prior : OmReference [ '1839' ],		#self : OmReference [ '1840' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'log:',			#protocol : #'math functions',			#sourceCode : 'log: base\r  #metaObject count: 1.\r  nil.\r  ^self collect: [:each |  #metaObject count: 2.\r        nil.\r        each log: base ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.684565-04:00' ],		#prior : OmReference [ '1840' ],		#self : OmReference [ '1841' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortedDescending,			#protocol : #sorting,			#sourceCode : 'sortedDescending\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:a :b |  #metaObject count: 2.\r        nil.\r        a > b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.686557-04:00' ],		#prior : OmReference [ '1841' ],		#self : OmReference [ '1842' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #>=',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.68926-04:00' ],		#prior : OmReference [ '1842' ],		#self : OmReference [ '1843' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: aBlock\r  | selectedIndices |\r  #metaObject count: 1.\r  nil.\r  selectedIndices := (1 to: self size) select: [:i |  #metaObject count: 2.\r        nil.\r        aBlock value: (self atIndex: i) value: i ].\r  ^DataSeries withKeys: (selectedIndices collect: [:i |  #metaObject count: 3.\r              nil.\r              self keys at: i ]) values: (selectedIndices collect: [:i |  #metaObject count: 4.\r              nil.\r              self atIndex: i ]) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.690951-04:00' ],		#prior : OmReference [ '1843' ],		#self : OmReference [ '1844' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyDo:',			#protocol : #enumerating,			#sourceCode : 'withKeyDo: aBlock\r  #metaObject count: 1.\r  nil.\r  self keysDo: [:each |  #metaObject count: 2.\r        nil.\r        aBlock value: (self at: each) value: each ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.693596-04:00' ],		#prior : OmReference [ '1844' ],		#self : OmReference [ '1845' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #third,			#protocol : #accessing,			#sourceCode : 'third\r  "Answer the third element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 3',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.695762-04:00' ],		#prior : OmReference [ '1845' ],		#self : OmReference [ '1846' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= arg\r  "Element-wise comparision between two DataSeries.\r\t Does not consider keys for comparision."\r  #metaObject count: 1.\r  nil.\r  ^arg adaptToCollection: self andSend: #<=',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.698262-04:00' ],		#prior : OmReference [ '1846' ],		#self : OmReference [ '1847' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexDetect:ifNone:',			#protocol : #enumerating,			#sourceCode : 'withIndexDetect: aBlock ifNone: exceptionBlock\r  | selectedIndex |\r  #metaObject count: 1.\r  nil.\r  selectedIndex := (1 to: self size) detect: [:i |  #metaObject count: 2.\r        nil.\r        aBlock value: (self atIndex: i) value: i ] ifNone: [ #metaObject count: 3.\r        nil.\r        ^exceptionBlock value ].\r  ^self atIndex: selectedIndex',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.700303-04:00' ],		#prior : OmReference [ '1847' ],		#self : OmReference [ '1848' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #isSequenceable,			#protocol : #testing,			#sourceCode : 'isSequenceable\r  #metaObject count: 1.\r  nil.\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.704402-04:00' ],		#prior : OmReference [ '1848' ],		#self : OmReference [ '1849' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #removeNils,			#protocol : #removing,			#sourceCode : 'removeNils\r  #metaObject count: 1.\r  nil.\r  ^self reject: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.706944-04:00' ],		#prior : OmReference [ '1849' ],		#self : OmReference [ '1850' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #tail,			#protocol : #slicing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.709163-04:00' ],		#prior : OmReference [ '1850' ],		#self : OmReference [ '1851' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := self species newFrom: (self associations withIndexCollect: [:each :i |  #metaObject count: 2.\r              nil.\r              each key -> (aBlock value: each value value: i) ]).\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.710783-04:00' ],		#prior : OmReference [ '1851' ],		#self : OmReference [ '1852' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'sortAssociations:',			#protocol : #sorting,			#sourceCode : 'sortAssociations: aBlock\r  | sortedAssociations |\r  #metaObject count: 1.\r  nil.\r  sortedAssociations := self associations sort: aBlock.\r  self removeAll.\r  self addAll: sortedAssociations',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.712946-04:00' ],		#prior : OmReference [ '1852' ],		#self : OmReference [ '1853' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'reject:',			#protocol : #enumerating,			#sourceCode : 'reject: aBlock\r  | result |\r  #metaObject count: 1.\r  nil.\r  result := super reject: aBlock.\r  result name: self name.\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.715199-04:00' ],		#prior : OmReference [ '1853' ],		#self : OmReference [ '1854' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self at: (self keys at: aNumber)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.718508-04:00' ],		#prior : OmReference [ '1854' ],		#self : OmReference [ '1855' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #fifth,			#protocol : #accessing,			#sourceCode : 'fifth\r  "Answer the fifth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 5',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.721128-04:00' ],		#prior : OmReference [ '1855' ],		#self : OmReference [ '1856' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #mode,			#protocol : #accessing,			#sourceCode : 'mode\r  | valueCounts maxCount |\r  #metaObject count: 1.\r  nil.\r  valueCounts := self valueCounts.\r  maxCount := valueCounts max.\r  ^valueCounts keyAtValue: maxCount',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.723857-04:00' ],		#prior : OmReference [ '1856' ],		#self : OmReference [ '1857' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #summary,			#protocol : #statistics,			#sourceCode : 'summary\r  | summary |\r  #metaObject count: 1.\r  nil.\r  summary := self species new.\r  summary name: self name.\r  summary\r     at: \'Min\' put: self min;\r     at: \'1st Qu.\' put: self firstQuartile;\r     at: \'Median\' put: self median;\r     at: \'Average\' put: self average;\r     at: \'3rd Qu.\' put: self thirdQuartile;\r     at: \'Max\' put: self max.\r  ^summary',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.725751-04:00' ],		#prior : OmReference [ '1857' ],		#self : OmReference [ '1858' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'atIndex:transform:',			#protocol : #accessing,			#sourceCode : 'atIndex: aNumber transform: aBlock\r  "Evaluate aBlock on the value at aNumber and replace that value with the result"\r  | key |\r  #metaObject count: 1.\r  nil.\r  key := self keys at: aNumber.\r  self at: key transform: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.72808-04:00' ],		#prior : OmReference [ '1858' ],		#self : OmReference [ '1859' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #ninth,			#protocol : #accessing,			#sourceCode : 'ninth\r  "Answer the ninth element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 9',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.733983-04:00' ],		#prior : OmReference [ '1859' ],		#self : OmReference [ '1860' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #zerothQuartile,			#protocol : #statistics,			#sourceCode : 'zerothQuartile\r  #metaObject count: 1.\r  nil.\r  ^self quartile: 0',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.736675-04:00' ],		#prior : OmReference [ '1860' ],		#self : OmReference [ '1861' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sortDescending,			#protocol : #sorting,			#sourceCode : 'sortDescending\r  #metaObject count: 1.\r  nil.\r  self sort: [:a :b |  #metaObject count: 2.\r        nil.\r        a > b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.739585-04:00' ],		#prior : OmReference [ '1861' ],		#self : OmReference [ '1862' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #last,			#protocol : #accessing,			#sourceCode : 'last\r  "Answer the last element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: self size',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.742071-04:00' ],		#prior : OmReference [ '1862' ],		#self : OmReference [ '1863' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  name := self defaultName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.74501-04:00' ],		#prior : OmReference [ '1863' ],		#self : OmReference [ '1864' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'tail:',			#protocol : #slicing,			#sourceCode : 'tail: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self species withKeys: (self keys copyFrom: self size - aNumber + 1 to: self size) values: (self values copyFrom: self size - aNumber + 1 to: self size) name: self name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.747004-04:00' ],		#prior : OmReference [ '1864' ],		#self : OmReference [ '1865' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'removeAt:',			#protocol : #removing,			#sourceCode : 'removeAt: aKey\r  #metaObject count: 1.\r  nil.\r  ^self removeKey: aKey',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.749783-04:00' ],		#prior : OmReference [ '1865' ],		#self : OmReference [ '1866' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #sorted,			#protocol : #sorting,			#sourceCode : 'sorted\r  #metaObject count: 1.\r  nil.\r  ^self sorted: [:a :b |  #metaObject count: 2.\r        nil.\r        a <= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.752342-04:00' ],		#prior : OmReference [ '1866' ],		#self : OmReference [ '1867' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #seventh,			#protocol : #accessing,			#sourceCode : 'seventh\r  "Answer the seventh element of the receiver.\r\tRaise an error if there are not enough elements."\r  #metaObject count: 1.\r  nil.\r  ^self atIndex: 7',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.755865-04:00' ],		#prior : OmReference [ '1867' ],		#self : OmReference [ '1868' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withSeries:collect:',			#protocol : #enumerating,			#sourceCode : 'withSeries: otherDataSeries collect: twoArgBlock\r  "Collect and return the result of evaluating twoArgBlock with corresponding elements from this series and otherDataSeries."\r  | result |\r  #metaObject count: 1.\r  nil.\r  otherDataSeries size = self size ifFalse: [ #metaObject count: 2.\r        nil.\r        self errorSizeMismatch ].\r  otherDataSeries keys = self keys ifFalse: [ #metaObject count: 3.\r        nil.\r        self errorKeysMismatch ].\r  result := self species new: self size.\r  result name: self name.\r  self keysDo: [:key |  #metaObject count: 4.\r        nil.\r        result at: key put: (twoArgBlock value: (self at: key) value: (otherDataSeries at: key)) ].\r  ^result',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.758192-04:00' ],		#prior : OmReference [ '1868' ],		#self : OmReference [ '1869' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #name,			#protocol : #accessing,			#sourceCode : 'name\r  #metaObject count: 1.\r  nil.\r  ^name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.761575-04:00' ],		#prior : OmReference [ '1869' ],		#self : OmReference [ '1870' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataSeries			},			#name : #'withKeyReject:',			#protocol : #enumerating,			#sourceCode : 'withKeyReject: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self withKeySelect: [:each :key |  #metaObject count: 2.\r        nil.\r        (aBlock value: each value: key) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.763742-04:00' ],		#prior : OmReference [ '1870' ],		#self : OmReference [ '1871' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: keys values: values\r  #metaObject count: 1.\r  nil.\r  ^self newFromKeys: keys andValues: values',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.767627-04:00' ],		#prior : OmReference [ '1871' ],		#self : OmReference [ '1872' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withKeys:values:name:',			#protocol : #'instance creation',			#sourceCode : 'withKeys: keys values: values name: aName\r  #metaObject count: 1.\r  nil.\r  ^(self withKeys: keys values: values)\r     name: aName;\r     yourself',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.769933-04:00' ],		#prior : OmReference [ '1872' ],		#self : OmReference [ '1873' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:',			#protocol : #'instance creation',			#sourceCode : 'withValues: values\r  | keys |\r  #metaObject count: 1.\r  nil.\r  keys := (1 to: values size) asArray.\r  ^self withKeys: keys values: values',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.772394-04:00' ],		#prior : OmReference [ '1873' ],		#self : OmReference [ '1874' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'withValues:name:',			#protocol : #'instance creation',			#sourceCode : 'withValues: values name: aName\r  | keys |\r  #metaObject count: 1.\r  nil.\r  keys := (1 to: values size) asArray.\r  ^(self withKeys: keys values: values)\r     name: aName;\r     yourself',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.775718-04:00' ],		#prior : OmReference [ '1874' ],		#self : OmReference [ '1875' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataSeries class'			},			#name : #'newFrom:',			#protocol : #'instance creation',			#sourceCode : 'newFrom: aCollection\r  #metaObject count: 1.\r  nil.\r  aCollection ifEmpty: [ #metaObject count: 2.\r        nil.\r        ^self new ].\r  aCollection species == self ifTrue: [ #metaObject count: 3.\r        nil.\r        ^super newFrom: aCollection associations ].\r  \r  "If it\'s a collection of associations use the superclass implementation"^super newFrom: ((aCollection anyOne respondsTo: #key) ifTrue: [ #metaObject count: 4.\r              nil.\r              aCollection ] ifFalse: [ #metaObject count: 5.\r              nil.\r              aCollection withIndexCollect: [:each :i |  #metaObject count: 6.\r                    nil.\r                    i -> each ] ])',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.779069-04:00' ],		#prior : OmReference [ '1875' ],		#self : OmReference [ '1876' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: rowNumber\r  | newContents |\r  #metaObject count: 1.\r  nil.\r  newContents := Array2D rows: self numberOfRows - 1 columns: self numberOfColumns.\r  1 to: self numberOfColumns do: [:j |  #metaObject count: 2.\r        nil.\r        1 to: rowNumber - 1 do: [:i |  #metaObject count: 3.\r              nil.\r              newContents at: i at: j put: (contents at: i at: j) ].\r        rowNumber + 1 to: self numberOfRows do: [:i |  #metaObject count: 4.\r              nil.\r              newContents at: i - 1 at: j put: (contents at: i at: j) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.78082-04:00' ],		#prior : OmReference [ '1876' ],		#self : OmReference [ '1877' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:j |  #metaObject count: 2.\r        nil.\r        self at: aNumber at: j ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.783212-04:00' ],		#prior : OmReference [ '1877' ],		#self : OmReference [ '1878' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := Array2D new.\r  ^self',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.787661-04:00' ],		#prior : OmReference [ '1878' ],		#self : OmReference [ '1879' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber\r  "Executes aBlock for all elements in specified rowNumber and deletes the column\r\t which satisfied condition given in aBlock."\r  | newContents columnsToDrop k |\r  "columnsToDrop has 1 at i if i-th column needs to be dropped, else 0"\r  #metaObject count: 1.\r  nil.\r  columnsToDrop := (self rowAt: rowNumber) collect: [:ele |  #metaObject count: 2.\r        nil.\r        (aBlock value: ele) ifTrue: [ #metaObject count: 3.\r              nil.\r              true ] ifFalse: [ #metaObject count: 4.\r              nil.\r              false ] ].\r  newContents := Array2D rows: self numberOfRows columns: self numberOfColumns - (columnsToDrop select: [:ele |  #metaObject count: 5.\r                    nil.\r                    ele ]) size.\r  newContents numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  1 to: self numberOfRows do: [:i |  #metaObject count: 7.\r        nil.\r        k := 0.\r        1 to: self numberOfColumns do: [:j |  #metaObject count: 8.\r              nil.\r              (columnsToDrop at: j) ifTrue: [ #metaObject count: 9.\r                    nil.\r                    k := k + 1 ] ifFalse: [ #metaObject count: 10.\r                    nil.\r                    newContents at: i at: j - k put: (contents at: i at: j) ] ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.78984-04:00' ],		#prior : OmReference [ '1879' ],		#self : OmReference [ '1880' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber put: anArray\r  "Sets all the values of a given column equal to the values in array. It is assumed that array is of the same size as every column (number of rows). This should be tested in DataFrame"\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfRows) do: [:i |  #metaObject count: 2.\r        nil.\r        self at: i at: aNumber put: (anArray at: i) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.797395-04:00' ],		#prior : OmReference [ '1880' ],		#self : OmReference [ '1881' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray atPosition: aNumber\r  | rows cols newContents |\r  #metaObject count: 1.\r  nil.\r  rows := self numberOfRows.\r  cols := self numberOfColumns + 1.\r  anArray size = rows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  newContents := Array2D rows: rows columns: cols.\r  1 to: rows do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: aNumber - 1 do: [:j |  #metaObject count: 4.\r              nil.\r              newContents at: i at: j put: (self at: i at: j) ] ].\r  1 to: rows do: [:i |  #metaObject count: 5.\r        nil.\r        newContents at: i at: aNumber put: (anArray at: i) ].\r  1 to: rows do: [:i |  #metaObject count: 6.\r        nil.\r        aNumber + 1 to: cols do: [:j |  #metaObject count: 7.\r              nil.\r              newContents at: i at: j put: (self at: i at: j - 1) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.799658-04:00' ],		#prior : OmReference [ '1881' ],		#self : OmReference [ '1882' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents collect: aBlock)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.80283-04:00' ],		#prior : OmReference [ '1882' ],		#self : OmReference [ '1883' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndicesCollect: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: (contents withIndicesCollect: aBlock)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.805687-04:00' ],		#prior : OmReference [ '1883' ],		#self : OmReference [ '1884' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  "Converts DataFrameInternal to the array of columns"\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfColumns) collect: [:j |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfRows) collect: [:i |  #metaObject count: 3.\r              nil.\r              self at: i at: j ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.807844-04:00' ],		#prior : OmReference [ '1884' ],		#self : OmReference [ '1885' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r  #metaObject count: 1.\r  nil.\r  ^self class fromArray2D: contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.80991-04:00' ],		#prior : OmReference [ '1885' ],		#self : OmReference [ '1886' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex\r  #metaObject count: 1.\r  nil.\r  ^contents at: rowIndex at: columnIndex',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.812375-04:00' ],		#prior : OmReference [ '1886' ],		#self : OmReference [ '1887' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber put: anArray\r  "Sets all the values of a given row equal to the values in array. It is assumed that array is of the same size as every row (number of columns). This should be tested in DataFrame"\r  #metaObject count: 1.\r  nil.\r  (1 to: self numberOfColumns) do: [:j |  #metaObject count: 2.\r        nil.\r        self at: aNumber at: j put: (anArray at: j) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.814867-04:00' ],		#prior : OmReference [ '1887' ],		#self : OmReference [ '1888' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers\r  | dfInternal numberOfRows numberOfColumns |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfNumbers size.\r  numberOfColumns := self numberOfColumns.\r  dfInternal := DataFrameInternal new: numberOfRows @ numberOfColumns.\r  anArrayOfNumbers doWithIndex: [:i :k |  #metaObject count: 2.\r        nil.\r        1 to: numberOfColumns do: [:j |  #metaObject count: 3.\r              nil.\r              dfInternal at: k at: j put: (self at: i at: j) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.81665-04:00' ],		#prior : OmReference [ '1888' ],		#self : OmReference [ '1889' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: aBlock\r  #metaObject count: 1.\r  nil.\r  ^contents do: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.819452-04:00' ],		#prior : OmReference [ '1889' ],		#self : OmReference [ '1890' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'replaceMissingValuesStrings:',			#protocol : #filling,			#sourceCode : 'replaceMissingValuesStrings: aSet\r  "Replaces dataframeinternal values with nil if they are a part of aSet"\r  #metaObject count: 1.\r  nil.\r  1 to: self numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        1 to: self numberOfColumns do: [:j |  #metaObject count: 3.\r              nil.\r              (aSet includes: (contents at: i at: j)) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    contents at: i at: j put: nil ] ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.823904-04:00' ],		#prior : OmReference [ '1890' ],		#self : OmReference [ '1891' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber\r  "Removes all rows having a nil value at the column columnNumber"\r  | newContents rowsToDrop k |\r  "rowsToDrop has 1 at i if i-th row needs to be dropped, else 0"\r  #metaObject count: 1.\r  nil.\r  rowsToDrop := (self columnAt: columnNumber) collect: [:ele |  #metaObject count: 2.\r        nil.\r        (aBlock value: ele) ifTrue: [ #metaObject count: 3.\r              nil.\r              true ] ifFalse: [ #metaObject count: 4.\r              nil.\r              false ] ].\r  newContents := Array2D rows: self numberOfRows - (rowsToDrop select: [:ele |  #metaObject count: 5.\r                    nil.\r                    ele ]) size columns: self numberOfColumns.\r  newContents numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        contents := Array2D rows: 0 columns: 0.\r        ^self ].\r  1 to: self numberOfColumns do: [:j |  #metaObject count: 7.\r        nil.\r        k := 0.\r        1 to: self numberOfRows do: [:i |  #metaObject count: 8.\r              nil.\r              (rowsToDrop at: i) ifTrue: [ #metaObject count: 9.\r                    nil.\r                    k := k + 1 ] ifFalse: [ #metaObject count: 10.\r                    nil.\r                    newContents at: i - k at: j put: (contents at: i at: j) ] ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.825453-04:00' ],		#prior : OmReference [ '1891' ],		#self : OmReference [ '1892' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'withIndicesDo:',			#protocol : #enumerating,			#sourceCode : 'withIndicesDo: aBlock\r  #metaObject count: 1.\r  nil.\r  ^contents withIndicesDo: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.828323-04:00' ],		#prior : OmReference [ '1892' ],		#self : OmReference [ '1893' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: columnNumber\r  | newContents |\r  #metaObject count: 1.\r  nil.\r  newContents := Array2D rows: self numberOfRows columns: self numberOfColumns - 1.\r  1 to: self numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        1 to: columnNumber - 1 do: [:j |  #metaObject count: 3.\r              nil.\r              newContents at: i at: j put: (contents at: i at: j) ].\r        columnNumber + 1 to: self numberOfColumns do: [:j |  #metaObject count: 4.\r              nil.\r              newContents at: i at: j - 1 put: (contents at: i at: j) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.830754-04:00' ],		#prior : OmReference [ '1893' ],		#self : OmReference [ '1894' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers\r  | dfInternal numberOfRows numberOfColumns |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := self numberOfRows.\r  numberOfColumns := anArrayOfNumbers size.\r  dfInternal := DataFrameInternal new: numberOfRows @ numberOfColumns.\r  1 to: numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        anArrayOfNumbers doWithIndex: [:j :k |  #metaObject count: 3.\r              nil.\r              dfInternal at: i at: k put: (self at: i at: j) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.833085-04:00' ],		#prior : OmReference [ '1894' ],		#self : OmReference [ '1895' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  contents numberOfRows isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.835231-04:00' ],		#prior : OmReference [ '1895' ],		#self : OmReference [ '1896' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aPoint\r  #metaObject count: 1.\r  nil.\r  contents := Array2D rows: aPoint x columns: aPoint y.\r  ^self',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.83954-04:00' ],		#prior : OmReference [ '1896' ],		#self : OmReference [ '1897' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= other\r  #metaObject count: 1.\r  nil.\r  (other class == self class and: [ #metaObject count: 2.\r        nil.\r        other numberOfRows = self numberOfRows and: [ #metaObject count: 3.\r              nil.\r              other numberOfColumns = self numberOfColumns ] ]) ifFalse: [ #metaObject count: 4.\r        nil.\r        ^false ].\r  other withIndicesDo: [:each :i :j |  #metaObject count: 5.\r        nil.\r        (self at: i at: j) = each ifFalse: [ #metaObject count: 6.\r              nil.\r              ^false ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.841647-04:00' ],		#prior : OmReference [ '1897' ],		#self : OmReference [ '1898' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:i |  #metaObject count: 2.\r        nil.\r        self at: i at: aNumber ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.844212-04:00' ],		#prior : OmReference [ '1898' ],		#self : OmReference [ '1899' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  contents numberOfColumns isNil ifTrue: [ #metaObject count: 2.\r        nil.\r        ^0 ].\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.84593-04:00' ],		#prior : OmReference [ '1899' ],		#self : OmReference [ '1900' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r  #metaObject count: 1.\r  nil.\r  contents printOn: aStream',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.849146-04:00' ],		#prior : OmReference [ '1900' ],		#self : OmReference [ '1901' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  "Converts DataFrameInternal to the array of rows"\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:i |  #metaObject count: 2.\r        nil.\r        (1 to: self numberOfColumns) collect: [:j |  #metaObject count: 3.\r              nil.\r              self at: i at: j ] ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.853901-04:00' ],		#prior : OmReference [ '1901' ],		#self : OmReference [ '1902' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: anArray atPosition: aNumber\r  | rows cols newContents |\r  #metaObject count: 1.\r  nil.\r  rows := self numberOfRows + 1.\r  cols := self numberOfColumns.\r  anArray size = cols ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  newContents := Array2D rows: rows columns: cols.\r  1 to: aNumber - 1 do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: cols do: [:j |  #metaObject count: 4.\r              nil.\r              newContents at: i at: j put: (self at: i at: j) ] ].\r  1 to: cols do: [:j |  #metaObject count: 5.\r        nil.\r        newContents at: aNumber at: j put: (anArray at: j) ].\r  aNumber + 1 to: rows do: [:i |  #metaObject count: 6.\r        nil.\r        1 to: cols do: [:j |  #metaObject count: 7.\r              nil.\r              newContents at: i at: j put: (self at: i - 1 at: j) ] ].\r  contents := newContents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.858588-04:00' ],		#prior : OmReference [ '1902' ],		#self : OmReference [ '1903' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #asArray2D,			#protocol : #converting,			#sourceCode : 'asArray2D\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.861669-04:00' ],		#prior : OmReference [ '1903' ],		#self : OmReference [ '1904' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameInternal			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex put: value\r  #metaObject count: 1.\r  nil.\r  ^contents at: rowIndex at: columnIndex put: value',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.865748-04:00' ],		#prior : OmReference [ '1904' ],		#self : OmReference [ '1905' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays\r  | numberOfRows numberOfColumns dfInternal |\r  #metaObject count: 1.\r  nil.\r  numberOfColumns := anArrayOfArrays size.\r  numberOfRows := 0.\r  1 to: numberOfColumns do: [:index |  #metaObject count: 2.\r        nil.\r        numberOfRows := numberOfRows max: (anArrayOfArrays at: index) size ].\r  dfInternal := self new: numberOfRows @ numberOfColumns.\r  1 to: numberOfRows do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: numberOfColumns do: [:j |  #metaObject count: 4.\r              nil.\r              dfInternal at: i at: j put: ((anArrayOfArrays at: j) asArray at: i ifAbsent: nil) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.867984-04:00' ],		#prior : OmReference [ '1905' ],		#self : OmReference [ '1906' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aPoint\r  #metaObject count: 1.\r  nil.\r  ^self new initialize: aPoint',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.870213-04:00' ],		#prior : OmReference [ '1906' ],		#self : OmReference [ '1907' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'fromArray2D:',			#protocol : #'instance creation',			#sourceCode : 'fromArray2D: anArray2D\r  | dfInternal |\r  "We can\'t use Array2D>>extent, because it gives us col@row instead of row@col"\r  #metaObject count: 1.\r  nil.\r  dfInternal := self new: anArray2D rowCount @ anArray2D columnCount.\r  anArray2D withIndicesDo: [:each :i :j |  #metaObject count: 2.\r        nil.\r        dfInternal at: i at: j put: each ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.873155-04:00' ],		#prior : OmReference [ '1907' ],		#self : OmReference [ '1908' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrameInternal class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays\r  | numberOfRows numberOfColumns dfInternal |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfArrays size.\r  numberOfColumns := 0.\r  1 to: numberOfRows do: [:index |  #metaObject count: 2.\r        nil.\r        numberOfColumns := numberOfColumns max: (anArrayOfArrays at: index) size ].\r  dfInternal := self new: numberOfRows @ numberOfColumns.\r  1 to: numberOfRows do: [:i |  #metaObject count: 3.\r        nil.\r        1 to: numberOfColumns do: [:j |  #metaObject count: 4.\r              nil.\r              dfInternal at: i at: j put: ((anArrayOfArrays at: i) asArray at: j ifAbsent: nil) ] ].\r  ^dfInternal',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.87662-04:00' ],		#prior : OmReference [ '1908' ],		#self : OmReference [ '1909' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #'cellColumn:row:',			#protocol : #accessing,			#sourceCode : 'cellColumn: column row: rowNumber\r  | columnNumber |\r  #metaObject count: 1.\r  nil.\r  column id = \'#\' ifTrue: [ #metaObject count: 2.\r        nil.\r        ^FTCellMorph new addMorph: (elements rowNames at: rowNumber) asMorph ].\r  columnNumber := elements columnNames indexOf: column id.\r  ^FTCellMorph new addMorph: (elements at: rowNumber at: columnNumber) asMorph',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.879026-04:00' ],		#prior : OmReference [ '1909' ],		#self : OmReference [ '1910' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrameFTData			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^elements numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.883417-04:00' ],		#prior : OmReference [ '1910' ],		#self : OmReference [ '1911' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'do:',			#protocol : #enumerating,			#sourceCode : 'do: aBlock\r  "We enumerate through the data enrties - through rows of a data frame"\r  | row |\r  #metaObject count: 1.\r  nil.\r  1 to: self numberOfRows do: [:i |  #metaObject count: 2.\r        nil.\r        row := self rowAt: i.\r        aBlock value: row.\r        \r        "A hack to allow modification of rows inside do block"self rowAt: i put: row asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.885606-04:00' ],		#prior : OmReference [ '1911' ],		#self : OmReference [ '1912' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame on: aColumnName\r  "Outer join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self outerJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.887989-04:00' ],		#prior : OmReference [ '1912' ],		#self : OmReference [ '1913' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'inject:into:',			#protocol : #enumerating,			#sourceCode : 'inject: thisValue into: binaryBlock\r  | series |\r  #metaObject count: 1.\r  nil.\r  series := super inject: thisValue into: binaryBlock.\r  series name: series defaultName.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.89021-04:00' ],		#prior : OmReference [ '1913' ],		#self : OmReference [ '1914' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfColumns,			#protocol : #accessing,			#sourceCode : 'numberOfColumns\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.892388-04:00' ],		#prior : OmReference [ '1914' ],		#self : OmReference [ '1915' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnAt: columnNumber applyElementwise: aBlock\r  | columnName |\r  #metaObject count: 1.\r  nil.\r  columnName := self columnNames at: columnNumber.\r  ^self toColumn: columnName applyElementwise: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.894836-04:00' ],		#prior : OmReference [ '1915' ],		#self : OmReference [ '1916' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:put:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfNumbers size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfNumbers with: anArrayOfArrays do: [:index :array |  #metaObject count: 3.\r        nil.\r        self columnAt: index put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.897158-04:00' ],		#prior : OmReference [ '1916' ],		#self : OmReference [ '1917' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumn:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumn: columnName applyElementwise: aBlock\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := (self column: columnName) asArray.\r  column := column collect: [:each |  #metaObject count: 2.\r        nil.\r        aBlock value: each ].\r  self column: columnName put: column asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.899498-04:00' ],		#prior : OmReference [ '1917' ],		#self : OmReference [ '1918' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame on: aColumnName\r  "Right join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self rightJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.901445-04:00' ],		#prior : OmReference [ '1918' ],		#self : OmReference [ '1919' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsAt:',			#protocol : #removing,			#sourceCode : 'removeColumnsAt: aCollectionOfColumnIndices\r  | columnNamesToRemove |\r  #metaObject count: 1.\r  nil.\r  columnNamesToRemove := aCollectionOfColumnIndices collect: [:i |  #metaObject count: 2.\r        nil.\r        columnNames at: i ].\r  self removeColumns: columnNamesToRemove',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.903894-04:00' ],		#prior : OmReference [ '1919' ],		#self : OmReference [ '1920' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexDo:',			#protocol : #enumerating,			#sourceCode : 'withIndexDo: elementAndIndexBlock\r  #metaObject count: 1.\r  nil.\r  1 to: self size do: [:i |  | row |\r        #metaObject count: 2.\r        nil.\r        row := self rowAt: i.\r        elementAndIndexBlock value: row value: i.\r        \r        "A hack to allow modification of rows inside do block"self rowAt: i put: row asArray ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.907389-04:00' ],		#prior : OmReference [ '1920' ],		#self : OmReference [ '1921' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'select:',			#protocol : #enumerating,			#sourceCode : 'select: aBlock\r  "Evaluate aBlock with each of the receiver\'s elements as the argument. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to true. Answer the new collection."\r  | rows selectedRows selectedRowNames selectedColumnNames selectedRowsAsArrays df |\r  #metaObject count: 1.\r  nil.\r  rows := self asArrayOfRows.\r  selectedRows := rows select: aBlock.\r  selectedRowNames := selectedRows isEmpty ifTrue: [ #metaObject count: 2.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 3.\r        nil.\r        selectedRows collect: #name ].\r  selectedColumnNames := selectedRows isEmpty ifTrue: [ #metaObject count: 4.\r        nil.\r        #() ] ifFalse: [ #metaObject count: 5.\r        nil.\r        self columnNames ].\r  selectedRowsAsArrays := selectedRows collect: #asArray.\r  df := self class withRows: selectedRowsAsArrays rowNames: selectedRowNames columnNames: selectedColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.90973-04:00' ],		#prior : OmReference [ '1921' ],		#self : OmReference [ '1922' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName ifAbsent: exceptionBlock\r  "Answer the column with columnName as a DataSeries or evaluate exception block if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self columnAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.912508-04:00' ],		#prior : OmReference [ '1922' ],		#self : OmReference [ '1923' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame\r  "Performs left join on aDataFrame with rowNames as keys"\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := self rowNames intersection: aDataFrame rowNames.\r  self rowNames do: [:rowName |  | rowToAdd |\r        #metaObject count: 2.\r        nil.\r        rowToAdd := (commonRows includes: rowName) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: rowName) asArray , (aDataFrame row: rowName) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: rowName) asArray , (Array new: aDataFrame columnNames size) ].\r        outputDf addRow: rowToAdd named: rowName ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.91468-04:00' ],		#prior : OmReference [ '1923' ],		#self : OmReference [ '1924' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:transform:',			#protocol : #accessing,			#sourceCode : 'at: aNumber transform: aBlock\r  "Evaluate aBlock on the row at aNumber and replace that row with the result"\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: aNumber transform: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.916938-04:00' ],		#prior : OmReference [ '1924' ],		#self : OmReference [ '1925' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #head,			#protocol : #accessing,			#sourceCode : 'head\r  #metaObject count: 1.\r  nil.\r  ^self head: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.921086-04:00' ],		#prior : OmReference [ '1925' ],		#self : OmReference [ '1926' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: aString atPosition: aNumber\r  "Add an empty column at the given position"\r  #metaObject count: 1.\r  nil.\r  self addColumn: (Array new: self numberOfRows) named: aString atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.924089-04:00' ],		#prior : OmReference [ '1926' ],		#self : OmReference [ '1927' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:using:',			#protocol : #sorting,			#sourceCode : 'sortBy: columnName using: aBlock\r  | column sortedKeys newContents |\r  #metaObject count: 1.\r  nil.\r  column := self column: columnName.\r  column := column copy.\r  column sort: aBlock.\r  sortedKeys := column keys.\r  newContents := DataFrameInternal new: self dimensions.\r  sortedKeys withIndexDo: [:key :i |  #metaObject count: 2.\r        nil.\r        newContents rowAt: i put: (self row: key) asArray ].\r  contents := newContents.\r  self rowNames: sortedKeys',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.927707-04:00' ],		#prior : OmReference [ '1927' ],		#self : OmReference [ '1928' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #average,			#protocol : #statistics,			#sourceCode : 'average\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #average',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.930276-04:00' ],		#prior : OmReference [ '1928' ],		#self : OmReference [ '1929' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray named: aString\r  "Add a new column at the end"\r  #metaObject count: 1.\r  nil.\r  self addColumn: anArray named: aString atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.933589-04:00' ],		#prior : OmReference [ '1929' ],		#self : OmReference [ '1930' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName transform: aBlock ifAbsent: exceptionBlock\r  "Evaluate aBlock on the column with columnName and replace column with the result. Evaluate exceptionBlock if columnName was not found"\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := self column: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  self column: columnName put: (aBlock value: column)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.939028-04:00' ],		#prior : OmReference [ '1930' ],		#self : OmReference [ '1931' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs inner join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputRows outputDf |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  \r  "Skip join if any of the dataframe is zero"self size isZero | aDataFrame size isZero ifFalse: [ #metaObject count: 2.\r        nil.\r        outputRows := OrderedCollection new.\r        (self column: leftColumn) withIndexDo: [:ele :index |  #metaObject count: 3.\r              nil.\r              ((aDataFrame column: rightColumn) includes: ele) ifTrue: [ #metaObject count: 4.\r                    nil.\r                    outputRows add: index ] ].\r        outputRows do: [:rowIndex |  | rowsWithSameKey rowToAdd |\r              #metaObject count: 5.\r              nil.\r              rowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r              rowsWithSameKey do: [:rightRow |  #metaObject count: 6.\r                    nil.\r                    rowToAdd := (self rowAt: rowIndex) asArray , (aDataFrame rowAt: rightRow) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 7.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.941282-04:00' ],		#prior : OmReference [ '1931' ],		#self : OmReference [ '1932' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:',			#protocol : #accessing,			#sourceCode : 'row: rowName transform: aBlock\r  "Evaluate aBlock on the row with rowName and replace row with the result. Signal an exception if rowName was not found"\r  | row |\r  #metaObject count: 1.\r  nil.\r  row := self row: rowName.\r  self row: rowName put: (aBlock value: row) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.943371-04:00' ],		#prior : OmReference [ '1932' ],		#self : OmReference [ '1933' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumns:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumns: arrayOfColumnNames applyElementwise: aBlock\r  #metaObject count: 1.\r  nil.\r  arrayOfColumnNames do: [:each |  #metaObject count: 2.\r        nil.\r        self toColumn: each applyElementwise: aBlock ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.94546-04:00' ],		#prior : OmReference [ '1933' ],		#self : OmReference [ '1934' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #thirdQuartile,			#protocol : #statistics,			#sourceCode : 'thirdQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #thirdQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.946913-04:00' ],		#prior : OmReference [ '1934' ],		#self : OmReference [ '1935' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyElementwise:',			#protocol : #applying,			#sourceCode : 'applyElementwise: aBlock\r  "Applies a given block to all columns of a data frame"\r  #metaObject count: 1.\r  nil.\r  self toColumns: self columnNames applyElementwise: aBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.949311-04:00' ],		#prior : OmReference [ '1935' ],		#self : OmReference [ '1936' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfRows,			#protocol : #converting,			#sourceCode : 'asArrayOfRows\r  "Converts DataFrame to the array of rows"\r  #metaObject count: 1.\r  nil.\r  ^(1 to: self numberOfRows) collect: [:i |  #metaObject count: 2.\r        nil.\r        self at: i ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.951192-04:00' ],		#prior : OmReference [ '1936' ],		#self : OmReference [ '1937' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:atPosition:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: aString atPosition: aNumber\r  "Add an empty row at the given position"\r  #metaObject count: 1.\r  nil.\r  self addRow: (Array new: self numberOfColumns) named: aString atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.953529-04:00' ],		#prior : OmReference [ '1937' ],		#self : OmReference [ '1938' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #transposed,			#protocol : #geometry,			#sourceCode : 'transposed\r  "Returs a transposed DataFrame. Columns become rows and rows become columns."\r  | transposedDf |\r  #metaObject count: 1.\r  nil.\r  transposedDf := DataFrame withRows: self asArrayOfColumns.\r  transposedDf rowNames: self columnNames.\r  transposedDf columnNames: self rowNames.\r  ^transposedDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.955039-04:00' ],		#prior : OmReference [ '1938' ],		#self : OmReference [ '1939' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorItemsIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorItemsIn: composite\r  "Hide Items from inspector"\r  #metaObject count: 1.\r  nil.\r  composite fastTable when: [ #metaObject count: 2.\r        nil.\r        false ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.957424-04:00' ],		#prior : OmReference [ '1939' ],		#self : OmReference [ '1940' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber put: value\r  #metaObject count: 1.\r  nil.\r  contents at: rowNumber at: columnNumber put: value',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.960917-04:00' ],		#prior : OmReference [ '1940' ],		#self : OmReference [ '1941' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber\r  | columnNamesCopy |\r  #metaObject count: 1.\r  nil.\r  (rowNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        rowNumber > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: rowNumber ].\r  columnNamesCopy := columnNames deepCopy.\r  columnNames removeAll.\r  columnNamesCopy withIndexDo: [:columnName :j |  #metaObject count: 4.\r        nil.\r        (aBlock value: (contents at: rowNumber at: j)) ifFalse: [ #metaObject count: 5.\r              nil.\r              columnNames add: columnName ] ].\r  contents removeColumnsOfRowElementsSatisfing: aBlock onRow: rowNumber.\r  self numberOfColumns = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        rowNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.963043-04:00' ],		#prior : OmReference [ '1941' ],		#self : OmReference [ '1942' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #columnNames,			#protocol : #accessing,			#sourceCode : 'columnNames\r  #metaObject count: 1.\r  nil.\r  ^columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.964967-04:00' ],		#prior : OmReference [ '1942' ],		#self : OmReference [ '1943' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'toColumnsAt:applyElementwise:',			#protocol : #applying,			#sourceCode : 'toColumnsAt: arrayOfColumnNumbers applyElementwise: aBlock\r  #metaObject count: 1.\r  nil.\r  arrayOfColumnNumbers do: [:each |  #metaObject count: 2.\r        nil.\r        self toColumnAt: each applyElementwise: aBlock ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.972456-04:00' ],		#prior : OmReference [ '1943' ],		#self : OmReference [ '1944' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs outer join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputDf commonRows leftNils |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r  1 to: self size do: [:rowIndex |  | rowsWithSameKey rowToAdd |\r        #metaObject count: 2.\r        nil.\r        (commonRows includes: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn))) ifTrue: [ #metaObject count: 3.\r              nil.\r              rowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r              rowsWithSameKey do: [:rightRow |  #metaObject count: 4.\r                    nil.\r                    rowToAdd := (self rowAt: rowIndex) asArray , (aDataFrame rowAt: rightRow) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              rowToAdd := (self rowAt: rowIndex) asArray , (Array new: aDataFrame columnNames size).\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  1 to: aDataFrame size do: [:rowIndex |  | rowToAdd |\r        #metaObject count: 6.\r        nil.\r        (commonRows includes: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn))) ifFalse: [ #metaObject count: 7.\r              nil.\r              leftNils := self columnNames collect: [:col |  #metaObject count: 8.\r                    nil.\r                    col = rightColumn ifTrue: [ #metaObject count: 9.\r                          nil.\r                          (aDataFrame rowAt: rowIndex) at: rightColumn ] ifFalse: [ #metaObject count: 10.\r                          nil.\r                          nil ] ].\r              rowToAdd := leftNils , (aDataFrame rowAt: rowIndex) asArray.\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 11.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.975333-04:00' ],		#prior : OmReference [ '1944' ],		#self : OmReference [ '1945' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: anArray named: aString atPosition: aNumber\r  "Add a new column at the given position"\r  #metaObject count: 1.\r  nil.\r  (self columnNames includes: aString) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A column with that name already exists\' ].\r  contents addColumn: anArray asArray atPosition: aNumber.\r  columnNames add: aString afterIndex: aNumber - 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.97675-04:00' ],		#prior : OmReference [ '1945' ],		#self : OmReference [ '1946' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyRowNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyRowNamed: aString\r  "Add an empty row at the end"\r  #metaObject count: 1.\r  nil.\r  self addEmptyRowNamed: aString atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.978568-04:00' ],		#prior : OmReference [ '1946' ],		#self : OmReference [ '1947' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #defaultHeadTailSize,			#protocol : #accessing,			#sourceCode : 'defaultHeadTailSize\r  #metaObject count: 1.\r  nil.\r  ^5',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.980712-04:00' ],		#prior : OmReference [ '1947' ],		#self : OmReference [ '1948' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'collect:',			#protocol : #enumerating,			#sourceCode : 'collect: aBlock\r  "Overrides the Collection>>collect to create DataFrame with the same number of columns as values in the first row"\r  | firstRow newDataFrame |\r  #metaObject count: 1.\r  nil.\r  firstRow := aBlock value: (self rowAt: 1) copy.\r  newDataFrame := self class new: 0 @ firstRow size.\r  newDataFrame columnNames: firstRow keys.\r  self do: [:each |  #metaObject count: 2.\r        nil.\r        newDataFrame add: (aBlock value: each copy) ].\r  ^newDataFrame',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.983318-04:00' ],		#prior : OmReference [ '1948' ],		#self : OmReference [ '1949' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName put: anArray ifAbsent: exceptionBlock\r  "Replace the current values of row with rowName with anArray or evaluate exception block if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self rowAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.986736-04:00' ],		#prior : OmReference [ '1949' ],		#self : OmReference [ '1950' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:',			#protocol : #accessing,			#sourceCode : 'column: columnName\r  "Answer the column with columnName as a DataSeries or signal an exception if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  ^self columnAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.988355-04:00' ],		#prior : OmReference [ '1950' ],		#self : OmReference [ '1951' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeRows:',			#protocol : #initialization,			#sourceCode : 'initializeRows: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withRows: anArrayOfArrays.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.990067-04:00' ],		#prior : OmReference [ '1951' ],		#self : OmReference [ '1952' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: aNumber\r  #metaObject count: 1.\r  nil.\r  ^self rowAt: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.993223-04:00' ],		#prior : OmReference [ '1952' ],		#self : OmReference [ '1953' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'outerJoin:',			#protocol : #splitjoin,			#sourceCode : 'outerJoin: aDataFrame\r  "Performs outer join on aDataFrame with rowNames as keys"\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := self rowNames intersection: aDataFrame rowNames.\r  self rowNames do: [:rowName |  | rowToAdd |\r        #metaObject count: 2.\r        nil.\r        rowToAdd := (commonRows includes: rowName) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: rowName) asArray , (aDataFrame row: rowName) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (self row: rowName) asArray , (Array new: aDataFrame columnNames size) ].\r        outputDf addRow: rowToAdd named: rowName ].\r  aDataFrame rowNames do: [:rowName |  #metaObject count: 5.\r        nil.\r        (commonRows includes: rowName) ifFalse: [ #metaObject count: 6.\r              nil.\r              outputDf addRow: (Array new: self columnNames size) , (aDataFrame row: rowName) asArray named: rowName ] ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.995321-04:00' ],		#prior : OmReference [ '1953' ],		#self : OmReference [ '1954' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: begin to: end\r  | array |\r  #metaObject count: 1.\r  nil.\r  array := begin < end ifTrue: [ #metaObject count: 2.\r        nil.\r        (begin to: end) asArray ] ifFalse: [ #metaObject count: 3.\r        nil.\r        (end to: begin) asArray reverse ].\r  ^self columnsAt: array',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.997868-04:00' ],		#prior : OmReference [ '1954' ],		#self : OmReference [ '1955' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber\r  | series |\r  #metaObject count: 1.\r  nil.\r  series := (contents columnAt: aNumber) asDataSeries.\r  series name: (self columnNames at: aNumber).\r  series keys: self rowNames.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:21.999767-04:00' ],		#prior : OmReference [ '1955' ],		#self : OmReference [ '1956' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:atPosition:',			#protocol : #adding,			#sourceCode : 'addColumn: aDataSeries atPosition: aNumber\r  "Add DataSeries as a new column at the given position"\r  #metaObject count: 1.\r  nil.\r  self addColumn: aDataSeries asArray named: aDataSeries name atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.00163-04:00' ],		#prior : OmReference [ '1956' ],		#self : OmReference [ '1957' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:',			#protocol : #accessing,			#sourceCode : 'column: columnName put: anArray\r  "Replace the current values of column with columnName with anArray or signal an exception if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  ^self columnAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.003974-04:00' ],		#prior : OmReference [ '1957' ],		#self : OmReference [ '1958' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumn:',			#protocol : #removing,			#sourceCode : 'removeColumn: columnName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  self removeColumnAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.005951-04:00' ],		#prior : OmReference [ '1958' ],		#self : OmReference [ '1959' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameColumn:to:',			#protocol : #renaming,			#sourceCode : 'renameColumn: oldName to: newName\r  "Find a column with oldName and rename it to newName"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: oldName.\r  self columnNames at: index put: newName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.008511-04:00' ],		#prior : OmReference [ '1959' ],		#self : OmReference [ '1960' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #max,			#protocol : #statistics,			#sourceCode : 'max\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #max',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.012223-04:00' ],		#prior : OmReference [ '1960' ],		#self : OmReference [ '1961' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName ifAbsent: exceptionBlock\r  "Answer the row with rowName as a DataSeries or evaluate exception block if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self rowAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.013856-04:00' ],		#prior : OmReference [ '1961' ],		#self : OmReference [ '1962' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRows:',			#protocol : #removing,			#sourceCode : 'removeRows: aCollectionOfRowNames\r  #metaObject count: 1.\r  nil.\r  aCollectionOfRowNames do: [:each |  #metaObject count: 2.\r        nil.\r        self removeRow: each ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.016202-04:00' ],		#prior : OmReference [ '1962' ],		#self : OmReference [ '1963' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'gtInspectorFastTableIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'gtInspectorFastTableIn: composite\r  < gtInspectorPresentationOrder: 0>\r  < gtInspectorTag: #basic>\r  #metaObject count: 1.\r  nil.\r  composite morph\r     title: \'Fast Table\';\r     display: [ #metaObject count: 2.\r        nil.\r        self showWithGlamourIn: composite ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.018174-04:00' ],		#prior : OmReference [ '1963' ],		#self : OmReference [ '1964' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsOfRowElementsSatisfing:onRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsOfRowElementsSatisfing: aBlock onRowNamed: rowName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  self removeColumnsOfRowElementsSatisfing: aBlock onRow: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.020989-04:00' ],		#prior : OmReference [ '1964' ],		#self : OmReference [ '1965' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: anArray named: aString atPosition: aNumber\r  "Add a new row at the given position"\r  #metaObject count: 1.\r  nil.\r  (self rowNames includes: aString) ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'A row with that name already exists\' ].\r  contents addRow: anArray atPosition: aNumber.\r  rowNames add: aString afterIndex: aNumber - 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.023509-04:00' ],		#prior : OmReference [ '1965' ],		#self : OmReference [ '1966' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= aDataFrame\r  "Most objects will fail here"\r  #metaObject count: 1.\r  nil.\r  aDataFrame species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  \r  "This is the fastest way for two data frames with different dimensions"aDataFrame dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  \r  "If the names are different we don\'t need to iterate through values"(aDataFrame rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        aDataFrame columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  ^aDataFrame contents = self contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.025875-04:00' ],		#prior : OmReference [ '1966' ],		#self : OmReference [ '1967' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:',			#protocol : #grouping,			#sourceCode : 'group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock\r  #metaObject count: 1.\r  nil.\r  ^self group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock as: anAggregateColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.028248-04:00' ],		#prior : OmReference [ '1967' ],		#self : OmReference [ '1968' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #contents,			#protocol : #accessing,			#sourceCode : 'contents\r  #metaObject count: 1.\r  nil.\r  ^contents',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.029975-04:00' ],		#prior : OmReference [ '1968' ],		#self : OmReference [ '1969' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexReject:',			#protocol : #enumerating,			#sourceCode : 'withIndexReject: elementAndIndexBlock\r  "Evaluate aBlock with each of the receiver\'s elements and index as the arguments. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to false. Answer the new collection."\r  #metaObject count: 1.\r  nil.\r  ^self withIndexSelect: [:row :index |  #metaObject count: 2.\r        nil.\r        (elementAndIndexBlock value: row value: index) not ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.032398-04:00' ],		#prior : OmReference [ '1969' ],		#self : OmReference [ '1970' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:transform:',			#protocol : #accessing,			#sourceCode : 'at: rowIndex at: columnIndex transform: aBlock\r  "Evaluate aBlock on the value at the intersection of rowIndex and columnIndex and replace that value with the result"\r  | value |\r  #metaObject count: 1.\r  nil.\r  value := self at: rowIndex at: columnIndex.\r  self at: rowIndex at: columnIndex put: (aBlock value: value)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.034282-04:00' ],		#prior : OmReference [ '1970' ],		#self : OmReference [ '1971' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #firstQuartile,			#protocol : #statistics,			#sourceCode : 'firstQuartile\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #firstQuartile',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.03634-04:00' ],		#prior : OmReference [ '1971' ],		#self : OmReference [ '1972' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: columnName\r  "Answer the index of a column with a given name or signal an exception if the column with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self indexOfColumnNamed: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Column \' , columnName , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.038399-04:00' ],		#prior : OmReference [ '1972' ],		#self : OmReference [ '1973' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:transform:',			#protocol : #accessing,			#sourceCode : 'column: columnName transform: aBlock\r  "Evaluate aBlock on the column with columnName and replace column with the result. Signal an exception if columnName was not found"\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := self column: columnName.\r  self column: columnName put: (aBlock value: column) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.041753-04:00' ],		#prior : OmReference [ '1973' ],		#self : OmReference [ '1974' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : ': arg2;\r     columnNames: arg3',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'group:by:aggregateUsing:as:',			#protocol : #grouping,			#sourceCode : 'group: anAggregateColumnName by: aGroupColumnName aggregateUsing: aBlock as: aNewColumnName\r  | groupColumn aggregateColumn |\r  #metaObject count: 1.\r  nil.\r  aGroupColumnName = anAggregateColumnName ifTrue: [ #metaObject count: 2.\r        nil.\r        Error signal: \'Can not group a column by itself\' ].\r  groupColumn := self column: aGroupColumnName.\r  aggregateColumn := self column: anAggregateColumnName.\r  ^aggregateColumn groupBy: groupColumn aggregateUsing: aBlock as: aNewColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.043689-04:00' ],		#prior : OmReference [ '1974' ],		#self : OmReference [ '1975' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #median,			#protocol : #statistics,			#sourceCode : 'median\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #median',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.045211-04:00' ],		#prior : OmReference [ '1975' ],		#self : OmReference [ '1976' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumn: columnNumber\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onColumn: columnNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.048905-04:00' ],		#prior : OmReference [ '1976' ],		#self : OmReference [ '1977' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: aPoint\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new: aPoint.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.050474-04:00' ],		#prior : OmReference [ '1977' ],		#self : OmReference [ '1978' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addEmptyColumnNamed:',			#protocol : #adding,			#sourceCode : 'addEmptyColumnNamed: aString\r  "Add an empty column at the end"\r  #metaObject count: 1.\r  nil.\r  self addEmptyColumnNamed: aString atPosition: self numberOfColumns + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.052491-04:00' ],		#prior : OmReference [ '1978' ],		#self : OmReference [ '1979' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAll:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAll: anObject atColumn: columnName\r  "Returns rowNames of rows having anObject at columnName"\r  #metaObject count: 1.\r  nil.\r  ^self rowNames select: [:row |  #metaObject count: 2.\r        nil.\r        ((self column: columnName) at: row) = anObject ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.055603-04:00' ],		#prior : OmReference [ '1979' ],		#self : OmReference [ '1980' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'head:',			#protocol : #accessing,			#sourceCode : 'head: aNumber\r  | n |\r  #metaObject count: 1.\r  nil.\r  self numberOfRows > aNumber ifTrue: [ #metaObject count: 2.\r        nil.\r        n := aNumber ] ifFalse: [ #metaObject count: 3.\r        nil.\r        n := self numberOfRows ].\r  ^self rowsAt: (1 to: n)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.061314-04:00' ],		#prior : OmReference [ '1980' ],		#self : OmReference [ '1981' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs right join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputDf commonRows leftNils |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r  1 to: aDataFrame size do: [:rowIndex |  | rowToAdd rowsWithSameKey |\r        #metaObject count: 2.\r        nil.\r        (commonRows includes: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn))) ifTrue: [ #metaObject count: 3.\r              nil.\r              rowsWithSameKey := self findAllIndicesOf: (aDataFrame at: rowIndex at: (aDataFrame indexOfColumnNamed: rightColumn)) atColumn: leftColumn.\r              rowsWithSameKey do: [:leftRow |  #metaObject count: 4.\r                    nil.\r                    rowToAdd := (self rowAt: leftRow) asArray , (aDataFrame rowAt: rowIndex) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              leftNils := self columnNames collect: [:col |  #metaObject count: 6.\r                    nil.\r                    col = rightColumn ifTrue: [ #metaObject count: 7.\r                          nil.\r                          (aDataFrame rowAt: rowIndex) at: rightColumn ] ifFalse: [ #metaObject count: 8.\r                          nil.\r                          nil ] ].\r              rowToAdd := leftNils , (aDataFrame rowAt: rowIndex) asArray.\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 9.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.064131-04:00' ],		#prior : OmReference [ '1981' ],		#self : OmReference [ '1982' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: begin to: end\r  #metaObject count: 1.\r  nil.\r  ^self rowsAt: (begin to: end)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.066148-04:00' ],		#prior : OmReference [ '1982' ],		#self : OmReference [ '1983' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: rowName\r  "Answer the index of a row with a given name or signal an exception if the row with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self indexOfRowNamed: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        LibrarySymbolNotFoundError signal: \'Row \' , rowName , \' was not found\' ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.06808-04:00' ],		#prior : OmReference [ '1983' ],		#self : OmReference [ '1984' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber\r  | series |\r  #metaObject count: 1.\r  nil.\r  series := (contents rowAt: aNumber) asDataSeries.\r  series name: (self rowNames at: aNumber).\r  series keys: self columnNames.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.070981-04:00' ],		#prior : OmReference [ '1984' ],		#self : OmReference [ '1985' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'column:put:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'column: columnName put: anArray ifAbsent: exceptionBlock\r  "Replace the current values of column with columnName with anArray or evaluate exception block if a column with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  ^self columnAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.073405-04:00' ],		#prior : OmReference [ '1985' ],		#self : OmReference [ '1986' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame\r  "Performs inner join on aDataFrame with rowNames as keys"\r  | outputRows outputDf |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  \r  "Using select instead of intersection to preserve order"outputRows := self rowNames select: [:row |  #metaObject count: 2.\r        nil.\r        aDataFrame rowNames includes: row ].\r  outputRows do: [:rowName |  | rowToAdd |\r        #metaObject count: 3.\r        nil.\r        rowToAdd := (self row: rowName) asArray , (aDataFrame row: rowName) asArray.\r        outputDf addRow: rowToAdd named: rowName ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.07558-04:00' ],		#prior : OmReference [ '1986' ],		#self : OmReference [ '1987' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #interquartileRange,			#protocol : #statistics,			#sourceCode : 'interquartileRange\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #interquartileRange',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.077545-04:00' ],		#prior : OmReference [ '1987' ],		#self : OmReference [ '1988' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'at:at:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber\r  #metaObject count: 1.\r  nil.\r  ^contents at: rowNumber at: columnNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.080232-04:00' ],		#prior : OmReference [ '1988' ],		#self : OmReference [ '1989' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeContents:rowNames:columnNames:',			#protocol : #initialization,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeContents:rowNames:columnNames:',			#protocol : #initialization,			#sourceCode : 'initializeContents: aDataFrameInternal rowNames: rows columnNames: columns\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := aDataFrameInternal.\r  self rowNames: rows.\r  self columnNames: columns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.082192-04:00' ],		#prior : OmReference [ '1989' ],		#self : OmReference [ '1990' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame on: aColumnName\r  "Left join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self leftJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.084502-04:00' ],		#prior : OmReference [ '1990' ],		#self : OmReference [ '1991' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'groupBy:aggregate:',			#protocol : #grouping,			#sourceCode : 'groupBy: columnName aggregate: anArrayOfUsingAsStatements\r  | aggregatedColumns |\r  #metaObject count: 1.\r  nil.\r  aggregatedColumns := anArrayOfUsingAsStatements collect: [:aBlock |  #metaObject count: 2.\r        nil.\r        aBlock value: self value: columnName ].\r  ^DataFrame withColumns: aggregatedColumns rowNames: aggregatedColumns first keys columnNames: (aggregatedColumns collect: #name)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.088129-04:00' ],		#prior : OmReference [ '1991' ],		#self : OmReference [ '1992' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'closeTo:',			#protocol : #comparing,			#sourceCode : 'closeTo: aDataFrame\r  #metaObject count: 1.\r  nil.\r  aDataFrame species = self species ifFalse: [ #metaObject count: 2.\r        nil.\r        ^false ].\r  aDataFrame dimensions = self dimensions ifFalse: [ #metaObject count: 3.\r        nil.\r        ^false ].\r  (aDataFrame rowNames = self rowNames and: [ #metaObject count: 4.\r        nil.\r        aDataFrame columnNames = self columnNames ]) ifFalse: [ #metaObject count: 5.\r        nil.\r        ^false ].\r  1 to: self numberOfRows do: [:i |  #metaObject count: 6.\r        nil.\r        1 to: self numberOfColumns do: [:j |  #metaObject count: 7.\r              nil.\r              ((self at: i at: j) closeTo: (aDataFrame at: i at: j)) ifFalse: [ #metaObject count: 8.\r                    nil.\r                    ^false ] ] ].\r  ^true',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.090364-04:00' ],		#prior : OmReference [ '1992' ],		#self : OmReference [ '1993' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #stdev,			#protocol : #statistics,			#sourceCode : 'stdev\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #stdev',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.091877-04:00' ],		#prior : OmReference [ '1993' ],		#self : OmReference [ '1994' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addColumn:',			#protocol : #adding,			#sourceCode : 'addColumn: aDataSeries\r  "Add DataSeries as a new column at the end"\r  #metaObject count: 1.\r  nil.\r  self addColumn: aDataSeries named: aDataSeries name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.09672-04:00' ],		#prior : OmReference [ '1994' ],		#self : OmReference [ '1995' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'rowsFrom: firstNumber to: secondNumber put: anArrayOfArrays\r  | interval |\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = ((firstNumber - secondNumber) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  interval := secondNumber >= firstNumber ifTrue: [ #metaObject count: 3.\r        nil.\r        firstNumber to: secondNumber ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (secondNumber to: firstNumber) reversed ].\r  interval withIndexDo: [:rowIndex :i |  #metaObject count: 5.\r        nil.\r        self rowAt: rowIndex put: (anArrayOfArrays at: i) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.098806-04:00' ],		#prior : OmReference [ '1995' ],		#self : OmReference [ '1996' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #numberOfRows,			#protocol : #accessing,			#sourceCode : 'numberOfRows\r  #metaObject count: 1.\r  nil.\r  ^contents numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.100614-04:00' ],		#prior : OmReference [ '1996' ],		#self : OmReference [ '1997' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:named:',			#protocol : #adding,			#sourceCode : 'addRow: anArray named: aString\r  "Add a new row at the end"\r  #metaObject count: 1.\r  nil.\r  self addRow: anArray named: aString atPosition: self numberOfRows + 1',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.102545-04:00' ],		#prior : OmReference [ '1997' ],		#self : OmReference [ '1998' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #rowNames,			#protocol : #accessing,			#sourceCode : 'rowNames\r  #metaObject count: 1.\r  nil.\r  ^rowNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.104421-04:00' ],		#prior : OmReference [ '1998' ],		#self : OmReference [ '1999' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnAt:',			#protocol : #removing,			#sourceCode : 'removeColumnAt: columnNumber\r  #metaObject count: 1.\r  nil.\r  (columnNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        columnNumber > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: columnNumber ].\r  contents removeColumnAt: columnNumber.\r  columnNames := columnNames copyWithoutIndex: columnNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.106218-04:00' ],		#prior : OmReference [ '1999' ],		#self : OmReference [ '2000' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers\r  | newRowNames |\r  #metaObject count: 1.\r  nil.\r  newRowNames := anArrayOfNumbers collect: [:i |  #metaObject count: 2.\r        nil.\r        self rowNames at: i ].\r  ^DataFrame withDataFrameInternal: (self contents rowsAt: anArrayOfNumbers) rowNames: newRowNames columnNames: self columnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.108493-04:00' ],		#prior : OmReference [ '2000' ],		#self : OmReference [ '2001' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:put:',			#protocol : #accessing,			#sourceCode : 'columns: anArrayOfColumnNames put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfColumnNames size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfColumnNames with: anArrayOfArrays do: [:name :array |  #metaObject count: 3.\r        nil.\r        self column: name put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.111928-04:00' ],		#prior : OmReference [ '2001' ],		#self : OmReference [ '2002' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columns:',			#protocol : #accessing,			#sourceCode : 'columns: anArrayOfNames\r  | anArrayOfNumbers |\r  #metaObject count: 1.\r  nil.\r  anArrayOfNumbers := anArrayOfNames collect: [:name |  #metaObject count: 2.\r        nil.\r        self indexOfColumnNamed: name ].\r  ^self columnsAt: anArrayOfNumbers',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.114821-04:00' ],		#prior : OmReference [ '2002' ],		#self : OmReference [ '2003' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfRowNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfRowNamed: rowName ifAbsent: exceptionBlock\r  "Answer the index of a row with a given name or evaluate the exceptionBlock if the row with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self rowNames indexOf: rowName ifAbsent: exceptionBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.116802-04:00' ],		#prior : OmReference [ '2003' ],		#self : OmReference [ '2004' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRow:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRow: rowNumber\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onRow: rowNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.11839-04:00' ],		#prior : OmReference [ '2004' ],		#self : OmReference [ '2005' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:',			#protocol : #adding,			#sourceCode : 'addRow: aDataSeries\r  "Add DataSeries as a new row at the end"\r  #metaObject count: 1.\r  nil.\r  self addRow: aDataSeries asArray named: aDataSeries name',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.12043-04:00' ],		#prior : OmReference [ '2005' ],		#self : OmReference [ '2006' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:put:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber put: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents columnAt: aNumber put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.122371-04:00' ],		#prior : OmReference [ '2006' ],		#self : OmReference [ '2007' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:transform:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber transform: aBlock\r  "Evaluate aBlock on the row at aNumber and replace that row with the result"\r  | row |\r  #metaObject count: 1.\r  nil.\r  row := self rowAt: aNumber.\r  self rowAt: aNumber put: (aBlock value: row) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.124186-04:00' ],		#prior : OmReference [ '2007' ],		#self : OmReference [ '2008' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aDataSeries\r  "Add DataSeries as a new row at the end"\r  #metaObject count: 1.\r  nil.\r  self addRow: aDataSeries',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.126106-04:00' ],		#prior : OmReference [ '2008' ],		#self : OmReference [ '2009' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:put:',			#protocol : #accessing,			#sourceCode : 'row: rowName put: anArray\r  "Replace the current values of row with rowName with anArray or signal an exception if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  ^self rowAt: index put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.129127-04:00' ],		#prior : OmReference [ '2009' ],		#self : OmReference [ '2010' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'findAllIndicesOf:atColumn:',			#protocol : #find-select,			#sourceCode : 'findAllIndicesOf: anObject atColumn: columnName\r  "Returns indices of rows having anObject at columnName"\r  | output |\r  #metaObject count: 1.\r  nil.\r  output := OrderedCollection new.\r  self rowNames withIndexDo: [:row :index |  #metaObject count: 2.\r        nil.\r        ((self column: columnName) at: row) = anObject ifTrue: [ #metaObject count: 3.\r              nil.\r              output add: index ] ].\r  ^output',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.132356-04:00' ],		#prior : OmReference [ '2010' ],		#self : OmReference [ '2011' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'getJointColumnsWith:',			#protocol : #private,			#sourceCode : 'getJointColumnsWith: aDataFrame\r  "comment stating purpose of message"\r  | columnIntersection outputColumns |\r  #metaObject count: 1.\r  nil.\r  columnIntersection := (self columnNames intersection: aDataFrame columnNames) asSet.\r  outputColumns := OrderedCollection new.\r  self columnNames do: [:column |  #metaObject count: 2.\r        nil.\r        (columnIntersection includes: column) ifTrue: [ #metaObject count: 3.\r              nil.\r              outputColumns add: (\'\' join: {(column , \'_x\')}) ] ifFalse: [ #metaObject count: 4.\r              nil.\r              outputColumns add: column ] ].\r  aDataFrame columnNames do: [:column |  #metaObject count: 5.\r        nil.\r        (columnIntersection includes: column) ifTrue: [ #metaObject count: 6.\r              nil.\r              outputColumns add: (\'\' join: {(column , \'_y\')}) ] ifFalse: [ #metaObject count: 7.\r              nil.\r              outputColumns add: column ] ].\r  ^outputColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.134325-04:00' ],		#prior : OmReference [ '2011' ],		#self : OmReference [ '2012' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnNames:',			#protocol : #accessing,			#sourceCode : 'columnNames: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of column names\' ].\r  anArray asSet size = anArray size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All column names must be distinct\' ].\r  columnNames := anArray asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.137602-04:00' ],		#prior : OmReference [ '2012' ],		#self : OmReference [ '2013' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsAt:',			#protocol : #removing,			#sourceCode : 'removeRowsAt: aCollectionOfRowIndices\r  | rowNamesToRemove |\r  #metaObject count: 1.\r  nil.\r  rowNamesToRemove := aCollectionOfRowIndices collect: [:i |  #metaObject count: 2.\r        nil.\r        rowNames at: i ].\r  self removeRows: rowNamesToRemove',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.140456-04:00' ],		#prior : OmReference [ '2013' ],		#self : OmReference [ '2014' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:transform:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'row: rowName transform: aBlock ifAbsent: exceptionBlock\r  "Evaluate aBlock on the row with rowName and replace row with the result. Evaluate exceptionBlock if rowName was not found"\r  | row |\r  #metaObject count: 1.\r  nil.\r  row := self row: rowName ifAbsent: [ #metaObject count: 2.\r        nil.\r        ^exceptionBlock value ].\r  self row: rowName put: (aBlock value: row)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.143133-04:00' ],		#prior : OmReference [ '2014' ],		#self : OmReference [ '2015' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexSelect:',			#protocol : #enumerating,			#sourceCode : 'withIndexSelect: elementAndIndexBlock\r  "Evaluate aBlock with each of the receiver\'s elements and index as the arguments. \r\tCollect into a new collection like the receiver, only those elements for \r\twhich aBlock evaluates to true. Answer the new collection."\r  | rows selectedRowIndices selectedRowNames selectedRowsAsArrays df |\r  #metaObject count: 1.\r  nil.\r  rows := self asArrayOfRows.\r  selectedRowIndices := (1 to: rows size) select: [:i |  #metaObject count: 2.\r        nil.\r        elementAndIndexBlock value: (rows at: i) value: i ].\r  selectedRowNames := selectedRowIndices collect: [:i |  #metaObject count: 3.\r        nil.\r        self rowNames at: i ].\r  selectedRowsAsArrays := selectedRowIndices collect: [:i |  #metaObject count: 4.\r        nil.\r        (rows at: i) asArray ].\r  df := self class withRows: selectedRowsAsArrays rowNames: selectedRowNames columnNames: self columnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.145895-04:00' ],		#prior : OmReference [ '2015' ],		#self : OmReference [ '2016' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.14928-04:00' ],		#prior : OmReference [ '2016' ],		#self : OmReference [ '2017' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumn:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber\r  | rowNamesCopy |\r  #metaObject count: 1.\r  nil.\r  (columnNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        columnNumber > self numberOfColumns ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: columnNumber ].\r  rowNamesCopy := rowNames deepCopy.\r  rowNames removeAll.\r  rowNamesCopy withIndexDo: [:rowName :i |  #metaObject count: 4.\r        nil.\r        (aBlock value: (contents at: i at: columnNumber)) ifFalse: [ #metaObject count: 5.\r              nil.\r              rowNames add: rowName ] ].\r  contents removeRowsOfColumnElementsSatisfing: aBlock onColumn: columnNumber.\r  self numberOfRows = 0 ifTrue: [ #metaObject count: 6.\r        nil.\r        columnNames removeAll ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.154771-04:00' ],		#prior : OmReference [ '2017' ],		#self : OmReference [ '2018' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'leftJoin:onLeft:onRight:',			#protocol : #splitjoin,			#sourceCode : 'leftJoin: aDataFrame onLeft: leftColumn onRight: rightColumn\r  "Performs left join on aDataFrame with rowNames as keys.\r\t rowNames are not preserved.\r\t Duplicate column names will be appended with \'_x\' and \'_y\'."\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := (self column: leftColumn) asArray intersection: (aDataFrame column: rightColumn) asArray.\r  1 to: self size do: [:rowIndex |  | rowsWithSameKey rowToAdd |\r        #metaObject count: 2.\r        nil.\r        (commonRows includes: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn))) ifTrue: [ #metaObject count: 3.\r              nil.\r              rowsWithSameKey := aDataFrame findAllIndicesOf: (self at: rowIndex at: (self indexOfColumnNamed: leftColumn)) atColumn: rightColumn.\r              rowsWithSameKey do: [:rightRow |  #metaObject count: 4.\r                    nil.\r                    rowToAdd := (self rowAt: rowIndex) asArray , (aDataFrame rowAt: rightRow) asArray.\r                    outputDf addRow: rowToAdd named: outputDf size + 1 ] ] ifFalse: [ #metaObject count: 5.\r              nil.\r              rowToAdd := (self rowAt: rowIndex) asArray , (Array new: aDataFrame columnNames size).\r              outputDf addRow: rowToAdd named: outputDf size + 1 ] ].\r  \r  "Since Key is common, remove duplicate key column if it is of same name"leftColumn = rightColumn ifTrue: [ #metaObject count: 6.\r        nil.\r        outputDf removeColumn: rightColumn , \'_y\'.\r        outputDf renameColumn: leftColumn , \'_x\' to: leftColumn ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.157403-04:00' ],		#prior : OmReference [ '2018' ],		#self : OmReference [ '2019' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'withIndexCollect:',			#protocol : #enumerating,			#sourceCode : 'withIndexCollect: elementAndIndexBlock\r  "Overrides withIndexCollect: to create DataFrame with the same number of columns as values in the first row"\r  | firstRow newDataFrame |\r  #metaObject count: 1.\r  nil.\r  firstRow := (self rowAt: 1) copy.\r  newDataFrame := self class new: 0 @ (elementAndIndexBlock value: firstRow value: 1) size.\r  newDataFrame columnNames: firstRow keys.\r  self withIndexDo: [:each :index |  #metaObject count: 2.\r        nil.\r        newDataFrame add: (elementAndIndexBlock value: each copy value: index) ].\r  ^newDataFrame',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.159821-04:00' ],		#prior : OmReference [ '2019' ],		#self : OmReference [ '2020' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowsAt:put:',			#protocol : #accessing,			#sourceCode : 'rowsAt: anArrayOfNumbers put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfNumbers size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfNumbers with: anArrayOfArrays do: [:index :array |  #metaObject count: 3.\r        nil.\r        self rowAt: index put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.162235-04:00' ],		#prior : OmReference [ '2020' ],		#self : OmReference [ '2021' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r  | title |\r  #metaObject count: 1.\r  nil.\r  title := self class name.\r  aStream\r     nextPutAll: (title first isVowel ifTrue: [ #metaObject count: 2.\r              nil.\r              \'an \' ] ifFalse: [ #metaObject count: 3.\r              nil.\r              \'a \' ]);\r     nextPutAll: title;\r     space;\r     nextPutAll: self dimensions asString',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.164363-04:00' ],		#prior : OmReference [ '2021' ],		#self : OmReference [ '2022' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #tail,			#protocol : #accessing,			#sourceCode : 'tail\r  #metaObject count: 1.\r  nil.\r  ^self tail: self defaultHeadTailSize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.166359-04:00' ],		#prior : OmReference [ '2022' ],		#self : OmReference [ '2023' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #min,			#protocol : #statistics,			#sourceCode : 'min\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #min',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.168739-04:00' ],		#prior : OmReference [ '2023' ],		#self : OmReference [ '2024' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'showWithGlamourIn:',			#protocol : #gt-inspector-extension,			#sourceCode : 'showWithGlamourIn: composite\r  | table headerNames |\r  #metaObject count: 1.\r  nil.\r  table := FTTableMorph new.\r  \r  "extent: 650@500"table\r     beResizable;\r     intercellSpacing: 1;\r     dataSource: (DataFrameFTData elements: self);\r     onAnnouncement: FTSelectionChanged do: [:ann |  #metaObject count: 2.\r        nil.\r        (self rowAt: ann newSelectedIndexes first) inspect ].\r  \r  "\t\tonAnnouncement: FTSelectionChanged \r\t\t\tdo: [ :ann | (self rowsAt: ann newSelectedRowIndexes) gtInspectorItemsIn: composite ];"headerNames := #(\'#\') , self columnNames.\r  table columns: (headerNames collect: [:name |  #metaObject count: 3.\r              nil.\r              (FTColumn id: name) width: 100 ]).\r  ^table',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.170396-04:00' ],		#prior : OmReference [ '2024' ],		#self : OmReference [ '2025' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortBy:',			#protocol : #sorting,			#sourceCode : 'sortBy: columnName\r  #metaObject count: 1.\r  nil.\r  self sortBy: columnName using: [:a :b |  #metaObject count: 2.\r        nil.\r        a <= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.175445-04:00' ],		#prior : OmReference [ '2025' ],		#self : OmReference [ '2026' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #mode,			#protocol : #statistics,			#sourceCode : 'mode\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #mode',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.177522-04:00' ],		#prior : OmReference [ '2026' ],		#self : OmReference [ '2027' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'indexOfColumnNamed:ifAbsent:',			#protocol : #accessing,			#sourceCode : 'indexOfColumnNamed: columnName ifAbsent: exceptionBlock\r  "Answer the index of a column with a given name or evaluate the exceptionBlock if the column with that name was not found"\r  #metaObject count: 1.\r  nil.\r  ^self columnNames indexOf: columnName ifAbsent: exceptionBlock',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.17932-04:00' ],		#prior : OmReference [ '2027' ],		#self : OmReference [ '2028' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'initializeColumns:',			#protocol : #initialization,			#sourceCode : 'initializeColumns: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  contents := DataFrameInternal withColumns: anArrayOfArrays.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.181822-04:00' ],		#prior : OmReference [ '2028' ],		#self : OmReference [ '2029' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsAt:',			#protocol : #accessing,			#sourceCode : 'columnsAt: anArrayOfNumbers\r  | newColumnNames |\r  #metaObject count: 1.\r  nil.\r  newColumnNames := anArrayOfNumbers collect: [:i |  #metaObject count: 2.\r        nil.\r        self columnNames at: i ].\r  ^DataFrame withDataFrameInternal: (self contents columnsAt: anArrayOfNumbers) rowNames: self rowNames columnNames: newColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.183846-04:00' ],		#prior : OmReference [ '2029' ],		#self : OmReference [ '2030' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowAt:',			#protocol : #removing,			#sourceCode : 'removeRowAt: rowNumber\r  #metaObject count: 1.\r  nil.\r  (rowNumber < 1 or: [ #metaObject count: 2.\r        nil.\r        rowNumber > self numberOfRows ]) ifTrue: [ #metaObject count: 3.\r        nil.\r        SubscriptOutOfBounds signalFor: rowNumber ].\r  contents removeRowAt: rowNumber.\r  rowNames := rowNames copyWithoutIndex: rowNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.185494-04:00' ],		#prior : OmReference [ '2030' ],		#self : OmReference [ '2031' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumnsWithNilsAtRowNamed:',			#protocol : #removing,			#sourceCode : 'removeColumnsWithNilsAtRowNamed: rowName\r  #metaObject count: 1.\r  nil.\r  self removeColumnsOfRowElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onRowNamed: rowName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.18839-04:00' ],		#prior : OmReference [ '2031' ],		#self : OmReference [ '2032' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'renameRow:to:',			#protocol : #renaming,			#sourceCode : 'renameRow: oldName to: newName\r  "Find a row with oldName and rename it to newName"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: oldName.\r  self rowNames at: index put: newName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.19142-04:00' ],		#prior : OmReference [ '2032' ],		#self : OmReference [ '2033' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:put:',			#protocol : #accessing,			#sourceCode : 'rows: anArrayOfRowNames put: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = anArrayOfRowNames size ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  anArrayOfRowNames with: anArrayOfArrays do: [:name :array |  #metaObject count: 3.\r        nil.\r        self row: name put: array ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.193999-04:00' ],		#prior : OmReference [ '2033' ],		#self : OmReference [ '2034' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsWithNilsAtColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsWithNilsAtColumnNamed: columnName\r  #metaObject count: 1.\r  nil.\r  self removeRowsOfColumnElementsSatisfing: [:ele |  #metaObject count: 2.\r        nil.\r        ele isNil ] onColumnNamed: columnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.196678-04:00' ],		#prior : OmReference [ '2034' ],		#self : OmReference [ '2035' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #variance,			#protocol : #statistics,			#sourceCode : 'variance\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #variance',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.19839-04:00' ],		#prior : OmReference [ '2035' ],		#self : OmReference [ '2036' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRow:',			#protocol : #removing,			#sourceCode : 'removeRow: rowName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  self removeRowAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.200564-04:00' ],		#prior : OmReference [ '2036' ],		#self : OmReference [ '2037' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowAt:put:',			#protocol : #accessing,			#sourceCode : 'rowAt: aNumber put: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfColumns ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  contents rowAt: aNumber put: anArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.202537-04:00' ],		#prior : OmReference [ '2037' ],		#self : OmReference [ '2038' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'addRow:atPosition:',			#protocol : #adding,			#sourceCode : 'addRow: aDataSeries atPosition: aNumber\r  "Add DataSeries as a new row at the given position"\r  #metaObject count: 1.\r  nil.\r  self addRow: aDataSeries named: aDataSeries name atPosition: aNumber',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.206044-04:00' ],		#prior : OmReference [ '2038' ],		#self : OmReference [ '2039' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnsFrom:to:put:',			#protocol : #accessing,			#sourceCode : 'columnsFrom: firstNumber to: secondNumber put: anArrayOfArrays\r  | interval |\r  #metaObject count: 1.\r  nil.\r  anArrayOfArrays size = ((firstNumber - secondNumber) abs + 1) ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal ].\r  interval := secondNumber >= firstNumber ifTrue: [ #metaObject count: 3.\r        nil.\r        firstNumber to: secondNumber ] ifFalse: [ #metaObject count: 4.\r        nil.\r        (secondNumber to: firstNumber) reversed ].\r  interval withIndexDo: [:columnIndex :i |  #metaObject count: 5.\r        nil.\r        self columnAt: columnIndex put: (anArrayOfArrays at: i) ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.208805-04:00' ],		#prior : OmReference [ '2039' ],		#self : OmReference [ '2040' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rightJoin:',			#protocol : #splitjoin,			#sourceCode : 'rightJoin: aDataFrame\r  "Performs right join on aDataFrame with rowNames as keys"\r  | outputDf commonRows |\r  #metaObject count: 1.\r  nil.\r  outputDf := self class withColumnNames: (self getJointColumnsWith: aDataFrame).\r  commonRows := self rowNames intersection: aDataFrame rowNames.\r  aDataFrame rowNames do: [:rowName |  | rowToAdd |\r        #metaObject count: 2.\r        nil.\r        rowToAdd := (commonRows includes: rowName) ifTrue: [ #metaObject count: 3.\r              nil.\r              (self row: rowName) asArray , (aDataFrame row: rowName) asArray ] ifFalse: [ #metaObject count: 4.\r              nil.\r              (Array new: self columnNames size) , (aDataFrame row: rowName) asArray ].\r        outputDf addRow: rowToAdd named: rowName ].\r  ^outputDf',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.211038-04:00' ],		#prior : OmReference [ '2040' ],		#self : OmReference [ '2041' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #range,			#protocol : #statistics,			#sourceCode : 'range\r  #metaObject count: 1.\r  nil.\r  ^self applyToAllColumns: #range',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.213535-04:00' ],		#prior : OmReference [ '2041' ],		#self : OmReference [ '2042' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := DataFrameInternal new.\r  self setDefaultRowColumnNames',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.215279-04:00' ],		#prior : OmReference [ '2042' ],		#self : OmReference [ '2043' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeColumns:',			#protocol : #removing,			#sourceCode : 'removeColumns: aCollectionOfColumnNames\r  #metaObject count: 1.\r  nil.\r  aCollectionOfColumnNames do: [:each |  #metaObject count: 2.\r        nil.\r        self removeColumn: each ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.217402-04:00' ],		#prior : OmReference [ '2043' ],		#self : OmReference [ '2044' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #dimensions,			#protocol : #accessing,			#sourceCode : 'dimensions\r  #metaObject count: 1.\r  nil.\r  ^self numberOfRows @ self numberOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.220801-04:00' ],		#prior : OmReference [ '2044' ],		#self : OmReference [ '2045' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'crossTabulate:with:',			#protocol : #accessing,			#sourceCode : 'crossTabulate: colName1 with: colName2\r  | col1 col2 |\r  #metaObject count: 1.\r  nil.\r  col1 := self column: colName1.\r  col2 := self column: colName2.\r  ^col1 crossTabulateWith: col2',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.22268-04:00' ],		#prior : OmReference [ '2045' ],		#self : OmReference [ '2046' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'innerJoin:on:',			#protocol : #splitjoin,			#sourceCode : 'innerJoin: aDataFrame on: aColumnName\r  "Inner join of self with aDataFrame on a column that has a name aColumnName in both data frames"\r  #metaObject count: 1.\r  nil.\r  ^self innerJoin: aDataFrame onLeft: aColumnName onRight: aColumnName',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.224639-04:00' ],		#prior : OmReference [ '2046' ],		#self : OmReference [ '2047' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'tail:',			#protocol : #accessing,			#sourceCode : 'tail: aNumber\r  | n rows |\r  #metaObject count: 1.\r  nil.\r  rows := self numberOfRows.\r  rows > aNumber ifTrue: [ #metaObject count: 2.\r        nil.\r        n := aNumber ] ifFalse: [ #metaObject count: 3.\r        nil.\r        n := rows ].\r  ^self rowsAt: (rows - n + 1 to: rows)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.226656-04:00' ],		#prior : OmReference [ '2047' ],		#self : OmReference [ '2048' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'columnAt:transform:',			#protocol : #accessing,			#sourceCode : 'columnAt: aNumber transform: aBlock\r  "Evaluate aBlock on the column at aNumber and replace that column with the result"\r  | column |\r  #metaObject count: 1.\r  nil.\r  column := self columnAt: aNumber.\r  self columnAt: aNumber put: (aBlock value: column) asArray',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.228286-04:00' ],		#prior : OmReference [ '2048' ],		#self : OmReference [ '2049' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'sortDescendingBy:',			#protocol : #sorting,			#sourceCode : 'sortDescendingBy: columnName\r  #metaObject count: 1.\r  nil.\r  self sortBy: columnName using: [:a :b |  #metaObject count: 2.\r        nil.\r        a >= b ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.230458-04:00' ],		#prior : OmReference [ '2049' ],		#self : OmReference [ '2050' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'removeRowsOfColumnElementsSatisfing:onColumnNamed:',			#protocol : #removing,			#sourceCode : 'removeRowsOfColumnElementsSatisfing: aBlock onColumnNamed: columnName\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfColumnNamed: columnName.\r  self removeRowsOfColumnElementsSatisfing: aBlock onColumn: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.232675-04:00' ],		#prior : OmReference [ '2050' ],		#self : OmReference [ '2051' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rowNames:',			#protocol : #accessing,			#sourceCode : 'rowNames: anArray\r  #metaObject count: 1.\r  nil.\r  anArray size = self numberOfRows ifFalse: [ #metaObject count: 2.\r        nil.\r        SizeMismatch signal: \'Wrong number of row names\' ].\r  anArray asSet size = anArray size ifFalse: [ #metaObject count: 3.\r        nil.\r        Error signal: \'All row names must be distinct\' ].\r  rowNames := anArray asOrderedCollection',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.23486-04:00' ],		#prior : OmReference [ '2051' ],		#self : OmReference [ '2052' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #setDefaultRowColumnNames,			#protocol : #private,			#sourceCode : 'setDefaultRowColumnNames\r  #metaObject count: 1.\r  nil.\r  self rowNames: (1 to: self numberOfRows).\r  self columnNames: (1 to: self numberOfColumns)',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.253767-04:00' ],		#prior : OmReference [ '2052' ],		#self : OmReference [ '2053' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'applyToAllColumns:',			#protocol : #private,			#sourceCode : 'applyToAllColumns: aSymbol\r  "Sends the unary selector, aSymbol, to all columns of DataFrame and collects the result into a DataSeries object. Used by statistical functions of DataFrame"\r  | series column |\r  #metaObject count: 1.\r  nil.\r  series := DataSeries withValues: (self columnNames collect: [:colName |  #metaObject count: 2.\r              nil.\r              column := self column: colName.\r              column perform: aSymbol ]).\r  series name: aSymbol.\r  series keys: self columnNames.\r  ^series',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.2571-04:00' ],		#prior : OmReference [ '2053' ],		#self : OmReference [ '2054' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #asArrayOfColumns,			#protocol : #converting,			#sourceCode : 'asArrayOfColumns\r  "Converts DataFrame to the array of columns"\r  #metaObject count: 1.\r  nil.\r  ^contents asArrayOfColumns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.259382-04:00' ],		#prior : OmReference [ '2054' ],		#self : OmReference [ '2055' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'rows:',			#protocol : #accessing,			#sourceCode : 'rows: anArrayOfNames\r  | anArrayOfNumbers |\r  #metaObject count: 1.\r  nil.\r  anArrayOfNumbers := anArrayOfNames collect: [:name |  #metaObject count: 2.\r        nil.\r        self indexOfRowNamed: name ].\r  ^self rowsAt: anArrayOfNumbers',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.261057-04:00' ],		#prior : OmReference [ '2055' ],		#self : OmReference [ '2056' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #DataFrame			},			#name : #'row:',			#protocol : #accessing,			#sourceCode : 'row: rowName\r  "Answer the row with rowName as a DataSeries or signal an exception if a row with that name was not found"\r  | index |\r  #metaObject count: 1.\r  nil.\r  index := self indexOfRowNamed: rowName.\r  ^self rowAt: index',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.262806-04:00' ],		#prior : OmReference [ '2056' ],		#self : OmReference [ '2057' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  ^self new initializeColumns: anArrayOfArrays',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.265983-04:00' ],		#prior : OmReference [ '2057' ],		#self : OmReference [ '2058' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays rowNames: anArrayOfRowNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withColumns: anArrayOfArrays)\r           rowNames: anArrayOfRowNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: anArrayOfRowNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.268005-04:00' ],		#prior : OmReference [ '2058' ],		#self : OmReference [ '2059' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays columnNames: anArrayOfColumnNames\r  | df |\r  #metaObject count: 1.\r  nil.\r  df := self withColumns: anArrayOfArrays.\r  df columnNames: anArrayOfColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.270384-04:00' ],		#prior : OmReference [ '2059' ],		#self : OmReference [ '2060' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r  "Create an empty data frame with given row and column names"\r  | numberOfRows numberOfColumns df |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfRowNames size.\r  numberOfColumns := anArrayOfColumnNames size.\r  df := self new: numberOfRows @ numberOfColumns.\r  df rowNames: anArrayOfRowNames.\r  df columnNames: anArrayOfColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.272933-04:00' ],		#prior : OmReference [ '2060' ],		#self : OmReference [ '2061' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays columnNames: anArrayOfColumnNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withRows: anArrayOfArrays)\r           columnNames: anArrayOfColumnNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: anArrayOfColumnNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.274472-04:00' ],		#prior : OmReference [ '2061' ],		#self : OmReference [ '2062' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays\r  #metaObject count: 1.\r  nil.\r  ^self new initializeRows: anArrayOfArrays',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.277875-04:00' ],		#prior : OmReference [ '2062' ],		#self : OmReference [ '2063' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumnNames: anArrayOfColumnNames\r  "Create an empty data frame with given column names"\r  | numberOfColumns df |\r  #metaObject count: 1.\r  nil.\r  numberOfColumns := anArrayOfColumnNames size.\r  df := self new: 0 @ numberOfColumns.\r  df columnNames: anArrayOfColumnNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.280864-04:00' ],		#prior : OmReference [ '2063' ],		#self : OmReference [ '2064' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withColumns:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withColumns: anArrayOfArrays rowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withColumns: anArrayOfArrays)\r           rowNames: anArrayOfRowNames;\r           columnNames: anArrayOfColumnNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withRowNames: anArrayOfRowNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.283895-04:00' ],		#prior : OmReference [ '2064' ],		#self : OmReference [ '2065' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays rowNames: anArrayOfRowNames columnNames: anArrayOfColumnNames\r  #metaObject count: 1.\r  nil.\r  ^anArrayOfArrays ifNotEmpty: [ #metaObject count: 2.\r        nil.\r        (self withRows: anArrayOfArrays)\r           rowNames: anArrayOfRowNames;\r           columnNames: anArrayOfColumnNames;\r           yourself ] ifEmpty: [ #metaObject count: 3.\r        nil.\r        self withColumnNames: anArrayOfColumnNames ]',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.285818-04:00' ],		#prior : OmReference [ '2065' ],		#self : OmReference [ '2066' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'nil.\r  ^contents at: arg1 at: arg2',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRows:rowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRows: anArrayOfArrays rowNames: anArrayOfRowNames\r  | df |\r  #metaObject count: 1.\r  nil.\r  df := self withRows: anArrayOfArrays.\r  df rowNames: anArrayOfRowNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.287442-04:00' ],		#prior : OmReference [ '2066' ],		#self : OmReference [ '2067' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withRowNames:',			#protocol : #'instance creation',			#sourceCode : 'withRowNames: anArrayOfRowNames\r  "Create an empty data frame with given row names"\r  | numberOfRows df |\r  #metaObject count: 1.\r  nil.\r  numberOfRows := anArrayOfRowNames size.\r  df := self new: numberOfRows @ 0.\r  df rowNames: anArrayOfRowNames.\r  ^df',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.289796-04:00' ],		#prior : OmReference [ '2067' ],		#self : OmReference [ '2068' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'rg1 to: arg2)',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r  #metaObject count: 1.\r  nil.\r  ^super new initialize',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.291722-04:00' ],		#prior : OmReference [ '2068' ],		#self : OmReference [ '2069' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'odsFor: \'as yet unclassified\' stamp: \'AndreinaCota 8/2/2020 16:26\' prior: 33624464',			#stamp : '',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aPoint\r  #metaObject count: 1.\r  nil.\r  ^super new initialize: aPoint',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}OmEntry {	#tags : {		#author : 'AndreinaCota',		#time : DateAndTime [ '2020-08-02T16:31:22.294405-04:00' ],		#prior : OmReference [ '2069' ],		#self : OmReference [ '2070' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'initializeContents: arg1 rowNames: arg2 columnNames: arg3\r  #metaObject count: 1.\r  nil.\r  super initialize.\r  contents := arg1.\r  self\r     rowNames: arg2;\r     columnNames: arg3',			#stamp : 'AndreinaCota 8/2/2020 16:26',			#package : #DataFrame		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'DataFrame class'			},			#name : #'withDataFrameInternal:rowNames:columnNames:',			#protocol : #'instance creation',			#sourceCode : 'withDataFrameInternal: aDataFrameIndernal rowNames: rows columnNames: columns\r  #metaObject count: 1.\r  nil.\r  ^self new initializeContents: aDataFrameIndernal rowNames: rows columnNames: columns',			#stamp : 'AndreinaCota 8/2/2020 16:31',			#package : #DataFrame		}	}}